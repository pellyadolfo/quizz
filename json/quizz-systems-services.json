{

	"Services - Design": "",
	"Services - Design - APIFirst": "The API-first approach, also known as 'design-first' emphasizes the design and documentation of the API as the primary starting point for development. In this approach, the API contract is defined upfront, specifying the resources, endpoints, data structures, and communication protocols before writing any code.",
	"Services - Design - APIFirst - DefineAPIContract": "Create a detailed specification of the API using tools like OpenAPI (formerly Swagger), API Blueprint, or RAML. This specification serves as a contract between the API provider and consumers, ensuring a clear understanding of the API’s functionality and behavior.",
	"Services - Design - APIFirst - RefineAPIContract": "Collaborate with stakeholders, including product owners, developers, and potential consumers, to review and refine the API contract until it meets the required functionality and adheres to best practices.",
	"Services - Design - APIFirst - GenerateClientLibraries": "Use the API specification to automatically generate client libraries, documentation, and other artifacts that facilitate API consumption and integration.",
	"Services - Design - APIFirst - ImplementAPI:": "With the contract in place, developers can begin implementing the API logic, adhering strictly to the defined contract.",
	"Services - Design - CodeFirst:": "In contrast to the API-first approach, the code-first approach, also known as 'implementation-first' focuses on writing the application code first and then generating the API contract from the implemented code. This approach is often preferred when the application logic is well-understood, and the API is primarily an interface for exposing the existing functionality.",
	"Services - Design - CodeFirst - DevelopApplicationLogic:": "Write the application code, including business logic, data models, and other components, without initially considering the API.",
	"Services - Design - CodeFirst - DefineAPIContract:": "Use code annotations, decorators, or other language-specific mechanisms to define the API contract based on the existing code.",
	"Services - Design - CodeFirst - GenerateAPISpecification:": "Tools like Swagger, NSwag, or Swashbuckle analyze the code and generate the API specification (e.g., OpenAPI, Swagger JSON/YAML) based on the defined contract.",
	"Services - Design - CodeFirst - IterateAndRefine:": "Review and refine the generated API specification to ensure it aligns with best practices and meets the desired functionality.",

	"Networking - Layer4": "SECTION",
	"Networking - Layer4 - Protocols - TCPIP": "",
	"Networking - Layer4 - VPC": "",
	"Networking - Layer4 - VPN": "https://www.linkedin.com/posts/sandip-das-developer_this-is-how-%F0%9D%90%95%F0%9D%90%8F%F0%9D%90%8D-works-and-every-cloud-activity-7318836487989444612-M7IR/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Networking - Layer4 - VPN ": "https://www.linkedin.com/posts/activity-7318807987937030144-xpBu/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Networking - Layer4 - NetworkFirewalls - Layer4": "TCPIP - network firewalls look at data packets and their state.",
	"Networking - Layer4 - ReverseProxy": "A Reverse Proxy is a type of proxy server that retrieves resources on behalf of a client from one or more servers. Operate at the Application Layer,",
	"Networking - Layer4 - ReverseProxy - Location": "It sits between the client and the backend services or servers.",
	"Networking - Layer4 - ReverseProxy - Functions": "A Reverse Proxy focuses more on network-level concerns like load balancing, security, and caching for a wider range of applications.",
	"Networking - Layer4 - ReverseProxy - Functions - TrafficManagement": "Forwards client requests to backend servers.",
	"Networking - Layer4 - ReverseProxy - Functions - Security": "Provides an additional layer of defense (hides the identities of backend servers).",
	"Networking - Layer4 - ReverseProxy - Functions - Security - SSL": "Handles SSL encryption and decryption, offloading that responsibility from backend servers.",
	"Networking - Layer4 - ReverseProxy - Functions - Caching": "Can cache content to reduce server load and improve performance.",
	"Networking - Layer4 - ForwardProxy": "A Forward Proxy, also known simply as a proxy, acts as an intermediary between client devices and the internet. It facilitates requests from clients to external servers, providing functionalities such as content filtering, access control, and anonymity.",
	"Networking - Layer4 - ForwardProxy - Functions - ContentFiltering": "Organizations use Forward Proxies to control and monitor internet usage within their network. Proxies can filter out malicious content, restrict access to certain websites, and enforce usage policies.",
	"Networking - Layer4 - ForwardProxy - Functions - Anonymity": "Forward Proxies provide a level of anonymity for clients by masking their IP addresses. This is particularly useful for users seeking to access the internet without revealing their identity.",
	"Networking - Layer4 - LoadBalancer": "A Load Balancer is a network distributor at Layer 4 or 7 of OSI Model.",
	"Networking - Layer4 - LoadBalancer 0": "https://www.linkedin.com/posts/umarjon-backendev-devops_how-to-use-nginx-as-a-load-balancer-nginx-activity-7322257505047265280-ZtMm/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Networking - Layer4 - LoadBalancer - Types - Hardware": "Expensive but provide high performance.",
	"Networking - Layer4 - LoadBalancer - Types - Software": "Cost-effective and flexible (Nginx, HAProxy).",
	"Networking - Layer4 - LoadBalancer - Functions - TrafficDistribution": "Distributes requests across multiple servers.",
	"Networking - Layer4 - LoadBalancer - Functions - HighAvailability": "Prevents overload, ensures uptime, and reroutes traffic on failure.",
	"Networking - Layer4 - LoadBalancer - Functions - Scalability": "Optimizes routing for minimal latency and resource efficiency.",
	"Networking - Layer4 - LoadBalancer - Functions - Types - CLB": "Classic Load Balancer (CLB). CLB operates in Layer 4 and Layer 7.",
	"Networking - Layer4 - LoadBalancer - Functions - Types - ALB": "Application Load Balancer (ALB). ALB operates in Layer 7",
	"Networking - Layer4 - LoadBalancer - Functions - Types - NLB": "Network Load Balancer (NLB). NLB operates in Layer 4",
	"Networking - Layer4 - LoadBalancer - Functions - Types - GLB": "Gateway Load Balancer (GLB). NLB operates in Layer 3",
	"Networking - Layer4 - LoadBalancer - Algorithms": "Optimizing by servers capacity.",
	"Networking - Layer4 - LoadBalancer - Algorithms - RoundRobin": "Sequential manner. Applies to servers relatively equal. Simple but does not account for server load or capability",
	"Networking - Layer4 - LoadBalancer - Algorithms - StickyRoundRobin": "Maintains session persistence. Apps that maintain user sessions. Improves user experience but can lead to uneven load distribution",
	"Networking - Layer4 - LoadBalancer - Algorithms - WeightedRoundRobin": "Assigns a weight to each server based on its capacity or capability. Applies servers of varying capabilities but requires  monitoring and configuration of server weights",
	"Networking - Layer4 - LoadBalancer - Algorithms - LeastResponseTime": "Routes to server with lowest response time. Apps where response time is critical but requires constant monitoring.",
	"Networking - Layer4 - LoadBalancer - Algorithms - LeastBandwith": "Routes to server with least network bandwidth at the moment. Useful when managing network usage is important to prevent congestion.",
	"Networking - Layer4 - LoadBalancer - Algorithms - LeastPackets": "Prioritizes the server that has received the fewest packets, enhancing efficiency.",
	"Networking - Layer4 - LoadBalancer - Algorithms - LeastConnections": "Directs to the server with the fewest active connections (e.g., database connections, file uploads). More efficient use of resources but requires real-time monitoring of active connections.",
	"Networking - Layer4 - LoadBalancer - Algorithms - WeightedLeastConnections": "",
	"Networking - Layer4 - LoadBalancer - Algorithms - HashingFunction": "A hash function determines which server should handle a request (e.g. client's IP address or session ID). Applies to scenarios where user data needs to be kept on the same server. Traditionally how the data is distributed to all these nodes was using a hash function.",
	"Networking - Layer4 - LoadBalancer - Algorithms - HashingFunction - Permanent": "",
	"Networking - Layer4 - LoadBalancer - Algorithms - HashingFunction - Distributed": "Distributed hashing allows us to implement the hash table across multiple machines. A Distributed Hash Table(DHT) is a decentralized data store that allows us to store and retrieve data efficiently. The decentralized nature of the Distributed Hash Table allows all nodes to form the collective system without any centralized coordination.",
	"Networking - Layer4 - LoadBalancer - Algorithms - HashingFunction - Distributed - Properties - Decentralization": "All the nodes of the system collectively form the system without any central coordination.",
	"Networking - Layer4 - LoadBalancer - Algorithms - HashingFunction - Distributed - Properties - FaultTolerant": "The system is reliable(in some sense), with lots of nodes joining, leaving, and failing at all times.",
	"Networking - Layer4 - LoadBalancer - Algorithms - HashingFunction - Distributed - Properties - Scalable": "The system works efficiently with a large number of nodes.",
	"Networking - Layer4 - LoadBalancer - Algorithms - HashingFunction - Distributed - Limitations": "The scalability in the distributed hash table is static.",
	"Networking - Layer4 - LoadBalancer - Algorithms - HashingFunction - Consistent": "Consistent hashing is a technique that works independently of the number of servers. One of the main goals of consistent hashing is to reduce data redistribution. Consistent hashing is a popular technique used in distributed systems to address the challenge of efficiently distributing keys or data elements across multiple nodes in a network. Consistent hashing’s primary objective is to reduce the number of remapping operations necessary when adding or removing nodes from the network, which contributes to the stability and dependability of the system. ",
	"Networking - Layer4 - LoadBalancer - Algorithms - HashingFunction - Consistent - How": "Consistent hashing presents a crucial solution to the challenges of distributing data across nodes in distributed systems. By utilizing a hash ring structure and deterministic mapping algorithms, consistent hashing ensures that data is evenly spread across nodes, promoting efficient load balancing and fault tolerance.",
	"Networking - Layer4 - LoadBalancer - Algorithms - HashingFunction - Consistent - Usage - Cassandra": "Apache Cassandra uses consistent hashing to distribute and replicate data efficiently across the cluster.",
	"Networking - Layer4 - LoadBalancer - Algorithms - HashingFunction - Consistent - Usage - CDN": "Content Delivery Networks(CDN) distribute contents evenly across the edge servers using consistent hashing.",
	"Networking - Layer4 - LoadBalancer - Algorithms - HashingFunction - Consistent - Usage - LoadBalancers": "Load Balancers use consistent hashing to distribute persistent connections across backend servers.",
	"Networking - Layer4 - LoadBalancer - Algorithms - ContentBased": "Distributes traffic based on the content being requested.",
	"Networking - Layer4 - LoadBalancer - Algorithms - Geographical": "Routes users to the nearest server, minimizing latency.",
	"Networking - Layer4 - LoadBalancer - Algorithms - Layer7": "Looks deeper into the request data, allowing for more intelligent routing.",
	"Networking - Layer4 - LoadBalancer - Algorithms - RequestBased": "Balances traffic according to the rate of incoming requests.",
	"Networking - Layer4 - LoadBalancer - Algorithms - DNS": "Uses DNS to distribute load among multiple servers, enhancing fault tolerance.",
	"Networking - Layer4 - LoadBalancer - Algorithms - Random": "It picks a server at random for each new request. Useful when you don't need to consider server load or differences in server capacity.",
	"Networking - Layer4 - LoadBalancer - UseCases": ".",
	"Networking - Layer4 - LoadBalancer - UseCases - HealthMonitoring": "It checks if services are alive. If one fails, it stops sending traffic there. This keeps users away from broken systems.",
	"Networking - Layer4 - LoadBalancer - UseCases - SSLTermination ": "It handles encryption at the edge. This offloads the heavy SSL work from your backend, making things faster.",
	"Networking - Layer4 - LoadBalancer - UseCases - SessionPersistence ": "It keeps users connected to the same server. Useful for logins, shopping carts, or anything that needs memory of past actions.",
	"Networking - Layer4 - LoadBalancer - UseCases - TrafficDistribution ": "It spreads requests across servers. This avoids overload and keeps response times low.",
	"Networking - Layer4 - LoadBalancer - UseCases - HighAvailability ": "If one server dies, traffic is rerouted. This keeps your app running even when parts fail.",
	"Networking - Layer4 - LoadBalancer - UseCases - Scalability": "It lets you add more servers as demand grows. No downtime needed — just plug and play.",
	"Networking - Layer4 - LoadBalancer - Tools - NGINX": "",
	"Networking - Layer4 - LoadBalancer - Tools - HAProxy": "",
	"Networking - Layer4 - LoadBalancer - Tools - AWS ELB": "",
	"Networking - Layer4 - LoadBalancer - Tools - Ribbon": "",
	"Networking - Layer4 - LoadBalancer - Tools - SpringCloudLoadBalancer": "",

	"Networking - Layer7": "SECTION",
	"Networking - Layer7 - Protocols - HTTP": "",
	"Networking - Layer7 - Protocols - HTTP - keep-alive": "Keep Connections Alive: Enable HTTP keep-alive to avoid re-establishing connections for every request.",
	"Networking - Layer7 - Protocols - HTTP2": "HTTP/2 began as the SPDY protocol, developed primarily at Google",
	"Networking - Layer7 - Protocols - HTTP2 - Goal": "Reducing server latency",
	"Networking - Layer7 - Protocols - HTTP2 - Features - Binary": "binary framing layer. As opposed to HTTP/1.1, which keeps all requests and responses in plain text format, HTTP/2 uses the binary framing layer to encapsulate all messages in binary format, while still maintaining HTTP semantics, such as verbs, methods, and headers.",
	"Networking - Layer7 - Protocols - HTTP2 - Features - Headers - compression": "Small files load more quickly than large ones. To speed up web performance, both HTTP/1.1 and HTTP/2 compress HTTP messages to make them smaller. However, HTTP/2 uses a more advanced compression method called HPACK that eliminates redundant information in HTTP header packets. This eliminates a few bytes from every HTTP packet. Given the volume of HTTP packets involved in loading even a single webpage, those bytes add up quickly, resulting in faster loading.",
	"Networking - Layer7 - Protocols - HTTP2 - Features - Prioritization": "Stream prioritization not only solves the possible issue of requests competing for the same resource, but also allows developers to customize the relative weight of requests to better optimize application performance.",
	"Networking - Layer7 - Protocols - HTTP2 - Features - Multiplexing": "HTTP/1.1 loads resources one after the other, so if one resource cannot be loaded, it blocks all the other resources behind it. In contrast, HTTP/2 is able to use a single TCP connection to send multiple streams of data at once so that no one resource blocks any other resource. HTTP/2 does this by splitting data into binary-code messages and numbering these messages so that the client knows which stream each binary message belongs to.",
	"Networking - Layer7 - Protocols - HTTP2 - Features - Push": "Server push: Typically, a server only serves content to a client device if the client asks for it. However, this approach is not always practical for modern webpages, which often involve several dozen separate resources that the client must request. HTTP/2 solves this problem by allowing a server to 'push' content to a client before the client asks for it. The server also sends a message letting the client know what pushed content to expect – like if Bob had sent Alice a Table of Contents of his novel before sending the whole thing.",
	"Networking - Layer7 - Protocols - HTTP3 - Transport": "Both HTTP/1.1 and HTTP/2 use TCP as their transport, whereas HTTP/3 is based on Google’s QUIC – a transport layer network protocol that implements user space congestion control over UDP (User Datagram Protocol).",

	"Processing": "SECTION",
	"Processing - Servers": "",
	"Processing - Servers - Java - SpringBoot": "",
	"Processing - Servers - Java - Micronaut ": "",
	"Processing - Servers - Java - Quarkus ": "",
	"Processing - Servers - Java - Vert.x: ": "",
	"Processing - Servers - Java - Dropwizard ": "",
	"Processing - Servers - Java - Helidon ": "",
	"Processing - Servers - Java - Lagom ": "",
	"Processing - Servers - Java - KumuluzEE ": "",
	"Processing - Servers - JS - ExpressJS ": "",
	"Processing - Servers - JS - NestJS": ".",
	"Processing - Servers - JS - NestJS - Features - Layers": "Too Many Layers and Abstractions. Nest.js often borrows ideas from Java’s Spring framework — Singletons, Dependency Injection, and so forth. In TypeScript/JavaScript, many of these patterns can be implemented in simpler ways, like exporting instances directly from modules. Nest.js adds multiple layers of “magic” that sometimes feel more burdensome than helpful in a dynamic language.",
	"Processing - Servers - JS - NestJS - Features - Debugging": "Debugging Nightmares. While developing APIs, I encountered stack traces pointing to deeply wrapped compiled JavaScript files. Tracing an error back to the original TypeScript code could become tedious. It slowed me down, especially when quick fixes were needed.",
	"Processing - Servers - JS - NestJS - Features - Dependency": "Version Conflicts and Dependency Chaos. The Node.js ecosystem moves fast. It’s common for one minor library update to break compatibility with another. I faced scenarios where Nest.js would stop building after a minor version change in a secondary dependency — only because TypeScript definitions had shifted. Rolling back versions or hunting down workarounds took time and energy I’d rather spend on new features.",
	"Processing - Servers - JS - Fastify": "",
	"Processing - Servers - JS - Fastify - Features - Structure": "Clear Structure. By dividing code into repositories, services, and controllers, I keep my architecture organized while avoiding unnecessary overhead.",
	"Processing - Servers - JS - Fastify - Features - Debugging": "Simplified Debugging. With fewer decorators and wrappers, errors point more directly to the right place in my TypeScript source.",
	"Processing - Servers - JS - Fastify - Features - Dependency": "Reduced Dependency Headaches. Fewer layers mean less risk of version conflicts. Fastify itself is lightweight, and updates generally go smoothly..",
	"Processing - Servers - Python - Flask": "",
	"Processing - Serverless": "Use a deployment infrastructure that hides any concept of servers (i.e. reserved or preallocated resources)- physical or virtual hosts, or containers. The infrastructure takes your service’s code and runs it. You are charged for each request based on the resources consumed. To deploy your service using this approach, you package the code (e.g. as a ZIP file), upload it to the deployment infrastructure and describe the desired performance characteristics. The deployment infrastructure is a utility operated by a public cloud provider. It typically uses either containers or virtual machines to isolate the services. However, these details are hidden from you. Neither you nor anyone else in your organization is responsible for managing any low-level infrastructure such as operating systems, virtual machines, etc.",
	"Processing - Serverless - Tools - Firebase": "Firebase by Google provides a complete suite of backend services, including real-time databases, authentication, hosting, and cloud functions.",
	"Processing - Serverless - Tools - Susabase": "Often referred to as the open-source alternative to Firebase, Supabase offers a powerful Postgres database, authentication, and real-time capabilities.",
	"Processing - Serverless - Tools - Backendless": "Backendless is a no-code/low-code platform that provides backend features like databases, APIs, and user management.",
	"Processing - Serverless - Tools - Netlify": "Netlify combines frontend hosting with backend-like functionalities, such as serverless functions and database integrations.",
	"Processing - Serverless - Tools - Zapier": "Zapier connects different web applications, automating workflows and reducing the need for custom backend APIs.",
	"Processing - Serverless - Tools - NotionAPI": "Notion’s API allows developers to use its robust database and organization tools as a backend.",
	"Processing - Serverless - Tools - AWSAmplify": "AWS Amplify is a powerful toolset for building serverless applications. It provides backend services like authentication, storage, and APIs without needing to code backend logic.",
	"Processing - Serverless - Tools - Bubble": "Bubble is a no-code platform that lets you build full-stack applications without touching backend code.",
	"Processing - Serverless - Tools - Hasura": "Hasura is a GraphQL engine that lets you build scalable APIs over your databases instantly.",
	"Processing - Serverless - Tools - SpringCloudFunction": "",
	"Processing - Serverless - Tools - AWSLambda": "",
	"Processing - Serverless - Tools - AzureFunctions": ""

}