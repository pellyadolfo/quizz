{
  "NextJS": "SECTION",

	"Structure": "SECTION",
  "Structure - app": "Next.js uses the App component to initialize pages. You can override it and control the page initialization and: Create a shared layout between page changes, Inject additional data into pages, Add global CSS",
  "Structure - app - create-next-app": "The easiest way to get started with Next.js is by using create-next-app. This CLI tool enables you to quickly start building a new Next.js application, with everything set up for you.",
  "Structure - app - _app": "To override the default App, create the file pages/_app",
	"Structure - layout": "A layout is UI that is shared between multiple routes. On navigation, layouts preserve state, remain interactive, and do not re-render. Layouts can also be nested.",
  "Structure - layout - root": "The root layout is defined at the top level of the app directory and applies to all routes. This layout is required and must contain html and body tags, allowing you to modify the initial HTML returned from the server.",
  "Structure - layout - nested": ".",
  "Structure - layout - templates": "Templates are similar to layouts in that they wrap a child layout or page. Unlike layouts that persist across routes and maintain state, templates create a new instance for each of their children on navigation. This means that when a user navigates between routes that share a template, a new instance of the child is mounted, DOM elements are recreated, state is not preserved in Client Components, and effects are re-synchronized.",
	"Structure - page": "In Next.js, a page is a React Component exported from a .js, .jsx, .ts, or .tsx file in the pages directory. Each page is associated with a route based on its file name.",
  "Structure - page - Page": "A page is UI that is unique to a route. You can define a page by default exporting a component from a page.js file.",
  "Structure - page - Page - getStaticPaths": "",
  "Structure - page - Page - getStaticProps": "",
  "Structure - page - access": "If you create pages/about.js that exports a React component like below, it will be accessible at /about.",
  "Structure - page - import": "",
  "Structure - page - import - dynamic": "",
  "Structure - page - import - dynamic - module": "const module = await import('some-big-library');",
  "Structure - page - import - dynamic - react": "For React components, Next.js provides a next/dynamic function to handle dynamic imports seamlessly with server-side rendering support. This is especially useful for heavy components that are not critical to the initial rendering of the page. const DynamicComponent = dynamic(() => import('../components/HeavyComponent'), { loading: () => <p>Loading...</p>, ssr: false, });",
	"Structure - Components": "",
  "Structure - Components - Font": "",
  "Structure - Components - Head": "",
  "Structure - Components - Image": "",
  "Structure - Components - Script": "",
	"Structure - Router - PagesRouter": "Legacy. Before Next.js 13, the Pages Router was the main way to create routes in Next.js. It used an intuitive file-system router to map each file to a route. The Pages Router is still supported in newer versions of Next.js, but we recommend migrating to the new App Router to leverage React's latest features.",
	"Structure - Router - PagesRouter - automatic": "Automatic Route Mapping: Each file in the pages directory is automatically mapped to a URL based on its file path. For example, pages/about.js is accessible at /about. The code below creates an ‘About us’ page that can be accessed at the /about URL.",
	"Structure - Router - PagesRouter - dynamic": "Dynamic Routing: Brackets in the file name are used to create dynamic path segments. For example, pages/posts/[id].js allows access to paths like posts/1, posts/2, etc. The code below creates a page that can be accessed with dynamic URLs such as posts/1, posts/2, etc.",
	"Structure - Router - PagesRouter - nested": "Nested Routing: The directory structure is used to easily create nested paths. For example, pages/blog/2020/post.js is accessible at /blog/2020/post. The code below creates a blog post page that can be accessed at the /blog/2020/post URL.",
	"Structure - Router - AppRouter": "In version 13, Next.js introduced a new App Router built on React Server Components, which supports shared layouts, nested routing, loading states, error handling, and more.",
  "Structure - Router - AppRouter - app": "The App Router works in a new directory named /app. By default, components inside app are React Server Components. This is a performance optimization and allows you to easily adopt them, and you can also use Client Components.",
  "Structure - Router - AppRouter - segments": "Each folder in a route represents a route segment. Each route segment is mapped to a corresponding segment in a URL path.",
  "Structure - Router - AppRouter - server": "Server-Centric Routing: React Server Components are used to generate HTML on the server, and only a minimal amount of JavaScript code is sent to the client.",
  "Structure - Router - AppRouter - layouts": "Layouts: The app directory must include a root layout, which allows UI to be shared across multiple pages. This concept is similar to the existing _app.tsx file and helps prevent re-rendering and improve performance.",
  "Structure - Router - AppRouter - dynamic": "Dynamic Rendering: When navigating pages, the entire page is not re-rendered; instead, only the changed segments are rendered, providing an experience similar to a Single Page Application (SPA).",
  "Structure - Router - AppRouter - nested": "Nested Routing: A complex routing structure can be constructed using a nested directory structure. To create a nested route, you can nest folders inside each other. For example, you can add a new /dashboard/settings route by nesting two new folders in the app directory.",
  "Structure - Router - AppRouter - streaming": "Streaming: The loading.tsx file is used to display a loading indicator or placeholder content while the page is fetching data. Once the data is ready, the server streams the actual page content, replacing the loading UI.",
  "Structure - Router - AppRouter - suspense": "Suspense: React’s Suspense component can be used to wrap components that rely on asynchronous data fetching. Next.js streams the HTML of these components once the necessary data is ready. A fallback UI to display during data loading can be provided inside Suspense.",
	"Structure - Router - navigating": ".",
  "Structure - Router - navigating - <Link/>": "<Link/> in import Link from 'next/link",
  "Structure - Router - navigating - useRouter": ".",
  "Structure - Router - navigating - redirect": ".",
  "Structure - Router - navigating - permanentRedirect": ".",
  "Structure - Router - navigating - redirects": ".",
  "Structure - Router - navigating - NextResponse.redirect": ".",
  "Structure - Router - navigating - HistoryAPI": ".",
  "Structure - Router - dynamic": ".",
  "Structure - Router - parallel": ".",
  "Structure - Router - intercepting": ".",

	"Data": "SECTION",

	"Logic": "SECTION",
	"Logic - Components - permanentRedirect": "The permanentRedirect function allows you to redirect the user to another URL. permanentRedirect can be used in Server Components, Client Components, Route Handlers, and Server Actions. When used in a streaming context, this will insert a meta tag to emit the redirect on the client side. When used in a server action, it will serve a 303 HTTP redirect response to the caller. Otherwise, it will serve a 308 (Permanent) HTTP redirect response to the caller.",
	"Logic - ClientComponents - useParams": "useParams is a Client Component hook that lets you read a route's dynamic params filled in by the current URL.",
	"Logic - ClientComponents - usePathname": "usePathname is a Client Component hook that lets you read the current URL's pathname.",
	"Logic - ClientComponents - useRouter": "The useRouter hook allows you to programmatically change routes inside Client Components.",
	"Logic - ClientComponents - useSearchParams": "useSearchParams is a Client Component hook that lets you read the current URL's query string. useSearchParams returns a read-only version of the URLSearchParams interface.",
	"Logic - ClientComponents - useSelectedLayoutSegment": "useSelectedLayoutSegment is a Client Component hook that lets you read the active route segment one level below the Layout it is called from. It is useful for navigation UI, such as tabs inside a parent layout that change style depending on the active child segment.",
	"Logic - ClientComponents - useSelectedLayoutSegments": "useSelectedLayoutSegments is a Client Component hook that lets you read the active route segments below the Layout it is called from. It is useful for creating UI in parent Layouts that need knowledge of active child segments such as breadcrumbs.",
	"Logic - ClientComponents - DataFetching - NextRequest": "NextRequest extends the WebRequestAPI with additional convenience methods. NextResponse extends the Web Response API with additional convenience methods.",
	"Logic - ClientComponents - DataFetching - RouteHandler": "Route Handlers allow you to create custom request handlers for a given route using the WebRequestAPI.",
	"Logic - ClientComponents - DataFetching - RouteHandler - methods": "The following HTTP methods are supported: GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS. If an unsupported method is called, Next.js will return a 405 Method Not Allowed response.",
	"Logic - ClientComponents - DataFetching - RouteHandler - Cache - Next14": "In Next.js 14, GET route handlers are cached by default.",
	"Logic - ClientComponents - DataFetching - RouteHandler - Cache - Next15": "In Next.js 15, GET route handlers won’t cache by default. If you want to cache GET route handlers in Next.js 15, you can use export const dynamic = 'force-static'.",
	"Logic - ClientComponents - DataFetching - RouteHandler - Cache - Next14 - staleTime": "In Next.js 14.2.0, the experimental staleTimes flag was introduced, allowing custom configuration of router caching. By default, the staleTime for dynamic routes is a non-zero value, defaulting to 30. If the prefetch parameter is set in the <Link> component, the default is 5 minutes.",
	"Logic - ClientComponents - DataFetching - RouteHandler - Cache - Next15 - staleTime": "In Next.js 15, the `staleTime` for Page segments defaults to 0, meaning the client will always fetch the latest page component data during in-app navigation.",
	"Logic - ClientComponents - DataFetching - RouteHandler - API": "Any file inside the folder pages/api is mapped to /api/* and will be treated as an API endpoint instead of a page. They are server-side only bundles and won't increase your client-side bundle size.",
	"Logic - ClientComponents - DataFetching - RouteHandler - APIRoutes": "export default async (req, res) => { ... return data }",
	"Logic - ClientComponents - DataFetching - RouteHandler - APIRoutes - NextApiRequest": "NextApiRequest extends Node.js' IncomingMessage (from node:http) and also adds several helpers to it. It's used in API routes.",
	"Logic - ClientComponents - DataFetching - RouteHandler - APIRoutes - caching": "export default async (req, res) => { res.setHeader('Cache-Control', 's-maxage=3600, stale-while-revalidate'); ... retrun data }",
	"Logic - ClientComponents - Caching - RouterCache": "Next.js Caching on the Client. Next.js has an in-memory client-side cache called the Router Cache.",
	"Logic - ClientComponents - Caching - RouterCache - Prefetching - <Link>": "<Link> component: Routes are automatically prefetched as they become visible in the user's viewport. Prefetching happens when the page first loads or when it comes into view through scrolling.",
	"Logic - ClientComponents - Caching - RouterCache - Prefetching - router.prefetch()": "router.prefetch(): The useRouter hook can be used to prefetch routes programmatically.",
	"Logic - ClientComponents - Caching - RouterCache - Prefetching - router.refresh()": "Revalidate RouterCache.",
	"Logic - ServerComponents - generateImageMetadata": "You can use generateImageMetadata to generate different versions of one image or return multiple images for one route segment. This is useful for when you want to avoid hard-coding metadata values, such as for icons.",
	"Logic - ServerComponents - generateMetadata": "This page covers all Config-based Metadata options with generateMetadata and the static metadata object. The metadata object and generateMetadata function exports are only supported in Server Components.",
	"Logic - ServerComponents - generateSitemaps": "You can use the generateSitemaps function to generate multiple sitemaps for your application.",
	"Logic - ServerComponents - generateStaticParams": "The generateStaticParams function can be used in combination with dynamic route segments to statically generate routes at build time instead of on-demand at request time.",
	"Logic - ServerComponents - generateViewport": "You can customize the initial viewport of the page with the static viewport object or the dynamic generateViewport function.",
	"Logic - ServerComponents - ImageResponse": "The ImageResponse constructor allows you to generate dynamic images using JSX and CSS. This is useful for generating social media images such as Open Graph images, Twitter cards, and more.",
	"Logic - ServerComponents - headers": "The headers function allows you to read the HTTP incoming request headers from a Server Component.",
	"Logic - ServerComponents - cookies": "The cookies function allows you to read the HTTP incoming request cookies from a Server Component or write outgoing request cookies in a Server Action or Route Handler.",
	"Logic - ServerComponents - redirect": "The redirect function allows you to redirect the user to another URL. redirect can be used in Server Components, Route Handlers, and Server Actions. When used in a streaming context, this will insert a meta tag to emit the redirect on the client side. When used in a server action, it will serve a 303 HTTP redirect response to the caller. Otherwise, it will serve a 307 HTTP redirect response to the caller. If a resource doesn't exist, you can use the notFound function instead.",
	"Logic - ServerComponents - draftMode": "The draftMode function allows you to detect Draft Mode inside a Server Component.",
  "Logic - ServerComponents - DataFetching - getInitialProps": "getInitialProps is a method used in older versions of Next.js (versions prior to 9.3) to fetch data on the server side before rendering a page. It was the primary data fetching method used in Next.js before newer data fetching methods like getServerSideProps and getStaticProps were introduced. In older versions of Next.js, getInitialProps was the primary data fetching mechanism for both SSR and client-side rendering. getInitialProps is a special function provided by Next.js that runs on the server side before rendering a page. This function allows you to fetch data from an external API, database, or any other data source, and pass it as props to your React components. By doing so, you can pre-populate your pages with data and make them more SEO-friendly, as search engines can crawl your pages’ content easily. In this article, we will explore one of its features, getInitialProps, by building a small app. getInitialProps is a lifecycle method in Next.js that allows you to asynchronously fetch data and pass it to your page or component as props before rendering. It can be used in both pages and custom App components, making it versatile for server-side data fetching.",
  "Logic - ServerComponents - DataFetching - getServerSideProps": "getServerSideProps is a data fetching method that was introduced in Next.js 9.3. It is used specifically for server-side rendering (SSR). Unlike getInitialProps, getServerSideProps is only executed on the server side during the initial page request and not on subsequent client-side navigations. This change improves performance by reducing duplicate data fetching and provides better predictability of server-side data fetching.",
  "Logic - ServerComponents - DataFetching - getStaticProps": "getStaticProps is another data fetching method that was introduced in Next.js 9.3, and it is used for static site generation (SSG). When using getStaticProps, Next.js pre-renders the page at build time and fetches the data during the build process. The pre-rendered HTML pages are then served to users directly from the CDN, offering faster page loads and reducing server load.. You need to export an asynchronous function called getStaticProps in your page component. This function is responsible for providing the page's props and is executed at build time.",
	"Logic - ServerComponents - DataFetching - WebAPI - fetch": "Next.js extends the native Web fetch() API to allow each request on the server to set its own persistent caching semantics. In the browser, the cache option indicates how a fetch request will interact with the browser's HTTP cache. With this extension, cache indicates how a server-side fetch request will interact with the framework's persistent HTTP cache. You can call fetch with async and await directly within Server Components.",
	"Logic - ServerComponents - DataFetching - WebAPI - fetch - Cache - Next14": "In Next.js 14, fetch requests use the force-cache strategy by default, meaning data is cached by default. const res = await fetch('https://api.weijunext.com/');",
	"Logic - ServerComponents - DataFetching - WebAPI - fetch - Cache - Next15": "In Next.js 15, fetch requests will use the no-store strategy by default, meaning they won’t cache by default. If you want to cache data in Next.js 15, you need to explicitly specify the caching parameters. For example: const res = await fetch('https://api.weijunext.com/', { cache: 'force-cache' });",
	"Logic - ServerComponents - Caching - FullRouteCache": "Next.js Caching on the Server. Next.js automatically renders and caches routes at build time. This is an optimization that allows you to serve the cached route instead of rendering on the server for every request, resulting in faster page loads. The default behavior of Next.js is to cache the rendered result (React Server Component Payload and HTML) of a route on the server. This applies to statically rendered routes at build time, or during revalidation.",
	"Logic - ServerComponents - Caching - FullRouteCache - fetch": "",
	"Logic - ServerComponents - Caching - FullRouteCache - revalidateTag": "",
	"Logic - ServerComponents - Caching - FullRouteCache - revalidatePath": "revalidatePath allows you manually revalidate data and re-render the route segments below a specific path in a single operation. Calling the revalidatePath method revalidates the Data Cache, which in turn invalidates the Full Route Cache.",
	"Logic - ServerComponents - Caching - FullRouteCache - cookies": "",
	"Logic - ServerComponents - Caching - FullRouteCache - headers": "",
	"Logic - ServerComponents - Caching - FullRouteCache - searchParams": "",
	"Logic - ServerComponents - Caching - FullRouteCache - generateStaticParams": "",
	"Logic - ServerComponents - Caching - DataCache": "Next.js has a built-in Data Cache that persists the result of data fetches across incoming server requests and deployments. This is possible because Next.js extends the native fetch API to allow each request on the server to set its own persistent caching semantics.",
	"Logic - ServerComponents - Caching - DataCache - fetch": "",
	"Logic - ServerComponents - Caching - DataCache - revalidateTag": "",
	"Logic - ServerComponents - Caching - DataCache - revalidatePath": "revalidatePath allows you manually revalidate data and re-render the route segments below a specific path in a single operation. Calling the revalidatePath method revalidates the Data Cache, which in turn invalidates the Full Route Cache.",

	"View": "SECTION",
	"View - Process - Rendering - ClientComponents": "The rendering work is split into chunks: by individual routes segments and Suspense boundaries.",
	"View - Process - Rendering - ClientComponents - RenderOnServer": "1. React Rendering on the Server. Each chunk is rendered in two steps: React renders Server Components into a special data format, optimized for streaming, called the React Server Component Payload. Next.js uses the React Server Component Payload and Client Component JavaScript instructions to render HTML on the server. This means we don't have to wait for everything to render before caching the work or sending a response. Instead, we can stream a response as work is completed.",
	"View - Process - Rendering - ClientComponents - CacheOnServer": "2. Next.js Caching on the Server (Full Route Cache). The default behavior of Next.js is to cache the rendered result (React Server Component Payload and HTML) of a route on the server. This applies to statically rendered routes at build time, or during revalidation.",
	"View - Process - Rendering - ClientComponents - HydrationOnClient": "3. React Hydration and Reconciliation on the Client. At request time, on the client: The HTML is used to immediately show a fast non-interactive initial preview of the Client and Server Components. The React Server Components Payload is used to reconcile the Client and rendered Server Component trees, and update the DOM. The JavaScript instructions are used to hydrate Client Components and make the application interactive.",
	"View - Process - Rendering - ClientComponents - CacheOnClient": "4. Next.js Caching on the Client (Router Cache). The React Server Component Payload is stored in the client-side Router Cache - a separate in-memory cache, split by individual route segment. This Router Cache is used to improve the navigation experience by storing previously visited routes and prefetching future routes.",
	"View - Process - Rendering - ClientComponents - Rerendering": "5. Subsequent Navigations. On subsequent navigations or during prefetching, Next.js will check if the React Server Components Payload is stored in the Router Cache. If so, it will skip sending a new request to the server. If the route segments are not in the cache, Next.js will fetch the React Server Components Payload from the server, and populate the Router Cache on the client.",
	"View - Process - Rendering - ServerComponents": "On the server, Next.js uses React's APIs to orchestrate rendering. The rendering work is split into chunks: by individual route segments and Suspense Boundaries.",
	"View - Process - Rendering - ServerComponents - RSC Payload": "1. React renders Server Components into a special data format called the React Server Component Payload (RSC Payload).",
	"View - Process - Rendering - ServerComponents - RenderOnServer": "2. Next.js uses the RSC Payload and Client Component JavaScript instructions to render HTML on the server.",
	"View - Process - Rendering - ServerComponents - ShowPreview": "3. The HTML is used to immediately show a fast non-interactive preview of the route - this is for the initial page load only.",
	"View - Process - Rendering - ServerComponents - UpdateDOM": "4. The React Server Components Payload is used to reconcile the Client and Server Component trees, and update the DOM.",
	"View - Process - Rendering - ServerComponents - HydrationOnClient": "5. The JavaScript instructions are used to hydrate Client Components and make the application interactive.",

	"CICD": "SECTION",
	"CICD - Bundling - external packages": "Next.js 15 introduces stable configuration options for optimizing the bundling of external packages in both the App Router and Pages Router. These improvements aim to enhance cold-start performance and provide developers with more control over how external dependencies are included in their applications.",
	"CICD - Building - Caching": "Static and Dynamic Rendering. Whether a route is cached or not at build time depends on whether it's statically or dynamically rendered. Static routes are cached by default, whereas dynamic routes are rendered at request time, and not cached.",
	"CICD - Building - Caching - Static": "As the web started to become a mainstream platform for consuming information, people began sharing information by writing HTML documents. All the information was written as static markup and published to the internet. Each time something new needed to be shared, we would add another HTML document, and everything worked seamlessly.",
	"CICD - Building - Caching - CSR": "Whenever the page requires more data, an API call can be made to a backend hosted independently, which provides the required data in a format agreed upon by the client and server (e.g., JSON). Poor SEO.",
  "CICD - Building - Caching - SSG": "Static Content / Static Site Generation (SSG). HTML pages are generated at build time and served directly from a CDN, resulting in blazing-fast load times and good performance.",
  "CICD - Building - Caching - SSG - Static": "The downside is that there won't be any dynamic content. This strategy is extremely useful for writing articles, documentation, etc.",
	"CICD - Building - Caching - SSR": "If a page uses Server-side Rendering, the page HTML is generated on each request.",
	"CICD - Building - Caching - SSR - drawbacks - load": "Try to use SSR consciously and check whether you actually need SEO or not for your application. SSR takes up an immense load, so if you avoid using it when not required, you will be blessed.",
  "CICD - Building - Caching - SSR - benefits - Data Fetching": "Data Fetching: Server Components allow you to move data fetching to the server, closer to your data source. This can improve performance by reducing time it takes to fetch data needed for rendering, and the number of requests the client needs to make.",
  "CICD - Building - Caching - SSR - benefits - Security": "Security: Server Components allow you to keep sensitive data and logic on the server, such as tokens and API keys, without the risk of exposing them to the client.",
  "CICD - Building - Caching - SSR - benefits - Caching": "Caching: By rendering on the server, the result can be cached and reused on subsequent requests and across users. This can improve performance and reduce cost by reducing the amount of rendering and data fetching done on each request.",
  "CICD - Building - Caching - SSR - benefits - Performance": "Performance: Server Components give you additional tools to optimize performance from the baseline. For example, if you start with an app composed of entirely Client Components, moving non-interactive pieces of your UI to Server Components can reduce the amount of client-side JavaScript needed. This is beneficial for users with slower internet or less powerful devices, as the browser has less client-side JavaScript to download, parse, and execute.",
  "CICD - Building - Caching - SSR - benefits - Initial Page Load": "Initial Page Load and First Contentful Paint (FCP): On the server, we can generate HTML to allow users to view the page immediately, without waiting for the client to download, parse and execute the JavaScript needed to render the page.",
  "CICD - Building - Caching - SSR - benefits - SEO": "Search Engine Optimization and Social Network Shareability: The rendered HTML can be used by search engine bots to index your pages and social network bots to generate social card previews for your pages.",
  "CICD - Building - Caching - SSR - benefits - Streaming": "Streaming: Server Components allow you to split the rendering work into chunks and stream them to the client as they become ready. This allows the user to see parts of the page earlier without having to wait for the entire page to be rendered on the server.",
  "CICD - Building - Caching - SSR - strategies - Static": "With Static Rendering, routes are rendered at build time, or in the background after data revalidation. The result is cached and can be pushed to a Content Delivery Network (CDN). This optimization allows you to share the result of the rendering work between users and server requests. Static rendering is useful when a route has data that is not personalized to the user and can be known at build time, such as a static blog post or a product page.",
  "CICD - Building - Caching - SSR - strategies - Dynamic": "With Dynamic Rendering, routes are rendered for each user at request time. Dynamic rendering is useful when a route has data that is personalized to the user or has information that can only be known at request time, such as cookies or the URL's search params.",
  "CICD - Building - Caching - SSR - strategies - Streaming": "Streaming enables you to progressively render UI from the server. Work is split into chunks and streamed to the client as it becomes ready. This allows the user to see parts of the page immediately, before the entire content has finished rendering.",
	"CICD - Building - Caching - SSR - getServerSideProps": "To use Server-side Rendering for a page, you need to export an async function called getServerSideProps. This function will be called by the server on every request.",
  "CICD - Building - Caching - SSR - no data": ".",
  "CICD - Building - Caching - SSR - data": ".",
  "CICD - Building - Caching - SSR - hydration": "Hydration is the process of transforming pre-rendered server-side content into an interactive user interface on the client side. When a user accesses a pre-rendered page, Next.js promptly sends the fully rendered HTML content to the client's browser, complete with initial data and UI from the server. Then, client-side JavaScript hydrates this static content, imbuing it with interactivity to form a fully functional React application. https://dev.to/rajaerobinson/understanding-hydration-in-nextjs-b5m",
  "CICD - Building - Caching - ISR": "SSG+Update. With ISR, pages are initially generated statically, but they can be dynamically updated in the background based on specific triggers or time intervals. This provides a balance of speed and dynamic content updates..",
  "CICD - Building - Caching - ISR - revalidate": "Within the object returned by the getStaticProps function, you can set a revalidate property. The value of this property is a number, indicating how many seconds after which the page content will be regenerated.",
  "CICD - Building - Caching - ISR - how": "When a request is made for a statically generated page, if the time since the last generation has exceeded the revalidate setting, Next.js will regenerate the page in the background. Meanwhile, for user requests, the old page content will still be provided until the new page is generated, ensuring the immediacy and consistency of access.",
	"CICD - Building - Caching - PPR": "Next.js 14 introduces an experimental feature called Partial Prerendering (PPR).",
	"CICD - Building - Caching - PPR - how": "PPR allows developers to incrementally adopt a hybrid rendering approach.",
	"CICD - Building - Caching - PPR - how - static": "A static shell that’s pre-rendered on the server at build time (or potentially on-demand). This shell contains the basic structure and layout of the page, along with any static or non-personalized content.",
	"CICD - Building - Caching - PPR - how - dynamic": "You can wrap dynamic UI components in a Suspense boundary. Dynamic holes or placeholders for Client Components that will be fetched and hydrated on the client-side after the initial page load. These components handle dynamic or personalized content.",
	"CICD - Building - Caching - PPR - enable": "To enable PPR, set the experimental.ppr config option to ‘incremental’ in next.config.js:",
  "CICD - Building - Caching - ASO": "Next.js automatically determines that a page is static (can be prerendered) if it has no blocking data requirements. This determination is made by the absence of getServerSideProps and getInitialProps in the page.",
	"CICD - Deploying - Multi-Zones": "An interesting feature offered by Next.js is Multi-Zones, an approach to micro-frontends. It allows a large application to be divided into smaller, independent Next.js applications, each serving a specific set of paths on the same domain. This modularization can improve build times and reduce code complexity.",
	"CICD - Deploying - Multi-Zones - multiapp": "Each zone is a standard Next.js application configured with a basePath to prevent conflicts.",
	"CICD - Deploying - Multi-Zones - navigation": "Navigation within a zone is seamless (soft navigation), while navigating between zones triggers a full page reload (hard navigation).",
	"CICD - Deploying - Multi-Zones - proxies": "An HTTP proxy or a designated Next.js application can be used to route requests to the correct zone.",
	"CICD - Deploying - Multi-Zones - anchor": "Anchor tags (<a>) should be used for links between zones.",
	"CICD - Deploying - Multi-Zones - code": "Code sharing can be facilitated through monorepos or NPM packages, and feature flags can help coordinate feature releases across zones.",
	"CICD - Deploying - server": "By default, Next.js includes its own server with next start.",
	"CICD - Deploying - SST": "https://levelup.gitconnected.com/deploy-next-js-to-aws-using-sst-fa2f50c5737a",
	"CICD - Deploying - assetPrefix": "In Next.js, publishing static assets to a CDN and managing them through the assetPrefix configuration is a very efficient method. It can help optimize your application's load time and reduce server load. module.exports = { assetPrefix: isProd ? 'https://yourcdn.example.com' : '', };",
	"CICD - Deploying - next/after API": "The next/after API is another experimental feature in Next.js 15 RC. This feature enables developers to perform secondary tasks or cleanup operations without blocking the primary response. This addition provides more flexibility in handling post-response logic, allowing for cleaner and more efficient code management. Potential use cases include analytics logging, resource cleanup, or additional data fetching after the initial response.",
  "CICD - SEO - robots.txt": "This is a text file placed in the root directory of your site that tells search engine crawlers which pages or sections of your site should not be crawled and indexed. For a Next.js site, you can create a robots.txt file and serve it statically. Ensure it’s accessible by placing it in the public folder. This will help control the crawler traffic to your site, prevent the indexing of certain pages, and help manage the crawl budget.",
  "CICD - SEO - XML Sitemaps": "A sitemap is crucial as it lists all URLs for a site, allowing search engines to crawl the site more intelligently. In Next.js, you can generate sitemaps dynamically or during your build process. Static generation is often preferred for performance reasons. You can use libraries like next-sitemap to automate the generation of sitemaps during your build process.",
  "CICD - SEO - Semantic HTML": "Semantic HTML5 elements (like <header>, <footer>, <article>, and <section>) help search engines understand the structure of your website and the importance of the content within each section. This can be particularly beneficial for SEO.",
  "CICD - SEO - Optimize Page Speed": "Google considers page speed as a ranking factor. Optimize images, leverage efficient CSS and JavaScript, use Next.js’s Image component for optimized image handling, and consider implementing a Content Delivery Network (CDN) to serve your content faster.",
  "CICD - SEO - Meta Tags": "Ensure each page has a unique title and description meta tags that accurately describe the page content. These are crucial for SEO as they appear in search engine results.",
  "CICD - SEO - Structured Data": "Implement structured data using JSON-LD to help search engines understand the content of your pages and provide rich results. Next.js can handle inline scripts where you can place your JSON-LD structured data.",
  "CICD - SEO - Accessibility (A11y)": "Making your website accessible is not only a good practice for usability; it also impacts SEO. Ensuring your website is accessible to all users, including those with disabilities, can positively influence your rankings.",
  "CICD - SEO - Mobile-Friendliness": "With the increasing use of mobile devices, having a mobile-friendly website is crucial. Next.js’s responsive design capabilities can help ensure that your website looks good on all devices, which is important for both user experience and SEO.",
  "CICD - SEO - Content Quality": "Regularly update your website with high-quality, relevant content that addresses your audience’s needs. This is vital for SEO and helps retain visitors."

}