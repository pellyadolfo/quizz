{
  "NextJS": "SECTION",

	"Structure": "SECTION",
  "Structure - app": "Next.js uses the App component to initialize pages. You can override it and control the page initialization and: Create a shared layout between page changes, Inject additional data into pages, Add global CSS",
  "Structure - app - create-next-app": "The easiest way to get started with Next.js is by using create-next-app. This CLI tool enables you to quickly start building a new Next.js application, with everything set up for you.",
  "Structure - app - _app": "To override the default App, create the file pages/_app",
	"Structure - layout": "A layout is UI that is shared between multiple routes. On navigation, layouts preserve state, remain interactive, and do not re-render. Layouts can also be nested.",
  "Structure - layout - root": "The root layout is defined at the top level of the app directory and applies to all routes. This layout is required and must contain html and body tags, allowing you to modify the initial HTML returned from the server.",
  "Structure - layout - nested": ".",
  "Structure - layout - templates": "Templates are similar to layouts in that they wrap a child layout or page. Unlike layouts that persist across routes and maintain state, templates create a new instance for each of their children on navigation. This means that when a user navigates between routes that share a template, a new instance of the child is mounted, DOM elements are recreated, state is not preserved in Client Components, and effects are re-synchronized.",
	"Structure - page": "In Next.js, a page is a React Component exported from a .js, .jsx, .ts, or .tsx file in the pages directory. Each page is associated with a route based on its file name.",
  "Structure - page - Page": "A page is UI that is unique to a route. You can define a page by default exporting a component from a page.js file.",
  "Structure - page - Page - getStaticPaths": "",
  "Structure - page - Page - getStaticProps": "",
  "Structure - page - access": "If you create pages/about.js that exports a React component like below, it will be accessible at /about.",
  "Structure - page - import": "",
  "Structure - page - import - dynamic": "",
  "Structure - page - import - dynamic - module": "const module = await import('some-big-library');",
  "Structure - page - import - dynamic - react": "For React components, Next.js provides a next/dynamic function to handle dynamic imports seamlessly with server-side rendering support. This is especially useful for heavy components that are not critical to the initial rendering of the page. const DynamicComponent = dynamic(() => import('../components/HeavyComponent'), { loading: () => <p>Loading...</p>, ssr: false, });",
	"Structure - Components": "",
  "Structure - Components - Font": "",
  "Structure - Components - Head": "",
  "Structure - Components - Image": "",
  "Structure - Components - Script": "",
	"Structure - Router - PagesRouter": "Before Next.js 13, the Pages Router was the main way to create routes in Next.js. It used an intuitive file-system router to map each file to a route. The Pages Router is still supported in newer versions of Next.js, but we recommend migrating to the new App Router to leverage React's latest features.",
	"Structure - Router - PagesRouter - automatic": "Automatic Route Mapping: Each file in the pages directory is automatically mapped to a URL based on its file path. For example, pages/about.js is accessible at /about. The code below creates an ‘About us’ page that can be accessed at the /about URL.",
	"Structure - Router - PagesRouter - dynamic": "Dynamic Routing: Brackets in the file name are used to create dynamic path segments. For example, pages/posts/[id].js allows access to paths like posts/1, posts/2, etc. The code below creates a page that can be accessed with dynamic URLs such as posts/1, posts/2, etc.",
	"Structure - Router - PagesRouter - nested": "Nested Routing: The directory structure is used to easily create nested paths. For example, pages/blog/2020/post.js is accessible at /blog/2020/post. The code below creates a blog post page that can be accessed at the /blog/2020/post URL.",
	"Structure - Router - PagesRouter - api": "API Routes: Files inside the pages/api directory function as API endpoints. This makes it easy to implement serverless functions. The code below creates an API endpoint that returns a JSON-formatted ‘Hello!’ message when accessed at the /api/hello URL.",
	"Structure - Router - AppRouter": "In version 13, Next.js introduced a new App Router built on React Server Components, which supports shared layouts, nested routing, loading states, error handling, and more.",
  "Structure - Router - AppRouter - app": "The App Router works in a new directory named app. By default, components inside app are React Server Components. This is a performance optimization and allows you to easily adopt them, and you can also use Client Components.",
  "Structure - Router - AppRouter - segments": "Each folder in a route represents a route segment. Each route segment is mapped to a corresponding segment in a URL path.",
  "Structure - Router - AppRouter - server": "Server-Centric Routing: React Server Components are used to generate HTML on the server, and only a minimal amount of JavaScript code is sent to the client.",
  "Structure - Router - AppRouter - layouts": "Layouts: The app directory must include a root layout, which allows UI to be shared across multiple pages. This concept is similar to the existing _app.tsx file and helps prevent re-rendering and improve performance.",
  "Structure - Router - AppRouter - dynamic": "Dynamic Rendering: When navigating pages, the entire page is not re-rendered; instead, only the changed segments are rendered, providing an experience similar to a Single Page Application (SPA).",
  "Structure - Router - AppRouter - nested": "Nested Routing: A complex routing structure can be constructed using a nested directory structure. To create a nested route, you can nest folders inside each other. For example, you can add a new /dashboard/settings route by nesting two new folders in the app directory.",
  "Structure - Router - AppRouter - streaming": "Streaming: The loading.tsx file is used to display a loading indicator or placeholder content while the page is fetching data. Once the data is ready, the server streams the actual page content, replacing the loading UI.",
  "Structure - Router - AppRouter - suspense": "Suspense: React’s Suspense component can be used to wrap components that rely on asynchronous data fetching. Next.js streams the HTML of these components once the necessary data is ready. A fallback UI to display during data loading can be provided inside Suspense.",
	"Structure - Router - navigating": ".",
  "Structure - Router - navigating - <Link/>": "<Link/> in import Link from 'next/link",
  "Structure - Router - navigating - useRouter": ".",
  "Structure - Router - navigating - redirect": ".",
  "Structure - Router - navigating - permanentRedirect": ".",
  "Structure - Router - navigating - redirects": ".",
  "Structure - Router - navigating - NextResponse.redirect": ".",
  "Structure - Router - navigating - HistoryAPI": ".",
  "Structure - Router - dynamic": ".",
  "Structure - Router - parallel": ".",
  "Structure - Router - intercepting": ".",
  "Structure - Router - handlers": ".",

	"Data": "SECTION",
  "Data - Props - getInitialProps": "getInitialProps is a special function provided by Next.js that runs on the server side before rendering a page. This function allows you to fetch data from an external API, database, or any other data source, and pass it as props to your React components. By doing so, you can pre-populate your pages with data and make them more SEO-friendly, as search engines can crawl your pages’ content easily. In this article, we will explore one of its features, getInitialProps, by building a small app. getInitialProps is a lifecycle method in Next.js that allows you to asynchronously fetch data and pass it to your page or component as props before rendering. It can be used in both pages and custom App components, making it versatile for server-side data fetching.",
  "Data - Props - getServerSideProps": "",

	"Logic": "SECTION",
	"Logic - Request - URL": "https://medium.com/@PropelAuth/getting-the-current-url-in-next-js-server-components-507baaec80e5",
	"Logic - EndPoints - API Routing": "export default async (req, res) => { ... retrun data }",
	"Logic - EndPoints - API Routing - caching": "export default async (req, res) => { res.setHeader('Cache-Control', 's-maxage=3600, stale-while-revalidate'); ... retrun data }",
	"Logic - DataFeching - Types": "There are four ways you can fetch data: (1) On the server, with fetch, (2) On the server, with third-party libraries (3) On the client, via a Route Handler (4) On the client, with third-party libraries.",
	"Logic - DataFeching - Types - server fetch": ".",
	"Logic - DataFeching - Types - server libraries": ".",
	"Logic - DataFeching - Types - WebRequestAPI": ".",
	"Logic - DataFeching - Types - WebRequestAPI - NextRequest": "NextRequest extends the Web Response API with additional convenience methods.",
  "Logic - DataFeching - Types - WebRequestAPI - NextResponse": "NextResponse extends the Web Response API with additional convenience methods.",
	"Logic - DataFeching - Types - client RouteHandler": "Route Handlers allow you to create custom request handlers for a given route using the Web Request and Response APIs. The following HTTP methods are supported: GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS. If an unsupported method is called, Next.js will return a 405 Method Not Allowed response.",
	"Logic - DataFeching - Types - client libraries": ".",
	"Logic - server - ServerActions": "Next.js 13+. Next.js Server Actions are functions that execute on the server side. Having these special functions that only run on the server means that developers can offload responsibilities like data fetching and mutations to them, avoiding the vulnerabilities and security concerns of fetching and mutating data from the client.",
	"Logic - server - ServerActions - React": "from React Server Actions",

	"View": "SECTION",
  "View - Rendering - strategy - CSR": "In Client-Side Rendering (CSR) with React, the browser downloads a minimal HTML page and the JavaScript needed for the page. The JavaScript is then used to update the DOM and render the page. When the application is first loaded, the user may notice a slight delay before they can see the full page, this is because the page isn't fully rendered until all the JavaScript is downloaded, parsed, and executed.",
	"View - Rendering - strategy - SSR": "If a page uses Server-side Rendering, the page HTML is generated on each request.",
	"View - Rendering - strategy - SSR - drawbacks - load": "Try to use SSR consciously and check whether you actually need SEO or not for your application. SSR takes up an immense load, so if you avoid using it when not required, you will be blessed.",
  "View - Rendering - strategy - SSR - benefits - Data Fetching": "Data Fetching: Server Components allow you to move data fetching to the server, closer to your data source. This can improve performance by reducing time it takes to fetch data needed for rendering, and the number of requests the client needs to make.",
  "View - Rendering - strategy - SSR - benefits - Security": "Security: Server Components allow you to keep sensitive data and logic on the server, such as tokens and API keys, without the risk of exposing them to the client.",
  "View - Rendering - strategy - SSR - benefits - Caching": "Caching: By rendering on the server, the result can be cached and reused on subsequent requests and across users. This can improve performance and reduce cost by reducing the amount of rendering and data fetching done on each request.",
  "View - Rendering - strategy - SSR - benefits - Performance": "Performance: Server Components give you additional tools to optimize performance from the baseline. For example, if you start with an app composed of entirely Client Components, moving non-interactive pieces of your UI to Server Components can reduce the amount of client-side JavaScript needed. This is beneficial for users with slower internet or less powerful devices, as the browser has less client-side JavaScript to download, parse, and execute.",
  "View - Rendering - strategy - SSR - benefits - Initial Page Load": "Initial Page Load and First Contentful Paint (FCP): On the server, we can generate HTML to allow users to view the page immediately, without waiting for the client to download, parse and execute the JavaScript needed to render the page.",
  "View - Rendering - strategy - SSR - benefits - SEO": "Search Engine Optimization and Social Network Shareability: The rendered HTML can be used by search engine bots to index your pages and social network bots to generate social card previews for your pages.",
  "View - Rendering - strategy - SSR - benefits - Streaming": "Streaming: Server Components allow you to split the rendering work into chunks and stream them to the client as they become ready. This allows the user to see parts of the page earlier without having to wait for the entire page to be rendered on the server.",
  "View - Rendering - strategy - SSR - strategies - Static": "With Static Rendering, routes are rendered at build time, or in the background after data revalidation. The result is cached and can be pushed to a Content Delivery Network (CDN). This optimization allows you to share the result of the rendering work between users and server requests. Static rendering is useful when a route has data that is not personalized to the user and can be known at build time, such as a static blog post or a product page.",
  "View - Rendering - strategy - SSR - strategies - Dynamic": "With Dynamic Rendering, routes are rendered for each user at request time. Dynamic rendering is useful when a route has data that is personalized to the user or has information that can only be known at request time, such as cookies or the URL's search params.",
  "View - Rendering - strategy - SSR - strategies - Streaming": "Streaming enables you to progressively render UI from the server. Work is split into chunks and streamed to the client as it becomes ready. This allows the user to see parts of the page immediately, before the entire content has finished rendering.",
	"View - Rendering - strategy - SSR - getServerSideProps": "To use Server-side Rendering for a page, you need to export an async function called getServerSideProps. This function will be called by the server on every request.",
  "View - Rendering - strategy - SSR - no data": ".",
  "View - Rendering - strategy - SSR - data": ".",
  "View - Rendering - strategy - SSR - hydration": "Hydration is the process of transforming pre-rendered server-side content into an interactive user interface on the client side. When a user accesses a pre-rendered page, Next.js promptly sends the fully rendered HTML content to the client's browser, complete with initial data and UI from the server. Then, client-side JavaScript hydrates this static content, imbuing it with interactivity to form a fully functional React application. https://dev.to/rajaerobinson/understanding-hydration-in-nextjs-b5m",
  "View - Rendering - strategy - SSG": "HTML pages are generated at build time and served directly from a CDN, resulting in blazing-fast load times and good performance.",
  "View - Rendering - strategy - ISR": "SSG+Update. With ISR, pages are initially generated statically, but they can be dynamically updated in the background based on specific triggers or time intervals. This provides a balance of speed and dynamic content updates..",
  "View - Rendering - strategy - ISR - getStaticProps": "You need to export an asynchronous function called getStaticProps in your page component. This function is responsible for providing the page's props and is executed at build time.",
  "View - Rendering - strategy - ISR - revalidate": "Within the object returned by the getStaticProps function, you can set a revalidate property. The value of this property is a number, indicating how many seconds after which the page content will be regenerated.",
  "View - Rendering - strategy - ISR - how": "When a request is made for a statically generated page, if the time since the last generation has exceeded the revalidate setting, Next.js will regenerate the page in the background. Meanwhile, for user requests, the old page content will still be provided until the new page is generated, ensuring the immediacy and consistency of access.",
	"View - Rendering - strategy - PPR": "Next.js 14 introduces an experimental feature called Partial Prerendering (PPR).",
	"View - Rendering - strategy - PPR - how": "PPR allows developers to incrementally adopt a hybrid rendering approach.",
	"View - Rendering - strategy - PPR - how - static": "A static shell that’s pre-rendered on the server at build time (or potentially on-demand). This shell contains the basic structure and layout of the page, along with any static or non-personalized content.",
	"View - Rendering - strategy - PPR - how - dynamic": "You can wrap dynamic UI components in a Suspense boundary. Dynamic holes or placeholders for Client Components that will be fetched and hydrated on the client-side after the initial page load. These components handle dynamic or personalized content.",
	"View - Rendering - strategy - PPR - enable": "To enable PPR, set the experimental.ppr config option to ‘incremental’ in next.config.js:",
  "View - Rendering - ASO": "Next.js automatically determines that a page is static (can be prerendered) if it has no blocking data requirements. This determination is made by the absence of getServerSideProps and getInitialProps in the page.",
	"View - Caching": ".",
	"View - Caching - mechanisms - fetch - Next14": "In Next.js 14, fetch requests use the force-cache strategy by default, meaning data is cached by default. const res = await fetch('https://api.weijunext.com/');",
	"View - Caching - mechanisms - fetch - Next15": "In Next.js 15, fetch requests will use the no-store strategy by default, meaning they won’t cache by default. If you want to cache data in Next.js 15, you need to explicitly specify the caching parameters. For example: const res = await fetch('https://api.weijunext.com/', { cache: 'force-cache' });",
	"View - Caching - mechanisms - Request Memoization": ".",
	"View - Caching - mechanisms - Data Cache": ".",
	"View - Caching - mechanisms - Full Route Cache": ".",
	"View - Caching - mechanisms - Router Cache - Next14": "In Next.js 14, GET route handlers are cached by default.",
	"View - Caching - mechanisms - Router Cache - Next15": "In Next.js 15, GET route handlers won’t cache by default. If you want to cache GET route handlers in Next.js 15, you can use export const dynamic = 'force-static'.",
	"View - Caching - mechanisms - Router Cache - Next14 - staleTime": "In Next.js 14.2.0, the experimental staleTimes flag was introduced, allowing custom configuration of router caching. By default, the staleTime for dynamic routes is a non-zero value, defaulting to 30. If the prefetch parameter is set in the <Link> component, the default is 5 minutes.",
	"View - Caching - mechanisms - Router Cache - Next15 - staleTime": "In Next.js 15, the `staleTime` for Page segments defaults to 0, meaning the client will always fetch the latest page component data during in-app navigation.",

	"CICD": "SECTION",
	"CICD - Bundling - external packages": "Next.js 15 introduces stable configuration options for optimizing the bundling of external packages in both the App Router and Pages Router. These improvements aim to enhance cold-start performance and provide developers with more control over how external dependencies are included in their applications.",
	"CICD - Deploying - Multi-Zones": "An interesting feature offered by Next.js is Multi-Zones, an approach to micro-frontends. It allows a large application to be divided into smaller, independent Next.js applications, each serving a specific set of paths on the same domain. This modularization can improve build times and reduce code complexity.",
	"CICD - Deploying - Multi-Zones - multiapp": "Each zone is a standard Next.js application configured with a basePath to prevent conflicts.",
	"CICD - Deploying - Multi-Zones - navigation": "Navigation within a zone is seamless (soft navigation), while navigating between zones triggers a full page reload (hard navigation).",
	"CICD - Deploying - Multi-Zones - proxies": "An HTTP proxy or a designated Next.js application can be used to route requests to the correct zone.",
	"CICD - Deploying - Multi-Zones - anchor": "Anchor tags (<a>) should be used for links between zones.",
	"CICD - Deploying - Multi-Zones - code": "Code sharing can be facilitated through monorepos or NPM packages, and feature flags can help coordinate feature releases across zones.",
	"CICD - Deploying - server": "By default, Next.js includes its own server with next start.",
	"CICD - Deploying - SST": "https://levelup.gitconnected.com/deploy-next-js-to-aws-using-sst-fa2f50c5737a",
	"CICD - Deploying - assetPrefix": "In Next.js, publishing static assets to a CDN and managing them through the assetPrefix configuration is a very efficient method. It can help optimize your application's load time and reduce server load. module.exports = { assetPrefix: isProd ? 'https://yourcdn.example.com' : '', };",
	"CICD - Deploying - next/after API": "The next/after API is another experimental feature in Next.js 15 RC. This feature enables developers to perform secondary tasks or cleanup operations without blocking the primary response. This addition provides more flexibility in handling post-response logic, allowing for cleaner and more efficient code management. Potential use cases include analytics logging, resource cleanup, or additional data fetching after the initial response.",
  "CICD - SEO - robots.txt": "This is a text file placed in the root directory of your site that tells search engine crawlers which pages or sections of your site should not be crawled and indexed. For a Next.js site, you can create a robots.txt file and serve it statically. Ensure it’s accessible by placing it in the public folder. This will help control the crawler traffic to your site, prevent the indexing of certain pages, and help manage the crawl budget.",
  "CICD - SEO - XML Sitemaps": "A sitemap is crucial as it lists all URLs for a site, allowing search engines to crawl the site more intelligently. In Next.js, you can generate sitemaps dynamically or during your build process. Static generation is often preferred for performance reasons. You can use libraries like next-sitemap to automate the generation of sitemaps during your build process.",
  "CICD - SEO - Semantic HTML": "Semantic HTML5 elements (like <header>, <footer>, <article>, and <section>) help search engines understand the structure of your website and the importance of the content within each section. This can be particularly beneficial for SEO.",
  "CICD - SEO - Optimize Page Speed": "Google considers page speed as a ranking factor. Optimize images, leverage efficient CSS and JavaScript, use Next.js’s Image component for optimized image handling, and consider implementing a Content Delivery Network (CDN) to serve your content faster.",
  "CICD - SEO - Meta Tags": "Ensure each page has a unique title and description meta tags that accurately describe the page content. These are crucial for SEO as they appear in search engine results.",
  "CICD - SEO - Structured Data": "Implement structured data using JSON-LD to help search engines understand the content of your pages and provide rich results. Next.js can handle inline scripts where you can place your JSON-LD structured data.",
  "CICD - SEO - Accessibility (A11y)": "Making your website accessible is not only a good practice for usability; it also impacts SEO. Ensuring your website is accessible to all users, including those with disabilities, can positively influence your rankings.",
  "CICD - SEO - Mobile-Friendliness": "With the increasing use of mobile devices, having a mobile-friendly website is crucial. Next.js’s responsive design capabilities can help ensure that your website looks good on all devices, which is important for both user experience and SEO.",
  "CICD - SEO - Content Quality": "Regularly update your website with high-quality, relevant content that addresses your audience’s needs. This is vital for SEO and helps retain visitors."

}