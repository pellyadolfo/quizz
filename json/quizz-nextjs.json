{
  "NextJS": "SECTION",

	"Structure": "SECTION",
  "Structure - app": "Next.js uses the App component to initialize pages. You can override it and control the page initialization and: Create a shared layout between page changes, Inject additional data into pages, Add global CSS",
  "Structure - app - create-next-app": "The easiest way to get started with Next.js is by using create-next-app. This CLI tool enables you to quickly start building a new Next.js application, with everything set up for you.",
  "Structure - app - _app": "To override the default App, create the file pages/_app",
	"Structure - layout": "A layout is UI that is shared between multiple routes. On navigation, layouts preserve state, remain interactive, and do not re-render. Layouts can also be nested.",
  "Structure - layout - root": "The root layout is defined at the top level of the app directory and applies to all routes. This layout is required and must contain html and body tags, allowing you to modify the initial HTML returned from the server.",
  "Structure - layout - nested": ".",
  "Structure - layout - templates": "Templates are similar to layouts in that they wrap a child layout or page. Unlike layouts that persist across routes and maintain state, templates create a new instance for each of their children on navigation. This means that when a user navigates between routes that share a template, a new instance of the child is mounted, DOM elements are recreated, state is not preserved in Client Components, and effects are re-synchronized.",
	"Structure - page": "In Next.js, a page is a React Component exported from a .js, .jsx, .ts, or .tsx file in the pages directory. Each page is associated with a route based on its file name.",
  "Structure - page - Page": "A page is UI that is unique to a route. You can define a page by default exporting a component from a page.js file.",
  "Structure - page - Page - getStaticPaths": "",
  "Structure - page - Page - getStaticProps": "",
  "Structure - page - access": "If you create pages/about.js that exports a React component like below, it will be accessible at /about.",
  "Structure - page - import": "",
  "Structure - page - import - dynamic": "",
  "Structure - page - import - dynamic - module": "const module = await import('some-big-library');",
  "Structure - page - import - dynamic - react": "For React components, Next.js provides a next/dynamic function to handle dynamic imports seamlessly with server-side rendering support. This is especially useful for heavy components that are not critical to the initial rendering of the page. const DynamicComponent = dynamic(() => import('../components/HeavyComponent'), { loading: () => <p>Loading...</p>, ssr: false, });",
	"Structure - Components": "",
  "Structure - Components - Font": "",
  "Structure - Components - Head": "",
  "Structure - Components - Image": "",
  "Structure - Components - Script": "",
	"Structure - Router - PagesRouter - legacy": "Before Next.js 13, the Pages Router was the main way to create routes in Next.js. It used an intuitive file-system router to map each file to a route. The Pages Router is still supported in newer versions of Next.js, but we recommend migrating to the new App Router to leverage React's latest features.",
	"Structure - Router - PagesRouter - /pages": "Automatic Route Mapping: Each file in the pages directory is automatically mapped to a URL based on its file path. For example, pages/about.js is accessible at /about. The code below creates an ‘About us’ page that can be accessed at the /about URL.",
	"Structure - Router - PagesRouter - /pages/_app.tsx": "_app.tsx file inside pages/ to define the global layout. Entry point to the application.",
	"Structure - Router - PagesRouter - /pages/index.tsx": "Next.js pages/index.js is the default route. It corresponds to the index.html of static webages, i.e. the page that comes up if you type e.g. http://localhost:3000 (without any page name) in the browsers address bar.",
  "Structure - Router - PagesRouter - /pages/...path.../index.tsx": "Default page for this folder route.",
	"Structure - Router - PagesRouter - /pages/about.tsx": "",
	"Structure - Router - PagesRouter - /pages/404.tsx": ".",
	"Structure - Router - PagesRouter - nested": "Nested Routing: The directory structure is used to easily create nested paths. For example, pages/blog/2020/post.js is accessible at /blog/2020/post. The code below creates a blog post page that can be accessed at the /blog/2020/post URL.",
	"Structure - Router - PagesRouter - dynamic": "Dynamic Routing: Brackets in the file name are used to create dynamic path segments. For example, pages/posts/[id].js allows access to paths like posts/1, posts/2, etc. The code below creates a page that can be accessed with dynamic URLs such as posts/1, posts/2, etc.",
	"Structure - Router - PagesRouter - useRouter": "The useRouter hook allows you to access the Next.js router object and obtain information about the current route, query parameters, and other route-related details. The useRouter hook is imported from the next/router module in Next.js applications.",
	"Structure - Router - AppRouter": "In version 13, Next.js introduced a new App Router built on React Server Components, which supports shared layouts, nested routing, loading states, error handling, and more. The App Router uses a hybrid approach for routing and navigation. On the server, your application code is automatically code-split by route segments. And on the client, Next.js prefetches and caches the route segments. This means, when a user navigates to a new route, the browser doesn't reload the page, and only the route segments that change re-render - improving the navigation experience and performance.",
  "Structure - Router - AppRouter - /app": "The App Router works in a new directory named /app. By default, components inside app are React Server Components. The app directory must include a root layout. This is a performance optimization and allows you to easily adopt them, and you can also use Client Components.",
  "Structure - Router - AppRouter - /app/layout.tsx": "The equivalent for the PagesRouter _app.tsx entrypoint for AppRouter in Next.js 13 is the app/layout.tsx file. This file is used to render the initial layout of your application, and it can be used to add global functionality to your application.",
  "Structure - Router - AppRouter - /app/...path.../layout.tsx": "These are layouts defined inside folders and apply to specific route segments and render when those segments are active. It allows you to define multiple levels of layout components, each enclosing the content of its child components.",
  "Structure - Router - AppRouter - /app/template.tsx": "Template components are like layouts, but they create a new instance for each child on navigation. This means recreating DOM elements, losing state, and resetting effects every time the route changes. You can use them for things like tracking page views or interactive widgets. You can create a template by exporting a default React component from a template.js file. This component should be designed to receive a children prop.",
  "Structure - Router - AppRouter - /app/page.tsx": "The equivalent for the PagesRouter index.tsx. The default page.",
  "Structure - Router - AppRouter - /app/...path.../page.tsx": "Use page.js to define UI unique to a route. Each folder in a route represents a route segment. Each route segment is mapped to a corresponding segment in a URL path.",
  "Structure - Router - AppRouter - /app/...path.../files.tsx": "Nested Routing: A complex routing structure can be constructed using a nested directory structure. To create a nested route, you can nest folders inside each other. For example, you can add a new /dashboard/settings route by nesting two new folders in the app directory.",
	"Structure - Router - AppRouter - /app/about/page.tsx": "Equivalent to /pages/about.tsx",
  "Structure - Router - AppRouter - /app/loading.tsx": "The special file loading.js helps you create meaningful Loading UI with React Suspense. With this convention, you can show an instant loading state from the server while the content of a route segment loads. The new content is automatically swapped in once rendering is complete.",
  "Structure - Router - AppRouter - /app/route.tsx": "API endpoint. Route handler",
  "Structure - Router - AppRouter - /app/default.tsx": "Parallel route fallback page",
	"Structure - Router - AppRouter - /app/not-found.tsx": "If you don't like the style of Next.js' default 404 page, you can customize its look with the not-found.{js,tsx} file.",
  "Structure - Router - AppRouter - /app/not-found.tsx - notFound()": "When a user tries to access a page that doesn't exist, it's good to show a 404 page (along with a 404 HTTP status code). With Next.js' App Router you can accomplish this by returning notFound() from the next/navigation module in page.{js,tsx}.",
  "Structure - Router - AppRouter - /app/error.tsx": "Implement error boundaries using error.tsx and global-error.tsx files to handle unexpected errors and provide a fallback UI. error.js creates a React Error Boundary around a specific component or page.js. It uses the exported React component from error.js as a backup. If an error occurs within this boundary, it's isolated, and the backup component is shown. Despite the error, layouts above the boundary stay functional, allowing for error recovery options within the backup component. The root app/error.js boundary doesn't handle errors from root app/layout.js or app/template.js components.",
  "Structure - Router - AppRouter - /app/global-error.tsx": "Implement error boundaries using error.tsx and global-error.tsx files to handle unexpected errors and provide a fallback UI. The root app/error.js boundary doesn't handle errors from root app/layout.js or app/template.js components. For handling errors in these root components, utilize a variant named app/global-error.js, placed in the root app directory.",
  "Structure - Router - AppRouter - /app/...path.../not-found.tsx": "Handles not found in a path.",
	"Structure - Router - AppRouter - /app - ServerComponents": "In the new app directory, by default, Next.js uses Server Components, where the JSX gets compiled to 'pure HTML' and sent to the browser. Server-Centric Routing: React Server Components are used to generate HTML on the server, and only a minimal amount of JavaScript code is sent to the client.",
  "Structure - Router - AppRouter - /app - ServerComponents - rendering": "Dynamic Rendering: When navigating pages, the entire page is not re-rendered; instead, only the changed segments are rendered, providing an experience similar to a Single Page Application (SPA).",

	"Rendering": "SECTION",
	"Rendering - ": "The rendering work is split into chunks: by individual routes segments and Suspense boundaries.",
  "Rendering - Features - CodeSplitting": "To improve the navigation experience, Next.js automatically code splits your application by route segments. Work is split into chunks and streamed to the client as it becomes ready. This allows the user to see parts of the page immediately, before the entire content has finished rendering.",
  "Rendering - Features - CodeSplitting - vs SPA": "This is different from a traditional React SPA, where the browser loads all your application code on initial load. Splitting code by routes means that pages become isolated. If a certain page throws an error, the rest of the application will still work.",
  "Rendering - Features - Prefetching": "Furthermore, in production, whenever <Link> components appear in the browser's viewport, Next.js automatically prefetches the code for the linked route in the background. By the time the user clicks the link, the code for the destination page will already be loaded in the background, and this is what makes the page transition near-instant!. <Link> is a React component that extends the HTML <a> element to provide prefetching and client-side navigation between routes.",
	"Rendering - Features - Prefetching - <Link>": "<Link> component: Routes are automatically prefetched as they become visible in the user's viewport. Prefetching happens when the page first loads or when it comes into view through scrolling.",
	"Rendering - Features - Prefetching - router.prefetch()": "router.prefetch(): The useRouter hook can be used to prefetch routes programmatically.",
	"Rendering - Features - Prefetching - router.refresh()": "Revalidate RouterCache.",
	"Rendering - ServerComponents - RenderOnServer": "React Rendering on the Server. Each chunk is rendered in two steps: React renders Server Components into a special data format, optimized for streaming, called the React Server Component Payload. Next.js uses the React Server Component Payload and Client Component JavaScript instructions to render HTML on the server. This means we don't have to wait for everything to render before caching the work or sending a response. Instead, we can stream a response as work is completed.",
	"Rendering - ServerComponents - RSCPayload": "React renders Server Components into a special data format, optimized for streaming, called the React Server Component Payload.",
	"Rendering - ServerComponents - RSCPayload - Structure": "The React Server Component Payload is a compact binary representation of the rendered React Server Components tree. It’s used by React on the client to update the browser’s DOM.",
	"Rendering - ServerComponents - Caching": "Next.js Caching on the Server (Full Route Cache). The default behavior of Next.js is to cache the rendered result (React Server Component Payload and HTML) of a route on the server. This applies to statically rendered routes at build time, or during revalidation. If the route segments are not in the cache, Next.js will fetch the React Server Components Payload from the server, and populate the Router Cache on the client.",
	"Rendering - ServerComponents - Caching - FullRouteCache": "Next.js Caching on the Server. Next.js automatically renders and caches routes at build time. This is an optimization that allows you to serve the cached route instead of rendering on the server for every request, resulting in faster page loads. The default behavior of Next.js is to cache the rendered result (React Server Component Payload and HTML) of a route on the server.",
	"Rendering - ServerComponents - Caching - FullRouteCache - ApplyTo - static": "Full Route Cache only caches statically rendered routes",
	"Rendering - ServerComponents - Caching - FullRouteCache - ApplyTo - dynamic": "No",
	"Rendering - ServerComponents - Caching - FullRouteCache - ApplyTo - fetch": "",
	"Rendering - ServerComponents - Caching - FullRouteCache - ApplyTo - cookies": "",
	"Rendering - ServerComponents - Caching - FullRouteCache - ApplyTo - headers": "",
	"Rendering - ServerComponents - Caching - FullRouteCache - ApplyTo - searchParams": "",
	"Rendering - ServerComponents - Caching - FullRouteCache - ApplyTo - generateStaticParams": "",
	"Rendering - ServerComponents - Caching - FullRouteCache - Invalidating - revalidateTag": "",
	"Rendering - ServerComponents - Caching - FullRouteCache - Invalidating - revalidatePath": "revalidatePath allows you manually revalidate data and re-render the route segments below a specific path in a single operation. Calling the revalidatePath method revalidates the Data Cache, which in turn invalidates the Full Route Cache. revalidatePath('/') means you purge all paths in the Router Cache,",
	"Rendering - ServerComponents - Caching - FullRouteCache - Invalidating - redeploying": "Unlike the Data Cache, which persists across deployments, the Full Route Cache is cleared on new deployments.",
	"Rendering - ServerComponents - Caching - FullRouteCache - OptOut - dynamic function": "This will opt the route out from the Full Route Cache and dynamically render it at request time. The Data Cache can still be used.",
	"Rendering - ServerComponents - Caching - FullRouteCache - OptOut - force-dynamic": "This will skip the Full Route Cache",
	"Rendering - ServerComponents - Caching - FullRouteCache - OptOut - revalidate": "This will skip the Full Route Cache",
	"Rendering - ServerComponents - Caching - FullRouteCache - OptOut - OptOut DataCache": "If a route has a fetch request that is not cached, this will opt the route out of the Full Route Cache. The data for the specific fetch request will be fetched for every incoming request. Other fetch requests that do not opt out of caching will still be cached in the Data Cache. This allows for a hybrid of cached and uncached data.",
	"Rendering - Streaming": "Streaming enables you to progressively render UI from the server.",
  "Rendering - Streaming - Suspense - Boundaries": "On the server, Next.js uses React's APIs to orchestrate rendering.",
  "Rendering - Streaming - Suspense": "React’s Suspense component can be used to wrap components that rely on asynchronous data fetching. Next.js streams the HTML of these components once the necessary data is ready. A fallback UI to display during data loading can be provided inside Suspense.",
  "Rendering - Streaming - Loading": "loading.tsx is a special Next.js file built on top of Suspense, it allows you to create fallback UI to show as a replacement while page content loads.",
  "Rendering - Streaming - Loading - loading.tsx": "The loading.tsx file is used to display a loading indicator or placeholder content while the page is fetching data. Once the data is ready, the server streams the actual page content, replacing the loading UI.",
	"Rendering - ClientComponents - ShowPreview": "The HTML is used to immediately show a fast non-interactive preview of the route - this is for the initial page load only.",
	"Rendering - ClientComponents - UpdateDOM": "4. The React Server Components Payload is used to reconcile the Client and Server Component trees, and update the DOM.",
	"Rendering - ClientComponents - HydrationOnClient": "3. React Hydration and Reconciliation on the Client. At request time, on the client: The HTML is used to immediately show a fast non-interactive initial preview of the Client and Server Components. The React Server Components Payload is used to reconcile the Client and rendered Server Component trees, and update the DOM. The JavaScript instructions are used to hydrate Client Components and make the application interactive.",
	"Rendering - ClientComponents - Caching": "4. Next.js Caching on the Client (Router Cache). The React Server Component Payload is stored in the client-side Router Cache - a separate in-memory cache, split by individual route segment. This Router Cache is used to improve the navigation experience by storing previously visited routes and prefetching future routes.",
	"Rendering - ClientComponents - Caching - RouterCache": "Next.js Caching on the Client. Next.js has an in-memory client-side cache called the Router Cache. A separate in-memory cache.",
	"Rendering - ClientComponents - Caching - RouterCache - Features - location": "Next.js Caching on the Client. Next.js has an in-memory client-side cache called the Router Cache. A separate in-memory cache, split by individual route segment. On subsequent navigations or during prefetching, Next.js will check if the React Server Components Payload is stored in the Router Cache. If so, it will skip sending a new request to the server. The Router Cache temporarily stores the React Server Component Payload in the browser for the duration of a user session.",
	"Rendering - ClientComponents - Caching - RouterCache - Features - structure": "split by individual route segment.",
	"Rendering - ClientComponents - Caching - RouterCache - Features - duration - session": "The Router Cache temporarily stores the React Server Component Payload in the browser for the duration of a user session.",
	"Rendering - ClientComponents - Caching - RouterCache - Features - duration - period": "Automatic Invalidation Period: The cache of an individual segment is automatically invalidated after a specific time. The duration depends on whether the route is statically or dynamically rendered: Dynamically Rendered: 30 seconds. Statically Rendered: 5 minutes.",
	"Rendering - ClientComponents - Caching - RouterCache - ApplyTo - static": "Router Cache applies to both statically and dynamically rendered routes.",
	"Rendering - ClientComponents - Caching - RouterCache - ApplyTo - dynamic": "Router Cache applies to both statically and dynamically rendered routes.",
	"Rendering - ClientComponents - Caching - RouterCache - Invalidating - revalidatePath": "",
	"Rendering - ClientComponents - Caching - RouterCache - Invalidating - revalidateTag": "",
	"Rendering - ClientComponents - Caching - RouterCache - Invalidating - cookies": "Using cookies.set or cookies.delete invalidates the Router Cache to prevent routes that use cookies from becoming stale (e.g. authentication).",
	"Rendering - ClientComponents - Caching - RouterCache - Invalidating - router.refresh": "Calling router.refresh will invalidate the Router Cache and make a new request to the server for the current route.",
	"Rendering - ClientComponents - Caching - RouterCache - OptOut": "It’s not possible to opt out of the Router Cache.",

	"Navigation": "SECTION",
	"Navigation - ClientComponents - ClientSide": "Client-side navigation or soft navigation means that the page transition happens using JavaScript, which is faster than the default navigation done by the browser.",
	"Navigation - ClientComponents - ClientSide - Cases - static": ".",
	"Navigation - ClientComponents - ClientSide - Cases - dynamic": "When you don't know the exact segment names ahead of time and want to create routes from dynamic data, you can use Dynamic Segments that are filled in at request time or prerendered at build time.",
  "Navigation - ClientComponents - ClientSide - Cases - parallel": "Parallel Routes allows you to simultaneously or conditionally render one or more pages within the same layout. They are useful for highly dynamic sections of an app, such as dashboards and feeds on social sites.",
  "Navigation - ClientComponents - ClientSide - Cases - intercepting": "Intercepting routes allows you to load a route from another part of your application within the current layout. This routing paradigm can be useful when you want to display the content of a route without the user switching to a different context.",
	"Navigation - ClientComponents - ClientSide - Tools - <Link/>": "It is the primary way to navigate between routes in Next.js. <Link/> in import Link from 'next/link. <Link> allows you to do client-side navigation with JavaScript.",
  "Navigation - ClientComponents - ClientSide - Tools - <Link/> - a": "The Link component wraps around an anchor tag to define the navigation path. <a> tag attributes such as className or target='_blank' can be added to <Link> as props and will be passed to the underlying <a> element. Before Next.js 12.2, it was required that the Link component wrapped an <a> tag, but this is not required in versions 12.2 and above.",
  "Navigation - ClientComponents - ClientSide - Tools - <Link/> - params - href": "The path or URL to navigate to.",
  "Navigation - ClientComponents - ClientSide - Tools - <Link/> - params - replace": "Defaults to false. When true, next/link will replace the current history state instead of adding a new URL into the browser's history stack.",
  "Navigation - ClientComponents - ClientSide - Tools - <Link/> - params - scroll": "Defaults to true. The default scrolling behavior of <Link> in Next.js is to maintain scroll position, similar to how browsers handle back and forwards navigation. When you navigate to a new Page, scroll position will stay the same as long as the Page is visible in the viewport. However, if the Page is not visible in the viewport, Next.js will scroll to the top of the first Page element.",
  "Navigation - ClientComponents - ClientSide - Tools - <Link/> - params - prefetch": "Prefetching happens when a <Link /> component enters the user's viewport (initially or through scroll). Next.js prefetches and loads the linked route (denoted by the href) and data in the background to improve the performance of client-side navigation's. Prefetching is only enabled in production.",
  "Navigation - ClientComponents - ClientSide - Tools - <Link/> - params - legacyBehavior": "If the child of Link is a functional component, in addition to using passHref and legacyBehavior, you must wrap the component in React.forwardRef:",
  "Navigation - ClientComponents - ClientSide - Tools - <Link/> - params - passHref": "If the child of Link is a custom component that wraps an <a> tag, you must add passHref to Link. This is necessary if you’re using libraries like styled-components. Without this, the <a> tag will not have the href attribute, which hurts your site's accessibility and might affect SEO. If you're using ESLint, there is a built-in rule next/link-passhref to ensure correct usage of passHref.",
  "Navigation - ClientComponents - ClientSide - Tools - <Link/> - params - shallow": "Update the path of the current page without rerunning getStaticProps, getServerSideProps or getInitialProps. Defaults to false.",
  "Navigation - ClientComponents - ClientSide - Tools - <Link/> - params - locale": "The active locale is automatically prepended. locale allows for providing a different locale. When false href has to include the locale as the default behavior is disabled.",
  "Navigation - ClientComponents - ClientSide - Tools - useRouter": "Perform a client-side navigation. The useRouter hook allows you to programmatically change routes inside Client Components.",
	"Navigation - ClientComponents - ClientSide - Tools - useParams": "useParams is a Client Component hook that lets you read a route's dynamic params filled in by the current URL.",
	"Navigation - ClientComponents - ClientSide - Tools - usePathname": "usePathname is a Client Component hook that lets you read the current URL's pathname. The pathname string has been removed from next/router - useRouter and is replaced by usePathname()",
	"Navigation - ClientComponents - ClientSide - Tools - useSearchParams": "useSearchParams is a Client Component hook that lets you read the current URL's query string. useSearchParams returns a read-only version of the URLSearchParams interface. The query object has been removed from next/router - useRouter and is replaced by useSearchParams()",
	"Navigation - ClientComponents - ClientSide - Tools - useSelectedLayoutSegment": "useSelectedLayoutSegment is a Client Component hook that lets you read the active route segment one level below the Layout it is called from. It is useful for navigation UI, such as tabs inside a parent layout that change style depending on the active child segment.",
	"Navigation - ClientComponents - ClientSide - Tools - useSelectedLayoutSegments": "useSelectedLayoutSegments is a Client Component hook that lets you read the active route segments below the Layout it is called from. It is useful for creating UI in parent Layouts that need knowledge of active child segments such as breadcrumbs.",
	"Navigation - ServerComponents - FullRefresh": ".",
  "Navigation - ServerComponents - FullRefresh - Tools - a": "<a> tag without using next/link's <Link> creates a standard hyperlink which directs end user to the url as a new page. (standard behavior). There's a full page refresh on each page navigation!",
	"Navigation - ServerComponents - Redirect": "Redirects will reroute to a new page and show the URL changes.",
	"Navigation - ServerComponents - Redirect - usage": "Use Redirects when you need to change the URL in the user’s browser, especially if you’re restructuring your site’s content or improving SEO. Redirects are also essential when you want to inform search engines that a page has permanently moved.",
	"Navigation - ServerComponents - Redirect - redirect": "The redirect function allows you to redirect the user to another URL. You can call redirect in Server Components, Route Handlers, and Server Actions.",
	"Navigation - ServerComponents - Redirect - redirect - async": "redirects is an async function that expects an array to be returned holding objects with source, destination, and permanent properties",
	"Navigation - ServerComponents - Redirect - permanent": "A permanent redirect from /old-path to /new-path. Permanent redirects (HTTP status code 301) indicate to search engines that the old URL has been replaced by the new one, which helps in preserving SEO rankings. A temporary redirect from /blog/:slug to /news/:slug. Temporary redirects (HTTP status code 302) are used when the move is not permanent, and search engines should continue to index the old URL.",
	"Navigation - ServerComponents - Redirect - permanentRedirect": "The permanentRedirect function allows you to redirect the user to another URL. permanentRedirect can be used in Server Components, Client Components, Route Handlers, and Server Actions. When used in a streaming context, this will insert a meta tag to emit the redirect on the client side. When used in a server action, it will serve a 303 HTTP redirect response to the caller. Otherwise, it will serve a 308 (Permanent) HTTP redirect response to the caller.",
	"Navigation - ServerComponents - Redirect - next.config.js": "To use redirects you can use the redirects key in next.config.js: module.exports = { async redirects() { return [ { source: '/about', destination: '/', permanent: true, },]},}",
  "Navigation - ServerComponents - Redirect - NextResponse.redirect": ".",
	"Navigation - ServerComponents - Rewrite": "Rewrites allow you to map an incoming request path to a different destination path. Rewrites act as a URL proxy and mask the destination path, making it appear the user hasn't changed their location on the site.",
	"Navigation - ServerComponents - Rewrite - usage": "Use Rewrites when you want to serve content under a specific URL without revealing the underlying structure or when you need to integrate with external services while maintaining a consistent URL pattern.",
	"Navigation - ServerComponents - Rewrite - rewrites": "",
	"Navigation - ServerComponents - Rewrite - rewrites - async": "rewrites is an async function that expects to return either an array or an object of arrays (see below) holding objects with source and destination properties",
	"Navigation - ServerComponents - Rewrite - next.config.js": "To use rewrites you can use the rewrites key in next.config.js: module.exports = { async rewrites() { return [ { source: '/about', destination: '/', },]},}",
	"Navigation - ServerComponents - generateImageMetadata": "You can use generateImageMetadata to generate different versions of one image or return multiple images for one route segment. This is useful for when you want to avoid hard-coding metadata values, such as for icons.",
	"Navigation - ServerComponents - generateMetadata": "This page covers all Config-based Metadata options with generateMetadata and the static metadata object. The metadata object and generateMetadata function exports are only supported in Server Components.",
	"Navigation - ServerComponents - generateSitemaps": "You can use the generateSitemaps function to generate multiple sitemaps for your application.",
	"Navigation - ServerComponents - generateStaticParams": "The generateStaticParams function can be used in combination with dynamic route segments to statically generate routes at build time instead of on-demand at request time.",
	"Navigation - ServerComponents - generateViewport": "You can customize the initial viewport of the page with the static viewport object or the dynamic generateViewport function.",
	"Navigation - ServerComponents - ImageResponse": "The ImageResponse constructor allows you to generate dynamic images using JSX and CSS. This is useful for generating social media images such as Open Graph images, Twitter cards, and more.",
	"Navigation - ServerComponents - headers": "The headers function allows you to read the HTTP incoming request headers from a Server Component.",
	"Navigation - ServerComponents - cookies": "The cookies function allows you to read the HTTP incoming request cookies from a Server Component or write outgoing request cookies in a Server Action or Route Handler.",
	"Navigation - ServerComponents - redirect": "The redirect function allows you to redirect the user to another URL. redirect can be used in Server Components, Route Handlers, and Server Actions. When used in a streaming context, this will insert a meta tag to emit the redirect on the client side. When used in a server action, it will serve a 303 HTTP redirect response to the caller. Otherwise, it will serve a 307 HTTP redirect response to the caller. If a resource doesn't exist, you can use the notFound function instead.",
	"Navigation - ServerComponents - draftMode": "The draftMode function allows you to detect Draft Mode inside a Server Component.",
  "Navigation - ServerComponents - HistoryAPI": ".",
  "Navigation - ServerComponents - HistoryAPI - window.history.pushState": "Use it to add a new entry to the browser's history stack. The user can navigate back to the previous state.",
  "Navigation - ServerComponents - HistoryAPI - window.history.replaceState": "Use it to replace the current entry on the browser's history stack. The user is not able to navigate back to the previous state.",

	"DataFetching": "SECTION",
	"DataFetching - ClientComponents - NextRequest": "NextRequest extends the WebRequestAPI with additional convenience methods. NextResponse extends the Web Response API with additional convenience methods.",
	"DataFetching - ClientComponents - RouteHandler": "Route Handlers allow you to create custom request handlers for a given route using the WebRequestAPI.",
	"DataFetching - ClientComponents - RouteHandler - methods": "The following HTTP methods are supported: GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS. If an unsupported method is called, Next.js will return a 405 Method Not Allowed response.",
	"DataFetching - ClientComponents - RouteHandler - Cache - Next14": "In Next.js 14, GET route handlers are cached by default.",
	"DataFetching - ClientComponents - RouteHandler - Cache - Next15": "In Next.js 15, GET route handlers won’t cache by default. If you want to cache GET route handlers in Next.js 15, you can use export const dynamic = 'force-static'.",
	"DataFetching - ClientComponents - RouteHandler - Cache - Next14 - staleTime": "In Next.js 14.2.0, the experimental staleTimes flag was introduced, allowing custom configuration of router caching. By default, the staleTime for dynamic routes is a non-zero value, defaulting to 30. If the prefetch parameter is set in the <Link> component, the default is 5 minutes.",
	"DataFetching - ClientComponents - RouteHandler - Cache - Next15 - staleTime": "In Next.js 15, the `staleTime` for Page segments defaults to 0, meaning the client will always fetch the latest page component data during in-app navigation.",
	"DataFetching - ClientComponents - RouteHandler - APIRoutes - pages/api": "Any file inside the folder pages/api is mapped to /api/* and will be treated as an API endpoint instead of a page. They are server-side only bundles and won't increase your client-side bundle size.",
	"DataFetching - ClientComponents - RouteHandler - APIRoutes": "export default async (req, res) => { ... return data }",
	"DataFetching - ClientComponents - RouteHandler - APIRoutes - NextApiRequest": "NextApiRequest extends Node.js' IncomingMessage (from node:http) and also adds several helpers to it. It's used in API routes.",
	"DataFetching - ClientComponents - RouteHandler - APIRoutes - caching": "export default async (req, res) => { res.setHeader('Cache-Control', 's-maxage=3600, stale-while-revalidate'); ... retrun data }",
	"DataFetching - ServerComponents - Caching - DataCache": "Next.js has a built-in Data Cache that persists the result of data fetches across incoming server requests and deployments. This is possible because Next.js extends the native fetch API to allow each request on the server to set its own persistent caching semantics.",
	"DataFetching - ServerComponents - Caching - DataCache - fetch": "",
	"DataFetching - ServerComponents - Caching - DataCache - revalidateTag": "",
	"DataFetching - ServerComponents - Caching - DataCache - revalidatePath": "revalidatePath allows you manually revalidate data and re-render the route segments below a specific path in a single operation. Calling the revalidatePath method revalidates the Data Cache, which in turn invalidates the Full Route Cache.",
  "DataFetching - ServerComponents - getInitialProps": "getInitialProps is a method used in older versions of Next.js (versions prior to 9.3) to fetch data on the server side before rendering a page. It was the primary data fetching method used in Next.js before newer data fetching methods like getServerSideProps and getStaticProps were introduced. In older versions of Next.js, getInitialProps was the primary data fetching mechanism for both SSR and client-side rendering. getInitialProps is a special function provided by Next.js that runs on the server side before rendering a page. This function allows you to fetch data from an external API, database, or any other data source, and pass it as props to your React components. By doing so, you can pre-populate your pages with data and make them more SEO-friendly, as search engines can crawl your pages’ content easily. In this article, we will explore one of its features, getInitialProps, by building a small app. getInitialProps is a lifecycle method in Next.js that allows you to asynchronously fetch data and pass it to your page or component as props before rendering. It can be used in both pages and custom App components, making it versatile for server-side data fetching.",
  "DataFetching - ServerComponents - getServerSideProps": "getServerSideProps is a data fetching method that was introduced in Next.js 9.3. It is used specifically for server-side rendering (SSR). Unlike getInitialProps, getServerSideProps is only executed on the server side during the initial page request and not on subsequent client-side navigations. This change improves performance by reducing duplicate data fetching and provides better predictability of server-side data fetching.",
  "DataFetching - ServerComponents - getStaticProps": "getStaticProps is another data fetching method that was introduced in Next.js 9.3, and it is used for static site generation (SSG). When using getStaticProps, Next.js pre-renders the page at build time and fetches the data during the build process. The pre-rendered HTML pages are then served to users directly from the CDN, offering faster page loads and reducing server load.. You need to export an asynchronous function called getStaticProps in your page component. This function is responsible for providing the page's props and is executed at build time.",
	"DataFetching - ServerComponents - WebAPI - fetch": "Next.js extends the native Web fetch() API to allow each request on the server to set its own persistent caching semantics. In the browser, the cache option indicates how a fetch request will interact with the browser's HTTP cache. With this extension, cache indicates how a server-side fetch request will interact with the framework's persistent HTTP cache. You can call fetch with async and await directly within Server Components.",
	"DataFetching - ServerComponents - WebAPI - fetch - Cache - Next14": "In Next.js 14, fetch requests use the force-cache strategy by default, meaning data is cached by default. const res = await fetch('https://api.weijunext.com/');",
	"DataFetching - ServerComponents - WebAPI - fetch - Cache - Next15": "In Next.js 15, fetch requests will use the no-store strategy by default, meaning they won’t cache by default. If you want to cache data in Next.js 15, you need to explicitly specify the caching parameters. For example: const res = await fetch('https://api.weijunext.com/', { cache: 'force-cache' });",

	"CICD": "SECTION",
	"CICD - Bundling - Techniques - external packages": "Next.js 15 introduces stable configuration options for optimizing the bundling of external packages in both the App Router and Pages Router. These improvements aim to enhance cold-start performance and provide developers with more control over how external dependencies are included in their applications.",
  "CICD - Bundling - Tools - JSX - transpilation - transpilePackages": "Next.js can automatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies (node_modules). This replaces the next-transpile-modules package. module.exports = { transpilePackages: ['package-name'], }",
	"CICD - Building - Caching": "Static and Dynamic Rendering. Whether a route is cached or not at build time depends on whether it's statically or dynamically rendered. Static routes are cached by default, whereas dynamic routes are rendered at request time, and not cached.",
	"CICD - Building - Caching - Static": "As the web started to become a mainstream platform for consuming information, people began sharing information by writing HTML documents. All the information was written as static markup and published to the internet. Each time something new needed to be shared, we would add another HTML document, and everything worked seamlessly.",
	"CICD - Building - Caching - CSR": "Whenever the page requires more data, an API call can be made to a backend hosted independently, which provides the required data in a format agreed upon by the client and server (e.g., JSON). Poor SEO.",
  "CICD - Building - Caching - SSG": "Static Content / Static Site Generation (SSG). HTML pages are generated at build time and served directly from a CDN, resulting in blazing-fast load times and good performance.",
  "CICD - Building - Caching - SSG - Static": "The downside is that there won't be any dynamic content. This strategy is extremely useful for writing articles, documentation, etc.",
	"CICD - Building - Caching - SSR": "If a page uses Server-side Rendering, the page HTML is generated on each request.",
	"CICD - Building - Caching - SSR - drawbacks - load": "Try to use SSR consciously and check whether you actually need SEO or not for your application. SSR takes up an immense load, so if you avoid using it when not required, you will be blessed.",
  "CICD - Building - Caching - SSR - benefits - Data Fetching": "Data Fetching: Server Components allow you to move data fetching to the server, closer to your data source. This can improve performance by reducing time it takes to fetch data needed for rendering, and the number of requests the client needs to make.",
  "CICD - Building - Caching - SSR - benefits - Security": "Security: Server Components allow you to keep sensitive data and logic on the server, such as tokens and API keys, without the risk of exposing them to the client.",
  "CICD - Building - Caching - SSR - benefits - Caching": "Caching: By rendering on the server, the result can be cached and reused on subsequent requests and across users. This can improve performance and reduce cost by reducing the amount of rendering and data fetching done on each request.",
  "CICD - Building - Caching - SSR - benefits - Performance": "Performance: Server Components give you additional tools to optimize performance from the baseline. For example, if you start with an app composed of entirely Client Components, moving non-interactive pieces of your UI to Server Components can reduce the amount of client-side JavaScript needed. This is beneficial for users with slower internet or less powerful devices, as the browser has less client-side JavaScript to download, parse, and execute.",
  "CICD - Building - Caching - SSR - benefits - Initial Page Load": "Initial Page Load and First Contentful Paint (FCP): On the server, we can generate HTML to allow users to view the page immediately, without waiting for the client to download, parse and execute the JavaScript needed to render the page.",
  "CICD - Building - Caching - SSR - benefits - SEO": "Search Engine Optimization and Social Network Shareability: The rendered HTML can be used by search engine bots to index your pages and social network bots to generate social card previews for your pages.",
  "CICD - Building - Caching - SSR - benefits - Streaming": "Streaming: Server Components allow you to split the rendering work into chunks and stream them to the client as they become ready. This allows the user to see parts of the page earlier without having to wait for the entire page to be rendered on the server.",
  "CICD - Building - Caching - SSR - strategies - Static": "With Static Rendering, routes are rendered at build time, or in the background after data revalidation. The result is cached and can be pushed to a Content Delivery Network (CDN). This optimization allows you to share the result of the rendering work between users and server requests. Static rendering is useful when a route has data that is not personalized to the user and can be known at build time, such as a static blog post or a product page.",
  "CICD - Building - Caching - SSR - strategies - Dynamic": "With Dynamic Rendering, routes are rendered for each user at request time. Dynamic rendering is useful when a route has data that is personalized to the user or has information that can only be known at request time, such as cookies or the URL's search params.",
  "CICD - Building - Caching - SSR - strategies - Streaming": "Streaming enables you to progressively render UI from the server. Work is split into chunks and streamed to the client as it becomes ready. This allows the user to see parts of the page immediately, before the entire content has finished rendering.",
	"CICD - Building - Caching - SSR - getServerSideProps": "To use Server-side Rendering for a page, you need to export an async function called getServerSideProps. This function will be called by the server on every request.",
  "CICD - Building - Caching - SSR - no data": ".",
  "CICD - Building - Caching - SSR - data": ".",
  "CICD - Building - Caching - SSR - hydration": "Hydration is the process of transforming pre-rendered server-side content into an interactive user interface on the client side. When a user accesses a pre-rendered page, Next.js promptly sends the fully rendered HTML content to the client's browser, complete with initial data and UI from the server. Then, client-side JavaScript hydrates this static content, imbuing it with interactivity to form a fully functional React application. https://dev.to/rajaerobinson/understanding-hydration-in-nextjs-b5m",
  "CICD - Building - Caching - ISR": "SSG+Update. With ISR, pages are initially generated statically, but they can be dynamically updated in the background based on specific triggers or time intervals. This provides a balance of speed and dynamic content updates..",
  "CICD - Building - Caching - ISR - revalidate": "Within the object returned by the getStaticProps function, you can set a revalidate property. The value of this property is a number, indicating how many seconds after which the page content will be regenerated.",
  "CICD - Building - Caching - ISR - how": "When a request is made for a statically generated page, if the time since the last generation has exceeded the revalidate setting, Next.js will regenerate the page in the background. Meanwhile, for user requests, the old page content will still be provided until the new page is generated, ensuring the immediacy and consistency of access.",
	"CICD - Building - Caching - PPR": "Next.js 14 introduces an experimental feature called Partial Prerendering (PPR).",
	"CICD - Building - Caching - PPR - how": "PPR allows developers to incrementally adopt a hybrid rendering approach.",
	"CICD - Building - Caching - PPR - how - static": "A static shell that’s pre-rendered on the server at build time (or potentially on-demand). This shell contains the basic structure and layout of the page, along with any static or non-personalized content.",
	"CICD - Building - Caching - PPR - how - dynamic": "You can wrap dynamic UI components in a Suspense boundary. Dynamic holes or placeholders for Client Components that will be fetched and hydrated on the client-side after the initial page load. These components handle dynamic or personalized content.",
	"CICD - Building - Caching - PPR - enable": "To enable PPR, set the experimental.ppr config option to ‘incremental’ in next.config.js:",
  "CICD - Building - Caching - ASO": "Next.js automatically determines that a page is static (can be prerendered) if it has no blocking data requirements. This determination is made by the absence of getServerSideProps and getInitialProps in the page.",
	"CICD - Building - Tools - NextCompiler": "The Next.js Compiler, written in Rust using SWC, allows Next.js to transform and minify your JavaScript code for production. This replaces Babel for individual files and Terser for minifying output bundles. Compilation using the Next.js Compiler is 17x faster than Babel and enabled by default since Next.js version 12. If you have an existing Babel configuration or are using unsupported features, your application will opt-out of the Next.js Compiler and continue using Babel.",
	"CICD - Building - Tools - next.config.js - webpack": "In order to extend our usage of webpack, you can define a function that extends its config inside next.config.js",
	"CICD - Building - Tools - next.config.js - turbo": "Turbopack can be customized to transform different files and change how modules are resolved.",
	"CICD - Exporting - .out - next export": "Creates .out file.",
	"CICD - Exporting - .out - ": "next export has been removed in favor of 'output: export' in next.config.js.",
	"CICD - Deploying - Multi-Zones": "An interesting feature offered by Next.js is Multi-Zones, an approach to micro-frontends. It allows a large application to be divided into smaller, independent Next.js applications, each serving a specific set of paths on the same domain. This modularization can improve build times and reduce code complexity.",
	"CICD - Deploying - Multi-Zones - multiapp": "Each zone is a standard Next.js application configured with a basePath to prevent conflicts.",
	"CICD - Deploying - Multi-Zones - navigation": "Navigation within a zone is seamless (soft navigation), while navigating between zones triggers a full page reload (hard navigation).",
	"CICD - Deploying - Multi-Zones - proxies": "An HTTP proxy or a designated Next.js application can be used to route requests to the correct zone.",
	"CICD - Deploying - Multi-Zones - anchor": "Anchor tags (<a>) should be used for links between zones.",
	"CICD - Deploying - Multi-Zones - code": "Code sharing can be facilitated through monorepos or NPM packages, and feature flags can help coordinate feature releases across zones.",
	"CICD - Deploying - server": "By default, Next.js includes its own server with next start.",
	"CICD - Deploying - SST": "https://levelup.gitconnected.com/deploy-next-js-to-aws-using-sst-fa2f50c5737a",
	"CICD - Deploying - assetPrefix": "In Next.js, publishing static assets to a CDN and managing them through the assetPrefix configuration is a very efficient method. It can help optimize your application's load time and reduce server load. module.exports = { assetPrefix: isProd ? 'https://yourcdn.example.com' : '', };",
	"CICD - Deploying - next/after API": "The next/after API is another experimental feature in Next.js 15 RC. This feature enables developers to perform secondary tasks or cleanup operations without blocking the primary response. This addition provides more flexibility in handling post-response logic, allowing for cleaner and more efficient code management. Potential use cases include analytics logging, resource cleanup, or additional data fetching after the initial response.",
	"CICD - Execution - HMR": "That’s why Next.js introduced the Hot Module Replacement (HMR) mechanism, more commonly known as Fast Refresh. The HMR feature ensures that any edits you make in your code are quickly reflected in the browser without requiring a full page reload, enhancing your development experience as a result.",
  "CICD - SEO - robots.txt": "This is a text file placed in the root directory of your site that tells search engine crawlers which pages or sections of your site should not be crawled and indexed. For a Next.js site, you can create a robots.txt file and serve it statically. Ensure it’s accessible by placing it in the public folder. This will help control the crawler traffic to your site, prevent the indexing of certain pages, and help manage the crawl budget.",
  "CICD - SEO - XML Sitemaps": "A sitemap is crucial as it lists all URLs for a site, allowing search engines to crawl the site more intelligently. In Next.js, you can generate sitemaps dynamically or during your build process. Static generation is often preferred for performance reasons. You can use libraries like next-sitemap to automate the generation of sitemaps during your build process.",
  "CICD - SEO - Semantic HTML": "Semantic HTML5 elements (like <header>, <footer>, <article>, and <section>) help search engines understand the structure of your website and the importance of the content within each section. This can be particularly beneficial for SEO.",
  "CICD - SEO - Optimize Page Speed": "Google considers page speed as a ranking factor. Optimize images, leverage efficient CSS and JavaScript, use Next.js’s Image component for optimized image handling, and consider implementing a Content Delivery Network (CDN) to serve your content faster.",
  "CICD - SEO - Meta Tags": "Ensure each page has a unique title and description meta tags that accurately describe the page content. These are crucial for SEO as they appear in search engine results.",
  "CICD - SEO - Structured Data": "Implement structured data using JSON-LD to help search engines understand the content of your pages and provide rich results. Next.js can handle inline scripts where you can place your JSON-LD structured data.",
  "CICD - SEO - Accessibility (A11y)": "Making your website accessible is not only a good practice for usability; it also impacts SEO. Ensuring your website is accessible to all users, including those with disabilities, can positively influence your rankings.",
  "CICD - SEO - Mobile-Friendliness": "With the increasing use of mobile devices, having a mobile-friendly website is crucial. Next.js’s responsive design capabilities can help ensure that your website looks good on all devices, which is important for both user experience and SEO.",
  "CICD - SEO - Content Quality": "Regularly update your website with high-quality, relevant content that addresses your audience’s needs. This is vital for SEO and helps retain visitors."

}