{
	"hashcode": "SECTION",
	"hashcode - rules - repeatable": "Whenever it is invoked on the same object more than once during an execution of a Java application, hashCode() must consistently return the same value, provided no information used in equals comparisons on the object is modified. This value needs not remain consistent from one execution of an application to another execution of the same application",
	"hashcode - rules - equal objects": "If two objects are equal according to the equals(Object) method, then calling the hashCode() method on each of the two objects must produce the same value",
	"hashcode - rules - no equal object": "It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, developers should be aware that producing distinct integer results for unequal objects improves the performance of hash tables",
	"hashcode - rules - equals": "Whenever you implement equals, you MUST also implement hashCode If you fail to do so, you will end up with broken objects. Why? An object’s hashCode method must take the same fields into account as its equals method. By overriding the equals method, you’re declaring some objects as equal to other objects, but the original hashCode method treats all objects as different. So you will have equal objects with different hash codes. ",
	"hashcode - rules - hash collision": "Whenever two different objects have the same hash code, we call this a collision..",
	"hashcode - rules - hash collision - collection": "A collision is nothing critical, it just means that there is more than one object in a single bucket, so a HashMap lookup has to look again to find the right object. A lot of collisions will degrade the performance of a system, but they won’t lead to incorrect results.",
	"hashcode - int  Object.hash​(Object... values) (Java 7)": "Generates a hash code for a sequence of input values. The hash code is generated as if all the input values were placed into an array, and that array were hashed by calling Arrays.hashCode(Object[]). This method is useful for implementing Object.hashCode() on objects containing multiple fields.",
	"hashcode - Arrays.hashcode() (Java 5)": "Returns a hash code based on the contents of the specified array.",
	"hashcode - Arrays.hashcode() vs Object.hash()": "Arrays.hashCode(Object[]) and Objects.hash(Object...) behave exactly the same way, because Objects.hash(Object...) completely delegates to Arrays.hashCode(Object[]).",

	"String": "SECTION",
	"String ": "",
	"String - String Pool": "String pool (String intern pool) is a special storage area in Method Area. When a string is created and if the string already exists in the pool, the reference of the existing string will be returned, instead of creating a new object. If a string is mutable, changing the string with one reference will lead to the wrong value for the other references.",
	"String - Inmutability": "String is immutable in Java. An immutable class is simply a class whose instances cannot be modified. All information in an instance is initialized when the instance is created and the information can not be modified. ",
	"String - Thread Safe": "Immutable objects are naturally thread-safe Because immutable objects can not be changed, they can be shared among multiple threads freely. This eliminates the requirements of doing synchronization.",
	"String - String#join(CharSequence delimiter, CharSequence... elements)": "Returns a new String composed of copies of the CharSequence elements joined together with a copy of the specified delimiter",
	"String - String#join(CharSequence delimiter, Iterable<? extends CharSequence> elements)": "Returns a new String composed of copies of the CharSequence elements joined together with a copy of the specified delimiter.",
	"String - String#split(String regex)": "Splits this string around matches of the given regular expression.",
	"String - String#split(String regex, int limit)": "Splits this string around matches of the given regular expression",
	"String - String#repeat (Java 11)": "This method allows concatenating a String with itself a given number of times: var string = 'foo bar ', var result = string.repeat(2), // foo bar foo bar",
	"String - String#isBlank (Java 11)": "That one is super straightforward. Now, we can check if a String instance is empty or contains whitespace ",
	"String - String#strip (Java 11)": "We can easily get rid of all the whitespace from each String now ",
	"String - String#lines (Java 11)": "Using this new method, we can easily split a String instance into a Stream<String> of separate lines",
	"String - Compact Strings (Java 9)": "Until now, the String was stored as a char[]: From now on, it’ll be a byte[]: This means that whenever we create a String if all the characters of the String can be represented using a byte — LATIN-1 representation, a byte array will be used internally, such that one byte is given for one character. In other cases, if any character requires more than 8-bits to represent it, all the characters are stored using two bytes for each — UTF-16 representation. So basically, whenever possible, it’ll just use a single byte for each character.",

	"HTTP clients": "SECTION",
	"HTTP/2 Client (Java 9)": "So for Java 9, a new API has been introduced that is cleaner and clearer to use and that also adds support for HTTP/2. The new API handles HTTP connections through three classes. (1) HttpClient handles the creation and sending of requests. (2) HttpRequest is used to construct a request to be sent via the HttpClient. (3) HttpResponse holds the response from the request that has been sent. java.net has introduced the HttpClient class as well as HttpRequest and HttpResponse",
	"HTTP/2 Client - HttpClient": "",
	"HTTP/2 Client - HttpRequest": "",
	"HTTP/2 Client - HttpResponse": "",
	"HTTP/2 Client - example - sync)": "HttpResponse < String > httpResponse = httpClient.send(httpRequest, HttpResponse.BodyHandler.asString()),",
	"HTTP/2 Client - example - async)": "CompletableFuture > httpResponse = httpClient.sendAsync(httpRequest, HttpResponse.BodyHandler.asString()),",

	"locale": "SECTION",
	"Language Tag Extensions (Java 7)": "The Java SE 7 release conforms to the IETF BCP 47 standard, which supports adding extensions to a Locale. Any single character can be used to denote an extension, but there are two predefined extension codes: 'u' specifies a Unicode locale extension, and 'x' specifies a private use extension.",
	"Language Tag Extensions - extension": "An extension is specified as a key/value pair, where the key is a single character (typically 'u' or 'x')..",
	"Language Tag Extensions - Locale#getExtensionKeys()": "Returns the set of extension keys associated with this locale, or the empty set if it has no extensions. The returned set is unmodifiable. The keys will all be lower-case.",
	"Language Tag Extensions - Locale#getUnicodeLocaleKeys()": "Returns the Unicode locale key codes or an empty set if the locale has none. For the German example, this would return a set containing the single string 'co'.",
	"Language Tag Extensions - Locale#getUnicodeLocaleType(String)": "Returns the Unicode locale type associated with the Unicode locale key code. Invoking getUnicodeLocaleType('co') for the German example would return the string 'phonebk'.",
	"Language Tag Extensions - Locale#getUnicodeLocaleAttributes()": "Returns the set of Unicode locale attributes associated with this locale, if any. In the German example, this would return a set containing the single string 'email'",
	"Language Tag Extensions - extension - Unicode": "Unicode locale extensions are defined by the Unicode Common Locale Data Repository (CLDR) project. They are used to specify information that is non-language-specific such as calendars or currency",
	"Language Tag Extensions - extension - Unicode - ca": "calendar algorithm, e.g. ca-buddhist: Thai Buddhist calendar",
	"Language Tag Extensions - extension - Unicode - co": "collation type, co-pinyin: Pinyin ordering for Latin",
	"Language Tag Extensions - extension - Unicode - ka": "collation parameters",
	"Language Tag Extensions - extension - Unicode - cu": "currency type, cu-usd: U.S. dollars",
	"Language Tag Extensions - extension - Unicode - nu": "number type, nu-jpanfin:Japanese financial numerals",
	"Language Tag Extensions - extension - Unicode - va": "common variant type, tz-aldav: Europe/Andorra",
	"Language Tag Extensions - extension - Unicode - fw (Java 10)": "first day of week",
	"Language Tag Extensions - extension - Unicode - rg (Java 10)": "region override",
	"Language Tag Extensions - extension - Unicode - tz (Java 10)": "time zone",
	"Language Tag Extensions - extension - Unicode - de-DE-u-email-co-phonebk-x-linux": "German language locale for the country of Germany using a phonebook style of ordering for the Linux platform. This example also contains an attribute named 'email'.",
	"Language Tag Extensions - extension - Private": "A private use extension may be used to specify any other information, such as platform (for example, Windows, UNIX, or Linux), or release information (for example, 6u23 or JDK 7).",
	"Language Tag Extensions - extension - Private - x-jdk-1-7": "",
	"Language Tag Extensions - extension - Private - x-linux": "",
	"Common Locale Data Repository (Java 8)": "The Unicode Consortium's Common Locale Data Repository is the de-facto standard for locale data on many platforms. Although CLDR locale data is bundled with the JRE as of JDK 8, it is not enabled by default. To turn it on, the end user must explicitly set the system property java.locale.providers, e.g.: java.locale.providers=JRE,CLDR",
	"Common Locale Data Repository - default (Java 9)": "By enabling the use of CLDR data by default, de-facto standard locale data will be provided to users without any further action on their part."
}