{
	"hashcode": "SECTION",
	"hashcode - rules - repeatable": "Whenever it is invoked on the same object more than once during an execution of a Java application, hashCode() must consistently return the same value, provided no information used in equals comparisons on the object is modified. This value needs not remain consistent from one execution of an application to another execution of the same application",
	"hashcode - rules - equal objects": "If two objects are equal according to the equals(Object) method, then calling the hashCode() method on each of the two objects must produce the same value",
	"hashcode - rules - no equal object": "It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, developers should be aware that producing distinct integer results for unequal objects improves the performance of hash tables",
	"hashcode - rules - equals": "Whenever you implement equals, you MUST also implement hashCode If you fail to do so, you will end up with broken objects. Why? An object’s hashCode method must take the same fields into account as its equals method. By overriding the equals method, you’re declaring some objects as equal to other objects, but the original hashCode method treats all objects as different. So you will have equal objects with different hash codes. ",
	"hashcode - rules - hash collision": "Whenever two different objects have the same hash code, we call this a collision..",
	"hashcode - rules - hash collision - collection": "A collision is nothing critical, it just means that there is more than one object in a single bucket, so a HashMap lookup has to look again to find the right object. A lot of collisions will degrade the performance of a system, but they won’t lead to incorrect results.",
	"hashcode - int  Object.hash​(Object... values) (Java 7)": "Generates a hash code for a sequence of input values. The hash code is generated as if all the input values were placed into an array, and that array were hashed by calling Arrays.hashCode(Object[]). This method is useful for implementing Object.hashCode() on objects containing multiple fields.",
	"hashcode - Arrays.hashcode() (Java 5)": "Returns a hash code based on the contents of the specified array.",
	"hashcode - Arrays.hashcode() vs Object.hash()": "Arrays.hashCode(Object[]) and Objects.hash(Object...) behave exactly the same way, because Objects.hash(Object...) completely delegates to Arrays.hashCode(Object[]).",


	"locale": "SECTION",
	"Language Tag Extensions (Java 7)": "The Java SE 7 release conforms to the IETF BCP 47 standard, which supports adding extensions to a Locale. Any single character can be used to denote an extension, but there are two predefined extension codes: 'u' specifies a Unicode locale extension, and 'x' specifies a private use extension.",
	"Language Tag Extensions - extension": "An extension is specified as a key/value pair, where the key is a single character (typically 'u' or 'x')..",
	"Language Tag Extensions - Locale#getExtensionKeys()": "Returns the set of extension keys associated with this locale, or the empty set if it has no extensions. The returned set is unmodifiable. The keys will all be lower-case.",
	"Language Tag Extensions - Locale#getUnicodeLocaleKeys()": "Returns the Unicode locale key codes or an empty set if the locale has none. For the German example, this would return a set containing the single string 'co'.",
	"Language Tag Extensions - Locale#getUnicodeLocaleType(String)": "Returns the Unicode locale type associated with the Unicode locale key code. Invoking getUnicodeLocaleType('co') for the German example would return the string 'phonebk'.",
	"Language Tag Extensions - Locale#getUnicodeLocaleAttributes()": "Returns the set of Unicode locale attributes associated with this locale, if any. In the German example, this would return a set containing the single string 'email'",
	"Language Tag Extensions - extension - Unicode": "Unicode locale extensions are defined by the Unicode Common Locale Data Repository (CLDR) project. They are used to specify information that is non-language-specific such as calendars or currency",
	"Language Tag Extensions - extension - Unicode - ca": "calendar algorithm, e.g. ca-buddhist: Thai Buddhist calendar",
	"Language Tag Extensions - extension - Unicode - co": "collation type, co-pinyin: Pinyin ordering for Latin",
	"Language Tag Extensions - extension - Unicode - ka": "collation parameters",
	"Language Tag Extensions - extension - Unicode - cu": "currency type, cu-usd: U.S. dollars",
	"Language Tag Extensions - extension - Unicode - nu": "number type, nu-jpanfin:Japanese financial numerals",
	"Language Tag Extensions - extension - Unicode - va": "common variant type, tz-aldav: Europe/Andorra",
	"Language Tag Extensions - extension - Unicode - fw (Java 10)": "first day of week",
	"Language Tag Extensions - extension - Unicode - rg (Java 10)": "region override",
	"Language Tag Extensions - extension - Unicode - tz (Java 10)": "time zone",
	"Language Tag Extensions - extension - Unicode - de-DE-u-email-co-phonebk-x-linux": "German language locale for the country of Germany using a phonebook style of ordering for the Linux platform. This example also contains an attribute named 'email'.",
	"Language Tag Extensions - extension - Private": "A private use extension may be used to specify any other information, such as platform (for example, Windows, UNIX, or Linux), or release information (for example, 6u23 or JDK 7).",
	"Language Tag Extensions - extension - Private - x-jdk-1-7": "",
	"Language Tag Extensions - extension - Private - x-linux": "",
	"Common Locale Data Repository (Java 8)": "The Unicode Consortium's Common Locale Data Repository is the de-facto standard for locale data on many platforms. Although CLDR locale data is bundled with the JRE as of JDK 8, it is not enabled by default. To turn it on, the end user must explicitly set the system property java.locale.providers, e.g.: java.locale.providers=JRE,CLDR",
	"Common Locale Data Repository - default (Java 9)": "By enabling the use of CLDR data by default, de-facto standard locale data will be provided to users without any further action on their part."


}