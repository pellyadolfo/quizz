{
	"SQL": "SECTION",

	"SQL - Schema": "A collection of database structural elements such as tables, stored procedures, indexes, functions, and triggers. It shows the overall database architecture, specifies the relationships between various objects of a database, and defines different access permissions for them. Read our database schema guide for a deeper understanding.",
	"SQL - Entities": ".",

	"SQL - CONSTRAINTS": "SECTION",
	"SQL - CONSTRAINTS ": "A set of conditions defining the type of data that can be input into each column of a table. Constraints ensure data integrity in a table and block undesired actions.",
	"SQL - CONSTRAINTS - DEFAULT": "provides a default value for a column.",
	"SQL - CONSTRAINTS - UNIQUE": "allows only unique values.",
	"SQL - CONSTRAINTS - NOT NULL": "allows only non-null values.",
	"SQL - CONSTRAINTS - PRIMARY KEY": "allows only unique and strictly non-null values (NOT NULL and UNIQUE).",
	"SQL - CONSTRAINTS - FOREIGN KEY": "provides shared keys between two or more tables.",

	"SQL - OPERATORS": "SECTION",
	"SQL - OPERATORS - Arithmetic": "Arithmetic (+, -, *, /, etc.)",
	"SQL - OPERATORS - Comparison": "Comparison (>, <, =, >=, etc.)",
	"SQL - OPERATORS - Compound": "Compound (+=, -=, *=, /=, etc.)",
	"SQL - OPERATORS - Logical": "Logical (AND, OR, NOT, BETWEEN, etc.)",
	"SQL - OPERATORS - String": "String (%, _, +, ^, etc.)",
	"SQL - OPERATORS - Set": "Set (UNION, UNION ALL, INTERSECT, and MINUS (or EXCEPT))",

	"SQL - CLAUSE": "SECTION",
	"SQL - CLAUSE ": "A condition imposed on a SQL query to filter the data to obtain the desired result. Some examples are WHERE, LIMIT, HAVING, LIKE, AND, OR, ORDER BY, etc.",
	"SQL - CLAUSE - FROM": "",
	"SQL - CLAUSE - GROUP BY": "",
	"SQL - CLAUSE - JOIN": "",
	"SQL - CLAUSE - WHERE": "checks each row individually",
	"SQL - CLAUSE - ORDER BY": "",
	"SQL - CLAUSE - LIMIT": "",
	"SQL - CLAUSE - HAVING": "works on aggregated data after they are grouped",

	"SQL - DDL": "SECTION",
	"SQL - DDL - CREATE": "",
	"SQL - DDL - ALTERTABLE": "",
	"SQL - DDL - DELETE": "",
	"SQL - DDL - DROP": "DROP deletes a table from the database completely, including the table structure and all the associated constraints, relationships with other tables, and access privileges. TRUNCATE deletes all rows from a table without affecting the table structure and constraints. DROP works slower than TRUNCATE. Both are irreversible DDL (Data Definition Language) commands.",
	"SQL - DDL - TRUNCATE": "",
	"SQL - DDL - ADDCOLUMN": "",

	"SQL - DML": "SECTION",
	"SQL - DML - INSERT": "",
	"SQL - DML - UPDATE": "",
	"SQL - DML - DELETE": "",

	"SQL - DCL": "SECTION",
	"SQL - DCL - GRANT": "",
	"SQL - DCL - REVOKE": "",

	"SQL - TCL": "SECTION",
	"SQL - TCL - COMMIT": "",
	"SQL - TCL - SET TRANSACTION": "",
	"SQL - TCL - ROLLBACK": "",
	"SQL - TCL - SAVEPOINT": "",

	"SQL - DQL": "SECTION",
	"SQL - DQL - SELECT": "",
	"SQL - DQL - SELECT - DISTINCT": "",
	"SQL - DQL - SELECT - JOINS": "A clause used to combine and retrieve records from two or multiple tables. SQL tables can be joined based on the relationship between the columns of those tables.",
	"SQL - DQL - SELECT - JOINS - (INNER) JOIN": "returns only those records that satisfy a defined join condition in both (or all) tables. It's a default SQL join.",
	"SQL - DQL - SELECT - JOINS - LEFT (OUTER) JOIN": "returns all records from the left table and those records from the right table that satisfy a defined join condition.",
	"SQL - DQL - SELECT - JOINS - RIGHT (OUTER) JOIN": "returns all records from the right table and those records from the left table that satisfy a defined join condition.",
	"SQL - DQL - SELECT - JOINS - FULL (OUTER) JOIN": "returns all records from both (or all) tables. It can be considered as a combination of left and right joins.",

	"SQL - INDEX": "A special data structure related to a database table and used for storing its important parts and enabling faster data search and retrieval. Indexes are especially efficient for large databases, where they significantly enhance query performance.",
	"SQL - INDEX - Unique": "Unique index – doesn't allow duplicates in a table column and hence helps maintain data integrity.",
	"SQL - INDEX - Clustered": "Clustered index – defines the physical order of records of a database table and performs data searching based on the key values. A table can have only one clustered index.",
	"SQL - INDEX - Non-clustered": "Non-clustered index – keeps the order of the table records that don't match the physical order of the actual data on the disk. It means that the data is stored in one place and a non-clustered index – in another one. A table can have multiple non-clustered indexes.",
	"SQL - INDEX - B-Tree": "B-trees, short for balanced trees, are the most common type of database index. A B-tree index is an ordered list of values divided into ranges. By associating a key with a row or range of rows, B-trees provide excellent retrieval performance for a wide range of queries, including exact match and range searches.",
	"SQL - INDEX - Bitmap": "In a bitmap index, the database stores a bitmap for each index key. In a conventional B-tree index, one index entry points to a single row. In a bitmap index, each index key stores pointers to multiple rows. Bitmap indexes are primarily designed for data warehousing or environments in which queries reference many columns in an ad hoc fashion.",

	"Indexes": "SECTION",

	"Transaction": "SECTION",
	"Transaction - definition": "A transaction is an unit of work that helps to respect ACID principle. This unit of work can only be executed entirely. It means that database will see zero (if transaction fails, operation called rollback) or all operations placed inside transaction (if transaction succeeds, operation called commit).",
	"Transaction - Isolation": "The isolation determines the visibility of changes made by one transaction for another transactions.",
	"Transaction - Isolation - levels": "They're 4 mains transaction's isolation levels: read uncommited, read commited, repeatable read, serializable",
	"Transaction - Isolation - levels - ReadUncommited": "imagine two transactions, 'A' and 'B'. First, 'A' writes a data into one table without commiting the transaction. After, 'B' reads the uncommited data and work on it. But some error occurs on commiting the 'A' transaction and all changes are rollbacked. In this case, 'B' continues to work on uncommited data by the 'A' transaction. This mode is very fast but can introduce a lot of data consistency problems",
	"Transaction - Isolation - levels - ReadCommitted": "we still use the same scenario as for read uncommited, but commited data is locked. It means that 'B' can't see uncommited data from the 'A' transaction. 'B' can see it only when 'A' will commit its transaction.",
	"Transaction - Isolation - levels - RepeatableRead": "this isolation level promotes the same data read, even if the data was changed meanwhile. We continue to work with our 'A' and 'B' transactions. First, 'B' makes a SELECT query and lock selected rows. After, 'A' makes an INSERT query. 'B' executes a new SELECT query with the same conditions as the first one. 'B' will now see the same results as previously (the second SELECT must be made under the same transaction as the first one).",
	"Transaction - Isolation - levels - Serializable": "this level occurs when our 'B' transaction reads the data and lock whole data's table. It means that another transaction can't modify the data on this table. Unlike read uncommited, this way is the most secure. But in the other hand, it's also the slowest solution.",
	"Transaction - Reads": "Transaction isolation levels can lead to incoscient data reads. We can distinguish 3 types of these reads: Dirty, Phantom and NonRepeatable",
	"Transaction - Reads - States - DirtyRead ": "caused by read uncommited level. In this inconsistency, data is different for two or more participating transactions. For example, the first transaction can read the uncommitted data by the second transaction.",
	"Transaction - Reads - States - PhantomRead": "occurs when two identical queries, executed inside the same transaction, return different set of rows. So, it consists on reading two different set of values, inside the same transaction. But unlike dirty read, all data of phantom read are committed. Yes, it's called phantom because the first and the second SELECT queries contain some phantom data (data absent in the first SELECT results or in the second one)",
	"Transaction - Reads - States - NonRepeatableRead": "this problem looks almost as a phantom read. But unlike phantom, non-repetable read is applied the same results. Imagine that 'B' reads one row at the first time (for example, a row with id = 30) and 'A' changes one of this row's values (for example, name). After the commit of 'A' transaction, 'B' reads again the same row inside the same transaction. But regarding to the first SELECT, it retrieves the row with the different values. This error can be produced when read committed isolation level is applied to the transactions. It's called non-repeatable because the result of first read of 'B' can't be repeatead in the second read."

}