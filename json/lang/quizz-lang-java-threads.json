{

	"JavaThreads": "SECTION",
	"JavaThreads ": "https://www.linkedin.com/posts/kumarg21_java-multithreading-activity-7338898193302134784-LoSz?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",

	"Process": "SECTION",
	"Process.": "A Process is a program in execution. It has its own address space, a call stack, and link to any resources such as open files. A computer system normally has multiple processes running at a time. The operating system keeps track of all these processes and facilitates their execution by sharing the processing time of the CPU among them.",
	"Process - Java.lang.Process": "Java.lang.Process encapsulates the runtime information of a program in execution. Methods provided by the Process is used to perform input, output, waiting for the process o complete, checking exit status of the process and destroying process.",
	"Process - Process Builder": "This is an auxiliary class for the Process and is instantiated to manage a collection of process attributes.",
	"Process - Process Builder - Creation": "ProcessBuilder.start() and Runtime.getRuntime.exec() methods creates a native process and return an instance of a subclass of Process that can be used to control the process and obtain information about it. ProcessBuilder.start() is the most preferred way to create process.",
	"Process - Runtime": "Every Java program has an instance of the Runtime class, which encapsulates the runtime environment of the program. This class cannot be instantiated, but we can get a reference to the Runtime of the currently running program with the help of the static method called Runtime.getRuntime(). There are several methods defined in the Runtime class. These methods can be invoked to get the information about the runtime environment such as number of processors available to the JVM, about of memory available, loading native library, explicitly call garbage collector, and so forth.",
	"Process - ProcessHandler (Java 9)": "ProcessHandle identifies and provides control of native processes. Each individual process can be monitored for liveness, list its children, get information about the process or destroy it. By comparison, Process instances were started by the current process and additionally provide access to the process input, output, and error streams.",
	"Threads - Execution - Main": "Every process has at least one thread - called the main thread. The main thread can create additional threads within the process.",
	"Threads - Execution - Multiplicity": "We can create multiple threads in java, even if we don’t create any Thread, one Thread at least do exist i.e. main thread. Multiple threads run parallely in java.",
	"Threads - Execution - Order": "We can use join() method to ensure all threads that started from main must end in order in which they started and also main should end in last.In other words waits for this thread to die. Calling join() method internally calls join(0),",
	"Threads - Execution - Priority": "Thread Priority range is from 1 to 10. Where 1 is minimum priority and 10 is maximum priority. Thread with MAX_PRIORITY is likely to get more CPU as compared to low priority threads.",
	"Threads - Execution - Priority - Daemon - Low": "Daemon threads are low priority threads which runs intermittently in background for doing garbage collection. Thread scheduler schedules these threads only when CPU is idle. These threads are created before user threads are created and die after all other user threads dies. Priority of daemon threads is always 1 (i.e. MIN_PRIORITY). JVM can exit when only daemon threads exist in system.",
	"Threads - Execution - Priority - Daemon - Visualization": "You may like to see how daemon threads work, for that you can use VisualVM or jStack.",
	"Threads - Execution - Priority - Daemon - Methods": "We can use isDaemon() method to check whether thread is daemon thread or not. We can use setDaemon(boolean on) method to make any user method a daemon thread. If setDaemon(boolean on) is called on thread after calling start() method than IllegalThreadStateException is thrown.",
	"Threads - Execution - Weight": "Threads are lightweight process only if threads of same process are executing concurrently. But if threads of different processes are executing concurrently then threads are heavy weight process.",
	"Threads - Execution - Predictability": "Thread behaviour is unpredictable because execution of Threads depends on Thread scheduler, thread scheduler may have different implementation on different platforms like windows, unix etc. Same threading program may produce different output in subsequent executions even on same platform. To achieve we are going to create 2 threads on same Runnable Object, create for loop in run() method and start  both threads. There is no surety that which threads will complete first,  both threads will enter anonymously in for loop.",
	"Threads - Lifecycle - Creation": "by implementing java.lang.Runnableinterface or by creating a Thread object. You must extend Thread only when you are looking to modify run() and other methods as well. If you are simply looking to modify only the run() method implementing Runnable is the best option (Runnable interface has only one abstract method i.e. run() ).",
	"Threads - Lifecycle - Start. run() vs start() methods": "When you call start() method, main thread internally calls run() method to start newly created Thread, so run() method is ultimately called by newly created thread. When you call run() method main thread rather than starting run() method with newly thread it start run() method by itself.",
	"Threads - Lifecycle - Restart. IllegalThreadStateException": "We cannot start Thread again, doing so will throw runtimeException java.lang.IllegalThreadStateException. The reason is once run() method is executed by Thread, it goes into dead state.",
	"Threads - Memory": "Have their own stack, share heap.",
	"Threads - Memory - Thread Stack": "Yes, Threads have their own stack",
	"Threads - Memory - Thread Dumps - VisualVM": "VisualVM  is most popular way to generate Thread Dump",
	"Threads - Memory - Thread Dumps - jstack": "jstack is very easy way to generate Thread dump",
	"Threads - vs Process - Hierarchy": "One process can have multiple Threads. Thread are subdivision of Process. One or more Threads runs in the context of process. Threads can execute any part of process. And same part of process can be executed by multiple Threads.",
	"Threads - vs Process - Data Segment": "Processes have their own copy of the data segment of the parent process while Threads have direct access to the data segment of its process.",
	"Threads - vs Process - Address Space": "Processes have their own address while Threads share the address space of the process that created it.",
	"Threads - vs Process - Creation": "Process creation needs whole lot of stuff to be done, we might need to copy whole parent process, but Thread can be easily created. Thread are light weight process.",
	"Threads - vs Process - Comunication": "Processes can easily communicate with child processes but interprocess communication is difficult. While, Threads can easily communicate with other threads of the same process using wait() and notify() methods.",
	"Threads - vs Process - ThreadStack": "In process all threads share system resource like heap Memory etc. while Thread has its own stack.",
	"Threads - vs Process - Changes": "Any change made to process does not affect child processes, but any change made to thread can affect the behavior of the other threads of the process.",

	"Threads - Platform": "SECTION",
	"Threads - Platform ": "Platform threads (traditional Java threads), which map 1:1 to OS threads.",
	"Threads - Virtual - Usage - NoUse - IOBoundTasks ": "Prefer VirtualThreads",
	"Threads - Virtual - Usage - Use - CPUIntensiveOperations": "Use platform threads or a thread pool for CPU-bound work",
	"Threads - Platform - Overhead - OSThread": "Platform threads are Java threads mapped directly to native OS threads (e.g., Linux pthread, Windows thread).",
	"Threads - Platform - Overhead - OSThread - Exhaustion": "Thread Exhaustion. The JVM or OS puts a limit on max threads (based on memory and system resources). If you try to exceed it, you get OutOfMemoryError",
	"Threads - Platform - Overhead - MemoryAllocation": "Each OS thread gets a stack space, typically 1MB by default. Creating 10,000 threads = 10,000 MB (~10 GB) of memory.",
	"Threads - Platform - Overhead - MemoryAllocation - OutOfMemoryError": "As noted, each thread has a default stack size (1MB). Even idle threads consume memory. Leads to OutOfMemoryError or crash if thread count is very high.",
	"Threads - Platform - Overhead - ContextSwitching": "When more threads exist than CPU cores, the OS must pause one thread and resume another. This context switch involves saving/restoring thread states — which is CPU-intensive and slows everything down.",
	"Threads - Platform - Overhead - ContextSwitching - Expensive": "The more threads, the more the CPU spends time switching between threads instead of doing real work.",
	"Threads - Platform - Overhead - SchedulingOverhead": "The OS has to decide which thread to run next from thousands of waiting threads. Scheduling becomes complex, less efficient as thread count increases",
	"Threads - Platform - Overhead - SchedulingOverhead - CPU": "Many threads are just waiting for I/O (e.g., database, file system, network). CPU is idle, but system is overloaded due to thread count.",
	"Threads - Platform - Objects - Thread": "A thread is a lightweight unit of execution within a process.",
	"Threads - Platform - Objects - ThreadLocal": "ThreadLocal is a class which provides thread-local variables. Every thread has its own ThreadLocal value that makes ThreadLocal value threadsafe as well. ThreadLocal variables are thread safe. As every thread has its own ThreadLocal value and one thread can’t see other threads ThreadLocal value.",
	"Threads - Platform - Objects - ThreadLocal - OutOfMemoryError": "If one of the application classes stores a value in ThreadLocal variable and doesn’t remove it after the task at hand is completed, a copy of that Object will remain with the Thread (from the application server thread pool). Since lifespan of the pooled Thread surpasses that of the application, it will prevent the object and thus a ClassLoader being responsible for loading the application from being garbage collected. And we have created a leak, which has a chance to surface in a good old java.lang.OutOfMemoryError: PermGen space form.",
	"Threads - Platform - Objects - ThreadGroup": "When program starts JVM creates  a ThreadGroup named main. Unless specified, all  newly created threads become members of the main thread group. ThreadGroup is initialized with default priority of 10.",
	"Threads - Platform - Objects - ThreadPool": "ThreadPool is a pool of threads which reuses a fixed number of threads  to execute tasks. ThreadPool implementation internally uses LinkedBlockingQueue for adding and removing tasks. ThreadPool threadPool=new ThreadPool(2), Most of the executor implementations use thread pools to execute tasks. A thread pool is nothing but a bunch of worker threads that exist separately from the Runnable or Callable tasks and is managed by the executor.",
	"Threads - Platform - Objects - Runnable": "The Runnable interface should be implemented by any class whose instances are intended to be executed by a thread. The class must define a method of no arguments called run.",
	"Threads - Platform - Objects - Callable (Java 5)": "Java provides a Callable interface to define tasks that return a result. A Callable is similar to Runnable except that it can return a result and throw a checked exception. Callable interface has a single method call() which is meant to contain the code that is executed by a thread. Unlike Runnable, a Callable can throw a checked exception.",
	"Threads - Platform - Lifecycle - ThreadStates": "New > Runnable > Running > Waiting/blocked/sleeping > Terminated (Dead)",
	"Threads - Platform - Lifecycle - ThreadStates - New": "When instance of thread is created using new operator it is in new state, but the start() method has not been invoked on the thread yet, thread is not eligible to run yet.",
	"Threads - Platform - Lifecycle - ThreadStates - Runnable": "When start() method is called on thread it enters runnable state",
	"Threads - Platform - Lifecycle - ThreadStates - Running": "Entering run() method",
	"Threads - Platform - Lifecycle - ThreadStates - Waiting/blocked/sleeping": "Thread is still alive, but currently not eligible to run. wait() to Waiting state, sleep() to Sleeping state",
	"Threads - Platform - Lifecycle - ThreadStates - Waiting vs sleeping": "In waiting state it will wait for other threads to release object monitor/lock. In sleeping state it will wait for sleep time to get over. Should be called from synchronized block. wait() method belongs to java.lang.Object class but sleep() method belongs to java.lang.Thread class. wait() method is called on objects but sleep() method is called on Threads not objects.",
	"Threads - Platform - Lifecycle - ThreadStates - Terminated (Dead)": "A thread is considered dead when its run() method completes.",
	"Threads - Platform - Lifecycle - ThreadStates - suspend()/resume() deprecated": "Suspend() method is deadlock prone. Suspend() method puts thread from running to waiting state. And thread can go from waiting to runnable state only when resume() method is called on thread. It is deprecated method. Resume() method is only used with suspend() method that’s why it’s also deprecated method.",
	"Threads - Platform - Lifecycle - ThreadStates - destroy() deprecated": " destroy() method is deadlock prone. If the target thread holds a lock on object when it is destroyed, no thread can lock this object (Deadlock formed are similar to deadlock formed when suspend() and resume() methods are used improperly). It results in deadlock formation. These deadlocksare generally called Frozen processes. Additionally you must know calling destroy() method on Threads throw runtimeException i.e. NoSuchMethodError. Destroy() method puts thread from running to dead state.",
	"Threads - Platform - Lifecycle - ThreadStates - stop() deprecated": "Stopping a thread with Thread.stop() causes it to release all of the monitors that it has locked. If any of the objects previously protected by these monitors were in an inconsistent state, the damaged objects become visible to other threads, which might lead to unpredictable behavior.",
	"Threads - Platform - Lifecycle - ThreadStates - How to Stop a Thread?": "(1) calling stop (deprecated), (2) calling interrupt plus catch InterruptionException, (3) put a flag to allow thread stop by itself",
	"Threads - Platform - Lifecycle - ThreadStates - notify vs notifiyAll()": "notify()- Wakes up a single thread that is waiting on this object's monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is random and occurs at the discretion of the implementation. notifyAll()- Wakes up all threads that are waiting on this object's monitor. A thread waits on an object's monitor by calling one of the wait methods.",
	"Threads - Platform - Lifecycle - Safepoint": "A safepoint is a range of execution where the state of the executing thread is well described. Safepoints are a common JVM implementation detail",
	"Threads - Platform - Lifecycle - Safepoint - How": "At a safepoint the mutator thread is at a known and well defined point in it’s interaction with the heap. This means that all the references on the stack are mapped (at known locations) and the JVM can account for all of them. As long as the thread remains at a safepoint we can safely manipulate the heap + stack such that the thread’s view of the world remains consistent when it leaves the safepoint.",
	"Threads - Platform - Lifecycle - Safepoint - When - Yes": "A Java thread is at a safepoint if it is blocked on a lock or synchronized block, waiting on a monitor, parked, or blocked on blocking IO. Essentially these all qualify as orderly de-scheduling events for the Java thread and as part of tidying up before put on hold the thread is brought to a safepoint. A Java thread is at a safepoint while executing JNI code. Before crossing the native call boundary the stack is left in a consistent state before handing off to the native code. This means that the thread can still run while at a safepoint.",
	"Threads - Platform - Lifecycle - Safepoint - How - No": "A Java thread which is executing bytecode is NOT at a safepoint (or at least the JVM cannot assume that it is at a safepoint).",
	"Threads - Platform - Lifecycle - Safepoint - flag": "Java threads poll a ‘safepoint flag’ (global or thread level) at ‘reasonable’ intervals and transition into a safepoint state (thread is blocked at a safepoint) when they observe a ‘Go to safepoint’ flag",
	"Threads - Platform - Variables - Thread-Local Handshakes - Java 10": "Introduce a way to execute a callback on threads without performing a global VM safepoint. Make it both possible and cheap to stop individual threads and not just all threads or none. A handshake operation is a callback that is executed for each JavaThread while that thread is in a safepoint safe state. The callback is executed either by the thread itself or by the VM thread while keeping the thread in a blocked state.",
	"Threads - Platform - Variables - Thread-Local Handshakes vs Safepoint": "The big difference between safepointing and handshaking is that the per thread operation will be performed on all threads as soon as possible and they will continue to execute as soon as it’s own operation is completed. If a JavaThread is known to be running, then a handshake can be performed with that single JavaThread as well.",
	"Threads - Platform - ConcurrencyModel - Sync - Execution - Executor (Java 5)": "A framework for creating and managing threads. Executors framework helps you with Thread Creation, Thread Management, Task submission and execution:",
	"Threads - Platform - ConcurrencyModel - Sync - Executor - Executor interfaces (Java 5)": "Java Concurrency API defines the following three executor interfaces that covers everything that is needed for creating and managing threads: Executor, ExecutorService, ScheduledExecutorService",
	"Threads - Platform - ConcurrencyModel - Sync - Executor - Executor interfaces - Executor": " A simple interface that contains a method called execute() to launch a task specified by a Runnable object. An object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An Executor is normally used instead of explicitly creating threads. For example, rather than invoking new Thread(new(RunnableTask())).start() for each of a set of tasks, you might use: Executor executor = anExecutor, executor.execute(new RunnableTask1()),",
	"Threads - Platform - ConcurrencyModel - Sync - Executor - Executor interfaces - ExecutorService": "A sub-interface of Executor that adds functionality to manage the lifecycle of the tasks. It also provides a submit() method whose overloaded versions can accept a Runnable as well as a Callable object. ExecutorService provides two methods for shutting down an executor : shutdown() and shutdownNow()",
	"Threads - Platform - ConcurrencyModel - Sync - Executor - Executor interfaces - ExecutorService. How": "Tasks are submitted to a thread pool via an internal queue called the Blocking Queue. If there are more tasks than the number of active threads, they are inserted into the blocking queue for waiting until any thread becomes available. If the blocking queue is full than new tasks are rejected.",
	"Threads - Platform - ConcurrencyModel - Sync - Executor - Executor interfaces - ScheduledExecutorService": "A sub-interface of ExecutorService. It adds functionality to schedule the execution of the tasks. ScheduledExecutorService is used to execute a task either periodically or after a specified delay.",
	"Threads - Platform - ConcurrencyModel - Sync - Executor - ThreadPool - ThreadPoolExecutor (Java 6) - implements ExecutorService": "An ExecutorService that executes each submitted task using one of possibly several pooled threads, normally configured using Executors factory methods.",
	"Threads - Platform - ConcurrencyModel - Sync - Executor - ThreadPool - ScheduledThreadPoolExecutor (Java 7)": "A ThreadPoolExecutor that can additionally schedule commands to run after a given delay, or to execute periodically. This class is preferable to Timer when multiple worker threads are needed, or when the additional flexibility or capabilities of ThreadPoolExecutor (which this class extends) are required.",
	"Threads - Platform - ConcurrencyModel - Sync - Executor - ForkJoin - Java 7": "The fork/join framework is an implementation of the ExecutorService interface that helps you take advantage of multiple processors. It is designed for work that can be broken into smaller pieces recursively. As with any ExecutorService implementation, the fork/join framework distributes tasks to worker threads in a thread pool. The fork/join framework is distinct because it uses a work-stealing algorithm. Worker threads that run out of things to do can steal tasks from other threads that are still busy.",
	"Threads - Platform - ConcurrencyModel - Sync - Executor - ForkJoin - ForkJoinPool (Java 7)": "The center of the fork/join framework is the ForkJoinPool class, an extension of the AbstractExecutorService class. ForkJoinPool implements the core work-stealing algorithm and can execute ForkJoinTask processes.",
	"Threads - Platform - ConcurrencyModel - Sync - Executor - ForkJoin - ForkJoinTask": "ForkJoinTask is the base type for tasks executed inside ForkJoinPool. In practice, one of its two subclasses should be extended: the RecursiveAction for void tasks and the RecursiveTask<V> for tasks that return a value. They both have an abstract method compute() in which the task’s logic is defined.",
	"Threads - Platform - ConcurrencyModel - Sync - Practical Options - Runnable.run()": "new Runnable() { @Override public void run() { ... } }.run(), Does not create a thread",
	"Threads - Platform - ConcurrencyModel - Sync - Practical Options - Thread.start()": "new Thread( new Runnable() { @Override public void run() { ... } }).start(), Correct. Thread dies after completion",
	"Threads - Platform - ConcurrencyModel - Sync - Practical Options - Executor.execute(...) (simple)": "Executors.newSingleThreadExecutor().execute(new Runnable() { @Override  public void run() { ... } }), Correct. Executor object is running open after thread finished",
	"Threads - Platform - ConcurrencyModel - Sync - Practical Options - Executor.execute(...) (scheduled)": "Executors.newSingleThreadScheduledExecutor().execute(new Runnable() { @Override  public void run() { ... } }), Correct. Creates a single-threaded executor that can schedule commands to run after a given delay, or to execute periodically.",
	"Threads - Platform - ConcurrencyModel - Sync - Practical Options - Executor.execute(...) (static thread pool)": "Executors.newFixedThreadPool().execute(new Runnable() { @Override  public void run() { ... } }), Correct. Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue. At any point, at most nThreads threads will be active processing tasks. If additional tasks are submitted when all threads are active, they will wait in the queue until a thread is available. If any thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks. The threads in the pool will exist until it is explicitly shutdown",
	"Threads - Platform - ConcurrencyModel - Sync - Practical Options - Executor.execute(...) (dynamic thread pool)": "Executors.newCachedThreadPool().execute(new Runnable() { @Override  public void run() { ... } }), Correct. Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available. These pools will typically improve the performance of programs that execute many short-lived asynchronous tasks. Calls to execute will reuse previously constructed threads if available. If no existing thread is available, a new thread will be created and added to the pool. Threads that have not been used for sixty seconds are terminated and removed from the cache. Thus, a pool that remains idle for long enough will not consume any resources. Note that pools with similar properties but different details (for example, timeout parameters) may be created using ThreadPoolExecutor constructors.",
	"Threads - Platform - ConcurrencyModel - Sync - Practical Options - Executor.execute(...) (fork/join - work stealing)": "Executors.newWorkStealingThreadPool().execute(new Runnable() { @Override  public void run() { ... } }), Correct. will create and shut down threads dynamically to accommodate the required parallelism level. It also tries to reduce the contention on the task queue, so can be really good in heavily loaded environments. Also good when your tasks create more tasks for the executor, like recursive tasks.",
	"Threads - Platform - ConcurrencyModel - Sync - Spring - TaskExecutor": "Spring provides the TaskExecutor as an abstraction for dealing with executors.",
	"Threads - Platform - ConcurrencyModel - Sync - Spring - TaskExecutor - SimpleAsyncTaskExecutor": "This implementation does not reuse any threads, rather it starts up a new thread for each invocation. However, it does support a concurrency limit which will block any invocations that are over the limit until a slot has been freed up. If you're looking for true pooling, keep scrolling further down the page.",
	"Threads - Platform - ConcurrencyModel - Sync - Spring - TaskExecutor - SyncTaskExecutor": "This implementation doesn't execute invocations asynchronously. Instead, each invocation takes place in the calling thread. It is primarily used in situations where mutlithreading isn't necessary such as simple test cases.",
	"Threads - Platform - ConcurrencyModel - Sync - Spring - TaskExecutor - ConcurrentTaskExecutor": "This implementation is a wrapper for a Java 5 java.util.concurrent.Executor. There is an alternative, ThreadPoolTaskExecutor, that exposes the Executor configuration parameters as bean properties. It is rare to need to use the ConcurrentTaskExecutor but if the ThreadPoolTaskExecutor isn't robust enough for your needs, the ConcurrentTaskExecutor is an alternative.",
	"Threads - Platform - ConcurrencyModel - Sync - Spring - TaskExecutor - SimpleThreadPoolTaskExecutor": "This implementation is actually a subclass of Quartz's SimpleThreadPool which listens to Spring's lifecycle callbacks. This is typically used when you have a threadpool that may need to be shared by both Quartz and non-Quartz components.",
	"Threads - Platform - ConcurrencyModel - Sync - Spring - TaskExecutor - ThreadPoolTaskExecutor": "This implementation can only be used in a Java 5 environment but is also the most commonly used one in that environment. It exposes bean properties for configuring a java.util.concurrent.ThreadPoolExecutor and wraps it in a TaskExecutor. If you need something advanced such as a ScheduledThreadPoolExecutor, it is recommended that you use a ConcurrentTaskExecutor instead.",
	"Threads - Platform - ConcurrencyModel - Sync - Spring - TaskExecutor - TimerTaskExecutor": "This implementation uses a single TimerTask as its backing implementation. It's different from the SyncTaskExecutor in that the method invocations are executed in a separate thread, although they are synchronous in that thread.",
	"Threads - Platform - ConcurrencyModel - Sync - Spring - TaskExecutor - WorkManagerTaskExecutor": "CommonJ is a set of specifications jointly developed between BEA and IBM. These specifications are not Java EE standards, but are standard across BEA's and IBM's Application Server implementations.This implementation uses the CommonJ WorkManager as its backing implementation and is the central convenience class for setting up a CommonJ WorkManager reference in a Spring context. Similar to the SimpleThreadPoolTaskExecutor, this class implements the WorkManager interface and therefore can be used directly as a WorkManager as well.",
	"Threads - Platform - ConcurrencyModel - Async - Future - Java5": "The concept of Future is similar to Promise in other languages like Javascript. It represents the result of a computation that will be completed at a later point of time in future. You can cancel a future using Future.cancel() method. The future.get() method blocks and waits for the task to complete. Future<String> future = executorService.submit(callable),",
	"Threads - Platform - ConcurrencyModel - Async - FutureTask - Java7": "A cancellable asynchronous computation. This class provides a base implementation of Future, with methods to start and cancel a computation, query to see if the computation is complete, and retrieve the result of the computation. The result can only be retrieved when the computation has completed, the get methods will block if the computation has not yet completed. Once the computation has completed, the computation cannot be restarted or cancelled (unless the computation is invoked using runAndReset()). A FutureTask can be used to wrap a Callable or Runnable object. Because FutureTask implements Runnable, a FutureTask can be submitted to an Executor for execution.",
	"Threads - Platform - ConcurrencyModel - Async - CompletableFuture - Java8": "CompletableFuture is at the same time a building block and a framework with about 50 different methods for composing, combining, executing asynchronous computation steps and handling errors.",
	"Threads - Platform - ConcurrencyModel - Async - CompletableFuture - Simple": "The CompletableFuture class implements the Future interface, so you can use it as a Future implementation, but with additional completion logic.",
	"Threads - Platform - ConcurrencyModel - Async - CompletableFuture - Computation": "Static methods runAsync(Runnable runnable), runAsync(Runnable runnable, Executor executor), supplyAsync(Supplier<U> supplier) and supplyAsync(Supplier<U> supplier, Executor executor) allow us to create a CompletableFuture instance out of Runnable and Supplier functional types correspondingly. supplyAsync() by default uses ForkJoinPool.commonPool(), thread pool shared between all CompletableFutures, all parallel streams and all applications deployed on the same JVM. This hard-coded, unconfigurable thread pool is completely outside of our control, hard to monitor and scale. Therefore you should always specify your own Executor",
	"Threads - Platform - ConcurrencyModel - Async - CompletableFuture - Computation - Async": "<b>thenApply</b> - thenApply(Function< ? super T,? extends U > fn), thenApplyAsync(Function< ? super T,? extends U > fn), thenApplyAsync(Function< ? super T,? extends U > fn, Executor executor), <br/><br/><b>thenAccept</b> - thenAccept(Consumer< ? super T > action), thenAcceptAsync(Consumer< ? super T > action), thenAcceptAsync(Consumer< ? super T > action, Executor executor), thenAcceptBoth(CompletionStage< ? extends U > other, BiConsumer< ? super T,? super U > action), thenAcceptBothAsync(CompletionStage< ? extends U > other, BiConsumer< ? super T,? super U > action), thenAcceptBothAsync(CompletionStage< ? extends U > other, BiConsumer< ? super T,? super U > action, Executor executor) <br/><br/><b>thenRun</b> - thenRun(Runnable action), thenRunAsync(Runnable action), thenRunAsync(Runnable action, Executor executor)",
	"Threads - Platform - ConcurrencyModel - Async - CompletableFuture - Combining": "<b>thenCompose</b>, <b>thenCombine</b> Ability to combine CompletableFuture instances in a chain of computation steps.",
	"Threads - Platform - ConcurrencyModel - Async - CompletableFuture - Multiple": "CompletableFuture<Void> combinedFuture = CompletableFuture.allOf(future1, future2, future3)",
	"Threads - Platform - ConcurrencyModel - Async - CompletableFuture - Errors": "handle()",
	"Threads - Platform - ConcurrencyModel - Async - CompletableFuture - Async": "supplyAsync() + thenApplyAsync()",

	"Threads - Virtual": "SECTION",
	"Threads - Virtual - Java19": "Project Loom. Introduced in Java 19 (JEP 425) as a preview feature and finalized in Java 21.",
	"Threads - Virtual - Features - Abstraction": "Virtual threads are a logical abstraction. Only carrier threads are scheduled on CPUs.",
	"Threads - Virtual - Features - LowMemoryFootprint": "measured in KBs vs MBs for platform threads.",
	"Threads - Virtual - Features - Scalability": "You can spawn millions of threads.",
	"Threads - Virtual - Features - Integration": "Native integration with the Java standard library.",
	"Threads - Virtual - Features - Unmount": "When a virtual thread runs blocking code (Thread.sleep, I/O), the JVM unmounts it from the carrier thread. The carrier thread can then serve another virtual thread. When the blocking operation completes, the virtual thread is resumed on any available carrier.",
	"Threads - Virtual - Benefits - NoStarvation": "No thread starvation: Unlike OS threads, millions of virtual threads can wait on locks without exhausting system resources.",
	"Threads - Virtual - Benefits - NoAPIGateway": ".",
	"Threads - Virtual - Benefits - NoPoolsNeeed": "No thread pools required:  They're cheap to create/destroy.",
	"Threads - Virtual - Benefits - Compatibility": "Work with existing Java APIs (Thread, ExecutorService)",
	"Threads - Virtual - Benefits - Compatibility - Debugging": "Stack traces work normally, unlike with reactive programming",
	"Threads - Virtual - Usage - Use - HighConcurrency": "High-concurrency I/O-bound applications (web servers, microservices)",
	"Threads - Virtual - Usage - Use - Blocking": "Applications with many blocking operations",
	"Threads - Virtual - Usage - Use - Pools": "Scenarios where you'd traditionally use thread pools",
	"Threads - Virtual - Usage - Use - IOBoundTasks ": "HTTP calls, DB queries, file operations",
	"Threads - Virtual - Usage - NoUse - CPUIntensiveOperations": "Virtual threads are lightweight and managed by the JVM, but when they execute CPU-bound tasks, they still run on a platform (OS) thread. No Benefit Over Platform Threads for CPU Work",
	"Threads - Virtual - Lifecycle - Create - startVirtualThread": "Thread.startVirtualThread(() -> { ... });",
	"Threads - Virtual - Lifecycle - Create - Thread.Builder": "Thread.ofVirtual().name('my-virtual-thread').start(() -> { /* task */ });",
	"Threads - Virtual - Lifecycle - Create - Executors.newVirtualThreadPerTaskExecutor": "try (var executor = Executors.newVirtualThreadPerTaskExecutor()) { executor.submit(() -> System.out.println('Running in virtual thread')); }",
	"Threads - Virtual - Lifecycle - Start - PlatformThread - Java19": "Thread platformThread = Thread.ofPlatform().start(() -> {...});",
	"Threads - Virtual - Lifecycle - Start - VirtualThread - Java19": "Thread virtualThread = Thread.ofVirtual().start(() -> {...}); System.out.println(virtualThread.isVirtual());",
	"Threads - Virtual - Variables - AvoidThreadLocals": "Avoid thread-local variables - They don't scale well with virtual threads",
	"Threads - Virtual - Variables - ScopedValues": "Similar to thread-local variables, scoped values use multiple incarnations, one per thread. Also, they are typically declared as public static fields that can easily be accessed by many components: public final static ScopedValue<User> LOGGED_IN_USER = ScopedValue.newInstance();",
	"Threads - Virtual - Variables - ScopedValues - immutable": "On the other hand, a scoped value is written once and is then immutable. The scoped value is available only for a bounded period of the execution of the thread",
	"Threads - Virtual - ConcurrencyModel": "A virtual thread runs Java code like a platform thread but gets parked when blocked, freeing up the underlying resources.",
	"Threads - Virtual - ConcurrencyModel - Sync - CarrierThread": "When blocked (I/O, waiting), they're automatically unmounted from the carrier thread",
	"Threads - Virtual - ConcurrencyModel - Sync - Block": "When blocked (I/O, waiting), they're automatically unmounted from the carrier thread",
	"Threads - Virtual - ConcurrencyModel - Sync - Unmounted": "The carrier thread can then execute other virtual threads",
	"Threads - Virtual - ConcurrencyModel - Sync - Unblock": "When unblocked, they're rescheduled onto a carrier thread",
	"Threads - Virtual - ConcurrencyModel - StructuredConcurrency - Java21": "Structured Concurrency lets you group related concurrent tasks and manage their lifecycle in a clear and maintainable way.",
	"Threads - Virtual - ConcurrencyModel - StructuredConcurrency - Principles - TaskHierarchy": "Child tasks are created within a defined scope and lifetime",
	"Threads - Virtual - ConcurrencyModel - StructuredConcurrency - Principles - ErrorPropagation": "Failures in child tasks propagate to the parent",
	"Threads - Virtual - ConcurrencyModel - StructuredConcurrency - Principles - CleanCancellation": "All child tasks are cancelled if the parent fails or is interrupted",
	"Threads - Virtual - ConcurrencyModel - StructuredConcurrency - Principles - Observability": "Clear parent-child relationships in thread dumps and debugging",
	"Threads - Virtual - ConcurrencyModel - StructuredConcurrency - StructuredTaskScope": "Since the advent of virtual threads in Java, we have had a new and nice concurrency model introduced as StructuredTaskScope.",
	"Threads - Virtual - ConcurrencyModel - StructuredConcurrency - StructuredTaskScope - Lifecycle": "StructuredTaskScope is created and destroyed as soon as we exit the method. We can do it because virtual threads are cheap — around 1000 times cheaper than platform threads.",
	"Threads - Virtual - ConcurrencyModel - StructuredConcurrency - StructuredTaskScope - ShutdownOnSuccess": "",
	"Threads - Virtual - ConcurrencyModel - StructuredConcurrency - Example": "try (var scope = StructuredTaskScope.ShutdownOnSuccess<String>()) { scope.fork(() -> fetchFromApi1()); scope.fork(() -> fetchFromApi2()); scope.join(); return scope.result(); }",
	"Threads - Virtual - ConcurrencyModel - StructuredConcurrency - Error": "try (var scope = new StructuredTaskScope.ShutdownOnFailure()) { scope.fork(() -> slowService()); scope.fork(() -> flakyService()); scope.join(); scope.throwIfFailed(); }",
	"Threads - Virtual - ConcurrencyModel - StructuredConcurrency - NoAsynNeeded": "Write synchronous-looking code that scales asynchronously",
	"Threads - Virtual - ConcurrencyModel - StructuredConcurrency - NoAsynNeeded - Sync": "Virtual threads run synchronously—they block like regular threads when waiting for I/O or other operations.",
	"Threads - Virtual - ConcurrencyModel - StructuredConcurrency - NoAsynNeeded - Blocking": "However, since they are lightweight (~1KB overhead vs. ~1MB for platform threads), blocking them is cheap.",
	"Threads - Virtual - ConcurrencyModel - StructuredConcurrency - NoAsynNeeded - Callbacks": "Virtual threads don’t require callbacks or chained operations.",
	"Threads - Virtual - ConcurrencyModel - StructuredConcurrency - NoAsynNeeded - JVM": "Virtual threads are lightweight threads managed by the JVM rather than the operating system.  The JVM schedules them onto a small pool of platform threads",

	"Threads - Locks": "SECTION",
	"Threads - Locks ": "By convention, a thread that needs exclusive and consistent access to an objects fields has to acquire the objects intrinsic lock before accessing them, and then release the intrinsic lock when it is done. A thread is said to own the intrinsic lock between the time it has acquired the lock and released the lock. As long as a thread owns an intrinsic lock, no other thread can acquire the same lock. The other thread will block when it attempts to acquire the lock. When a thread releases an intrinsic lock, a happens-before relationship is established between that action and any subsequent acquisition of the same lock.",
	"Threads - Locks - Liveness": "A concurrent application's ability to execute in a timely manner is known as its liveness. This section describes the most common kind of liveness problem, deadlock, and goes on to briefly describe two other liveness problems, starvation and livelock.",
	"Threads - Locks - Liveness - RaceCondition": "A race condition occurs when two or more threads can access shared data and they try to change it at the same time.",
	"Threads - Locks - Liveness - Livelock": "A thread often acts in response to the action of another thread. If the other thread's action is also a response to the action of another thread, then livelock may result. As with deadlock, livelocked threads are unable to make further progress. However, the threads are not blocked — they are simply too busy responding to each other to resume work. This is comparable to two people attempting to pass each other in a corridor: Alphonse moves to his left to let Gaston pass, while Gaston moves to his right to let Alphonse pass. Seeing that they are still blocking each other, Alphone moves to his right, while Gaston moves to his left. They're still blocking each other, so...",
	"Threads - Locks - Liveness - Deadlock": "Deadlock is a situation where two threads are waiting for each other to release lock holded by them on resources.",
	"Threads - Locks - Liveness - ThreadStarvation": "When thread does not enough CPU for its execution Thread starvation happens.",
	"Threads - Locks - Liveness - ThreadInterference": "Threads communicate primarily by sharing access to fields and the objects reference fields refer to. This form of communication is extremely efficient, but makes two kinds of errors possible: thread interference and memory consistency errors. The tool needed to prevent these errors is synchronization.",
	"Threads - Locks - Objects - LockObjects": "More sophisticated locking idioms are supported by the java.util.concurrent.locks package. Its most basic interface  is Lock. Lock objects work very much like the implicit locks used by synchronized code. As with implicit locks, only one thread can own a Lock object at a time. Lock objects also support a wait/notify mechanism, through their associated Condition objects.",
	"Threads - Locks - Objects - LockObjects - Features - wait/notify": "Lock objects also support a wait/notify mechanism, through their associated Condition objects.",
	"Threads - Locks - Objects - LockObjects - Lock - lock()": "Acquires the lock.",
	"Threads - Locks - Objects - LockObjects - Lock - lockInterruptibly()": "Acquires the lock unless the current thread is interrupted.",
	"Threads - Locks - Objects - LockObjects - Lock - newCondition()": "Returns a new Condition instance that is bound to this Lock instance.",
	"Threads - Locks - Objects - LockObjects - Lock - tryLock()": "Acquires the lock only if it is free at the time of invocation.",
	"Threads - Locks - Objects - LockObjects - Lock - tryLock(long time, TimeUnit unit)": "Acquires the lock if it is free within the given waiting time and the current thread has not been interrupted.",
	"Threads - Locks - Objects - LockObjects - Lock - unlock()": "Releases the lock.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock": "The intrinsic lock enforces exclusive access to an object's state.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - Features - thread": "Only one thread can own a Lock object at a time.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - Features - multiaccess": "The same thread can acquire the lock multiple times.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - Features - release": "Each lock acquisition must be paired with a corresponding unlock.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - Features - exceptions": "If a Thread Throws an Exception Inside a Lock, if you forget to unlock in a finally block, the lock stays locked forever.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock": "Synchronized code relies on a simple kind of ReentrantLock.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized": "Synchronization is built around an internal entity known as the intrinsic lock or monitor lock (monitor).",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - ReentrantSynchronization": "Recall that a thread cannot acquire a lock owned by another thread. But a thread can acquire a lock that it already owns. Allowing a thread to acquire the same lock more than once enables reentrant synchronization. This describes a situation where synchronized code, directly or indirectly, invokes a method that also contains synchronized code, and both sets of code use the same lock. Without reentrant synchronization, synchronized code would have to take many additional precautions to avoid having a thread cause itself to block.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - ReentrantSynchronization - levels": "",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - ReentrantSynchronization - levels - block": "",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - ReentrantSynchronization - levels - method": "",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - ReentrantSynchronization - levels - staticmethod": "",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - multiplicity": "Every instance of object has an intrinsic lock (aka monitor lock) associated with it.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - lifecycle": "When a thread invokes a synchronized method, it automatically acquires the intrinsic lock for that method's object and releases it when the method returns.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - scope": "The Java programming language provides two basic synchronization idioms: synchronized methods and synchronized statements.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - fast": "Optimized by the JVM. Faster than manual locking. Easier to reason about than ReentrantLock. Without contention, it is often extremely fast.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - slow": "synchronized becomes slow only when many threads fight for the same lock.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - exceptions": "If a Thread Throws an Exception Inside a Lock, the lock is released automatically.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - communication": "Threads can communicate with each other by using wait(), notify() and notifyAll() methods.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - communication - wait()": "releases the monitor lock.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - communication - notify()": ".",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - communication - notifyAll()": ".",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - communication - IllegalMonitorStateException": "wait(), notify() and notifyAll() methods are always called from Synchronized block only, and as soon as thread enters synchronized block it acquires object lock (by holding object monitor). If we call these methods without acquiring object lock i.e. from outside synchronize block then java.lang. IllegalMonitorStateException is thrown at runtime.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - communication - InterruptedException": "Wait() method needs to enclosed in try-catch block, because it throws compile time exception i.e. InterruptedException.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - Virtual - Pinning": "The virtual thread gets bound to a carrier thread, reducing scalability benefits.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - Virtual - Pinning - NoSynchronized": "When a virtual thread blocks on a ReentrantLock, the JVM detaches it from the carrier thread, allowing the carrier to execute another virtual thread.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - Virtual - Pinning - synchronize": "Synchronization of VirtualThreats can cause 'pinning'.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - Virtual - Pinning - eg": "If the read(buf) method blocks due to unavailable data, the virtual thread remains pinned, occupying the carrier thread and preventing it from executing other virtual threads.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - Virtual - Pinning - Fix - Locks": "We needed to fix this problem by using Java Lock objects.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - Virtual - Pinning - Fix - Locks - Avoid - ReentrantLock": ".",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - Virtual - Pinning - Fix - Locks - Avoid - ConcurrentDataStructures": ".",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - Virtual - Pinning - Fix - Locks - Avoid - AtomicClasses": ".",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - Virtual - Pinning - Fix - Locks - Avoid - Semaphore": ".",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - Virtual - Pinning - Fix - Locks - Avoid - CountDownLatch": ".",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - Virtual - Pinning - Fix - Locks - Avoid - Phaser": ".",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - Virtual - Pinning - Java24": "Now in Java 24, JVM handling of synchronization allows virtual threads to unmount from their carrier threads even when blocked within synchronized blocks or methods.",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - Virtual - ReentrantLock": "Prefer ReentrantLock over synchronized for blocking operations",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - Virtual - ReentrantLock - lock": "Instead, use plain lock() or tryLock() (without timeout).",
	"Threads - Locks - Objects - LockObjects - ReentrantLock - IntrinsicLock - synchronized - Virtual - ReentrantLock - tryLock": "Never Use ReentrantLock with tryLock(long, TimeUnit) in Virtual Threads. tryLock(timeout) pins the virtual thread to the carrier thread (bad for scalability).",
	"Threads - Locks - Objects - LockObjects - ReadWriteLock": "ReadWriteLock consists of a pair of locks - one for read access and one for write access.",
	"Threads - Locks - Objects - LockObjects - ReadWriteLock - read": "The read lock may be held by multiple threads simultaneously as long as the write lock is not held by any thread.",
	"Threads - Locks - Objects - LockObjects - ReadWriteLock - concurrency": "ReadWriteLock allows for an increased level of concurrency. It performs better compared to other locks in applications where there are fewer writes than reads.",
	"Threads - Locks - Objects - LockObjects - ReentrantReadWriteLock - synchronizedx2": "lock read/write separately, mutually exclusive lock with the same behavior as synchronized keyword.",
	"Threads - Locks - Objects - LockObjects - ReentrantReadWriteLock - multiple": "A thread that currently owns the lock can acquire it more than once without any problem.",
	"Threads - Locks - Objects - LockObjects - ReentrantReadWriteLock - tryLock": "The tryLock() method tries to acquire the lock without pausing the thread.",
	"Threads - Locks - Objects - LockObjects - StampedLock - Java8": "3 modes for controlling read/write access: writeLock, readLock, tryOptimisticRead()",
	"Threads - Locks - Objects - LockObjects - StampedLock - (1) writeLock()": "(1) Writing. Method writeLock() possibly blocks waiting for exclusive access, returning a stamp that can be used in method unlockWrite(long) to release the lock.",
	"Threads - Locks - Objects - LockObjects - StampedLock - (2) readLock()": "(2) Method readLock() possibly blocks waiting for non-exclusive access, returning a stamp that can be used in method unlockRead(long) to release the lock.",
	"Threads - Locks - Objects - LockObjects - StampedLock - (3) tryOptimisticRead()": "(3) Optimistic Reading. Method tryOptimisticRead() returns a non-zero stamp only if the lock is not currently held in write mode.",
	"Threads - Locks - Methods - ConcurrentCollections": "The java.util.concurrent package includes a number of additions to the Java Collections Framework. These are most easily categorized by the collection interfaces provided: BlockingQueue, ConcurrentMap, ConcurrentNavigableMap. All of these collections help avoid Memory Consistency Errors by defining a happens-before relationship between an operation that adds an object to the collection with subsequent operations that access or remove that object.",
	"Threads - Locks - Methods - ConcurrentCollections - BlockingQueue": "A Queue that additionally supports operations that wait for the queue to become non-empty when retrieving an element, and wait for space to become available in the queue when storing an element.",
	"Threads - Locks - Methods - ConcurrentCollections - ConcurrentMap": "ConcurrentMap is a subinterface of java.util.Map that defines useful atomic operations. These operations remove or replace a key-value pair only if the key is present, or add a key-value pair only if the key is absent. Making these operations atomic helps avoid synchronization. The standard general-purpose implementation of ConcurrentMap is ConcurrentHashMap, which is a concurrent analog of HashMap.",
	"Threads - Locks - Methods - ConcurrentCollections - ConcurrentNavigableMap": "ConcurrentNavigableMap is a subinterface of ConcurrentMap that supports approximate matches. The standard general-purpose implementation of ConcurrentNavigableMap is ConcurrentSkipListMap, which is a concurrent analog of TreeMap.",
	"Threads - Locks - Methods - AtomicAccess": "Using simple atomic variable access is more efficient than accessing these variables through synchronized code, but requires more care by the programmer to avoid memory consistency errors. Whether the extra effort is worthwhile depends on the size and complexity of the application.",
	"Threads - Locks - Methods - AtomicVariables": "Java concurrency api defines several classes in java.util.concurrent.atomic package that support Atomic operations on single variables. Atomic classes internally use compare-and-swap instructions supported by modern CPUs to achieve synchronization. These instructions are generally much faster than locks.",
	"Threads - Locks - Methods - VarHandle": "VarHandles are a key feature introduced in Java 9 as part of the Java Concurrency API improvements. They provide a safer and more performant alternative to using sun.misc.Unsafe for low-level memory operations.",
	"Threads - Locks - Methods - VarHandle - SaferThanUnsafe": "VarHandles are type-checked and don't allow arbitrary memory access",
	"Threads - Locks - Methods - VarHandle - Atomic": "*More flexible than Atomic classes**: Can be used with any field, not just specially declared ones",
	"Threads - Locks - Methods - VarHandle - StandardAPI": "Part of java.lang.invoke package, not an internal API",
	"Threads - Locks - Memory - WorkingMemory": "In Java, each thread has a separate memory space known as working memory, this holds the values of different variables used for performing operations. After performing an operation, thread copies the updated value of the variable to the main memory, and from there other threads can read the latest value.",
	"Threads - Locks - Memory - WorkingMemory - Volatile": "Volatile fields are instance or class (static) variables and are stored in the heap.",
	"Threads - Locks - Memory - WorkingMemory - Volatile - access": "multiple threads accessing it. Reads and writes are not reordered around it"
}