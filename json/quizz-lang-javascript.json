{
	"JS": "SECTION",
	"JS - ECMAScript": "JavaScript was invented by Brendan Eich in 1995, and became an ECMA standard in 1997.",
	"JS - ECMAScript - TC39": "Technical Committee 39 (TC39). This group includes representatives from all the major browser vendors and JavaScript experts.",
	"JS - ECMAScript - ES1": "1997",
	"JS - ECMAScript - ES2": "1998",
	"JS - ECMAScript - ES3": "1999",
	"JS - ECMAScript - ES4": "Never released",
	"JS - ECMAScript - ES5": "2009. Added 'strict mode'. Added JSON support. Added String.trim(). Added Array.isArray(). Added Array iteration methods. Allows trailing commas for object literals",
	"JS - ECMAScript - ES6": "2015. Added let and const. Added default parameter values. Added Array.find(). Added Array.findIndex(). ECMAScript 6 introduced the let and const keywords. These keywords can be used in place of the var keyword.",
	"JS - ECMAScript - ES7 - ES2016": "2016. Added exponential operator (**). Added Array.includes()",
	"JS - ECMAScript - ES8 - ES2017": "2017. Added string padding. Added Object.entries(). Added Object.values(). Added async functions. Added shared memory. Allows trailing commas for function parameters",
	"JS - ECMAScript - ES9 - ES2018": "2018. Added rest / spread properties. Added asynchronous iteration. Added Promise.finally(). Additions to RegExp",
	"JS - ECMAScript - ES10 - ES2019": "2019. String.trimStart(). String.trimEnd(). Array.flat(). Object.fromEntries. Optional catch binding",
	"JS - ECMAScript - ES11 - ES2020": "2020. The Nullish Coalescing Operator (??)",
	"JS - ECMAScript - ES12 - ES2021": "2021. Promise.any(). String replaceAll(). Numeric Separators (_)",
	"JS - ECMAScript - ES13 - ES2022": "2022. Array at(). String at(). RegExp /d. Object.hasOwn(). error.cause. await import. Class field declarations. Private methods and fields",
	"JS - ECMAScript - ES14 - ES2023": "2023. Array findLast(). Array findLastIndex(). Array toReversed(). Array toSorted(). Array toSpliced(). Array with(). #! (Shebang)",
	"JS - ECMAScript - ES15 - ES2024": "2024. Object.groupBy(). Map.groupBy(). Temporal.PlainDate(). Temporal.PlainTime(). Temporal.PlainMonthDay(). Temporal.PlainYearMonth()",

	"Data": "SECTION",
	"Data - Variables - DataTypes - Inmutable - Primitive": "In JavaScript, primitive data types represent the simplest and most basic building blocks of data. They are fundamental values that are immutable, meaning they cannot be altered once they are created. Primitive types are stored directly in memory and have a fixed size. These are stored directly in the stack, which is a simple memory allocation delivering quick access.",
	"Data - Variables - DataTypes - Inmutable - Primitive - Undefined": "A variable that has been declared but not yet assigned a value automatically gets the value undefined.",
	"Data - Variables - DataTypes - Inmutable - Primitive - Null": "Null: null represents the intentional absence of any object value. It is intentionally empty. It is distinct from undefined.",
	"Data - Variables - DataTypes - Inmutable - Primitive - String": "String: Strings represent text and are enclosed in either single (‘’) or double quotes. They are used for storing and manipulating textual data. Strings are immutable, which means that any operation on a string creates a new string rather than modifying the original one.",
	"Data - Variables - DataTypes - Inmutable - Primitive - String - indexOf": "console.log(m[m.length - 1]); ",
	"Data - Variables - DataTypes - Inmutable - Primitive - String - []": "console.log(m[m.length - 1]); ",
	"Data - Variables - DataTypes - Inmutable - Primitive - String - at()": "The at() method lets you simplify the last character access as follows: console.log(m.at(-1)); ",
	"Data - Variables - DataTypes - Inmutable - Primitive - String - includes": "The includes() method checks the existence of a specific character set in a string:",
	"Data - Variables - DataTypes - Inmutable - Primitive - String - startsWith": "The startsWith() method checks the start of a string",
	"Data - Variables - DataTypes - Inmutable - Primitive - String - endsWith": "The endsWith() method checks the end of a string",
	"Data - Variables - DataTypes - Inmutable - Primitive - String - union": "type Fruit = 'apple' | 'orange'; const fruit: Fruit = 'apple'",
	"Data - Variables - DataTypes - Inmutable - Primitive - String - repeat - ES6": "console.log('+-'.repeat(10));",
	"Data - Variables - DataTypes - Inmutable - Primitive - String - trim": "console.log(txt.trim());",
	"Data - Variables - DataTypes - Inmutable - Primitive - String - trimStart": "console.log(txt.trimStart());",
	"Data - Variables - DataTypes - Inmutable - Primitive - String - trimEnd": "console.log(txt.trimEnd());",
	"Data - Variables - DataTypes - Inmutable - Primitive - String - raw": "let path = String.raw'C:/Projects/MyProject1/myproject.config.json';",
	"Data - Variables - DataTypes - Inmutable - Primitive - String - padStart": ".toString().padStart(2, '0');",
	"Data - Variables - DataTypes - Inmutable - Primitive - String - padEnd": ".toString().padEnd(2, '0');",
	"Data - Variables - DataTypes - Inmutable - Primitive - String - replace": "console.log(msg.replace('JavaScript', 'Js'));",
	"Data - Variables - DataTypes - Inmutable - Primitive - String - replaceAll - ES21": "console.log(msg.replaceAll('JavaScript', 'Js'));",
	"Data - Variables - DataTypes - Inmutable - Primitive - String - matchAll": "let matches = msg.matchAll(/\b(([A-Z]{2})([0-9]{2}))\b/g);  ",
	"Data - Variables - DataTypes - Inmutable - Primitive - String - template literals": "const greeting = `Hello, ${name}!`;",
	"Data - Variables - DataTypes - Inmutable - Primitive - String - toWellFormed": "Unicode strings are crucial for representing the diverse characters and symbols of various languages. ES15 introduces the toWellFormed() method, which ensures that Unicode strings are handled correctly across different environments.",
	"Data - Variables - DataTypes - Inmutable - Primitive - String - detent": "It would clean up indentation",
	"Data - Variables - DataTypes - Inmutable - Primitive - Number": "Number: Numbers represent numeric values, both integers and floating-point numbers. They are used for performing mathematical operations. Numbers in JavaScript follow the IEEE 754 standard for floating-point arithmetic. Like strings, numbers are also immutable.",
	"Data - Variables - DataTypes - Inmutable - Primitive - Number - Number.EPSILON": "Number.EPSILON returns the difference between the smallest floating point number greater than 1 and 1. Number.EPSILON has the value of 2.220446049250313e-16.",
	"Data - Variables - DataTypes - Inmutable - Primitive - BigInt - ES11": "ES2020 introduced the BigInt inbuilt object to solve these issues in the default number format. This object lets you create large integers by sending integer values as a string let a = BigInt('36028797018963975');",
	"Data - Variables - DataTypes - Inmutable - Primitive - Boolean": "Boolean: Booleans have only two possible values: true and false. They are used to represent logical values and are essential for making decisions in your code. Booleans are immutable and serve as the basis for conditional statements and boolean algebra.",
	"Data - Variables - DataTypes - Inmutable - Primitive - Symbol": "Symbol (ES6): Symbols are unique and immutable values introduced in ECMAScript 2015 (ES6). They are often used as property keys in objects to avoid naming conflicts.",
	"Data - Variables - DataTypes - Inmutable - Primitive - Precision - Integer": "Integer Precision: JavaScript integers max out at 15 digits without decimals or exponents.",
	"Data - Variables - DataTypes - Inmutable - Primitive - Precision - Floating-Point": "Floating-Point Precision: While offering up to 17 decimal digits, floating-point calculations in JavaScript aren’t always 100% accurate — something to keep in mind!",
	"Data - Variables - DataTypes - Inmutable - Primitive - Precision - Bitwise": "Bitwise Operations: Operating directly on binary representations, these are lightning-fast low-level operations. Their speed comes at the cost of readability — often making them unsuitable for many scenarios.",
	"Data - Variables - DataTypes - Inmutable - Primitive - Precision - Bitwise - Integers": "Keep in mind that bitwise operators work exclusively with integers. If you use them with non-integer values, JavaScript automatically converts them to integers before proceeding.",
	"Data - Variables - DataTypes - Inmutable - Primitive - Precision - Bitwise - AND (&)": "This operator combines corresponding bits from two binary numbers. Both bits need to be 1 for the result to be 1.",
	"Data - Variables - DataTypes - Inmutable - Primitive - Precision - Bitwise - OR (|)": "Unlike the AND operator, | only needs one of the corresponding bits to be 1 for the result to be 1.",
	"Data - Variables - DataTypes - Inmutable - Primitive - Precision - Bitwise - XOR (^)": "The XOR operator returns 1 only when one of the corresponding bits is 1. If both bits are the same (either both 0 or both 1), the result is 0.",
	"Data - Variables - DataTypes - Inmutable - Primitive - Precision - Bitwise - NOT (~)": "The ~ operator flips the bits—1s become 0s, and 0s become 1s. Essentially, it calculates the two's complement of the number.",
	"Data - Variables - DataTypes - Inmutable - Primitive - Precision - Bitwise - LeftSwift (<<)": "This operator shifts the bits of a number to the left by a specified number of positions. The vacant positions on the right get filled with 0s.",
	"Data - Variables - DataTypes - Inmutable - Primitive - Precision - Bitwise - SignedRightSwift (>>)": "This operator shifts the bits to the right. The now-empty bits on the left are filled with the sign bit (the leftmost bit). This “sign-propagation” preserves the sign of the original number, hence the name “signed right shift.”",
	"Data - Variables - DataTypes - Inmutable - Primitive - Precision - Bitwise - UnsignedRightSwift (>>>)": "Similar to the signed right shift, this operator also shifts bits to the right. However, it always fills the vacant leftmost bits with 0s, irrespective of the original number’s sign. This means the result is always non-negative.",
	"Data - Variables - DataTypes - Inmutable - Object - Object.freeze()": "Object.freeze(). This handy method makes your object immutable, preventing any further changes. this only freezes the top-level properties.",
	"Data - Variables - DataTypes - Inmutable - Object - Object.seal()": "The Object.seal() static method seals an object. Sealing an object prevents extensions and makes existing properties non-configurable.",
	"Data - Variables - DataTypes - Inmutable - Object - Object.preventExtensions()": "An object is extensible if new properties can be added to it. Object.preventExtensions() stops new properties from being added to an object and prevents the object's prototype from being re-assigned, keeping it as it is from that point onward.",
	"Data - Variables - DataTypes - Inmutable - Object - constant": "By combining writable: false and configurable: false we can essentially create a constant object property. A read-only property that cannot be changed, redefined, or deleted.",
	"Data - Variables - DataTypes - Inmutable - Object - Record": "Records are like objects but are immutable and value-compared. Records are created using an object-like literal syntax prefixed with #. const record = #{ key1: 'value1', key2: 'value2' };",
	"Data - Variables - DataTypes - Inmutable - Object - Record - deep": "With Records, deep equality is built in — no need for extra libraries or workarounds.",
	"Data - Variables - DataTypes - Inmutable - Object - Record - types": "Keys must be strings, and values must be primitives (or other Records and Tuples).",
	"Data - Variables - DataTypes - Inmutable - Object - Record - fromObject": "Object(#{ x: 1, y: 4 });",
	"Data - Variables - DataTypes - Inmutable - Object - Record - toObject": "Record({ x: 1, y: 4 });",
	"Data - Variables - DataTypes - Inmutable - Object - Record - usages - CompoundKeys": "Maps with Compound Keys",
	"Data - Variables - DataTypes - Inmutable - Object - Tuple": "Tuples are like arrays but follow the same immutability and value-comparison principles. Tuples are created using an array-like literal syntax prefixed with #. const tuple = #['value1', 'value2'];",
	"Data - Variables - DataTypes - Inmutable - Object - Tuple - deep": "With Tuples, deep equality is built in — no need for extra libraries or workarounds.",
	"Data - Variables - DataTypes - Inmutable - Object - Tuple - types": "Only primitives allowed — no functions or symbols.",
	"Data - Variables - DataTypes - Inmutable - Object - Tuple - fromObject": "Tuple.from(['a', 'b']);",
	"Data - Variables - DataTypes - Inmutable - Object - Tuple - toObject": "Array.from(#['a', 'b']);",
  "Data - Variables - DataTypes - Inmutable - libs": "But it’s better to use an optimized library which provides a set of immutable data structures.",
  "Data - Variables - DataTypes - Inmutable - libs - Immutability Helper": "This is a good library when it’s comes to mutating a data copy without changing the source.",
  "Data - Variables - DataTypes - Inmutable - libs - Immutable.js": "provides a lot of persistent immutable data structures, including: List, Stack, Map, OrderedMap, Set, OrderedSet, and Record.",
  "Data - Variables - DataTypes - Inmutable - libs - Seamless-immutable:": "A library for immutable JavaScript data structures that are backward-compatible with normal arrays and objects.",
  "Data - Variables - DataTypes - Inmutable - libs - React-copy-write": "An immutable React state management library with a simple mutable API, memoized selectors, and structural sharing.",
	"Data - Variables - DataTypes - Reference": "Reference types store a reference to the object in the stack, while the object itself lives in the heap, a more complex but expansive memory structure.",
	"Data - Variables - DataTypes - Reference - Object": "",
	"Data - Variables - DataTypes - Reference - Object - Prototype": "In JavaScript, every object has an internal property called [[Prototype]]. This property is a reference to another object, which is referred to as the prototype. The prototype acts as a template from which objects inherit properties and methods.",
	"Data - Variables - DataTypes - Reference - Object - Prototype - Object.getPrototypeOf": "JavaScript also provides ways to access and manipulate an object’s prototype. The __proto__ property is a non-standard (but widely supported) way to access an object’s prototype, while Object.getPrototypeOf is the standardized way.",
	"Data - Variables - DataTypes - Reference - Object - Prototype - ES6": "For the majority of the project using modern JavaScript and TypeScript, it is quite rare to directly work with prototypes since ES6 brought class for coding.",
	"Data - Variables - DataTypes - Reference - Object - Prototype - OOP": "JavaScript uses a prototype-based approach to object-oriented programming. We can think of prototype as a 'bag of properties and functions'. It can be at both the class level and the object level. Prototype: Every function in JavaScript has a prototype property, which is an object that contains shared methods and properties. When an object is created, it inherits properties from its constructor's prototype.",
	"Data - Variables - DataTypes - Reference - Object - Prototype - search": "Whenever you attempt to access a property, or to call for a method on an object, first of all, JavaScript searches in the object itself. In case it does not find the property there, it then considers the object’s prototype. This process goes up the prototype chain until the property is located or the highest prototype which is null is encountered.",
	"Data - Variables - DataTypes - Reference - Object - Prototype - super": "Every object in JavaScript ultimately derives from Object.prototype, which is the root of the prototype chain. If a property or method isn’t found on an object’s prototype, JavaScript keeps moving up the chain until it reaches Object.prototype, which is the final fallback. alice → Person.prototype → Object.prototype → null",
	"Data - Variables - DataTypes - Reference - Object - Prototype - inheritance": "JavaScript uses prototypes to implement inheritance. Unlike classical inheritance, where classes inherit from other classes, JavaScript objects inherit directly from other objects. This is sometimes referred to as “prototypal inheritance”.",
	"Data - Variables - DataTypes - Reference - Object - Prototype - shadowing": "When a property or method is added to an object directly, it shadows the property or method of the same name in the prototype chain.",
	"Data - Variables - DataTypes - Reference - Object - Prototype - overload": "These overloaded functions are a nightmare to test, debug, and modify.",
	"Data - Variables - DataTypes - Reference - Object - Prototype - __proto__": "This is a reference to the object's prototype. When accessing a property on an object, JavaScript looks up the chain __proto__ until it finds the property or reaches the end of the chain (null).",
	"Data - Variables - DataTypes - Reference - Object - Prototype - pollution": "In JavaScript, all objects inherit properties and methods from `Object.prototype`, which means that if a malicious actor modifies this prototype, it could affect all objects in your application. This is the basis of prototype pollution.",
	"Data - Variables - DataTypes - Reference - Object - create - literal": "const person = { firstName: 'testFirstName', lastName: 'testLastName' };",
	"Data - Variables - DataTypes - Reference - Object - create - new": "const person = new Object(); person.firstName = 'testFirstName';",
	"Data - Variables - DataTypes - Reference - Object - create - Object.create()": "const employee = Object.create(orgObject, { name: { value: 'EmployeeOne' } });",
	"Data - Variables - DataTypes - Reference - Object - create - Object.assign()": "const employee = Object.assign({}, orgObject, carObject);",
	"Data - Variables - DataTypes - Reference - Object - create - entries": "`Object.entries()` converts an object to an array of key-value pairs, which is useful for looping through properties.",
	"Data - Variables - DataTypes - Reference - Object - create - fromEntries": "Object.fromEntries transforms a list of key-value pairs into an object. It's especially useful when combined with Object.entries for modifying object properties. const person = { name: 'John', age: 30 }; Object.entries(person)",
	"Data - Variables - DataTypes - Reference - Object - reflection - Reflect": "The Reflect namespace object contains static methods for invoking interceptable JavaScript object internal methods. The methods are the same as those of proxy handlers.",
	"Data - Variables - DataTypes - Reference - Object - reflection - Proxy - ES6": "It helps us override the default internal operations of JavaScript objects, like property setting/getting, by creating a proxy object. These operations include: Property lookup Assignment Enumeration Function invocation",
	"Data - Variables - DataTypes - Reference - Object - reflection - Proxy - create": "const proxy = new Proxy(target, handler);",
	"Data - Variables - DataTypes - Reference - Object - reflection - Proxy - create - target": "Target: The object you’re wrapping.",
	"Data - Variables - DataTypes - Reference - Object - reflection - Proxy - create - handler": "Handler: An object that defines “traps” — functions that intercept operations on the target.",
	"Data - Variables - DataTypes - Reference - Object - reflection - Proxy - apps - validations": ".",
	"Data - Variables - DataTypes - Reference - Object - reflection - Proxy - apps - notifications": ".",
	"Data - Variables - DataTypes - Reference - Object - reflection - Proxy - apps - data binding": ".",
	"Data - Variables - DataTypes - Reference - Object - properties - create - Object.defineProperty()": "We can use the Object.defineProperty() static method to define a new property on an object or modify an existing property on an object (if it’s configurable!). However, you generally wouldn’t use this manual approach unless you wanted to modify one of the descriptor characteristics from its normal behaviour.",
	"Data - Variables - DataTypes - Reference - Object - properties - PropertyDescriptor": "Object.getOwnPropertyDescriptor(series, 'name'); We’re using Object.getOwnPropertyDescriptor() to retrieve the data descriptor of the name property in the seriesobject. The output provides details about the configuration — its value, writability, enumerability, and configurability.",
	"Data - Variables - DataTypes - Reference - Object - properties - PropertyDescriptor - value": "",
	"Data - Variables - DataTypes - Reference - Object - properties - PropertyDescriptor - writable": "The ability for you to change the value of a property is controlled by writable. If writable is set to true, the property's value can be modified; if it's false, attempts to modify the property's value will be ignored.",
	"Data - Variables - DataTypes - Reference - Object - properties - PropertyDescriptor - enumerable": "The enumerable attribute controls whether a property will be included when the object’s properties are iterated through, such as in a for...in loop. By default, all user-defined properties are enumerable, but setting enumerable to falsehides the property during enumeration.",
	"Data - Variables - DataTypes - Reference - Object - properties - PropertyDescriptor - configurable": "The configurable attribute determines whether the property's descriptor definition can be modified and whether the property can be deleted.",
	"Data - Variables - DataTypes - Reference - Object - BuiltIn - web - URL - ES5": "const endpoint = 'https://api.example.com' + '/users/' + userId + '/details';",
	"Data - Variables - DataTypes - Reference - Object - BuiltIn - web - URL - ES6": "const endpoint = `${baseUrl}/users/${userId}/details`;",
	"Data - Variables - DataTypes - Reference - Object - BuiltIn - web - URL - Constructor": "const url = new URL(`/users/${userId}/details`, baseUrl);",
	"Data - Variables - DataTypes - Reference - Object - BuiltIn - web - URL - Constructor - params": "url.searchParams.append('type', 'EDIT');",
	"Data - Variables - DataTypes - Reference - Object - BuiltIn - i18n - Time - Date": "Date: The Date object represents date and time information. It provides methods for working with dates, times, and time zones. The Date object is used for tasks like date calculations and formatting.",
	"Data - Variables - DataTypes - Reference - Object - BuiltIn - i18n - Time - TemporalAPI - ES2024": "The Temporal API aims to provide a powerful and flexible toolkit for handling dates and times, making it easier for developers to manage various time-related tasks. https://javascript.plainenglish.io/exploring-the-new-javascript-feature-the-temporal-api-2c7318f047e7",
	"Data - Variables - DataTypes - Reference - Object - BuiltIn - i18n - Intl": "JavaScript offers inbuilt internationalization features via the Intl namespace object for developers to build international apps without using third-party packages or writing their own locale-specific implementations.",
	"Data - Variables - DataTypes - Reference - Collections": "JS variables are just references to the actual object in memory.",
	"Data - Variables - DataTypes - Reference - Collections - Array": "",
	"Data - Variables - DataTypes - Reference - Collections - Array - Creation - from": "Array.from can be used to create arrays from array-like objects (e.g., NodeList) or for initialising arrays with values, providing versatility in array creation. const initializedArray = Array.from({ length: 5 }, (_, index) => index * 2);",
	"Data - Variables - DataTypes - Reference - Collections - Array - Creation - concat": "",
	"Data - Variables - DataTypes - Reference - Collections - Array - Creation - Immutable - ES2024": "const immutableArray = ImmutableArray.from([1, 2, 3]);",	
	"Data - Variables - DataTypes - Reference - Collections - Array - Creation - Typed - ES2024": "ES2024 brings significant improvements to typed arrays, which are useful for handling binary data in a performant manner. These enhancements include new methods and better integration with other JavaScript features.",	
	"Data - Variables - DataTypes - Reference - Collections - Array - Accessing - []": "",
	"Data - Variables - DataTypes - Reference - Collections - Array - Accessing - at - ES13": "access by position",
	"Data - Variables - DataTypes - Reference - Collections - Array - Update - splice": "The splice() method changes the contents of an array by removing or replacing existing elements and/or adding new elements in place.",
	"Data - Variables - DataTypes - Reference - Collections - Array - Update - flat": "The .flat() method creates a new array with all sub-array elements concatenated into it recursively up to the specified depth, simplifying array flattening.",
	"Data - Variables - DataTypes - Reference - Collections - Array - Update - filter": "The filter() method creates a new array with all elements that pass the test implemented by the provided function.",
	"Data - Variables - DataTypes - Reference - Collections - Array - Update - group": "",
	"Data - Variables - DataTypes - Reference - Collections - Array - Update - groupBy": "",
	"Data - Variables - DataTypes - Reference - Collections - Array - Update - groupByToMap": "",
	"Data - Variables - DataTypes - Reference - Collections - Array - Destructuring": "Destructuring was introduced in ES6. It’s a JavaScript feature that allows us to extract multiple pieces of data from an array or object and assign them to their own variables. const { firstName, lastName, city } = person;.",
	"Data - Variables - DataTypes - Reference - Collections - Array - Destructuring - alias": "Destructuring allows you to unpack values from arrays or properties from objects into distinct variables. Aliases let you rename variables during this process, which is especially useful when dealing with data from external sources like APIs. const { first_name: firstName } = value;",
	"Data - Variables - DataTypes - Reference - Collections - Array - Destructuring - usage - swap": "[a, b] = [b, a];",
	"Data - Variables - DataTypes - Reference - Collections - Array - Destructuring - usage - return": "const [a, b, c] = getNumbers();",
	"Data - Variables - DataTypes - Reference - Collections - Array - Destructuring - usage - object": "const { name, age } = personObject;",
	"Data - Variables - DataTypes - Reference - Collections - Array - Spread": "The Spread operator is a key feature in JavaScript that enables an iterable to expand wherever zero or more arguments are required. Its primary use case is with arrays, especially when expecting multiple values. This operator provides the convenience of easily extracting a list of parameters from an array, making our code more versatile and readable.",	
	"Data - Variables - DataTypes - Reference - Collections - Array - Spread - usage - merge": "const mergedArr = [...arr1, ...arr2];",	
	"Data - Variables - DataTypes - Reference - Collections - Array - Spread - usage - copy": "const copiedPerson = { ...person };",	
	"Data - Variables - DataTypes - Reference - Collections - ArrayBuffer": "The ArrayBuffer object lets you define a generic raw byte buffer based on a given byte length. allocate a fixed-size memory space that you can access through wrappers",
	"Data - Variables - DataTypes - Reference - Collections - ArrayBuffer - create": "We can’t directly store binary data on it, so we should create a typed array referring to the array buffer. const ab = new ArrayBuffer(2);",
	"Data - Variables - DataTypes - Reference - Collections - ArrayBuffer - create - resize": "resize(), the buffer can grow or shrink as needed within the maximum size",
	"Data - Variables - DataTypes - Reference - Collections - ArrayBuffer - transfer": "The ECMAScript 2024 update introduces direct transfer methods for ArrayBuffers, making it easier to move large data buffers across different contexts. Previously, transferring ArrayBuffers relied on structured cloning, a complex process that could be inefficient for large data.",
	"Data - Variables - DataTypes - Reference - Collections - ArrayBuffer - transfer - transfer": "transfer(newLength?): Transfers the data from one buffer to a new one, optionally resizing to a specified new length.",
	"Data - Variables - DataTypes - Reference - Collections - ArrayBuffer - transfer - transferToFixedLength": "transferToFixedLength(newLength?): Similar to transfer, but the new buffer is fixed-length, which releases memory reserved for possible future resizing.",
	"Data - Variables - DataTypes - Reference - Collections - ArrayBuffer - transfer - structuredClone": "The structuredClone() function now supports ArrayBuffer transfers, enabling more efficient memory sharing across worker threads or different execution contexts.",
	"Data - Variables - DataTypes - Reference - Collections - ArrayBuffer - wrappers - TypedArrays": "These allow access to the ArrayBuffer through fixed-length numeric views",
	"Data - Variables - DataTypes - Reference - Collections - ArrayBuffer - wrappers - TypedArrays - Uint8Array": "Uint8Array object to access the array buffer. const arr = new Uint8Array(ab);",
	"Data - Variables - DataTypes - Reference - Collections - ArrayBuffer - wrappers - TypedArrays - Uint16Array": "Uint8Array object to access the array buffer. const arr = new Uint16Array(ab)",
	"Data - Variables - DataTypes - Reference - Collections - ArrayBuffer - wrappers - TypedArrays - Float32Array": "32-bit floating-point numbers",
	"Data - Variables - DataTypes - Reference - Collections - ArrayBuffer - wrappers - DataView": "JavaScript offers the DataView object to process array buffers using multiple number types (i.e., Uint8, Int64, …) without worrying about platform endianness.",
	"Data - Variables - DataTypes - Reference - Collections - Set - ES6": "The ES6 Set structure is like an array, but it doesn’t allow duplicate values; it ensures all items are unique.",
	"Data - Variables - DataTypes - Reference - Collections - Set - intersection": "mapaches1.intersection(mapaches2)",
	"Data - Variables - DataTypes - Reference - Collections - Set - union": "mapaches1.union(mapaches2)",
	"Data - Variables - DataTypes - Reference - Collections - Set - difference": "mapaches1.difference(mapaches2)",
	"Data - Variables - DataTypes - Reference - Collections - Set - symmetricDifference": "mapaches1.symmetricDifference(mapaches2)",
	"Data - Variables - DataTypes - Reference - Collections - Set - isSubsetOf": "newMapaches.isSubsetOf(allMapaches)",
	"Data - Variables - DataTypes - Reference - Collections - Set - isSupersetOf": "allMapaches.isSupersetOf(newMapaches)",
	"Data - Variables - DataTypes - Reference - Collections - Set - isDisjointFrom": "allMapaches.isDisjointFrom(mapaches3)",
	"Data - Variables - DataTypes - Reference - Collections - Map": "let map = new Map(); https://medium.com/@jacobmacinnis/javascript-map-vs-javascript-object-vs-traditional-hash-tables-83e5c3068fbd",
	"Data - Variables - DataTypes - Reference - Collections - Map vs Object - NonStringKey": "Flexible Key Types: One of the most significant advantages of Map over objects is its flexibility with key types. In an object, keys must be strings or symbols. In a Map, keys can be anything – from primitive values to complex objects. https://javascript.plainenglish.io/are-you-still-using-objects-discover-the-game-changing-power-of-map-in-js-ts-3600a6c28b60",
	"Data - Variables - DataTypes - Reference - Collections - Map vs Object - Order": "Maintains Order: Maps maintain the order of their entries, which means the sequence in which items are added is preserved. This is particularly useful when you need a predictable iteration order.",
	"Data - Variables - DataTypes - Reference - Collections - Map vs Object - Performance": "Better Performance for Frequent Additions/Removals: Maps are optimized for frequent additions and removals of key-value pairs. Objects, on the other hand, can suffer performance issues when properties are added or removed frequently, especially when dealing with a large number of entries.",
	"Data - Variables - DataTypes - Reference - Collections - Map vs Object - Size": "Size Property: Maps have a size property that provides the number of elements in the map. This is more efficient than calculating the size of an object using Object.keys(obj).length, which has to traverse the entire key set.",
	"Data - Variables - DataTypes - Reference - Collections - Map vs Object - Methods": "Built-In Methods: Maps come with built-in methods like set, get, has, delete, and clear which make manipulating key-value pairs straightforward and intuitive.",
	"Data - Variables - DataTypes - Reference - Collections - Map vs Object - overhead": "Maps have a bit more overhead compared to plain objects due to their internal structure and additional features. For scenarios where performance is critical and the collection is small and simple, this overhead might be unnecessary.",
	"Data - Variables - DataTypes - Reference - Collections - Map vs Object - JSON": "Unlike plain objects, Maps cannot be directly serialized to JSON. If you need to serialize your data, you’ll need to convert the Map to an object or an array first.",
	"Data - Variables - DataTypes - Reference - Functions": "Functions: Functions are first-class citizens in JavaScript. They are objects that can be invoked and passed around as arguments to other functions. Functions are used for encapsulating reusable code and implementing logic in JavaScript programs.",
	"Data - Variables - DataTypes - Operations - Inference - typeof": "The typeof operator returns the data type of a JavaScript variable.",
	"Data - Variables - DataTypes - Operations - Coercion - Implicit": "JavaScript is notorious for its implicit type coercion, where it automatically converts one data type to another in certain situations. While this can be helpful at times, it can also lead to some truly shocking and unexpected results.",
	"Data - Variables - DataTypes - Operations - Coercion - Conversion - Floating to Integer - ~~": "The ~~ operator quickly converts a floating-point number to an integer by truncating the decimal portion.",
	"Data - Variables - DataTypes - Operations - Coercion - Conversion - Strings to Numbers": ".",
	"Data - Variables - DataTypes - Operations - Coercion - Conversion - Numbers to Strings": ".",
	"Data - Variables - DataTypes - Operations - Coercion - Conversion - Dates to Numbers": ".",
	"Data - Variables - DataTypes - Operations - Coercion - Conversion - Numbers to Dates": ".",
	"Data - Variables - DataTypes - Operations - Coercion - Conversion - Booleans to Numbers": ".",
	"Data - Variables - DataTypes - Operations - Coercion - Conversion - Numbers to Booleans": ".",
	"Data - Variables - DataTypes - Operations - Coercion - Conversion - StringToJSON": "JSON.parse(...)",
	"Data - Variables - DataTypes - Operations - Coercion - Conversion - JSONToString - stringify": "JSON.stringify(person) https://blog.stackademic.com/the-json-stringify-you-dont-know-about-e0d21de6f4b3",
	"Data - Variables - DataTypes - Operations - Coercion - Conversion - JSONToString - stringify - functions": "Not Friendly to Functions. If an object’s property is a function, this property will be lost during serialization.",
	"Data - Variables - DataTypes - Operations - Coercion - Conversion - JSONToString - stringify - undefined": "If an object’s property value is undefined, it will be lost after conversion.",
	"Data - Variables - DataTypes - Operations - Coercion - Conversion - JSONToString - stringify - regex": "If an object’s property is a regular expression, it will turn into an empty Object after conversion.",
	"Data - Variables - DataTypes - Operations - Comparing - Value Comparison": "Primitive Types: Value Comparison. Primitive types are compared based on their values. When you compare two primitive values, you’re checking if their actual content is the same.",
	"Data - Variables - DataTypes - Operations - Comparing - Value Comparison - ==": "Loose Equality (==): Equality with Type coercion, meaning it converts the values to a common type before comparison. This can lead to unexpected results. console.log(1 == '1'); // true (because '1' is converted to 1).",
	"Data - Variables - DataTypes - Operations - Comparing - Value Comparison - ===": "Strict Equality (===): Equality without type coercion, meaning the values must be of the same type and value to be considered equal. console.log(1 === '1'); // false (different types) While === generally provides more predictable results than ==, it still has limitations, particularly when dealing with special values like NaN and differentiating between +0 and -0..",
	"Data - Variables - DataTypes - Operations - Comparing - Value Comparison - === - Limitations - NaN": "Handling of NaN: In JavaScript, NaN (Not-a-Number) is a special value that is not equal to itself when using the === operator. However, logically, comparing NaN to NaN should return true, which Object.is() corrects.",
	"Data - Variables - DataTypes - Operations - Comparing - Value Comparison - === - Limitations - Zero": "Differentiating Positive and Negative Zero: JavaScript treats +0 and -0 as equal with ===, but in some mathematical contexts, they represent different values. Object.is() accurately reflects this difference.",
	"Data - Variables - DataTypes - Operations - Comparing - Value Comparison - Object.is()": "The Object.is() method was introduced in ECMAScript 2015 (ES6) as a way to determine whether two values are exactly the same. It offers more precise comparisons in certain scenarios where the existing == (loose equality) and === (strict equality) operators fall short. Object.is(value1, value2); This method returns true if the two values are considered the same, and false otherwise. The Object.is() method fills important gaps left by the === operator, offering a more intuitive way to compare values in JavaScript. Whether you’re dealing with NaN, differentiating between positive and negative zero, or ensuring data integrity in complex applications, Object.is() can be the tool you need. Understanding when and how to use Object.is() will make your code more reliable and robust, helping you avoid common pitfalls associated with value comparisons in JavaScript.",
	"Data - Variables - DataTypes - Operations - Comparing - Value Comparison - Object.is() - Limitations - Deep": "Not Suitable for Deep Comparisons: Just like === and ==, the Object.is() method is not designed for deep comparisons of objects or arrays. It only checks if the two references point to the same object in memory, rather than comparing the contents of the objects.",
	"Data - Variables - DataTypes - Operations - Comparing - Value Comparison - Object.is() - Limitations - Limited": "Limited Use Cases: While Object.is() excels in certain scenarios, such as distinguishing between NaN and differentiating between +0 and -0, it is not a replacement for === in general comparisons.",
	"Data - Variables - DataTypes - Operations - Comparing - Reference Comparison": "Reference Types: Reference Comparison. Reference types, on the other hand, are compared based on their references to memory locations. When you compare two reference type variables, you’re checking if they point to the same memory address, not whether the objects they reference have the same content:.",
	"Data - Variables - DataTypes - Operations - Equalying - Shallow": "Shallow equality compares the references themselves, while deep equality compares the content of nested objects or arrays within reference types. For shallow equality, you can use the === operator or its counterpart, the Object.is() method, which behaves similarly but handles edge cases differently (e.g., handling NaN and -0 differently).",
	"Data - Variables - DataTypes - Operations - Equalying - Deep": "Deep equality requires custom comparison logic or libraries like Lodash’s isEqual method, which recursively checks the content of nested objects or arrays.",
	"Data - Variables - DataTypes - Operations - Copying - Shallow": "To create an independent copy of an object (copy by value), a shallow copy, which means they copy the top-level properties of the object but not nested objects. It’s essential to note that a shallow copy does not create copies of nested objects within the original object. Shallow Copy means the original data is unaffected by changes to the copied data for fundamental types. For reference types, a shallow copy might duplicate the first layer of an object, protecting the original data when modifying shallow properties in the copied object. https://javascript.plainenglish.io/is-the-spread-operator-a-deep-copy-261c109fb708",
	"Data - Variables - DataTypes - Operations - Copying - Shallow - with Object.assign()": "",
	"Data - Variables - DataTypes - Operations - Copying - Shallow - with (...)": "Spread operator",
	"Data - Variables - DataTypes - Operations - Copying - Deep": "To create deep copies, which include all nested objects, you would need to implement a custom copying function or use a library like Lodash. Deep Copy represents limitless hierarchical duplication. Changes to either fundamental or reference data types in the deep copy do not affect the original.",
	"Data - Variables - DataTypes - Operations - Clone - Shallow": "Object.create(), Spread Operator {...}",
	"Data - Variables - DataTypes - Operations - Clone - Deep - structuredClone": "const clonedObj = structuredClone(obj);",
	"Data - Variables - DataTypes - Operations - Clone - Deep - parse": "JSON.parse(JSON.stringify()), lodash.deepClone",
	"Data - Variables - DataTypes - Operations - Passing - by Value": "Passing Primitive Values: Passing by Value. When you pass a primitive value to a function, you are essentially passing a copy of that value. This is known as passing by value. Any changes made to the parameter within the function do not affect the original variable outside the function.",
	"Data - Variables - DataTypes - Operations - Passing - by Reference": "Passing Reference Values: Passing by Reference. When you pass a reference type (such as an object or array) to a function, you are passing a reference to the actual data. This is known as passing by reference. Any modifications made to the parameter within the function directly affect the original variable outside the function. Let’s see this in action:",
	"Data - Variables - DataTypes - Operations - Chaining - <ES11": "user && user.address && user.address.city",
	"Data - Variables - DataTypes - Operations - Chaining - ES11": "user?.address?.city Optional chaining (?.) Optional Chaining allows you to read the value of a property located deep within a chain of connected objects without having to check that each reference in the chain is valid.",
	"Data - Variables - DataTypes - Operations - Chaining - Nullish Coalescing": "user.name ?? 'Guest'",
	"Data - Variables - Declaration - Typing - var - preES6": "function scope.",
	"Data - Variables - Declaration - Typing - var - issues - scope": "Data - Variables declared with var are scoped to the function in which they are declared.",
	"Data - Variables - Declaration - Typing - var - issues - hoisting": "declarations are hoisted to the top of their scope, meaning they are accessible before they are declared, which can lead to unexpected behavior.",
	"Data - Variables - Declaration - Typing - var - issues - redeclared": "Data - Variables declared with var can be re-declared within the same scope, which can lead to confusion and errors.",
	"Data - Variables - Declaration - Typing - var - issues - loops": "",
	"Data - Variables - Declaration - Typing - let": "ES6. block scope.",
	"Data - Variables - Declaration - Typing - let - issues - scope": "Data - Variables declared with let are scoped to the block in which they are declared.",
	"Data - Variables - Declaration - Typing - let - issues - hoisting": "Although let declarations are hoisted to the top of their block, they are not initialized, so accessing them before declaration results in a ReferenceError.",
	"Data - Variables - Declaration - Typing - let - issues - redeclared": "Data - Variables declared with let cannot be re-declared within the same scope, which helps avoid errors.",
	"Data - Variables - Declaration - Typing - const": "ES6. Immutability. value will not change.",
	"Data - Variables - Declaration - Typing - const - issues - scope": "Like let, variables declared with const are block-scoped.",
	"Data - Variables - Declaration - Typing - const - issues - redeclared": "Data - Variables declared with const cannot be reassigned after their initial assignment. This makes const ideal for variables that should not change.",
	"Data - Variables - Declaration - Typing - const - issues - reference": "For objects and arrays, const prevents reassignment of the variable itself, but the contents can still be modified.",
	"Data - Variables - Declaration - Naming": "Naming conventions are a set of rules or guidelines used to name files, variables, functions, classes, or other entities in a consistent and meaningful way. They are important because they improve code readability, maintainability, and collaboration among team members.",
	"Data - Variables - Declaration - Naming - camelCase": "const userName= 'name'",
	"Data - Variables - Declaration - Naming - PascalCase": "const UserName= 'name'",
	"Data - Variables - Declaration - Naming - snake_case": "const user_name = 'name'",
	"Data - Variables - Declaration - Naming - kebab-case": "const user-name = 'name'",
	"Data - Variables - Declaration - Assignment": "pointing a variable name at a new thing",
	"Data - Variables - Declaration - Assignment - =": "",
	"Data - Variables - Declaration - Assignment - Safe - ?=": "Safe Assignment Operator (?=) — a new proposal for ECMAScript that aims to streamline error handling in JavaScript. This operator works by transforming the result of a function into an array, making it easier to handle both successful outcomes and errors gracefully.",
	"Data - Variables - Declaration - Assignment - Safe - ?= - purpose": "Error handling alternative to try catch",
	"Data - Variables - Declaration - Assignment - Safe - ?= - syntax - sync": "const [error, result] = ?= someOperation();",
	"Data - Variables - Declaration - Assignment - Safe - ?= - syntax - async": "const [error, data] = ?= await fetchData();",
	"Data - Variables - Declaration - Assignment - Safe - ?= - Symbol.result": "The Safe Assignment Operator derives its magic from the Symbol.result method. Any object that implements this method can be used with ?=. The Symbol.result method should return an array where: The first element represents the error (or null if no error occurred). The second element represents the result (or null if an error occurred).",
	"Data - Variables - Declaration - Assignment - Safe - ?= - recursive": "One of the standout features of the Safe Assignment Operator is its ability to handle errors recursively. If the result of an operation is an object that itself implements Symbol.result, the operator will automatically check for errors within that object as well!",
	"Data - Variables - Declaration - Assignment - Safe - ?= - promises": "This recursive behavior is particularly useful when working with Promises, which are often nested or chained together. The await keyword works seamlessly with ?=, allowing you to handle Promise rejections just like regular errors. const [error, data] ?= await promise",
	"Data - Variables - Declaration - Assignment - Logical - ??=": "Nulish coalescing. name ??= 'John Doe'; // Assigns if name is null or undefined",
	"Data - Variables - Declaration - Assignment - Logical - ||=": "name ||= 'Jane Doe'; // Assigns if name is falsy (e.g., '', 0, null, undefined)",
	"Data - Variables - Declaration - Assignment - Logical - &&=": "",
	"Data - Variables - Declaration - Assignment - Bitwise - |=": "The |= operator performs a bitwise OR operation and assigns the result to the variable.",
	"Data - Variables - Declaration - Assignment - Bitwise - &=": "The &= operator performs a bitwise AND operation and assigns the result to the variable.",
	"Data - Variables - Declaration - Assignment - destructuring": "[a, b] = [b, a];",
	"Data - Variables - Declaration - Assignment - using - ES2024": "ES2024 introduces the using keyword, which simplifies resource management in JavaScript. This feature automatically disposes of resources, reducing the risk of memory leaks.",
	"Data - Variables - Declaration - Assignment - property shorthand": "Object property shorthand allows you to create objects more concisely when the property names are the same as the variable names. const user = { name, age };",
	"Data - Variables - Declaration - Assignment - nulish Coalescing": "Nullish coalescing (??) provides a way to set default values only when the left-hand side is null or undefined, avoiding issues with falsy values like 0 or ''. const age = user.age ?? 18;",
	"Data - Variables - Declaration - Mutation": "editing the data within a thing.",
	"Data - DataFetching - XMLHttpRequest": "Synchronous AJAX requests block the browser until the request completes, freezing the UI and preventing user interactions. This can lead to a poor user experience, especially if the request takes a long time to complete.",
  "Data - DataFetching - fetch": "The fetch() method is a native JavaScript method. You can use it without any external libraries or dependencies.",
  "Data - DataFetching - fetch - 2step - headers": "const response = await fetch('https://example.com/data');",
  "Data - DataFetching - fetch - 2step - body": "const data = await response.json();",
	"Data - DataFetching - WebRequestAPI": ".",
  "Data - DataFetching - jQuery.ajax()": "",
  "Data - DataFetching - tRPC": "",
  "Data - DataFetching - TanStackQuery": "",
  "Data - DataFetching - ApolloClient": "",
  "Data - DataFetching - urql": "",
  "Data - DataFetching - Relay": "",
  "Data - DataFetching - RTKQuery": "",
  "Data - DataPersistence": "",
  "Data - DataPersistence - Targets - InBrowser - cookies": "Cookies are small pieces of data stored in the browser",
  "Data - DataPersistence - Targets - InBrowser - sessionStorage": "Data is cleared when the browser session ends (i.e., when the tab or browser is closed).",
  "Data - DataPersistence - Targets - InBrowser - localStorage": "Browser stores data as key-value pairs and remains available even after the browser is closed.",
  "Data - DataPersistence - Targets - InBrowser - IndexedDB": "IndexedDB is a large-scale, NoSQL storage system that allows storage of just about anything in the user's browser.",
  "Data - DataPersistence - Targets - InState - Libraries": "",
  "Data - DataPersistence - Targets - External - BackendAPI": "",

	"Logic": "SECTION",
	"Logic - Sync - Imperative - ControlFlow - Statements - with": "The original intention of “with” is to avoid redundant object calls. with(foo.bar.baz){ x = 1; y = 2; z = 3; }",
	"Logic - Sync - Imperative - ControlFlow - Statements - with - scope": "The `with` statement is used to temporarily modify the scope chain… This statement effectively adds an Object to the beginning of the scope chain, then executes the statement, and then restores the scope chain to its original state…",
	"Logic - Sync - Imperative - ControlFlow - Statements - with - abandoned": "But actually, using variable substitution is quite simple: var p = foo.bar.baz; p.x = 1; p.y = 2; p.z = 3;",
	"Logic - Sync - Imperative - ControlFlow - Conditions - if": "",
	"Logic - Sync - Imperative - ControlFlow - Conditions - if - ?": "let name = task.assignee ? task.assignee.name : 'Nobody';",
	"Logic - Sync - Imperative - ControlFlow - Conditions - if - ?.": "Optional chaining (?.) allows you to safely access deeply nested properties without having to check if each reference in the chain is valid. const city = user?.address?.city;",
	"Logic - Sync - Imperative - ControlFlow - Conditions - if - short circuit - ||": "Here we can use an inline short-circuit : doc.title = doc.title || 'Untitled';",
	"Logic - Sync - Imperative - ControlFlow - Conditions - if - short circuit - &&": "Similarly, it’s possible to use the && boolean operator to set the second value when the first value evaluates to true. JavaScript treats 0 and an empty string as false in the boolean context, so we need to be careful while using short circuits in some situations.",
	"Logic - Sync - Imperative - ControlFlow - Conditions - switch": "",
	"Logic - Sync - Imperative - ControlFlow - Conditions - !": "Bank operator. The ! in JavaScript, also called “bang”, is the logical “not” operator. If you place this operator in front of a boolean value, it will reverse the value, returning the opposite.",
	"Logic - Sync - Imperative - ControlFlow - Conditions - !!": "Bank bang operator to convert a non-boolean value to a boolean.",
	"Logic - Sync - Imperative - ControlFlow - Conditions - values - Truthy": "In JavaScript, a truthy value is a value that is considered true when encountered in a Boolean context. The following values are few examples that are considered by JavaScript to be truthys: Object: {} Array: [] Not empty string: 'anything' Number other than zero: 3.14 Date: new Date();",
	"Logic - Sync - Imperative - ControlFlow - Conditions - values - Falsy": "A falsy value is a value that is considered false when encountered in a Boolean context. The following values are few of the examples that are considered by JavaScript to be falsey: Empty string: '' 0 null undefined NaN and the list of falsy values below.",
	"Logic - Sync - Imperative - ControlFlow - PatternMatching - match - ES2024": "Pattern matching is one of the most anticipated features of ES2024. This feature allows you to match values against patterns, making it easier to work with complex data structures like objects and arrays.",
	"Logic - Sync - Imperative - ControlFlow - PatternMatching - flag - u - ES15": "Unicode pattern matching",
	"Logic - Sync - Imperative - ControlFlow - PatternMatching - flag - v - ES2024": "Now, there’s a new kid on the block: the v flag, which does everything the u flag does but with some cool extra features. To use the v flag, just slap a /v at the end of your regular expression. Simple as that..",
	"Logic - Sync - Imperative - ControlFlow - Iterators": "",
	"Logic - Sync - Imperative - ControlFlow - Iterators - Iterable": "Basically, an iterable is something you can loop through using [Symbol.iterator]()",
	"Logic - Sync - Imperative - ControlFlow - Iterators - Iterator": "An iterator is the thing that has a next() method to get the next item in the sequence.",
	"Logic - Sync - Imperative - ControlFlow - Iterators - for": "",
	"Logic - Sync - Imperative - ControlFlow - Iterators - for...in": "",
	"Logic - Sync - Imperative - ControlFlow - Iterators - for...of": "The for...of loop, introduced in ES6, offers a more flexible way to iterate over iterable objects (including arrays): ",
	"Logic - Sync - Imperative - ControlFlow - Iterators - for...of - examples - object properties": "for( const[key,value] of Object.entries(user)) { ... }",
	"Logic - Sync - Imperative - ControlFlow - Iterators - for...of - examples - destructuring": "for( const {name, age} of users) { ... }",
	"Logic - Sync - Imperative - ControlFlow - Iterators - while () {...}": "",
	"Logic - Sync - Imperative - ControlFlow - Iterators - do while": "",
	"Logic - Sync - Imperative - ControlFlow - Iterators - forEach": "",
	"Logic - Sync - Imperative - ControlFlow - Iterators - forEach - problem - break continue": "The flow of a forEach loop is uninterruptible. If you wish to break/continue an iteration, you are better off using the class “for i” loop or the “for of” loop statement.",
	"Logic - Sync - Imperative - ControlFlow - Iterators - forEach - problem - no async": "The forEach loop will not wait for the completion of async functions, which could lead to unexpected output orders.",
	"Logic - Sync - Imperative - ControlFlow - Iterators - forEach - problem - no Modify": "https://levelup.gitconnected.com/4-major-problems-with-javascript-foreach-b79f717c61b8",
	"Logic - Sync - Imperative - ControlFlow - Iterators - forEach - problem - exception": "In other words, if an error occurs inside a forEach, the error will not be caught by the loop itself, which means you must handle exceptions explicitly within the callback.",
	"Logic - Sync - Imperative - ErrorHandling - trycatch": "",
	"Logic - Sync - Imperative - ErrorHandling - trycatch - cause": "The enhanced error cause feature allows you to specify a cause when throwing an error, providing better context for debugging. new Error('Initial error')",
	"Logic - Sync - Imperative - ErrorHandling - trycatch - problems - nesting": "Multiple try-catch blocks can lead to increased code nesting levels, reducing readability.",
	"Logic - Sync - Imperative - ErrorHandling - trycatch - problems - scope": "To avoid nesting, variables sometimes need to be declared outside the try block, which can lead to overly broad variable scopes.",
	"Logic - Sync - Functional - ControlFlow - Invokations - Nesting": "uppercase(exclaim(listen(text)));",
	"Logic - Sync - Functional - ControlFlow - Invokations - Chaining": "text.listen().exclaim().uppercase();",
	"Logic - Sync - Functional - ControlFlow - Invokations - Pipe - |>": "The pipeline operator (|>) allows for a more readable and functional approach to chaining functions, inspired by languages like Elixir. It allows you to pass the result of one function directly into the next, making your code more readable and functional.",
	"Logic - Sync - Functional - ControlFlow - Invokations - Monads": "https://medium.com/@yourfuse/what-are-monads-in-javascript-and-how-can-they-improve-your-functional-programming-e42e56e7af9d https://medium.com/javascript-scene/javascript-monads-made-simple-7856be57bfe8",
	"Logic - Sync - Functional - ControlFlow - Invokations - Monads2": "https://javascript.plainenglish.io/50-single-line-code-examples-that-showcase-your-fundamental-skills-ea495082de45",
	"Logic - Sync - Functional - Decorators": "Decorators, inspired by TypeScript, allow declarative modification or augmentation of behavior for classes, methods, properties, or parameters.",
	"Logic - Sync - Functional - Decorators - Class": "Class Decorators: Applied directly to a class, affecting the entire class.",
	"Logic - Sync - Functional - Decorators - Method": "Method Decorators: Applied to class methods, allowing you to modify or extend the behavior of individual methods.",
	"Logic - Sync - Functional - Decorators - Parameter": "Accessor, Field, and Parameter Decorators: Each provides different ways to enhance fields, properties, or parameters of a class.",
	"Logic - Sync - Functional - ErrorHandling - .catch)": "",
	"Logic - Async - Imperative - Context - ES2024": "JavaScript now has AsyncContext that automatically tracks the context of async operations.",
	"Logic - Async - Imperative - Context - AsyncLocalStorage": "Async context provides a way to handle asynchronous operations more gracefully, preserving the context across async calls, making debugging and tracing easier. A go-to feature for backend developers working with Node.js and complex async operations. AsyncLocalStorage  is a Node.js API (based on the async_hooks API) that is used to create asynchronous state within callbacks and promise chains.",
	"Logic - Async - Imperative - ControlFlow - Delay - Atomics.waitAsync()": "This feature enables asynchronous waiting on atomic operations, making it easier to synchronize access to shared memory between threads. It’s particularly useful in scenarios involving Web Workers and shared memory.",
	"Logic - Async - Imperative - ControlFlow - Invokations - Events - prevent - detach": "Detach Event Listeners: Always remove event listeners when they are no longer needed.",
	"Logic - Async - Imperative - ControlFlow - Invokations - Events - prevent - multicall": "Events like scroll, resize, and mousemove can fire multiple times per second, leading to performance issues.",
	"Logic - Async - Imperative - ControlFlow - Invokations - Events - prevent - multicall - debounce": "Debouncing will only run after a certain period of time without new input.",
	"Logic - Async - Imperative - ControlFlow - Invokations - Events - prevent - multicall - throttle": "Throttling ensures that a function is called at most once per specified time period.",
	"Logic - Async - Imperative - ControlFlow - Invokations - Callback": "take a function as an argument that would be called when the response is available, freeing the CPU for other things while we wait for the response. in Node.js, almost every call is asynchronous",
	"Logic - Async - Imperative - ControlFlow - Invokations - Callback - Hell": "Callbacks are very good for the CPU but they are not so good for the programmer. multiple, deep nested callbacks within a function",
	"Logic - Async - Imperative - ControlFlow - Invokations - Async": "The word 'async' before a function makes the function returns a promise.",
	"Logic - Async - Imperative - ControlFlow - Invokations - Async - await": "wait until that promise settles and returns its result.",
	"Logic - Async - Imperative - ControlFlow - Invokations - Async - await - async": "works only inside async functions.",
	"Logic - Async - Imperative - ControlFlow - Invokations - Async - await - invoker": "if there’s any function relying on that function that code also has to be async and on and on and on. Until you reach the top level.",
	"Logic - Async - Imperative - ControlFlow - Invokations - Async - await - errors": "await Promise.reject(new Error('Whoops!')), or throw new Error('Whoops!')",
	"Logic - Async - Imperative - ControlFlow - Invokations - Async - await - scope - <ES13": "never use await in the global scope. Instead put an async function or create an async IIFE. ",
	"Logic - Async - Imperative - ControlFlow - Invokations - Async - await - scope - ES13": "can use await at the top level",
	"Logic - Async - Imperative - ControlFlow - Iterators - await...of": "for await (const data of fetchData()) { console.log(data); }",
	"Logic - Async - Functional - Promise - 2015": "A promise represents the eventual result of an asynchronous operation. It is a placeholder into which the successful result value or reason for failure will materialize. ES6 follows the standard Promises/A+ [1].",
	"Logic - Async - Functional - Promise - States": "A promise can be in one of 3 states:(1) Pending - the promise’s outcome hasn’t yet been determined, because the asynchronous operation that will produce its result hasn’t completed yet. (2) Fulfilled - the asynchronous operation has completed, and the promise has a value. (3) Rejected - the asynchronous operation failed, and the promise will never be fulfilled. In the rejected state, a promise has a reason that indicates why the operation failed..",
	"Logic - Async - Functional - Promise - new Promise()": "Creation. new Promise( /* executor */ function(resolve, reject) { ... } ).",
	"Logic - Async - Functional - Promise - Promise.all()": "Parallel. When you need to execute multiple asynchronous operations in parallel and continue executing subsequent code only when all asynchronous operations complete successfully. Promise.all([ asyncFunc1(), asyncFunc2(), ]).then(([result1, result2]) => {  ··· })",
	"Logic - Async - Functional - Promise - Promise.allSettled() - ES11": "Parallel Wait. When you want to wait for multiple asynchronous operations to complete and you need to know the result of each asynchronous operation. Promise.allSettled([promise1, promise2, promise3]).then((values) => { console.log(values); });",
	"Logic - Async - Functional - Promise - Promise.race()": "When you have multiple asynchronous operations and you only care which one completes first, whether it succeeds or fails. Promise.race([promise1, promise2, promise3]).then((values) => { console.log(values); });",
	"Logic - Async - Functional - Promise - Promise.race() - cancel": "Can be used as a trick to cancel Promises: const p = Promise.race([task, cancelP]);",
	"Logic - Async - Functional - Promise - Promise.any()": "ES12. When you have multiple asynchronous operations and you want to get the result of the first successful asynchronous operation and ignore the other asynchronous operations that have failed. Promise.any([promise1, promise2, promise3]).then((values) => { console.log(values); });",
	"Logic - Async - Functional - Promise - Promise.withResolvers() - ES15": "In some scenarios, we want to control the state of the Promise object externally. For example, in the scenario of requesting network data, the resolve method is called to set the return data of the current Promise only after all data is successfully received. https://javascript.plainenglish.io/ecmascript-2024-es15-is-coming-5-new-js-features-you-cant-miss-0d2833a53cfc",
	"Logic - Async - Functional - Promise - Chaining": "asyncFunc1().then().then()....",
	"Logic - Async - Functional - AbortController": "AbortController is a JavaScript global class designed to terminate any asynchronous operation.",
	"Logic - Async - Functional - AbortController - create": "const controller = new AbortController();",
	"Logic - Async - Functional - AbortController - features - signal": "The signal property: An AbortSignal instance that can be passed to APIs that support cancellation.",
	"Logic - Async - Functional - AbortController - features - signal - event": "We can listen for the abort event and implement specific abort logic: controller.signal.addEventListener('abort', () => { // Implement abort logic here });",
	"Logic - Async - Functional - AbortController - features - abort": "The abort() method: Triggers the abort event on the signal and marks it as aborted.",
	"Logic - Async - Functional - AbortController - features - AbortSignal.timeout": "Create a signal that aborts after a specified timeout: signal: AbortSignal.timeout(1700) .",
	"Logic - Async - Functional - AbortController - features - AbortSignal.any": "Combine multiple abort signals into one.",
	"Logic - Async - Functional - AbortController - usages - EventListeners": ".",
	"Logic - Async - Functional - AbortController - usages - FetchRequests": "The most common use case for AbortController is canceling fetch requests.",
	"Logic - Async - Functional - AbortController - usages - NodeHTTPRequests": "Even Node.js http module requests support the signal property",
	"Logic - Async - Functional - AbortController - usages - CancelStreams": ".",
	"Logic - Async - Functional - ErrorHandling": ".then(function (greeting) { .... }, function(error) { ... }), or .then(result2 => { ... }) catch(error => { ... })",
	"Logic - Async - Reactive - Observables": "An Observable is an array or a sequence of events over time. It has at least two participants, the creator (the data source) and the subscriber (subscription where data is being consumed)",
	"Logic - Async - Reactive - Observables - Observable": "you create an Observable instance that defines a subscriber function. This is the function that is executed when a consumer calls the subscribe() method producing vales asynchonously.",
	"Logic - Async - Reactive - Observables - Observable handler": "implements the Observer interface. Defines callback methods to handle the three types of notifications that an observable can send: next, error and complete",
	"Logic - Async - Reactive - Observables - Subscribing to Observable": "An Observable instance begins publishing values only when someone subscribes to it. You subscribe by calling the subscribe() method of the instance, passing an observer object to receive the notifications.",
	"Logic - Async - Reactive - Observables - Observable Multicasting": "practice of broadcasting to a list of multiple subscribers in a single execution.",
	"Logic - Async - Reactive - Observables - Observable Error Handling": "error callback on the observer",
	"Logic - Async - Reactive - Observables - Observable Unsubscribe": "On the ngOnDestroy lifecycle hook, unsubscribe to subscription to prevent memory leaks",
	"Logic - Async - Reactive - Observables - RxJS Operators List": "Creation (from, fromPromise, fromEvent, of), Combination (combineLatest , concat , merge , startWith , withLatestFrom , zip), Filtering (debounceTime , distinctUntilChanged , filter , take , takeUntil), Transformation (bufferTime , concatMap , map , mergeMap , scan , switchMap), Utility (tap), Multicasting  (share)",
	"Logic - Async - Reactive - Observables - RxJS Error Handling": "catchError operator",
	"Logic - Async - Reactive - Observables - RxJS Retry failed observable": "Use the retry operator before the catchError operator. It resubscribes to the original source observable, which can then re-run the full sequence of actions that resulted in the error. If this includes an HTTP request, it will retry that HTTP request.",
	"Logic - Async - Reactive - Observables - Examples": "(1) EventEmitter class extends Observable, (2) HTTP module uses observables to handle AJAX requests and responses, (3) Router and Forms modules use observables",
	"Logic - Async - Reactive - Observables - Observables compared to promises. Creation and subscription": "Observables are declarative, computation does not start until subscription. Promises execute immediately on creation",
	"Logic - Async - Reactive - Observables - Observables compared to promises. Chaining": "Observables differentiate between chaining and subscription. Promises only have .then() clauses",
	"Logic - Async - Reactive - Observables - Observables compared to promises. Cancellation": "Observable subscriptions are cancellable. Unsubscribing removes the listener. Promises are not cancellable.",
	"Logic - Async - Reactive - Observables - Observables compared to promises. Error Handling": "Observables subscribe() is responsible for handling errors. Promises push errors to the child promises (then().then().then().catch())",
	"Logic - Async - Reactive - Observables - Observables compared to promises. Multiplicity": "Observables provide many values. Promises provide one",
	"Logic - Async - Reactive - Observables - Observables compared to events API": "you can configure an observable to transform an event before passing the event to the handler",
	"Logic - Async - Reactive - Observables - Observables compared to arrays": "An observable produces values over time. An array is created as a static set of values. In a sense, observables are asynchronous where arrays are synchronous. ",
	"Logic - Async - Reactive - Signals": "Signals operate on a publish-subscribe model. A component (the publisher) emits a signal when a particular event occurs, and other components (subscribers) can listen for and react to that signal without needing direct knowledge of each other. Signals provide a powerful mechanism for communication between components in a React application. Rather than relying solely on traditional state management, Signals in React introduces a more event-driven approach. Components can emit signals, and other components can listen for these signals, allowing for a more loosely coupled and responsive architecture. https://github.com/tc39/proposal-signals",
  "Logic - Async - Reactive - Signals - Use - UIInteractions": "User Interface Interactions: Signals are commonly used in graphical user interfaces to handle user interactions such as button clicks, mouse movements, or keyboard inputs.",
  "Logic - Async - Reactive - Signals - Use - Cross-ComponentCommunication": "Cross-Component Communication: Signals facilitate communication between different components or modules, allowing them to coordinate actions without tight coupling.",
  "Logic - Async - Reactive - Signals - Use - SystemLevelEvents": "System-Level Events: In larger software systems, signals can be employed to handle system-level events, such as data updates, network activity, or error notifications.",
  "Logic - Async - Reactive - Signals - Benefits - DecouplingComponents": "Decoupling Components: Signals facilitate communication between components without creating direct dependencies, promoting a more modular and maintainable codebase.",
  "Logic - Async - Reactive - Signals - Benefits - Event-DrivenArchitecture": "Event-Driven Architecture: By embracing an event-driven architecture, Signals enable a flexible and scalable design. Components respond to signals based on their specific concerns, leading to a more responsive and intuitive user interface.",
  "Logic - Async - Reactive - Signals - Benefits - SimplifiedStateManagement": "Simplified State Management: While React has a robust state management system, Signals offer an alternative that might be more suitable for certain scenarios. Signals can be employed to manage specific aspects of the application state without the need for a centralised state management solution. Signals are reactive primitives for managing application state. What makes Signals unique is that state changes automatically update components and UI in the most efficient way possible. Automatic state binding and dependency tracking allows Signals to provide excellent ergonomics and productivity while eliminating the most common state management footguns. Signals are effective in applications of any size, with ergonomics that speed up the development of small apps, and performance characteristics that ensure apps of any size are fast by default.",

  "CICD - Applications - Authentication": "",
  "CICD - Applications - Authentication - custom - SessionBased": "When a user signs up or signs in, we create a session for them. This session is stored in a database and a cookie with a session token is set in the user's browser. Whenever the user sends a request to the server, we validate the session and if everything is fine, we return the session and the user.",
  "CICD - Applications - Authentication - custom - SessionBased - Function - CreateToken": "function which creates a random session token which will be used for the cookie",
  "CICD - Applications - Authentication - custom - SessionBased - Function - CreateSession": "function which creates a session for a user when a user signs up/in. The function takes a sessionToken generated from generateRandomSessionToken and the userId of the user which allows us to create a session for the user",
  "CICD - Applications - Authentication - custom - SessionBased - Function - ValidateSession": "function which validates a user's session whenever the user sends a request to the server. With every request the user sends to the server, which attempts to access a protected resource, we need to validate the session cookie.",
  "CICD - Applications - Authentication - custom - SessionBased - Function - DeleteSession": "function which deletes a user's session when the user signs out.",
  "CICD - Applications - Authentication - custom - SessionBased - Function - SetCookie": ".",
  "CICD - Applications - Authentication - custom - SessionBased - Function - DeleteCookie": ".",
  "CICD - Applications - Authentication - custom - SessionBased - Storage - Session": "If the cookie exists, we extract the session token from it and validate the session from the database. If the session is valid, we return the session and the user.",
  "CICD - Applications - Authentication - custom - SessionBased - Storage - User": "you need to define the user and session schema.",
  "CICD - Applications - Authentication - custom - PasswordBased": "",
  "CICD - Applications - Authentication - custom - PasswordBased - Function - SignIn": "It receives the form data from the client, retrieves the user by email, verifies the password, creates a session for the user, sets the session cookie in the user's browser, and redirects the user to the home page.",
  "CICD - Applications - Authentication - custom - PasswordBased - Function - SignUp": "It receives the form data from the client, hashes the password, creates a user and a session in the database, sets the session cookie in the user's browser, and redirects the user to the home page.",
  "CICD - Applications - Authentication - custom - PasswordBased - Function - SignOut": "It retrieves the session from the cookie, invalidates the session in the database, deletes the session cookie in the user's browser, and redirects the user to the sign in page.",
  "CICD - Applications - Authentication - custom - PasswordBased - Function - HashPassword": ".",
  "CICD - Applications - Authentication - custom - PasswordBased - Function - VerifyPassword": ".",
  "CICD - Applications - Authentication - custom - TokenBased": "basic token-based authentication system using JSON Web Tokens (JWT): { 'token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...' }",
  "CICD - Applications - Authentication - custom - TokenBased - Function": "",
  "CICD - Applications - Authentication - libs - Firebase": "",
  "CICD - Applications - Authentication - libs - AWS Cognito": "",
  "CICD - Applications - Authentication - libs - Auth0": "",
  "CICD - Applications - Authentication - libs - Passport.js": "",
  "CICD - Applications - Authentication - libs - NextAuth": "",
  "CICD - Applications - Authentication - libs - Supabase": "",
  "CICD - Applications - Authentication - libs - Clerk": "",
  "CICD - Applications - Authentication - libs - Lucia": "",
  "CICD - Applications - Authentication - libs - AuthKit": "",

	"CICD - VCS": "SECTION",
	"CICD - VCS - Monorepo": "A monorepo is a project which contains smaller projects -- whereas each project can be anything from individual application to reusable package (e.g. functions, components, services). The practice of combining projects dates back to the early 2000 when it was called a shared codebase.",
	"CICD - VCS - Monorepo - why": "There are two major advantages using a monorepo for a large scale codebase. First of all, shared packages can be used in multiple applications on a local machine without an online registry (e.g. npm). The developer experience improves tremendously here, because everything is in the same codebase without updating dependencies via third-parties. When a shared package gets updated, it gets immediately reflected in all applications which depend on it. Second, it improves collaboration across codebases. Teams working on different projects can improve the codebases from other teams without working on multiple repositories. It also improves accessibility without worrying about different setups and introduces a more flexible ownership of the source code across teams. Another benefit is the refactoring of code across many projects.",
	"CICD - VCS - Monorepo - structure": "A monorepo can contain multiple applications (here: apps) whereas each application has access to shared set of packages.",
	"CICD - VCS - Monorepo - structure - apps": "The apps are usually not dependent on each other, instead they only opt-in packages. Applications in apps do not know about being an repo in a monorepo, they just define dependencies",
	"CICD - VCS - Monorepo - structure - package": "A package, which is just a folder, can be anything. A package can be a dependency of another package.",
	"CICD - VCS - Monorepo - structure - workspace": "A monorepo, in our case, consists of multiple apps/packages working together. In the background, a tool called workspaces enables us to create a folder structure where apps can use packages as dependencies. In our case, we are using yarn workspaces to accomplish our goal. There are alternatives such as npm workspaces and pnpm workspaces too. Workspaces already allow us to create a monorepo structure.",
	"CICD - VCS - Monorepo - tools - NX": "Nx is a powerful Monorepo management tool that provides efficient build system optimization and developer tools. Features: Nx accelerates CI with fast build tools, targeted test runs, parallel task execution, and remote caching. It also has a rich plugin library, IDE tools like Nx Console, and supports various Monorepo styles.",
	"CICD - VCS - Monorepo - tools - Turborepo": ".",
	"CICD - VCS - Monorepo - tools - Lerna": ".",
	"CICD - VCS - Monorepo - tools - Rush": ".",
	"CICD - VCS - QA - Lerna": "Lerna simplifies the management of JavaScript monorepos.",
	"CICD - VCS - QA - ESLint": "A static code analysis tool that identifies and fixes problems in JavaScript code to enforce consistent coding standards. The deprecation of formatting rules in ESLint.",
	"CICD - VCS - QA - Prettier": "Prettier takes care of your code formatting.",
	"CICD - VCS - QA - dprint": "A Rust-based formatter supporting a smaller set of languages.",
	"CICD - VCS - QA - Biome": ".",
	"CICD - VCS - QA - EditorConfig": "EditorConfig helps maintain consistent coding styles between different editors and IDEs. It uses a simple configuration file to define basic formatting rules such as indentation style, line endings, and charset.",

	"CICD - Bundling": "SECTION",
	"CICD - Bundling - definition": "Bundling is the process of merging your app’s JavaScript files into one or a few large files.",
	"CICD - Bundling - Arch - Functions": "",
	"CICD - Bundling - Arch - Functions - firstclass": "JavaScript is a language with first-class functions, meaning functions are treated like regular variables. This allows us to pass functions into other functions and even return functions from functions.",
	"CICD - Bundling - Arch - Functions - properties": "In JavaScript, functions aren’t just code — they’re objects too. That means you can attach properties to them, just like you would with any other object. It’s wild. ",
	"CICD - Bundling - Arch - Functions - Declaration - ES5": "function getGreeting() { return 'Welcome to JavaScript'; }",
	"CICD - Bundling - Arch - Functions - Declaration - default params": "function greet(name = 'Guest') { ... }",
	"CICD - Bundling - Arch - Functions - Expression - ES6 - ArrowWithBody": "const getGreeting = () => { return 'Welcome to JavaScript'; }",
	"CICD - Bundling - Arch - Functions - Expression - ES6 - Arrow": "const getGreeting = () => 'Welcome to JavaScript';",
	"CICD - Bundling - Arch - Functions - Pure": "If I call a pure function, it will only take the data passed as parameters, perform an X operation, and return the output as a value. Pure functions do not print the output, call another function, perform another Y operation, etc. They only return a value.",
	"CICD - Bundling - Arch - Functions - Currying": "Currying refers to the process of transforming a function that accepts multiple arguments into a series of functions that each only accepts one argument. This allows for more flexible use of functions, reduces repetitive code, and increases code readability. https://javascript.info/currying-partials",
	"CICD - Bundling - Arch - Functions - Currying - formula": "curry(f) :: (a,b,c) -> f(a) -> f(b)-> f(c)",
	"CICD - Bundling - Arch - Functions - Hoisting": "In JavaScript, functions are hoisted, meaning you can call them before they are declared. However, this behavior is limited to function declarations, not function expressions.",
	"CICD - Bundling - Arch - Functions - call": "The call method invokes a function with a specified this value and individual arguments passed as separate arguments. It allows you to borrow functions from one object and invoke them in the context of another.",
	"CICD - Bundling - Arch - Functions - apply": "Similar to call, the apply method invokes a function with a specified this value, but it takes an array or an array-like object as its second argument, allowing you to pass a variable number of arguments to the function.",
	"CICD - Bundling - Arch - Functions - bind": "The bind method creates a new function that, when called, has its this value set to a specific value and prepends any provided arguments to the original function's arguments list. It is often used to create functions with preset contexts or partially applied arguments.",
	"CICD - Bundling - Arch - Functions - IIFE": "Self-invoking functions, also known as Immediately Invoked Function Expressions (IIFE), are functions that execute automatically when created. (function() { ... })();",
	"CICD - Bundling - Arch - Functions - IIFE - scope": "IIFE creates its own scope, which means that any variables declared inside the function are not accessible outside of it.",
	"CICD - Bundling - Arch - Functions - IIFE - global": "This is particularly useful when you want to keep your data private and avoid polluting the global scope.",
	"CICD - Bundling - Arch - Functions - IIFE - Initialization": "Clean Initialization. When building applications, especially with frameworks like React or Vue, you might want to initialize certain things right away, but without polluting the global space. IIFE lets you do just that.",
	"CICD - Bundling - Arch - Functions - IIFE - Parameters": "(function(name) { console.log(`Hello, ${name}!`); })('Alice');",
	"CICD - Bundling - Arch - Functions - IIFE - Patterns": "IIFEs are not just limited to small examples.",
	"CICD - Bundling - Arch - Functions - IIFE - Patterns - Modules": "IIFE is often used to create modules in JavaScript. A module can encapsulate specific functionality, expose only what’s necessary, and keep everything else private.",
	"CICD - Bundling - Arch - Functions - IIFE - Patterns - Events": "In web development, you often need to bind event handlers that require some setup but without exposing unnecessary functions or variables.",
	"CICD - Bundling - Arch - Functions - IIFE - async - IIAFE": "Self-invoking functions, also known as Immediately Invoked Async Function Expressions (async () => { console.log(data); })();",
	"CICD - Bundling - Arch - Functions - HOFs": "JavaScript offers a powerful feature known as higher order functions (HOFs). HOFs can accept functions as arguments and even return functions as results. https://www.freecodecamp.org/news/higher-order-functions-explained/",
	"CICD - Bundling - Arch - Functions - HOFs - eg - map": "The map() method creates a new array by calling a provided function on every element in the calling array.",
	"CICD - Bundling - Arch - Functions - HOFs - eg - filter": "The filter() method creates a new array with all elements that pass the test implemented by the provided function.",
	"CICD - Bundling - Arch - Functions - HOFs - eg - reduce": "The reduce() method applies a function against an accumulator and each element in the array to reduce it to a single value.",
	"CICD - Bundling - Arch - Functions - HOFs - eg - forEach": "The forEach() method executes a provided function once for each array element.",
	"CICD - Bundling - Arch - Functions - HOFs - eg - some": "The some() method tests whether at least one element in the array passes the test implemented by the provided function.",
	"CICD - Bundling - Arch - Functions - HOFs - eg - every": "The every() method tests whether all elements in the array pass the test implemented by the provided function.",
	"CICD - Bundling - Arch - Functions - HOFs - Techniques - Composition": "Function composition involves chaining multiple higher order functions together to create more complex operations or transformations.",
	"CICD - Bundling - Arch - Functions - HOFs - Techniques - Custom": "You can create custom higher order functions tailored to your specific requirements, encapsulating common patterns or behaviors into reusable functions.",
	"CICD - Bundling - Arch - Functions - HOFs - Techniques - Functional": "HOFs and Functional Programming Paradigms: Higher order functions are fundamental to functional programming paradigms, emphasizing the use of pure functions, immutability, and declarative programming style.",
  "CICD - Bundling - Arch - Functions - HOFs - async - HOFA": "",
	"CICD - Bundling - Arch - Functions - Closure": "A closure is an inner function that has access to the outer (enclosing) function’s variables—scope chain.",
	"CICD - Bundling - Arch - Functions - Closure - scope": "The closure has three scope chains: it has access to its own scope (variables defined between its curly brackets), it has access to the outer function’s variables, and it has access to the global variables.",
	"CICD - Bundling - Arch - Functions - Closure - memory": "A closure happens even after the outer function has finished running.",
	"CICD - Bundling - Arch - Functions - Closure - leak": "Closures are powerful, but they can also be sneaky memory hogs if not managed carefully. If a closure holds onto a reference to a large object that’s no longer needed, you’ve got yourself a memory leak.",
	"CICD - Bundling - Arch - Functions - Generator": "Regular functions return only one, single value (or nothing). Generators can return (“yield”) multiple values, one after another, on-demand. They work great with iterables, allowing to create data streams with ease. function* generateSequence() { yield 1; yield 2; return 3; }",
	"CICD - Bundling - Arch - Functions - Generator - declaration": "A generator function is declared just like a regular function but with an asterisk after the function keyword: function *myGenerator() {}, let iterator = myGenerator(), let firstYield = iterator.next(),",
	"CICD - Bundling - Arch - Functions - Generator - pausable": "Generator Function (ES6). Generator functions however are not “run to completion”. Generator functions can be paused and resumed so that other code can execute in between.",
	"CICD - Bundling - Arch - Functions - Generator - yield": "Unlike regular functions that execute top-to-bottom in one go, a generator can yield control back to the calling context, allowing for more granular control over its execution flow.",
	"CICD - Bundling - Arch - Functions - Generator - next": "Instead, it pauses at each yield statement, and only resumes when you explicitly call next() on it.",
	"CICD - Bundling - Arch - Functions - Generator - iterator": "When you invoke a generator function, it won’t execute the body of the function like a regular function. Instead, it will return a generator object called an iterator.",
	"CICD - Bundling - Arch - Functions - Generator - usage": "Generators are particularly useful in scenarios where you need fine-grained control over the execution flow. Here are some specific use cases:",
	"CICD - Bundling - Arch - Functions - Generator - usage - lazy iteration": "Generators shine when it comes to creating lazy iterators — sequences of values generated on the fly. This is especially useful when dealing with potentially infinite data streams or large datasets where loading everything into memory at once is impractical.",
	"CICD - Bundling - Arch - Functions - Generator - usage - state machine": "State machines are a common pattern in complex applications, and generators can be used to implement them cleanly and concisely. The ability to yield at specific states makes generators an excellent fit for managing transitions between states.",
	"CICD - Bundling - Arch - Functions - Generator - usage - flow control": "The great thing about this behavior is that we can use generators to manage flow control. Because generators allow us to pause execution, we can easily cancel asynchronous operations. Generators also allow us to turn asynchronous code into synchronous-looking code. ",
  "CICD - Bundling - Arch - Class - ES6": "Classes and functions are the primary ways to define objects and their behavior in JavaScript. They are syntactic sugar over JavaScript's prototype functionality; they do the same job but with a cleaner syntax.",
  "CICD - Bundling - Arch - Class - instantiation": "Cannot be called without new.",
	"CICD - Bundling - Arch - Class - constructor": "You will notice that this method is similar to using ‘new’ with user defined constructor function. The constructor functions are now replaced by classes as they are supported through ES6 specifications.",
  "CICD - Bundling - Arch - Class - fields": ".",
  "CICD - Bundling - Arch - Class - fields - <ES13": "Before ES13 we could only declare class fields in the constructor:",
  "CICD - Bundling - Arch - Class - fields - ES13": "Can declare or define them in the outermost scope of the class.",
  "CICD - Bundling - Arch - Class - fields - private - ES13": "#firstName= 'John'",
  "CICD - Bundling - Arch - Class - fields - static - ES13": "Static fields — properties of the class itself rather than any specific instance.",
  "CICD - Bundling - Arch - Class - blocks": ".",
  "CICD - Bundling - Arch - Class - blocks - static": "To execute code only once, at the creation of the class — just like static constructors in OOP languages like C# and Java.",
  "CICD - Bundling - Arch - Class - methods": "Methods defined within the class automatically go to the prototype.",
  "CICD - Bundling - Arch - Class - methods - static - ES13": "Static fields — properties of the class itself rather than any specific instance.",
	"CICD - Bundling - Arch - Services": ".",
	"CICD - Bundling - Arch - Services - DI": "Dependency injection is a design pattern that allows us to inject dependencies into a component from an external source, promoting loose coupling and enhancing code reusability.",
  "CICD - Bundling - Arch - Services - DI - mechanisms": "Instead of creating an instance of the Service internally within the MyComponent, we pass it from outside.",
  "CICD - Bundling - Arch - Services - DI - mechanisms - constructor": "as a constructor parameter during the component's initialization.",
  "CICD - Bundling - Arch - Services - DI - mechanisms - Libs - InversifyJS": "",
  "CICD - Bundling - Arch - Services - DI - mechanisms - Libs - Awilix": "",
  "CICD - Bundling - Arch - Services - DI - mechanisms - Libs - tsyringe": "",
	"CICD - Bundling - Arch - frameworks - Web - Binding based - Pros": "Pros: These frameworks reduce the boilerplate code needed for DOM manipulation, making it easier to create dynamic applications.",
	"CICD - Bundling - Arch - frameworks - Web - Binding based - Cons": "Cons: Mixing the JS logic in HTML goes against the principle of Separation of Concerns, which may also introduce complexity and performance issues in large-scale applications due to excessive DOM updates.",
  "CICD - Bundling - Arch - frameworks - Web - Binding based - KnockoutJS": "KnockoutJS: It uses two-way data binding to connect the UI to the underlying data model. Changes in the model automatically update the UI and vice versa.",
  "CICD - Bundling - Arch - frameworks - Web - Binding based - AngularJS": "AngularJS: This framework also utilizes two-way data binding, making it easy to keep the model and view in sync. It allows automatic synchronization of data between the model (business logic) and view (UI).",
  "CICD - Bundling - Arch - frameworks - Web - Binding based - Backbone": ".",
  "CICD - Bundling - Arch - frameworks - Web - Template based - Pros": "Pros: Simple. These frameworks focus on separating the presentation layer from logic, promoting a clear separation of concerns. They simplify rendering by using templates to bind data to the UI efficiently.",
  "CICD - Bundling - Arch - frameworks - Web - Template based - Cons": "Cons: When projects get bigger, you still need to write a lot of code, and much of the logic is duplicated. There are no reusable components, which can lead to code bloat and difficulty in maintaining a consistent structure across large applications.",
  "CICD - Bundling - Arch - frameworks - Web - Template based - HandlebarsJS": "HandlebarsJS: This is a way to build dynamic HTML pages by embedding expressions in HTML. It allows developers to create reusable templates for rendering content.",
  "CICD - Bundling - Arch - frameworks - Web - Template based - EmberJS": "EmberJS: Uses a templating engine similar to HandlebarsJS to render dynamic content. Ember’s template system automatically updates the DOM when the underlying data changes.",
  "CICD - Bundling - Arch - frameworks - Web - Template based - Eleventy": "",
  "CICD - Bundling - Arch - frameworks - Web - Components based - Pros": "Pros: These frameworks promote reusability and maintainability by encapsulating functionality within self-contained components. This modular approach simplifies the development of complex applications.",
  "CICD - Bundling - Arch - frameworks - Web - Components based - Cons": "Cons: There is a learning curve, especially when integrating advanced features like state management and routing. Additionally, because React and Vue are libraries rather than full frameworks, developers must make more decisions about which additional tools and libraries to use, like redux.",
	"CICD - Bundling - Arch - frameworks - Web - Components based - React": "",
  "CICD - Bundling - Arch - frameworks - Web - Components based - React - CRA": "Create React App (CRA): The Community Favorite. CRA remains a popular choice for React developers, known for its simplicity and ease of use",
  "CICD - Bundling - Arch - frameworks - Web - Components based - React - NextJS": "Next.js, a creation of Vercel, is the trusty all-terrain rover of the JavaScript world, capable of navigating a wide range of terrains, from simple static landing pages to complex, dynamic applications. Its hybrid rendering capabilities (SSR, SSG, ISR) make it a popular choice for projects that require both performance and flexibility.",
  "CICD - Bundling - Arch - frameworks - Web - Components based - React - Docusaurus": "",
  "CICD - Bundling - Arch - frameworks - Web - Components based - React - Remix - SPA": "Remix, built by the same team behind React Router, is laser-focused on making Single Page Applications (SPAs) run faster by leveraging native browser features and minimizing client-side JavaScript.",
  "CICD - Bundling - Arch - frameworks - Web - Components based - React - Gatsby": "",
  "CICD - Bundling - Arch - frameworks - Web - Components based - React - Redwood": "",
  "CICD - Bundling - Arch - frameworks - Web - Components based - Preact - DenoFresh": "",
  "CICD - Bundling - Arch - frameworks - Web - Components based - Astro": "Astro, a rising star in the JavaScript world, is quickly gaining traction for its lightweight design and laser focus on performance. Like a nimble lunar lander, Astro prioritizes speed and efficiency, making it an good choice for content-focused websites, blogs, and documentation sites. Last year Astro stepped in as the successor of Gatsby. While it became mainly known for static websites, its growing popularity pushed Astro to explore web applications and API endpoints too.",
  "CICD - Bundling - Arch - frameworks - Web - Components based - Astro - SSG": "Websites built with Astro are performant by default, because they start with zero JavaScript and move all the expensive rendering to the server. While static site generation (SSG) is the default, you can also opt-in into server-side rendering (SSR).",
  "CICD - Bundling - Arch - frameworks - Web - Components based - VueJS": "",
  "CICD - Bundling - Arch - frameworks - Web - Components based - VueJS - Nuxt": "",
  "CICD - Bundling - Arch - frameworks - Web - Components based - Sveltekit": "",
  "CICD - Bundling - Arch - frameworks - Web - Components based - SolidStart": "",
  "CICD - Bundling - Arch - frameworks - Web - Components based - Qwik": "",
  "CICD - Bundling - Arch - frameworks - Desktop - Chromium - Electron": "Electron embeds Chromium and Node.js to enable web developers to create desktop applications.",
  "CICD - Bundling - Arch - frameworks - Desktop - Chromium - NWjs": "NW.js is an app runtime based on Chromium and node.js. You can write native apps in HTML and JavaScript with NW.js. It also lets you call Node.js modules directly from the DOM and enables a new way of writing native applications with all Web technologies.",
  "CICD - Bundling - Arch - frameworks - Desktop - Webkit - Tauri": "Tauri uses the native WebView provided by the operating system. Based in Rust",
  "CICD - Bundling - Arch - frameworks - Desktop - Webkit - Neutralino": "",
  "CICD - Bundling - Arch - frameworks - Desktop - Webkit - Wails": "A Wails application is a standard Go application, with a webkit frontend.",
  "CICD - Bundling - Arch - frameworks - Desktop - Qt - NodeGui": "",
  "CICD - Bundling - Arch - Paradigms - MPA": "A Multi-Page Application (MPA) is the opposite of SPAs. MPAs rely on multiple HTML files and have multiple pages. While some companies, such as Amazon and eBay, still use MPAs, the trend is shifting towards SPAs for better user experience.",
  "CICD - Bundling - Arch - Paradigms - SPA": "Single-page applications are web applications that load once with new features just being mere additions to the user interface. It does not load new HTML pages to display the new page's content, instead generated dynamically. This is made possible through JavaScript's ability to manipulate the DOM elements on the existing page itself. A SPA approach is faster, thus providing a seamless user experience.",
  "CICD - Bundling - Arch - Paradigms - PWA": "A Progressive Web Application (PWA) is a web app that feels like a mobile app. It uses standard web technologies and service workers to enable features such as offline functionality, push notifications, and automatic updates.",
	"CICD - Bundling - Packaging - Managers - npm": "npm (node package manager) is the dependency/package manager you get out of the box when you install Node.js. It provides a way for developers to install packages both globally and locally.",
	"CICD - Bundling - Packaging - Managers - npm - local": "local installs have links created at the ./node_modules/.bin/ directory",
	"CICD - Bundling - Packaging - Managers - npm - global": "global installs have links created from the global bin/ directory (for example: /usr/local/bin on Linux or at %AppData%/npm on Windows)",
	"CICD - Bundling - Packaging - Managers - npm-run-all": "The npm-run-all package enables running multiple scripts simultaneously, which is particularly useful in CI/CD pipelines to speed up tasks like linting and testing.",
	"CICD - Bundling - Packaging - Managers - npx": "execute a package that wasn’t previously installed. You can use npx to run any GitHub gists and repositories.",
	"CICD - Bundling - Packaging - Managers - npmn": "",
	"CICD - Bundling - Packaging - Managers - yarn": "",
	"CICD - Bundling - Packaging - Managers - vlt": "https://javascript.plainenglish.io/npm-author-launches-new-javascript-package-manager-84b0d0ed977e",
	"CICD - Bundling - Packaging - Managers - JSR": "https://denoland.medium.com/jsr-is-not-another-package-manager-77fa596c345d",
	"CICD - Bundling - Packaging - Modules": "JavaScript modules are essential for maintaining and organizing code effectively. By dividing code into independent, self-contained parts, modules allow each component to focus on a specific function or task.",
	"CICD - Bundling - Packaging - Modules - Features - dependency": "Modules can load each other and use special directives export and import to interchange functionality, call functions of one module from another one:",
	"CICD - Bundling - Packaging - Modules - Features - reusability": "Modules also promote code reusability by encapsulating common functionalities, so developers can import and use these components as needed. A reusable module for form validation, for instance, can be implemented across multiple projects, reducing redundant code and improving consistency.",
	"CICD - Bundling - Packaging - Modules - Features - testing": "Modules also facilitate unit testing by isolating code segments. Testing individual modules in isolation helps ensure accuracy and reliability, without interference from other code.",
	"CICD - Bundling - Packaging - Modules - File": "A module is just a file. One script is one module. As simple as that.",
	"CICD - Bundling - Packaging - Modules - File - <2009": "Before CommonJS, JavaScript code was typically written in a single file, making it difficult to manage dependencies.",
	"CICD - Bundling - Packaging - Modules - Formats - CommonJS - 2009": "CommonJS (CJS). CommonJS was developed in 2009 by Kevin Dangoor and other developers. It was created to solve the problem of managing dependencies in JavaScript projects.",
	"CICD - Bundling - Packaging - Modules - Formats - CommonJS - .cjs": ".cjs files are treated as CommonJS files.",
	"CICD - Bundling - Packaging - Modules - Formats - CommonJS - browser - module": "When the type attribute is set to module, the file is treated as an ESM file.",
	"CICD - Bundling - Packaging - Modules - Formats - CommonJS - sync": "CommonJS is a synchronous module system. This means that when a module is imported, the code execution is blocked until the module is loaded.",
	"CICD - Bundling - Packaging - Modules - Formats - CommonJS - require": "CJS uses the require function to load modules and expose code as a module using either module.exports or exports objects.",
	"CICD - Bundling - Packaging - Modules - Formats - CommonJS - NodeJS": "CommonJS is a module system natively supported by Node.js, initially introduced to meet the needs of server-side modularity. .js file extension is by default associated with CommonJS modules.",
	"CICD - Bundling - Packaging - Modules - Formats - AMD": "Asynchromous Module Definition. The overall goal for the AMD format is to provide a solution for modular JavaScript that developers can use today.",
	"CICD - Bundling - Packaging - Modules - Formats - AMD - dojo": "It was born out of Dojo's real world experience using XHR+eval and proponents of this format wanted to avoid any future solutions suffering from the weaknesses of those in the past.",
	"CICD - Bundling - Packaging - Modules - Formats - AMD - history": "AMD began as a draft specification for a module format on the CommonJS list but as it wasn't able to reach full concensus,",
	"CICD - Bundling - Packaging - Modules - Formats - AMD - format": "The AMD module format itself is a proposal for defining modules where both the module and dependencies can be asynchronously loaded.",
	"CICD - Bundling - Packaging - Modules - Formats - AMD - group": "further development of the format moved to the amdjs group.",
	"CICD - Bundling - Packaging - Modules - Formats - AMD - define": "The AMD pattern offers clear advantages in browser environments. It uses the define function to specify dependencies and implementation details, improving code structure and avoiding global conflicts by isolating each module in its own closure.",
	"CICD - Bundling - Packaging - Modules - Formats - AMD - require": "",
	"CICD - Bundling - Packaging - Modules - Formats - AMD - require - RequireJS": "AMD module loaders like RequireJS also support older browsers, allowing modular development in legacy environments.",
	"CICD - Bundling - Packaging - Modules - Formats - AMD - async": "AMD supports asynchronous loading, allowing browsers to load multiple modules in parallel without blocking rendering, which speeds up page loads and enhances user experience.",
	"CICD - Bundling - Packaging - Modules - Formats - CMD": "Common Module Definition. Published by Chinese people who is developing SeaJS. It is like AMD.",
	"CICD - Bundling - Packaging - Modules - Formats - CMD - browser": "CMD is a module system used in browser environments.",
	"CICD - Bundling - Packaging - Modules - Formats - CMD - SeaJS": "SeaJS is a JavaScript module loader that follows the CMD specification. It offers a simple API for defining and using modules.",
	"CICD - Bundling - Packaging - Modules - Formats - CMD - require": "Loads external modules synchronously, blocking execution until completion.",
	"CICD - Bundling - Packaging - Modules - Formats - CMD - require - async": "Use require.async for asynchronous loading.",
	"CICD - Bundling - Packaging - Modules - Formats - CMD - exports": "Exports a module’s interface, allowing individual properties or methods.",
	"CICD - Bundling - Packaging - Modules - Formats - CMD - module": "Exports the entire object.",
	"CICD - Bundling - Packaging - Modules - Formats - UMD": "Universal Module Definition. Since CommonJS and AMD styles have both been equally popular, it seems there’s yet no consensus. This has brought about the push for a “universal” pattern that supports both styles, which brings us to none other than the Universal Module Definition.",
	"CICD - Bundling - Packaging - Modules - Formats - UMD - compatible": "AMD and CommonJS compatible",
	"CICD - Bundling - Packaging - Modules - Formats - ESM - 2015": "ECMAScript Module (ESM). ES Modules was introduced in ECMAScript 6 in 2015. It was created to provide a standardized way to modularize JavaScript code.",
	"CICD - Bundling - Packaging - Modules - Formats - ESM - .mjs": ".mjs files are treated as ESM files.",
	"CICD - Bundling - Packaging - Modules - Formats - ESM - browser - text/javascript": "When the type attribute is not specified or set to text/javascript, the file is treated as a CommonJS file.",
	"CICD - Bundling - Packaging - Modules - Formats - ESM - standard": "ESM is the official standard module system for modern JavaScript and is natively supported by the latest versions of browsers.",
	"CICD - Bundling - Packaging - Modules - Formats - ESM - static": "Unlike CommonJS, they are designed to be static, which means you cannot dynamically load or create modules at runtime.",
	"CICD - Bundling - Packaging - Modules - Formats - ESM - async": "Since ESM was introduced to Node.js, its asynchronous loading feature and module resolution logic have been well received.",
  "CICD - Bundling - Packaging - Modules - Formats - ESM - import": "Importing more components or modules than necessary can increase bundle size and negatively impact performance. Import only the specific components or functions you need from a module. Use code-splitting to load components on demand.",
	"CICD - Bundling - Packaging - Modules - Formats - ESM - import - default": "",
	"CICD - Bundling - Packaging - Modules - Formats - ESM - import - dynamic - ES11": "That’s where code-splitting and lazy loading come in. import('path/to/module').then(module => { ... });",
	"CICD - Bundling - Packaging - Modules - Formats - ESM - import - conditional - ES2024": "import { featureA } from './moduleA' if (condition); ",
  "CICD - Bundling - Packaging - Modules - Formats - ESM - import - SideEffect": "When you need to import something that doesn't export anything, but does something else, this is a side effect only module. This is often called a side effect import because it relies on the import doing something behind the scenes, like setting a global variable or adding features to a built-in object.",
  "CICD - Bundling - Packaging - Modules - Formats - ESM - export": ".",
	"CICD - Bundling - Packaging - Modules - Formats - compatibility": "Using require to load ES modules is not supported because ES modules are executed asynchronously. So, there’s nothing wrong with supporting require() for ESM that doesn’t include top-level await. Although some libraries may have valid reasons to use top-level await, it may not be so common.",
	"CICD - Bundling - Packaging - Modules - Formats - compatibility - dual - wrapper": "You write your library in CommonJS and create an ESM wrapper around it. The ESM wrapper imports the CommonJS code and re-exports it.",
	"CICD - Bundling - Packaging - Modules - Formats - compatibility - dual - separate": "Separate ESM and CommonJS builds. This approach involves writing your library in ESM and CommonJS separately - or more commonly, authoring in ESM and using tooling to generate the CommonJS build. This approach has the benefit of allowing you to write your code in ESM and get the benefits of ESM like tree-shaking with bundlers. But it also increases complexity in the build process.",
	"CICD - Bundling - Packaging - Modules - Formats - compatibility - dual - coexists": "Dual package hazard. With this approach, the ESM and CommonJS versions of the package are treated as separate modules by Node.js as they are different files, leading to potential issues if the package is both imported and required in the same runtime environment. If the package relies on any state that can cause issues if 2 separate instances are loaded, it's necessary to isolate the state into a separate CommonJS module that can be shared between the ESM and CommonJS builds. This is not an issue if it's safe to have 2 separate instances of the package loaded in the same environment, which is often the case for most libraries.",
	"CICD - Bundling - Packaging - Modules - Formats - compatibility - NodeJS - package.json": "Node.js allows the use of .mjs file extension or explicitly specifying the “type”: “module” property in package.json to indicate ESM modules.",
	"CICD - Bundling - Packaging - Modules - Formats - compatibility - experimental-require-module": "https://levelup.gitconnected.com/commonjs-and-es-module-are-finally-going-to-be-compatible-with-each-other-39b8b880796b.",
	"CICD - Bundling - Packaging - Modules - Formats - compatibility - polyfill": "https://amy-blankenship.medium.com/those-scary-stories-about-polyfill-io-theyre-just-the-beginning-5e24e7b5fe8a.",
	"CICD - Bundling - Packaging - Modules - Federation - MFE": "Module Federation: This webpack 5 feature enables micro frontends to share and dynamically load modules at runtime, allowing independent micro frontends to interact with each other. https://levelup.gitconnected.com/micro-frontend-architecture-b14b3a2c39a0",
  "CICD - Building - Packaging - Modules - HMR": "Hot Module Replacement (HMR). Hot Module Replacement (HMR) exchanges, adds, or removes modules while an application is running, without a full reload.",
	"CICD - Bundling - Optimization - CodeReduction": ".",
	"CICD - Bundling - Optimization - CodeReduction - Resources - ServeScaledImages": "Serve Scaled Images is used to improve the speed of your web application. It is a process to scale images that are used in your website, and it optimizes the site with scaled images. Although large images may be compressed into a fixed size, it will take up additional space to decrease the website's speed. To optimize angular performance and to avoid website down speed, developers must ensure that the uploaded images are the actual size of HTML images on the website.",
	"CICD - Bundling - Optimization - CodeReduction - Resources - OptimizeImages": "Use compressed images (WebP, AVIF) instead of PNG/JPEG.",
	"CICD - Bundling - Optimization - CodeReduction - Resources - Trimming": "If you wish to eliminate code redundancy, learn to trim your Javascript packages. When you cut-off duplicates and unnecessary code, the possibility of your React app performance multiplies. You must analyze and determine bundled code.",
	"CICD - Bundling - Optimization - CodeReduction - Resources - Compression": ".",
	"CICD - Bundling - Optimization - CodeReduction - Resources - Minification": "Minifying your JavaScript code removes unnecessary characters like whitespace and comments, reducing the size of your files. Compression further reduces the file size by encoding your code in a more efficient format..",
	"CICD - Bundling - Optimization - CodeReduction - Resources - Hashing": ".",
	"CICD - Bundling - Optimization - CodeReduction - TreeShaking": "Tree shaking is a form of dead code elimination. Modern JavaScript bundlers like Webpack can automatically remove unused code, reducing the final bundle size. To enable tree shaking in Webpack, ensure you’re using ES6 module syntax (import and export). Webpack will analyze the dependencies and eliminate code that is not used.",
	"CICD - Bundling - Optimization - CodeReduction - TreeShaking - side effects": "Side effects are actions performed by code that have an impact outside the function’s immediate scope. They make dependencies that make tree shaking modre difficult.",
	"CICD - Bundling - Optimization - CodeReduction - TreeShaking - side effects - mark": "Explicit Side Effect Marking: Some bundlers offer mechanisms to explicitly indicate if a module or function has side effects. This information helps the bundler make informed decisions when performing tree-shaking. For instance, if a function performs a crucial DOM manipulation, you might mark it as having side effects to ensure its inclusion in the final bundle.",
	"CICD - Bundling - Optimization - CodeReduction - TreeShaking - side effects - pure": "Embrace Pure Functions: Pure functions are the golden children of tree-shaking. They have no side effects and always return the same output for the same input. This predictability allows the bundler to confidently identify and remove unused pure functions. Aim to write code with minimal side effects whenever possible.",
	"CICD - Bundling - Optimization - CodeSplitting": "Code Splitting breaks your application into smaller, more manageable chunks.",
	"CICD - Bundling - Optimization - CodeSplitting - principles": "Code splitting is a technique offered by web bundlers that enables you to divide your code into multiple bundles, which can be loaded on-demand.",
	"CICD - Bundling - Optimization - CodeSplitting - principles - PageLevel": "Page-level splitting: Split the application into different pages or routes and then code-split for each page. This helps ensure that users only download code relevant to the page they are currently viewing.",
	"CICD - Bundling - Optimization - CodeSplitting - principles - OnDemand": "Loading on demand: Only load chunks of code when needed, avoiding loading all code on initial load. This can be achieved with React.lazy() and dynamic imports.",
	"CICD - Bundling - Optimization - CodeSplitting - principles - Prioritization": "Prioritization: According to the priority of the application, high-priority code blocks are split and loaded first, and then low-priority code blocks are loaded. This improves the performance perception of your application.",
	"CICD - Bundling - Optimization - CodeSplitting - principles - loadingstatus": "Provide loading status: When code splitting, provide feedback on loading status so users know something is loading. Loading indicators or placeholders are often used to represent the loading status.",
	"CICD - Bundling - Optimization - CodeSplitting - principles - ErrorHandling": "Error handling: During the loading process, possible error conditions are handled to prevent problems with the application. React Suspense provides the ability to handle loading errors.",
	"CICD - Bundling - Optimization - CodeSplitting - principles - Monitoring": "Performance Monitoring: Use tools to monitor the performance of your application to ensure that code splitting and on-demand loading are not causing performance issues.",
	"CICD - Bundling - Optimization - CodeSplitting - Loading - sync": "<script src='script.js'></script>",
	"CICD - Bundling - Optimization - CodeSplitting - Loading - async": "<script src='script.js' async></script>",
	"CICD - Bundling - Optimization - CodeSplitting - Loading - defer": "<script src='script.js' defer></script>",
	"CICD - Bundling - Optimization - CodeSplitting - Loading - Eager": "Feature modules under Eager loading are loaded before the application starts. This is typically used for small size applications.",
	"CICD - Bundling - Optimization - CodeSplitting - Loading - Lazy": "Similar to the list virtualization technique, lazy loading images prevents the creation of unnecessary DOM nodes, thereby boosting performance. Lazy loading allows you to defer or delay the loading of images until they are needed or visible to the user instead of loading all the images on page load..",
	"CICD - Bundling - Optimization - CodeSplitting - Loading - Lazy - technique": "The concept behind lazy loading is to initiate the load of a placeholder or a small low-resolution version of the image, typically a small-sized thumbnail or a blurred placeholder. As the user scrolls or interacts with the page, the actual image is loaded dynamically, replacing the placeholder when the user enters the viewport or when it becomes visible. Lazy loading in React can be achieved using various libraries and techniques. One of the popular libraries is the react-lazyload.  .",
	"CICD - Bundling - Optimization - CodeSplitting - Loading - Lazy - technique - Imports - Dynamic": "Dynamic Imports allow these chunks to be loaded on demand.",
	"CICD - Bundling - Optimization - CodeSplitting - Loading - Lazy - technique - Imports - Conditional": "not all components need to be loaded on every page.",
	"CICD - Bundling - Optimization - CodeSplitting - Loading - Lazy - compression": "Image compression reduces the file size of images without significant loss of visual quality..",
	"CICD - Bundling - Optimization - CodeSplitting - Webpack": "Webpack automatically supports code splitting when using dynamic imports (import()). Ensure your Webpack configuration is optimized for code splitting.",
	"CICD - Bundling - Optimization - CodeFetching": ".",
	"CICD - Bundling - Optimization - CodeFetching - Location - CDN": "A Content Delivery Network (CDN) is a network of servers distributed across various locations worldwide. By serving your JavaScript files (and other assets) from a CDN, you can reduce the latency for users accessing your site from different geographical regions.",
	"CICD - Building - Optimization - CodeFetching - Memoization": "Memoization is an optimization technique that involves caching the results of expensive function calls and returning the cached result when the same inputs occur again.",
	"CICD - Bundling - Optimization - CodeFetching - PreLoading": ".",
	"CICD - Bundling - Optimization - CodeFetching - PreLoading - prefetch": "rel='prefetch' attribute on a <link> tag.",
	"CICD - Bundling - tools": "JavaScript bundlers are tools that package our code and its dependencies into single or multiple JavaScript files, optimized for performance and browser loading.",
  "CICD - Bundling - tools - Brunch": ".",
  "CICD - Bundling - tools - tsup": ".",
  "CICD - Bundling - tools - tsc CLI": ".",
	"CICD - Bundling - tools - RequireJS - 2010": ".",
  "CICD - Bundling - tools - Browserify - 2011": ".",
	"CICD - Bundling - tools - Grunt - 2012": "",
	"CICD - Bundling - tools - Gulp - 2013": "",
	"CICD - Bundling - tools - WebPack - 2014": "It was revolutionary to be able to bundle not only JavaScript but also CSS, images, and fonts.",
	"CICD - Bundling - tools - WebPack - webpack.config.js": "Create a Webpack configuration file named `webpack.config.js` at the root of your project.",
  "CICD - Bundling - tools - WebPack - splitting - CommonsChunkPlugin": "",
  "CICD - Bundling - tools - WebPack - splitting - SplitChunksPlugin": "",
  "CICD - Bundling - tools - Webpack - Bundle Analyzer": "Webpack Bundle Analyzer helps analyze the size of webpack bundles and identify opportunities for optimization. By visualizing the composition of your bundles, you can pinpoint large dependencies or chunks that can be split or optimized.",
	"CICD - Bundling - tools - Rollup - 2015": "",
  "CICD - Bundling - tools - Parcel - 2017": "Features: Parcel allows you to work without a lot of configuration and provides a fast development server with hot reload, dynamic code splitting, and various production optimizations such as compression, tree shaking, and code compression for efficient builds.",
  "CICD - Bundling - tools - esbuild - 2020": ".",
  "CICD - Bundling - tools - Turbopack - 2022": "Turbopack is a new JavaScript/TypeScript bundler we’ve been cooking at Vercel. Building on 10+ years of learnings from webpack, we want to build a bundler that can be used with many frameworks. We’re moving the Turbopack codebase into the Next.js repository. 700x faster than Webpack",
	"CICD - Bundling - tools - Rspack - 2023": "It promised Webpack interoperability but with massive performance improvements (notably thanks to the Rust ecosystem).",
	"CICD - Bundling - tools - Rspack - Rsbuid": "Rsbuild is to Rspack what Create-React-App (CRA) is to webpack.",

	"CICD - Building": "SECTION",
	"CICD - Building - Compilation - Type - ByTime - JIT": "Interpreted. The Just-in-Time (JIT) compilation process is a way of compiling computer code to machine code during execution or run time.",
	"CICD - Building - Compilation - Type - ByTime - AOT": "The Ahead-of-time (AOT) compiler converts the HTML and TypeScript code into JavaScript code during the build phase, i.e., before the browser downloads and runs the code.",
	"CICD - Building - Compilation - Type - ByTime - AOT - Phases - CodeAnalysis": "The compiler records a representation of the source.",
	"CICD - Building - Compilation - Type - ByTime - AOT - Phases - CodeGeneration": "It handles the interpretation as well as places restrictions on what it interprets.",
	"CICD - Building - Compilation - Type - ByTime - AOT - Phases - Validation": "In this phase, the Angular template compiler uses the TypeScript compiler to validate the binding expressions in templates.",
	"CICD - Building - Compilation - Type - ByPlace - CSR": "HTML is generated in the browser using JavaScript.",
	"CICD - Building - Compilation - Type - ByPlace - CSR - Features - SEO": "No friendly (HTML is built in-browser)",
	"CICD - Building - Compilation - Type - ByPlace - CSR - Time - AOT": "Balance: faster load times, increased size.",
	"CICD - Building - Compilation - Type - ByPlace - CSR - Time - JIT": "JIT is commonly used during development for CSR applications",
	"CICD - Building - Compilation - Type - ByPlace - CSR - tools - Prerender": "However, there are also such gadgets as Prerender. io and Rendertron that can pre-render your SPA for search engines, giving you the best of both worlds: the comparative ease and practicality of CSR along with the SEO implications of SSR.",
	"CICD - Building - Compilation - Type - ByPlace - CSR - tools - Prerender - Prerender.io": ".",
	"CICD - Building - Compilation - Type - ByPlace - CSR - tools - Prerender - Rendertron": ".",
	"CICD - Building - Compilation - Type - ByPlace - CSR - libs - Remix": ".",
	"CICD - Building - Compilation - Type - ByPlace - SSG": "HTML is pre-generated at build time and served as static files.",
	"CICD - Building - Compilation - Type - ByPlace - SSG - Features - SEO": "Friendly (HTML is pre-built)",
	"CICD - Building - Compilation - Type - ByPlace - SSG - Features - Prerendering": "Prerendering, commonly referred to as Static Site Generation (SSG), represents the method by which pages are rendered to static HTML files during the build process.",
	"CICD - Building - Compilation - Type - ByPlace - SSG - Features - performance": "Prerendering maintains the same performance benefits of server-side rendering (SSR) but achieves a reduced Time to First Byte (TTFB), ultimately enhancing user experience. The key distinction lies in its approach that pages are served as static content, and there is no request-based rendering.",
	"CICD - Building - Compilation - Type - ByPlace - SSG - libs - NextJS": ".",
	"CICD - Building - Compilation - Type - ByPlace - SSG - libs - GatsbyJS": ".",
	"CICD - Building - Compilation - Type - ByPlace - SSG - libs - Astro": ".",
	"CICD - Building - Compilation - Type - ByPlace - SSR": "HTML is generated on the server for each request.",
	"CICD - Building - Compilation - Type - ByPlace - SSR - Features - SEO": "Friendly (HTML is pre-rendered)",
	"CICD - Building - Compilation - Type - ByPlace - SSR - Features - hydration": "Hydration is the process that restores the server-side rendered application on the client. This includes things like reusing the server rendered DOM structures, persisting the application state, transferring application data that was retrieved already by the server, and other processes.",
	"CICD - Building - Compilation - Type - ByPlace - SSR - Time - AOT": "AOT is a natural fit for SSR.",
	"CICD - Building - Compilation - Type - ByPlace - SSR - Time - JIT": "Balance: increase server load",
	"CICD - Building - Compilation - Type - ByPlace - SSR - libs - NextJS": ".",
	"CICD - Building - Compilation - Type - ByPlace - SSR - libs - NuxtJS": ".",
	"CICD - Building - Compilation - Type - ByPlace - SSR - libs - Remix": ".",
	"CICD - Building - Compilation - Type - ByPlace - SSR - libs - SvelteKit": "https://itnext.io/frontend-development-beyond-react-svelte-1-3-f47eda22cba5.",
	"CICD - Building - Compilation - Type - ByPlace - SSR - libs - FastHTML": "https://blog.stackademic.com/level-up-your-ssr-game-with-fasthtml-react-vue-and-more-weve-got-you-covered-dc363c19218b",
	"CICD - Building - Compilation - Type - ByPlace - SSR vs CSR": "By leveraging modern JavaScript capabilities, static site generation, and third-party services, you can build fast, SEO-friendly applications without the need for server-side rendering.",
	"CICD - Building - tools - Babel": "Babel is a toolchain that is mainly used to convert ECMAScript 2015+ code into a backwards compatible version of JavaScript in current and older browsers or environments.",
	"CICD - Building - tools - Optiflow": "https://itnext.io/optiflow-a-compiler-based-solution-for-next-generation-javascript-performance-e51c8c8de6ee",
	"CICD - Building - tools - Vite - 2020": "Vite is a modern build tool that champions speed and efficiency. https://vitejs.dev/ Vite pre-configures Rollup for you with sensible defaults and powerful plugins while giving you an insanely fast development server.",
  "CICD - Building - tools - Vite - simplicity": "Vite comes with a sensible set of defaults, and its configuration is minimal and straightforward. This ease of use means I can spend less time wrestling with my build tool and more time actually building my app.",
  "CICD - Building - tools - Vite - HMR": "Leverage Hot Module Replacement (HMR): Make the most out of Vite’s HMR for a seamless development experience. Keep your modules HMR-friendly by avoiding side effects in the module scope.",
  "CICD - Building - tools - Vite - PreBundling": "Optimize Dependency Pre-Bundling: Use the optimizeDeps option in vite.config.js to manually specify dependencies to pre-bundle, reducing startup time.",
  "CICD - Building - tools - Vite - ESM": "Utilize ES Modules for Assets: Import assets using ESM syntax for better caching and performance. native ES modules in the browser",

	"CICD - Execution": "SECTION",
	"CICD - Execution - Execution Context": "Execution context (EC) is defined as the environment in which JavaScript code is executed. By environment I mean the value of this, variables, objects, and functions JavaScript code has access to, constitutes it’s environment.",
	"CICD - Execution - Execution Context - Types": "Execution context in JavaScript are of three types: Global execution context, Functional execution context, Eval",
	"CICD - Execution - Execution Context - Global": "Global execution context (GEC): This is the default execution context in which JS code start it’s execution when the file first loads in the browser. All the global code are executed inside global execution context. In the browser context, if the code is executing in strict mode value of this is undefined else it is window object. Global execution context cannot be more than one because only one global environment is possible for JS code execution.",
	"CICD - Execution - Execution Context - Function": "Functional execution context (FEC): Functional execution context is defined as the context created by the execution of code inside a function. Each function has it’s own execution context. It can be more than one. Functional execution context have access to all the code of global execution context. While executing global execution context code, if JS engine finds a function call, it creates a new functional execution context for that function.",
	"CICD - Execution - Execution Context - Eval": "Eval: Execution context inside eval function.",
	"CICD - Execution - Execution Context - Eval - avoid": "The eval() function is a powerful but dangerous feature in JavaScript. It allows you to execute strings of JavaScript code, but it can also introduce security vulnerabilities and performance issues.",
	"CICD - Execution - Execution Context - Execution context stack (ECS)": "Execution context stack (ECS): Execution context stack is a stack data structure to store all the execution stacks created while executing the JS code. Global execution context is present by default in execution context stack and it is at the bottom of the stack. While executing global execution context code, if JS engines finds a function call, it creates functional execution context of that function and pushes that function execution context on top of execution context stack. JS engine executes the function whose execution context is at the top of the execution context stack. Once all the code of the function is executed, JS engines pop’s out that function’s execution context and start’s executing the function which is below it..",
	"CICD - Execution - Execution Context - StrictMode - ES5": "Strict Mode imposes restrictions that save hours of debugging. With Strict Mode, you’ll get an error if a variable doesn’t exist or has a typo, stopping your app from running and pinpointing the bug immediately. It throws visible errors for silent issues like wrong variable names and prevents using reserved keywords that could cause future problems.",
	"CICD - Execution - Execution Context - StrictMode - use strict": "Use the use strict line to enable Strict Mode anywhere in your code. I recommend placing it in the global context. It will cover the entire file.",
	"CICD - Execution - Scopes": "The namespace is sometimes an interchangeable word for scope, but usually the refers to the highest level scope. They are: Global, Function, Lexical (Closures), Block (ES6",
	"CICD - Execution - Scopes - Global": "the global scope is the scope that contains, and is visible in, all other scopes.",
	"CICD - Execution - Scopes - Global - GlobalObject": "The global object in JavaScript is an object which represents the global scope.",
	"CICD - Execution - Scopes - Global - GlobalObject - browsers": "In browsers, window is the global object.",
	"CICD - Execution - Scopes - Global - GlobalObject - NodeJS": "But in Node.js, it’s global",
	"CICD - Execution - Scopes - Global - GlobalObject - modernJS": "And in modern JavaScript modules? There’s no global object!",
	"CICD - Execution - Scopes - Global - declaration": "Contrary to the var keyword, the let and const keywords support the declaration of local scope inside block statements.",
	"CICD - Execution - Scopes - Global - avoid": "Avoid Global Variables: Global variables remain in memory throughout the lifecycle of your application, which can cause memory leaks if not handled properly.",
	"CICD - Execution - Scopes - Global - globalThis": "The globalThis global property allows one to access the global object regardless of the current environment.",
	"CICD - Execution - Scopes - OtherScopes - Local/Function": "All scopes in JavaScript are created with Function Scope only, they aren’t created by for or while loops or expression statements like if or switch. New functions = new scope - that’s the rule..",
	"CICD - Execution - Scopes - OtherScopes - Lexical": "Whenever you see a function within another function, the inner function has access to the scope in the outer function, this is called Lexical Scope or Closure - also referred to as Static Scope. Any variables/objects/functions defined in its parent scope, are available in the scope chain. ",
	"CICD - Execution - Scopes - OtherScopes - Block (ES6)": "Contrary to the var keyword, the let and const keywords support the declaration of local scope inside block statements.",
	"CICD - Execution - Scopes - ScopeChain": "Scope chains establish the scope for a given function. Each function defined has its own nested scope as we know, and any function defined within another function has a local scope which is linked to the outer function - this link is called the chain. It’s always the position in the code that defines the scope. When resolving a variable, JavaScript starts at the innermost scope and searches outwards until it finds the variable/object/function it was looking for..",
	"CICD - Execution - Scopes - this": "In JavaScript, this refers to the object executing the current function. It’s dynamic, changing based on how and where a function is called.",
	"CICD - Execution - Scopes - this - default": "By default this refers to the outer most global object, the window",
	"CICD - Execution - Scopes - this - global - browsers": "In a regular function, this refers to the global object (window in browsers).",
	"CICD - Execution - Scopes - this - global - node": "In Node.js, this points to an empty object ({}).",
	"CICD - Execution - Scopes - this - method": "In a method, this refers to the object that owns the method.",
	"CICD - Execution - Scopes - this - arrow": "they don’t have their own this. Instead, they inherit it from their surrounding context.",
	"CICD - Execution - Scopes - this - listeners - default": "By default, this in an event listener points to the element that triggered the event.",
	"CICD - Execution - Scopes - this - listeners - arrow": "Refers to the outer context",
	"CICD - Execution - Scopes - Changing Scope": "Sometimes you need to manipulate the scopes of your JavaScript depending on what you’re looking to do: .call() and .apply() and .bind()",
	"CICD - Execution - Scopes - Changing Scope - .call() and .apply()": "allow you to pass in a scope to a function, which binds the correct this value. We can use either .call() or .apply() to change the scope, but any further arguments are where the two differ: .call(scope, arg1, arg2, arg3) takes individual arguments, comma separated, whereas .apply(scope, [arg1, arg2]) takes an Array of arguments.",
	"CICD - Execution - Scopes - Changing Scope - .bind() (ES5)": "Unlike the above, using .bind() does not invoke a function, it merely binds the values before the function is invoked.",
	"CICD - Execution - Threads - LongRunningTasks": "code freezes the page",
	"CICD - Execution - Threads - LongRunningTasks - setTimeout": "keeps the page responsive, but the execution time skyrockets to about 17568 milliseconds.",
	"CICD - Execution - Threads - LongRunningTasks - setTimeout - 0": "Minimum Timeout: Even if you set it to 0, setTimeout() has a minimum delay of 4ms.",
	"CICD - Execution - Threads - LongRunningTasks - setTimeout - Priority": "Priority Issues: Resumed tasks get pushed to the end of the queue, potentially causing priority problems.",
	"CICD - Execution - Threads - LongRunningTasks - scheduler.yield": "Chrome 129 has introduced a game-changing solution: scheduler.yield().",
	"CICD - Execution - Threads - LongRunningTasks - scheduler.yield - Performance": "Better Performance: Execution time is much closer to uninterrupted tasks.",
	"CICD - Execution - Threads - LongRunningTasks - scheduler.yield - Priority": "Smart Priority Handling: Paused tasks are placed at the front of the queue, not the end.",
	"CICD - Execution - Threads - Multithreading": "JavaScript typically runs on a single thread, often referred to as the 'main thread.' This means that JavaScript executes one task at a time in a synchronous manner.",
	"CICD - Execution - Threads - Multithreading - main thread": "The main thread also handles rendering tasks such as painting and layout, along with user interactions, meaning that long-running JavaScript tasks can cause the browser to become unresponsive. This is why web pages may “freeze” when a heavy JavaScript function runs, blocking user interactions",
	"CICD - Execution - Threads - Multithreading - waitSync": "In modern programming, parallelism is essential, especially when working with shared memory. ES15 introduces waitSync, a method that ensures data integrity during multi-threading operations, preventing race conditions. waitSync ensures that shared memory operations are safe by blocking execution until a specified condition is met.",
	"CICD - Execution - Threads - Multithreading - Workers": "offloading heavy computation from the main thread. allow you to run JavaScript in background threads.",
	"CICD - Execution - Threads - Multithreading - Workers - WebWorkers": "Web workers are the most general purpose type of worker. Unlike service workers and worklets they do not have a specific use case, other than the feature of being run separately to the main thread. As a result, web workers can be used to offload pretty much any heavy processing from the main thread. Web Workers are lightweight, in-browser threads that we can use to execute JavaScript code without blocking the main browser process.  Web workers are created using the Web Workers API. const worker = new Worker(`./my-worker.worker`, { type: `module` });",
  "CICD - Execution - Threads - Multithreading - Workers - WebWorkers - HTML5": "Web Workers, part of the HTML5 spec. They were first proposed back in 2009.",
  "CICD - Execution - Threads - Multithreading - Workers - WebWorkers - usage - Parallel Processing": "Web Workers enable parallel processing by allowing you to execute JavaScript code in separate threads. This means that computationally intensive tasks can be offloaded to Web Workers, running concurrently with the main thread and significantly reducing the impact on overall performance.",
  "CICD - Execution - Threads - Multithreading - Workers - WebWorkers - usage - Offloading Expensive Computations": "By moving complex calculations, data processing, or heavy algorithms to Web Workers, you prevent them from blocking the main thread. This ensures that user interactions remain responsive and smooth UI even when dealing with intensive computations.",
  "CICD - Execution - Threads - Multithreading - Workers - WebWorkers - usage - Asynchronous Execution": "Web Workers communicate with the main thread via messages, allowing for asynchronous execution of tasks. This means time-consuming operations can be processed in the background without blocking the main thread, and results can be sent back asynchronously when ready.",
  "CICD - Execution - Threads - Multithreading - Workers - WebWorkers - usage - Improved Responsiveness": "Offloading expensive computations to Web Workers prevents UI freezes or slowdowns caused by long-running operations. Users can continue interacting with the application while the Web Workers handle the computationally intensive tasks in the background, leading to a more responsive and seamless experience.",
  "CICD - Execution - Threads - Multithreading - Workers - WebWorkers - errors": "Web Workers provide two helpful error-handling events:",
  "CICD - Execution - Threads - Multithreading - Workers - WebWorkers - errors - error": "error: Triggered when an error happens within the worker.",
  "CICD - Execution - Threads - Multithreading - Workers - WebWorkers - errors - messageerror": "messageerror: This one fires if the worker receives a message that can't be properly deserialized.",
	"CICD - Execution - Threads - Multithreading - Workers - WebWorkers - interthreads": "JavaScript’s Web Workers employ clever mechanisms to facilitate data exchange between threads:",
  "CICD - Execution - Threads - Multithreading - Workers - WebWorkers - interthreads - Structured Clone Algorithm": "Structured Clone Algorithm: This is the default and most compatible method. It’s a robust way to create deep copies of objects that can be safely shared between threads.",
  "CICD - Execution - Threads - Multithreading - Workers - WebWorkers - interthreads - Transferable Objects": "Transferable Objects: For scenarios demanding optimal performance, Transferable Objects are the way to go. They enable the transfer of ownership of certain data types, like ArrayBuffers, from one thread to another, eliminating unnecessary copying.",
  "CICD - Execution - Threads - Multithreading - Workers - WebWorkers - interthreads - SharedArrayBuffer": "SharedArrayBuffer: This one enables true shared memory between threads, allowing simultaneous access and modification. However, be aware that extra care needs to be taken to prevent race conditions and ensure data integrity.",
	"CICD - Execution - Threads - Multithreading - Workers - WebWorkers - main": "const worker = new Worker('worker.js'); worker.onmessage = function(e) { console.log('Worker said: ', e.data); };​ worker.postMessage('Hello, Worker!');.",
	"CICD - Execution - Threads - Multithreading - Workers - WebWorkers - worker": "self.onmessage = function(e) { console.log('Main thread said: ', e.data); self.postMessage('Hello, Main thread!'); };.",
	"CICD - Execution - Threads - Multithreading - Workers - WebWorkers - type - Dedicated": "Dedicated Workers: These workers are tied to the specific script that created them. It’s a one-on-one relationship.",
  "CICD - Execution - Threads - Multithreading - Workers - WebWorkers - type - Shared": "Shared Workers: As the name suggests, these workers can be shared by multiple scripts running in different windows or iframes, provided they belong to the same domain.",
  "CICD - Execution - Threads - Multithreading - Workers - WebWorkers - type - Service": "Service Workers: These special workers act like proxies, sitting between your web app, the browser, and the network. They’re essential for building robust offline experiences, intercepting network requests, and enabling features like push notifications.",
	"CICD - Execution - Threads - Multithreading - Workers - WebWorkers - type - Service - usage": "Service Workers can be used to cache assets and handle offline functionality. This can significantly improve the load time of your web app, especially on repeat visits.",
	"CICD - Execution - Threads - Multithreading - Workers - WebWorkers - type - Service - register": "navigator.serviceWorker.register('/service-worker.js').then(function(registration) {})",
	"CICD - Execution - Threads - Multithreading - Workers - ServiceWorkers": "Service Workers are JavaScript files that run in the background and enable offline functionality, push notifications, and caching of resources.",
	"CICD - Execution - Threads - Multithreading - Workers - ServiceWorkers - proxy": "Service Workers act as a proxy between the web application and the network, intercepting network requests made by the application.",
	"CICD - Execution - Threads - Multithreading - Workers - ServiceWorkers - applications - caching": "They allow web applications to work offline by caching the resources required for the application to function.",
	"CICD - Execution - Threads - Multithreading - Workers - ServiceWorkers - applications - PushNotifications": "Service Workers can also be used to push notifications to users even when the application is not running. This feature is particularly useful for web applications that need to send real-time notifications to users.",
	"CICD - Execution - Threads - Multithreading - Workers - Worklets": "",
	"CICD - Execution - Threads - Multithreading - WebAssembly": "",
	"CICD - Execution - Threads - Multithreading - WebAssembly - AssemblyScript": "If we compile that code, it will generate a release.wasm file. We can then use this Wasm file in our JavaScript codebase.",
	"CICD - Execution - Threads - Multithreading - WebAssembly - Rust": ".",
	"CICD - Execution - Threads - Concurrency - single-threaded": "Let’s now understand JavaScript’s single-threaded, non-blocking event loop concurrency model. A concurrency model refers to how the JavaScript engine manages multiple tasks occurring simultaneously. Since JavaScript runs on a single thread, it can only perform one task at a time. Therefore, we need a method to handle multiple tasks concurrently.",
	"CICD - Execution - Threads - Concurrency - event loop": "To avoid blocking, JavaScript uses a non-blocking behavior facilitated by the event loop. The event loop manages long-running tasks by executing them in the background and then placing them back on the main thread once they are completed.",
	"CICD - Execution - Scheduler - EventLoop": "JavaScript is single-threaded. JavaScript’s design is well-suited for handling many tasks efficiently, thanks to the event loop.",
	"CICD - Execution - Scheduler - EventLoop - how": "An event loop is something that pulls stuff out of the queue and places it onto the function execution stack whenever the function stack becomes empty. The event loop is the secret by which JavaScript gives us an illusion of being multithreaded even though it is single-threaded.",
	"CICD - Execution - Scheduler - EventLoop - priority": "Each task has a task type, and tasks of the same type must be in one queue, while tasks of different types belong to different queues. In a single event loop cycle, the browser can select tasks from different queues to execute based on the actual situation. The queues include ones for DOM manipulation, user interaction, network requests, webpage navigation and history traversal, rendering.",
	"CICD - Execution - Scheduler - EventLoop - priority - execution - CallStack": "JavaScript uses a call stack to keep track of the currently executing function (where the program is in its execution)",
	"CICD - Execution - Scheduler - EventLoop - priority - execution - CallStack - top": "The function on top of the call stack is executed. If this function contains asynchronous code, it might initiate further asynchronous operations.",
	"CICD - Execution - Scheduler - EventLoop - priority - execution - CallStack - priority": "The event loop continuously checks the call stack (current task) and the callback queue (asyncs). If the call stack is empty, it takes the first function from the callback queue and pushes it onto the call stack for execution.",
	"CICD - Execution - Scheduler - EventLoop - priority - execution - CallStack - Repeat": "The event loop continues this process, ensuring that the call stack is always empty before taking the next function from the callback queue.",
	"CICD - Execution - Scheduler - EventLoop - priority - async - CallbackQueue:": "Asynchronous operations, such as I/O operations or timers, are handled by the browser or Node.js runtime. When these operations are complete, corresponding functions (callbacks) are placed in the callback queue.",
	"CICD - Execution - Scheduler - EventLoop - priority - async - CallbackQueue - execution": "When an asynchronous operation is complete, its callback is placed in the callback queue.",
	"CICD - Execution - Scheduler - EventLoop - priority - async - CallbackQueue - priority": "For async tasks in JavaScript EventLoop, there is also the concept of priority. https://programming.earthonline.us/can-you-answer-this-senior-level-javascript-promise-interview-question-69f7b6ffc2e7",
	"CICD - Execution - Scheduler - EventLoop - priority - async - CallbackQueue - priority - microtasks": "Tasks with higher priority are called microtasks. Includes: Promise, ObjectObserver, MutationObserver, process.nextTick, async/await.",
	"CICD - Execution - Scheduler - EventLoop - priority - async - CallbackQueue - priority - microtasks - interaction": "High priority. Used for event handling tasks generated after actions.",
	"CICD - Execution - Scheduler - EventLoop - priority - async - CallbackQueue - priority - microtasks - Promise": "higher priority",
	"CICD - Execution - Scheduler - EventLoop - priority - async - CallbackQueue - priority - microtasks - async/await": "higher priority",
	"CICD - Execution - Scheduler - EventLoop - priority - async - CallbackQueue - priority - microtasks - Observer": "higher priority. ObjectObserver, MutationObserver",
	"CICD - Execution - Scheduler - EventLoop - priority - async - CallbackQueue - priority - macrotasks": "Tasks with lower priority are called macrotasks. Includes: setTimeout , setInterval and XHR.",
	"CICD - Execution - Scheduler - EventLoop - priority - async - CallbackQueue - priority - macrotasks - setTimeout": "Medium priority. Used for callback tasks triggered by timers reaching their deadlines.",
	"CICD - Execution - Scheduler - EventLoop - priority - async - CallbackQueue - priority - macrotasks - network": "Medium priority. Used for tasks generated by network activity.",
	"CICD - Execution - Scheduler - EventLoop - priority - async - CallbackQueue - priority - deprecated": "However, due to the rapid increase in browser complexity, W3C has abandoned the use of the term macrotask.",
	"CICD - Execution - Environment - engine - Google V8": "V8 is a browser engine",
	"CICD - Execution - Environment - runtime - node": "nodejs which is a runtime environment built on top of V8",
	"CICD - Execution - Environment - runtime - deno": "",
	"CICD - Execution - Environment - runtime - deno2": "https://javascript.plainenglish.io/deno-2-vs-node-js-is-this-the-end-of-10-million-node-js-users-d55d6649cb4d",
	"CICD - Execution - Environment - runtime - Bun": "",
	"CICD - Execution - Environment - browser - Blink": "Google Blink Engine",
	"CICD - Execution - Environment - browser - Webkit": "Apple Safari (webkit) is more power efficient Engine",
	"CICD - Execution - Environment - browser - Chromium": "Apple macOS Chromium (blink) is faster",
	"CICD - Execution - Environment - browser - Gecko": "Mozilla Firefox/Gecko Engine",
	"CICD - Execution - Environment - browser - Gecko - Goanna": "fork of Firefox/Gecko",
	"CICD - Execution - Environment - browser - Ladybird - 2024": "Google Blink Engine",
	"CICD - Execution - performance - debounce": "Debounce function is a javascript programming pattern for delaying execution of a function.",
	"CICD - Execution - performance - throttle": "Throttling is a technique that limits how often a function can be called in a given period of time.",
	"CICD - Execution - Memory": ".",
	"CICD - Execution - Memory - Heap": "This is where JavaScript stores objects and data that are dynamically allocated. Memory in the heap is allocated in an unordered way, which means data can be stored at any available location.",
	"CICD - Execution - Memory - Stack": "Stack memory is used to keep track of function calls. It works in a last-in, first-out (LIFO) manner, meaning the last function that gets pushed onto the stack is the first one to be popped off when it’s done.",
	"CICD - Execution - Memory - Stack - Function call": "The call stack specifically tracks which functions are being executed at any moment. If a function calls another function, the new function is added to the top of the stack. Once a function finishes, it’s removed from the stack, and execution resumes where it left off.",
	"CICD - Execution - Memory - GC - strong": "Strong reference – is a reference to an object or value, that prevents them from being deleted by the garbage collector. Thereby, keeping the object or value in memory, to which it points.. The Strong Refs are our normal everyday variables.",
	"CICD - Execution - Memory - GC - weak": "https://javascript.info/weakref-finalizationregistry",
	"CICD - Execution - Memory - GC - weak - usage": "So why do we need weak references? The biggest use case for them is caching..",
	"CICD - Execution - Memory - GC - weak - WeakRef": "ES12. Weak Refs need to be explicitly created with WeakRef()",
	"CICD - Execution - Memory - GC - weak - WeakMap": "automatic memory management. Objects in WeakMaps and WeakSets get garbage-collected once they lose all other references.",
	"CICD - Execution - Memory - GC - weak - WeakSet": "automatic memory management. Objects in WeakMaps and WeakSets get garbage-collected once they lose all other references.",
	"CICD - Execution - Memory - GC - weak - FinalizationRegistry": "Coupled with FinalizationRegistry, it facilitates cleaning up resources when objects are garbage collected.",
	"CICD - Execution - Memory - Leaks": "Memory leaks happen when allocated memory in your application is no longer in use but isn’t released back to the system.",
	"CICD - Execution - Memory - Leaks - sources - GlobalVariables": "userName = 'Alice'; Always declare variables explicitly with let, const, or var to avoid accidentally creating globals.",
	"CICD - Execution - Memory - Leaks - sources - EventListeners": "If you remove the element from the DOM without removing its listeners, the memory won’t be freed..",
	"CICD - Execution - Memory - Leaks - sources - ClosuresVariables": "Closures, functions that capture variables from their outer scope can also hold references to unused variables, leading to memory leaks.",
	"CICD - Execution - Memory - Leaks - sources - DOMReferences": "Detached elements are removed from the DOM but are still referenced in JavaScript. When you keep a reference to a DOM element even after it’s removed from the page, it persists in memory.",
	"CICD - Execution - Memory - Leaks - sources - Timers": "If the timer is linked to a component that gets removed, the interval continues to run, holding onto resources.",

	"CICD - Audit": "SECTION",
	"CICD - Audit - Debug - BrowserDeveloperTools": "",
	"CICD - Audit - Debug - breakpoints": "",
	"CICD - Audit - Debug - debugger": "The debugger keyword is used in the code to force stop the execution of the code at a breaking point and calls the debugging function.",
	"CICD - Audit - Log - Built-in - Verbose": "console.debug(). By default, Google Chrome will hide the Verbose log level.",
	"CICD - Audit - Log - Built-in - Info": "console.log(), console.info()",
	"CICD - Audit - Log - Built-in - Warning": "console.war()",
	"CICD - Audit - Log - Built-in - Error": "console.error()",
	"CICD - Audit - Log - Built-in - Assert": "console.assert()",
	"CICD - Audit - Log - Built-in - Group": "console.group() and console.groupEnd() help you create collapsible sections in the console",
	"CICD - Audit - Log - Built-in - GroupEnd": "console.group() and console.groupEnd() help you create collapsible sections in the console",
	"CICD - Audit - Log - Built-in - Table": "console.table(). Displays arrays or objects in a neat table format.",
	"CICD - Audit - Log - Built-in - Time": "console.time() ... console.timeEnd(). Measures the execution time of your code.",
	"CICD - Audit - Log - Built-in - Clear": "console.clear().",
	"CICD - Audit - Log - Built-in - Memory": "console.memory(). If you need lightweight insights into memory usage, use console.memory in Chrome.",
	"CICD - Audit - Log - Built-in - Dir": "console.dir(). Displays an interactive list of an object's properties.",
	"CICD - Audit - Log - libraries - Winston": "",
	"CICD - Audit - Log - libraries - Pino": "",
	"CICD - Audit - Log - libraries - Bunyan": "",
	"CICD - Audit - Log - libraries - Loglevel": "",
	"CICD - Audit - Log - libraries - Npmlog": "",
	"CICD - Audit - Log - process.stdout.write": "https://medium.com/coding-beauty/javascript-console-log-without-newline-20e7e63cca36",
	"CICD - Audit - Test - Jest": "A comprehensive testing framework developed by Facebook. Jest is easy to set up and comes with a built-in assertion library, mocking support, and code coverage. https://www.robinwieruch.de/react-testing-tutorial/.",
	"CICD - Audit - Test - Jasmine": "A behavior-driven development framework for testing JavaScript code. It has a clean and easy-to-read syntax.",
	"CICD - Audit - Test - Mocha": "A flexible testing framework that allows you to use any assertion library. It’s often paired with Chai for assertions.",
	"CICD - Audit - Test - Chai": ".",
	"CICD - Audit - Test - Vitest": ".",
	"CICD - Audit - Test - Playwright": ".",
	"CICD - Audit - Test - Storybook": ".",
	"CICD - Audit - test - Protractor": "Protractor has recently announced the end of support 2022.",
	"CICD - Audit - test - Cypress": "Cypress is built on Node.js, Cypress is an open-source Javascript/Typescript framework that enables unit testing, integration testing, and end-to-end testing. Unlike Protractor or WebdriverIO, Cypress runs on its own browser so we can expect fewer failures.",
	"CICD - Audit - Profile - Lighthouse": "Lighthouse is an open-source tool by Google for auditing performance, accessibility, and SEO.",
	"CICD - Audit - Profile - WebPageTest": "WebPageTest allows you to run performance tests from multiple locations around the world. It provides detailed insights into your site’s loading times, resource usage, and more.",
	"CICD - Audit - Profile - Chrome DevTools": "Chrome DevTools offers a suite of performance profiling and debugging tools.",
	"CICD - Audit - Profile - Firefox Developer Tools": "Similar to Chrome, open DevTools (F12), go to the “Performance” tab, and start recording.",
	"CICD - Audit - Profile - NodeJS - prof": "",
	"CICD - Audit - Profile - NodeJS - clinic": "",
	"CICD - Audit - DistributedTracing": "Distributed tracing addresses the challenge of monitoring and understanding request flow in complex, distributed systems.",
	"CICD - Audit - DistributedTracing - Jaeger": "An open-source, distributed tracing system developed by Uber.",
	"CICD - Audit - DistributedTracing - Zipkin": "Another open-source distributed tracing system initially developed by Twitter.",
	"CICD - Audit - DistributedTracing - OpenTelemetry": "A vendor-neutral specification for collecting and exporting telemetry data, including traces, metrics, and logs. It provides a standardized way to instrument applications for tracing.",
	"CICD - Audit - DistributedTracing - Datadog": "A cloud-based monitoring platform that offers comprehensive tracing features, including integration with various languages and frameworks.",
	"CICD - Audit - DistributedTracing - NewRelic": "Another cloud-based monitoring platform with robust tracing capabilities, providing insights into application performance and code-level diagnostics.",
	"CICD - Audit - Security - XSS": "Cross-Site Scripting (XSS).",
	"CICD - Audit - Security - CSP": "Content Security Policy (CSP) Headers. Implementing a Content Security Policy (CSP) is a crucial step in securing your web application against various types of attacks, including Cross-Site Scripting (XSS).",
	"CICD - Audit - Security - CSRF": "Cross-Site Request Forgery (CSRF) is a type of security attack on web applications. In a CSRF attack, the attacker tricks a legitimate user into submitting a request that they did not intend to..",
	"CICD - Audit - Security - IDOR": "Insecure Direct Object References (IDOR) refer to a security weakness where an application provides direct access to objects based on user-supplied input..",
	"CICD - Audit - Security - env": "One of the key aspects of frontend application security is protecting sensitive information like API keys, database credentials, and other confidential data. Use env variables so they don’t get leaked into the git repository. Especially when the repository is open source and public."

}