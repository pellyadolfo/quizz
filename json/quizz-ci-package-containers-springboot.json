{
	"SpringBoot": "SECTION",
	"SpringBoot 0": "https://www.linkedin.com/posts/praveen-bishnoi_springboot-interview-questions-activity-7316800647125684224-ziy9?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"SpringBoot 1": "https://dzone.com/articles/mastering-scalability-in-spring-boot",
	"SpringBoot 2": "https://www.linkedin.com/posts/nayankumar-dhome_spring-boot-profiles-and-their-role-activity-7325002563253096448-GbR1?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"SpringBoot 3": "https://www.linkedin.com/posts/lamhotsiagian_tdd-for-spring-boot-using-cucumber-activity-7326741728923656193-619A?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"SpringBoot 4": "https://www.linkedin.com/posts/lalit-ingale-b87368231_master-spring-boot-with-59-essential-interview-activity-7328349207810002945-jVZR?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"SpringBoot 5": "https://medium.com/@vermatanisha666/beyond-service-layers-real-world-alternatives-to-outdated-spring-boot-patterns-30dfcb312db9",
	"SpringBoot 6": "https://www.linkedin.com/posts/ashish-thakur-3b468b201_spring-boot-scheduling-activity-7330142769627258882-TBty?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"SpringBoot 7": "https://medium.com/@vermatanisha666/youre-still-using-service-layers-in-spring-boot-here-s-why-that-s-outdated-1f41ac801fdf",
	"SpringBoot 8": "https://medium.com/@vermatanisha666/still-using-service-layers-in-spring-boot-do-this-instead-a709ecac816b",
	"SpringBoot 9": "https://www.linkedin.com/posts/ravikar-bagri-761442253_activity-7330115338660999168-RY9P?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"SpringBoot10": "https://www.linkedin.com/posts/haithem-mihoubi_springboot-ugcPost-7331593857807056897-aACb?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"SpringBoot11": "https://www.linkedin.com/posts/geetha-reddy-kann130826_spring-boot-annotations-activity-7333537200619327491-3nnc/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"SpringBoot12": "https://www.linkedin.com/posts/rashmichowdaryboppudi-2316ba55_java-springboot-interviewprep-activity-7333357925186318337-1g0c?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"SpringBoot13": "https://www.linkedin.com/posts/nelsonamigoscode_systemdesign-coding-interviewtips-activity-7338904234232340480-4PQ5?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"SpringBoot14": "https://towardsdev.com/how-to-dynamically-switch-implementations-in-spring-boot-using-annotations-no-if-else-hell-7bb59a5dc580",
	"SpringBoot15": "",
	"SpringBoot16": "",
	"SpringBoot17": "",
	"SpringBoot18": "",
	"SpringBoot19": "",
	"SpringBoot - Features - Opinionated": "Be opinionated out of the box but get out of the way quickly as requirements start to diverge from the defaults. Absolutely no code generation and no requirement for XML configuration.",
	"SpringBoot - Features - CoC": "Convention over configuration",
	"SpringBoot - Features - RapidDevelopment": "Provide a radically faster and widely accessible getting-started experience for all Spring development.",
	"SpringBoot - Features - EmbeddedServer": "No need to deploy WAR files.",
	"SpringBoot - Features - Integration": "Provide a range of non-functional features that are common to large classes of projects (such as embedded servers, security, metrics, health checks, and externalized configuration).",
	"SpringBoot - Features - Ecosystem": "Integrates seamlessly with Spring Cloud, Kafka, Redis, Elasticsearch, etc..",
	"SpringBoot - Features - ProductionReady": "Metrics, health checks, and monitoring.",

	"SpringBootApplication": "SECTION",
	"SpringBootApplication - Bootstrappers - SpringApplication": "The SpringApplication class provides a convenient way to bootstrap a Spring application.",
	"SpringBootApplication - Bootstrappers - SpringApplication - Extending": "If the SpringApplication defaults are not to your taste, you can instead create a local instance and customize it. SpringApplication app = new SpringApplication(MySpringConfiguration.class),",
	"SpringBootApplication - Bootstrappers - SpringBootCLI ": "The Spring Boot CLI is a command line tool that you can use to bootstrap a new project from start.spring.io or encode a password.",
	"SpringBootApplication - Bootstrappers - SpringBootCLI - Language": "It lets you run Groovy scripts, which means that you have a familiar Java-like syntax without so much boilerplate code.",
	"SpringBootApplication - Bootstrappers - SpringApplicationBuilder": "The SpringApplicationBuilder lets you chain together multiple method calls and includes parent and child methods that let you create a hierarchy",
	"SpringBootApplication - AutoConfiguration - @SpringBootApplication": "often placed on your main class, implicitly defines a base search package. @SpringBootApplication = @Configuration + @ComponentScan + @EnableAutoConfiguration",
	"SpringBootApplication - AutoConfiguration - @EnableAutoConfiguration": "This annotation tells Spring Boot to 'guess' how you want to configure Spring, based on the jar dependencies that you have added. Since spring-boot-starter-web added Tomcat and Spring MVC, the auto-configuration assumes that you are developing a web application and sets up Spring accordingly. Starters and Auto-configuration Auto-configuration is designed to work well with 'Starters', but the two concepts are not directly tied. You are free to pick and choose jar dependencies outside of the starters.",
	"SpringBootApplication - AutoConfiguration - @EnableAutoConfiguration - With Starters": "Since spring-boot-starter-web added Tomcat and Spring MVC, the auto-configuration assumes that you are developing a web application and sets up Spring accordingly. Starters and Auto-configuration Auto-configuration is designed to work well with 'Starters', but the two concepts are not directly tied. You are free to pick and choose jar dependencies outside of the starters.",
	"SpringBootApplication - AutoConfiguration - @EnableAutoConfiguration - replacing": "Auto-configuration is non-invasive. At any point, you can start to define your own configuration to replace specific parts of the auto-configuration. For example, if you add your own DataSource bean, the default embedded database support backs away.",
	"SpringBootApplication - AutoConfiguration - @EnableAutoConfiguration - debug": " If you need to find out what auto-configuration is currently being applied, and why, start your application with the --debug switch. Doing so enables debug logs for a selection of core loggers and logs a conditions report to the console.",
	"SpringBootApplication - AutoConfiguration - @ImportAutoConfiguration": "Import and apply the specified auto-configuration classes. Applies the same ordering rules as @EnableAutoConfiguration but restricts the auto-configuration classes to the specified set, rather than consulting spring.factories.",
	"SpringBootApplication - AutoConfiguration - @ImportAutoConfiguration - exclude": "Can also be used to exclude() specific auto-configuration classes such that they will never be applied.",
	"SpringBootApplication - AutoConfiguration - @ImportAutoConfiguration - preference": "Generally, @EnableAutoConfiguration should be used in preference to this annotation, however.",
	"SpringBootApplication - AutoConfiguration - @ImportAutoConfiguration - usage": "@ImportAutoConfiguration can be useful in some situations and especially when writing tests.",
	"SpringBootApplication - AutoConfiguration - @AutoConfigureBefore": "Hint for that an auto-configuration should be applied before other specified auto-configuration classes.",
	"SpringBootApplication - AutoConfiguration - @AutoConfigureAfter": "Hint for that an auto-configuration should be applied after other specified auto-configuration classes.",
	"SpringBootApplication - AutoConfiguration - @AutoConfigureOrder": "Auto-configuration specific variant of Spring Framework's Order annotation.",
	"SpringBootApplication - AutoConfiguration - Conditional": "from Spring Core. You almost always want to include one or more @Conditional annotations on your auto-configuration class.",
	"SpringBootApplication - AutoConfiguration - Conditional - @ConditionalOnClass": "Conditional that only matches when the specified classes are on the classpath.",
	"SpringBootApplication - AutoConfiguration - Conditional - @ConditionalOnMissingClass": "Conditional that only matches when the specified classes are not on the classpath.",
	"SpringBootApplication - AutoConfiguration - Conditional - @ConditionalOnBean": "Conditional that only matches when the specified bean classes and/or names are already contained in the BeanFactory.",
	"SpringBootApplication - AutoConfiguration - Conditional - @ConditionalOnMissingBean": "Conditional that only matches when the specified bean classes and/or names are not already contained in the BeanFactory.",
	"SpringBootApplication - AutoConfiguration - Conditional - @ConditionalOnProperty": "The @ConditionalOnProperty annotation lets configuration be included based on a Spring Environment property. Use the prefix and name attributes to specify the property that should be checked. By default, any property that exists and is not equal to false is matched. You can also create more advanced checks by using the havingValue and matchIfMissing attributes.",
	"SpringBootApplication - AutoConfiguration - Conditional - @ConditionalOnResource": "The @ConditionalOnResource annotation lets configuration be included only when a specific resource is present. Resources can be specified by using the usual Spring conventions, as shown in the following example: file:/home/user/test.dat.",
	"SpringBootApplication - AutoConfiguration - Conditional - @ConditionalOnWebApplication": "Conditional that matches when the application is a web application. By default, any web application will match but it can be narrowed using the type() attribute.",
	"SpringBootApplication - AutoConfiguration - Conditional - @ConditionalOnNotWebApplication": "Conditional that only matches when the application context is a not a web application context.",
	"SpringBootApplication - AutoConfiguration - Conditional - @ConditionalOnExpression": "The @ConditionalOnExpression annotation lets configuration be included based on the result of a SpEL expression.",
	"SpringBootApplication - Bootstrap - main": "The SpringApplication class provides a convenient way to bootstrap a Spring application that is started from a main() method. In many situations, you can delegate to the static SpringApplication.run method, e.g. SpringApplication.run(MySpringConfiguration.class, args),",
	"SpringBootApplication - Bootstrap - WebApplicationType": "A SpringApplication attempts to create the right type of ApplicationContext on your behalf.",
	"SpringBootApplication - Bootstrap - WebApplicationType - algorithm": "The algorithm used to determine a WebApplicationType is fairly simple: (1) If Spring MVC is present, an AnnotationConfigServletWebServerApplicationContext is use (2) If Spring MVC is not present and Spring WebFlux is present, an AnnotationConfigReactiveWebServerApplicationContext is use (3) Otherwise, AnnotationConfigApplicationContext is used",
	"SpringBootApplication - Bootstrap - WebApplicationType - enumeration": "An enumeration of possible types of web application: NONE, REACTIVE, SERVLET. Sets the type of web application to be run. with setWebApplicationType(WebApplicationType webApplicationType)",
	"SpringBootApplication - Bootstrap - WebApplicationType - NONE": "The application should not run as a web application and should not start an embedded web server.",
	"SpringBootApplication - Bootstrap - WebApplicationType - REACTIVE": "The application should run as a reactive web application and should start an embedded reactive web server.",
	"SpringBootApplication - Bootstrap - WebApplicationType - SERVLET": "The application should run as a servlet-based web application and should start an embedded servlet web server.",
	"SpringBootApplication - Bootstrap - run - Method - args": "run(String... args) Run the Spring application, creating and refreshing a new ApplicationContext.",
	"SpringBootApplication - Bootstrap - run - Method - primarySource": "run(Class< ?> primarySource, String... args) Static helper that can be used to run a SpringApplication from the specified source using default settings.",
	"SpringBootApplication - Bootstrap - run - Method - primarySources": "run(Class< ?>[] primarySources, String[] args). Static helper that can be used to run a SpringApplication from the specified sources using default settings and user supplied arguments.",
	"SpringBootApplication - Bootstrap - run - Arguments": "If you need to access the application arguments that were passed to SpringApplication.run(…​), you can inject a org.springframework.boot.ApplicationArguments bean. The ApplicationArguments interface provides access to both the raw String[] arguments as well as parsed option and non-option arguments,",
	"SpringBootApplication - Bootstrap - Process": "Steps by default: (1) ApplicationContext (2) CommandLinePropertySource (3) loading beans (4) CommandLineRunner",
	"SpringBootApplication - Bootstrap - Process - (1) ApplicationContext": "You typically don’t need to manually create an ApplicationContext—instead, rely on SpringApplication.run().",
	"SpringBootApplication - Bootstrap - Process - (1) ApplicationContext - Containers": "Supports: Tomcat 9.0 (servlets 4.0), Jetty 9.4 (servlets 3.1), Undertow 2.0 (servlets 4.0)",
	"SpringBootApplication - Bootstrap - Process - (1) ApplicationContext - ApplicationContextInitializers": "from Spring Core",
	"SpringBootApplication - Bootstrap - Process - (1) ApplicationContext - ApplicationContextInitializers - addInitializers(ApplicationContextInitializer< ?>... initializers)": "Add ApplicationContextInitializers to be applied to the Spring ApplicationContext.",
	"SpringBootApplication - Bootstrap - Process - (1) ApplicationContext - ApplicationContextInitializers - applyInitializers(ConfigurableApplicationContext context)": "Apply any ApplicationContextInitializers to the context before it is refreshed.",
	"SpringBootApplication - Bootstrap - Process - (1) ApplicationContext - ApplicationContextInitializers - getInitializers()": "Returns read-only ordered Set of the ApplicationContextInitializers that will be applied to the Spring ApplicationContext.",
	"SpringBootApplication - Bootstrap - Process - (1) ApplicationContext - ApplicationContextInitializers - setInitializers(Collection< ? extends ApplicationContextInitializer< ?>> initializers)": "Sets the ApplicationContextInitializer that will be applied to the Spring ApplicationContext.",
	"SpringBootApplication - Bootstrap - Process - (1) ApplicationContext - ApplicationContextInitializers - ConfigFileApplicationContextInitializer": "ConfigFileApplicationContextInitializer is an ApplicationContextInitializer that you can apply to your tests to load Spring Boot application.properties files..",
	"SpringBootApplication - Bootstrap - Process - (2) CommandLinePropertySource": "Register a CommandLinePropertySource to expose command line arguments as Spring properties",
	"SpringBootApplication - Bootstrap - Process - (3) LoadBeans": "Refresh the application context, loading all singleton beans",
	"SpringBootApplication - Bootstrap - Process - (4) CommandLineRunner": "Trigger any CommandLineRunner beans",
	"SpringBootApplication - Bootstrap - Process - (4) CommandLineRunner - Runners": "If you need to run some specific code once the SpringApplication has started, you can implement the ApplicationRunner or CommandLineRunner interfaces.",
	"SpringBootApplication - Bootstrap - Process - (4) CommandLineRunner - Runners - run": "Both interfaces ovveride the run method.",
	"SpringBootApplication - Bootstrap - Process - (4) CommandLineRunner - Runners - ApplicationRunner": "The ApplicationRunner interfaces provides access to application arguments using the ApplicationArguments interface",
	"SpringBootApplication - Bootstrap - Process - (4) CommandLineRunner - Runners - CommandLineRunner": "The CommandLineRunner interfaces provides access to application arguments as a simple string array.",
	"SpringBootApplication - Bootstrap - Process - (4) CommandLineRunner - Runners - order": "If several CommandLineRunner or ApplicationRunner beans are defined that must be called in a specific order, you can additionally implement the org.springframework.core.Ordered interface or use the org.springframework.core.annotation.Order annotation.",
	"SpringBootApplication - Envs - Standalone - ApplicationContext - AnnotationConfigApplicationContext": "Used for standalone Java-based configuration (non-web applications). Loads @Configuration classes and @Component-annotated beans.",
	"SpringBootApplication - Envs - Standalone - ApplicationContext - FileSystemXmlApplicationContext": "Used for XML-based configuration (non-web).",
	"SpringBootApplication - Envs - Standalone - ApplicationContext - ClassPathXmlApplicationContext": "Used for XML-based configuration (non-web).",
	"SpringBootApplication - Envs - Web - ApplicationContext - ApplicationContext - XmlWebApplicationContext": "Legacy ApplicationContext for XML-based configuration in web apps. Rarely used in Spring Boot (preferring JavaConfig).",
	"SpringBootApplication - Envs - Web - ApplicationContext - GenericWebApplicationContext": "A general-purpose ApplicationContext for web environments. Used when programmatically configuring a web app.",
	"SpringBootApplication - Envs - Web - ApplicationContext - ServletWebServerApplicationContext": "This is a subclass of GenericWebApplicationContext that is designed specifically for applications with a servlet stack. Under the hood, Spring Boot uses a different type of ApplicationContext for embedded servlet container support. The ServletWebServerApplicationContext is a special type of WebApplicationContext that bootstraps itself by searching for a single ServletWebServerFactory bean.",
	"SpringBootApplication - Envs - Web - ApplicationContext - ServletWebServerApplicationContext - ServletWebServerFactory": "Factory interface that can be used to create a WebServer.",
	"SpringBootApplication - Envs - Web - ApplicationContext - ServletWebServerApplicationContext - ServletWebServerFactory - TomcatServletWebServerFactory": "AbstractServletWebServerFactory that can be used to create TomcatWebServers. Can be initialized using Spring's ServletContextInitializers or Tomcat LifecycleListeners. Unless explicitly configured otherwise this factory will create containers that listen for HTTP requests on port 8080.",
	"SpringBootApplication - Envs - Web - ApplicationContext - ServletWebServerApplicationContext - ServletWebServerFactory - JettyServletWebServerFactory": "ServletWebServerFactory that can be used to create a JettyWebServer. Can be initialized using Spring's ServletContextInitializers or Jetty Configurations. Unless explicitly configured otherwise this factory will create servers that listen for HTTP requests on port 8080.",
	"SpringBootApplication - Envs - Web - ApplicationContext - ServletWebServerApplicationContext - ServletWebServerFactory - UndertowServletWebServerFactory": "ServletWebServerFactory that can be used to create UndertowServletWebServers. Unless explicitly configured otherwise, the factory will create servers that listen for HTTP requests on port 8080.",
	"SpringBootApplication - Envs - Web - ApplicationContext - AnnotationConfigWebApplicationContext": "Used for web applications with Java-based configuration.",
	"SpringBootApplication - Envs - Web - ApplicationContext - AnnotationConfigWebApplicationContext - extends": "Extends GenericWebApplicationContext and is typically used in Servlet-based web apps.",
	"SpringBootApplication - Envs - Web - ApplicationContext - AnnotationConfigServletWebServerApplicationContext": "Default for Web",
	"SpringBootApplication - Envs - Web - ApplicationContext - AnnotationConfigReactiveWebServerApplicationContext": "Default for Reactive",
	"SpringBootApplication - Envs - Web - ApplicationContext - Decision": "Spring Boot automatically selects the appropriate ApplicationContext based on the application type (web/reactive/non-web) as configured in the starters.",
	"SpringBootApplication - Envs - Web - ApplicationContext - Decision - spring-boot-starter-web": "If spring-boot-starter-web is present → Servlet-based ApplicationContext.",
	"SpringBootApplication - Envs - Web - ApplicationContext - Decision - spring-boot-starter-webflux": "If spring-boot-starter-webflux is present → Reactive ApplicationContext.",
	"SpringBootApplication - Envs - Web - ApplicationContext - Decision - none": "If neither is present → Defaults to a non-web ApplicationContext.",
	"SpringBootApplication - Envs - Web - Components": "Any Servlet, Filter, or servlet *Listener instance that is a Spring bean is registered with the embedded container. This can be particularly convenient if you want to refer to a value from your application.properties during configuration.",
	"SpringBootApplication - Envs - Web - Components - Servlets - Scan - @ServletComponentScan": "When using an embedded container, automatic registration of classes annotated with @WebServlet, @WebFilter, and @WebListener Java annos can be enabled by using @ServletComponentScan.",
	"SpringBootApplication - Envs - Web - Components - Servlets - Declaring - @WebServlet": ".",
	"SpringBootApplication - Envs - Web - Components - Servlets - Registration - ServletRegistrationBean": "A ServletContextInitializer to register Servlets in a Servlet 3.0+ container. Similar to the registration features provided by ServletContext but with a Spring Bean friendly design. The servlet must be specified before calling RegistrationBean.onStartup(javax.servlet.ServletContext). URL mapping can be configured used setUrlMappings(java.util.Collection<java.lang.String>) or omitted when mapping to '/*' (unless alwaysMapUrl is set to false). The servlet name will be deduced if not specified.",
	"SpringBootApplication - Envs - Web - Components - Servlets - Registration - @ServletRegistration - SpringBoot3.5": ".",
	"SpringBootApplication - Envs - Web - Components - Servlets - path": "By default, if the context contains only a single Servlet, it is mapped to /. In the case of multiple servlet beans, the bean name is used as a path prefix. Filters map to /*.",
	"SpringBootApplication - Envs - Web - Components - JSP - limitations": "When running a Spring Boot application that uses an embedded servlet container (and is packaged as an executable archive), there are some limitations in the JSP support. With Jetty and Tomcat, it should work if you use war packaging. An executable war will work when launched with java -jar, and will also be deployable to any standard container. JSPs are not supported when using an executable jar. Undertow does not support JSPs. Creating a custom error.jsp page does not override the default view for error handling. Custom error pages should be used instead.",
	"SpringBootApplication - Envs - Web - Components - Filters - Types - OrderedCharacterEncodingFilter": "",
	"SpringBootApplication - Envs - Web - Components - Filters - Types - WebMvcMetricsFilter": "",
	"SpringBootApplication - Envs - Web - Components - Filters - Types - ErrorPageFilter": "",
	"SpringBootApplication - Envs - Web - Components - Filters - Types - HttpTraceFilter": "",
	"SpringBootApplication - Envs - Web - Components - Filters - Declaring - @WebFilter": "@WebFilter(urlPatterns = '/*') public class LoggingFilter implements Filter { ... }",
	"SpringBootApplication - Envs - Web - Components - Filters - Registration - FilterRegistrationBean": "A ServletContextInitializer to register Filters in a Servlet 3.0+ container. Similar to the registration features provided by ServletContext but with a Spring Bean friendly design. The Filter must be specified before calling RegistrationBean.onStartup(ServletContext). Registrations can be associated with URL patterns and/or servlets (either by name or via a ServletRegistrationBeans. When no URL pattern or servlets are specified the filter will be associated to '/*'. The filter name will be deduced if not specified.",
	"SpringBootApplication - Envs - Web - Components - Filters - Registration - @FilterRegistration - SpringBoot3.5": ".",
	"SpringBootApplication - Envs - Web - Components - Listener - Types - ServletContextAttributeListener": "",
	"SpringBootApplication - Envs - Web - Components - Listener - Types - ServletRequestListener": "",
	"SpringBootApplication - Envs - Web - Components - Listener - Types - ServletRequestAttributeListener": "",
	"SpringBootApplication - Envs - Web - Components - Listener - Types - HttpSessionAttributeListener": "",
	"SpringBootApplication - Envs - Web - Components - Listener - Types - HttpSessionListener": "",
	"SpringBootApplication - Envs - Web - Components - Listener - Types - ServletContextListener": "",
	"SpringBootApplication - Envs - Web - Components - Listener - Registration - ServletListenerRegistrationBean": "A ServletContextInitializer to register EventListeners in a Servlet 3.0+ container. Similar to the registration features provided by ServletContext but with a Spring Bean friendly design. This bean can be used to register the following types of listener: ServletContextAttributeListener ServletRequestListener ServletRequestAttributeListener HttpSessionAttributeListener HttpSessionListener ServletContextListener",
	"SpringBootApplication - Envs - Web - Components - Customize - by config": "Common servlet container settings can be configured by using Spring Environment properties. Usually, you would define the properties in your application.properties file.",
	"SpringBootApplication - Envs - Web - Components - Customize - by programmatically - WebServerFactoryCustomizer": "If you need to programmatically configure your embedded servlet container, you can register a Spring bean that implements the WebServerFactoryCustomizer interface. WebServerFactoryCustomizer provides access to the ConfigurableServletWebServerFactory, which includes numerous customization setter methods. ",
	"SpringBootApplication - Envs - Web - Components - Customize - by programmatically - ConfigurableServletWebServerFactory ": "If the preceding customization techniques are too limited, you can register the TomcatServletWebServerFactory, JettyServletWebServerFactory, or UndertowServletWebServerFactory bean yourself. @Bean public ConfigurableServletWebServerFactory webServerFactory() { ... }",
	"SpringBootApplication - Envs - Web - Components - Caching": "The Spring Framework provides support for transparently adding caching to an application. At its core, the abstraction applies caching to methods, thus reducing the number of executions based on the information available in the cache. The caching logic is applied transparently, without any interference to the invoker.",
	"SpringBootApplication - Envs - Web - Components - Caching - EnableCaching": "Spring Boot auto-configures the cache infrastructure as long as caching support is enabled via the @EnableCaching annotation. When @EnableCaching is present in your configuration, a suitable cache configuration is expected as well. If you need to disable caching altogether in certain environments, force the cache type to none to use a no-op implementation, as shown in the following example: spring.cache.type=none",
	"SpringBootApplication - Shutdown - setRegisterShutdownHook": "SpringApplication#setRegisterShutdownHook(boolean registerShutdownHook). Each SpringApplication registers a shutdown hook with the JVM to ensure that the ApplicationContext closes gracefully on exit. All the standard Spring lifecycle callbacks (such as the DisposableBean interface or the @PreDestroy annotation) can be used. In addition, beans may implement the org.springframework.boot.ExitCodeGenerator interface if they wish to return a specific exit code when SpringApplication.exit() is called. This exit code can then be passed to System.exit(). Also, the ExitCodeGenerator interface may be implemented by exceptions. When such an exception is encountered, Spring Boot returns the exit code provided by the implemented getExitCode() method.",

	"CI - Architecture": "SECTION",
	"CI - Architecture - Layers": "",
	"CI - Architecture - Layers - @Controller": "",
	"CI - Architecture - Layers - @Service": "",
	"CI - Architecture - Layers - @Service - Benefits - SeparationOfConcerns": "The DAO layer separates the data access logic from the business logic, allowing each layer to focus on its specific responsibility. Benefit: This leads to cleaner code, as your business logic does not need to worry about how the data is retrieved, stored, or updated.",
	"CI - Architecture - Layers - @Service - Benefits - Maintainability": "Since the data access logic is centralized in one layer, changes to the underlying data store (such as switching from one database to another) can be made in just the DAO layer without impacting the rest of the application. Benefit: Easier to maintain and refactor the application as the data access logic is isolated and doesn’t spread across the application.",
	"CI - Architecture - Layers - @Service - Benefits - CodeReusability": "The DAO layer allows you to encapsulate common data access operations (like save, update, delete, and find) in reusable methods. Benefit: This leads to less duplication of code, as any part of your application that needs to interact with the database can reuse the DAO layer.",
	"CI - Architecture - Layers - @Service - Benefits - DataSourceIndependence": "The DAO layer abstracts the underlying data source. If you need to switch from one database (e.g., MySQL) to another (e.g., MongoDB), you can modify the DAO layer with minimal changes to the business logic. Benefit: Decoupling the data source from the rest of the application allows for greater flexibility in choosing or changing data stores.",
	"CI - Architecture - Layers - @Service - Benefits - SimplifiedUnitTesting": "The DAO layer can be easily mocked or stubbed in unit tests, allowing you to test the business logic in isolation without needing an actual database connection. Benefit: It improves testability by enabling you to simulate different data access scenarios without the overhead of setting up a database.",
	"CI - Architecture - Layers - @Service - Benefits - TransactionManagement": "The DAO layer allows for better handling of transactions, especially when dealing with multiple database operations in a single transaction. Benefit: It simplifies transaction management by centralizing it in the DAO, and you can easily use @Transactional in a service layer to ensure consistency.",
	"CI - Architecture - Layers - @Service - Benefits - EncapsulationAndSecurity": "The DAO layer acts as a gatekeeper between the database and the rest of the application, controlling access to the data and hiding the complexities of direct database access (such as SQL queries, connections, etc.). Benefit: This improves security and reduces the risk of exposing sensitive database logic or vulnerabilities (e.g., SQL injection).",
	"CI - Architecture - Layers - @Service - Benefits - ImprovedReadability": "By abstracting the complexity of database queries and data handling into the DAO layer, your codebase becomes more readable and focused on higher-level operations. Benefit: Better organization of code, as the business logic is not cluttered with low-level database interactions.",
	"CI - Architecture - Layers - @Service - Benefits - FlexibilityDataHandling": "The DAO layer can offer more flexible methods for complex querying, including custom SQL or specific data transformations. Benefit: You can handle data operations in a customizable way, without cluttering the service layer or business logic.",
	"CI - Architecture - Layers - @Repository": "",

	"CI - Development": "SECTION",
	"CI - Development - Logging": "",
	"CI - Development - Logging - SLF4J": "",
	"CI - Development - Exceptions - @ControllerAdvice": "@ControllerAdvice is used to define a global exception handler for the entire application, combined with @ExceptionHandler to specify how to handle particular exceptions.",
	"CI - Development - Exceptions - @ExceptionHandler": "@ControllerAdvice is used to define a global exception handler for the entire application, combined with @ExceptionHandler to specify how to handle particular exceptions.",
	"CI - Development - Exceptions - @ResponseStatus": "",

  "CI - Packaging": "SECTION",
	"CI - Packaging - Resolution - Classes - Staterts": "Spring Boot provides a number of “Starters” that let you add jars to your classpath. Starters are a set of convenient dependency descriptors that you can include in your application. You get a one-stop shop for all the Spring and related technologies that you need without having to hunt through sample code and copy-paste loads of dependency descriptors. For example, if you want to get started using Spring and JPA for database access, include the spring-boot-starter-data-jpa dependency in your project. The starters contain a lot of the dependencies that you need to get a project up and running quickly and with a consistent, supported set of managed transitive dependencies.",
	"CI - Packaging - Resolution - Classes - Staterts - spring-boot-starter": "Core starter, including auto-configuration support, logging and YAML",
	"CI - Packaging - Resolution - Classes - Starters - spring-boot-starter-parent": "Parent POM. All Spring Boot projects typically use spring-boot-starter-parent as the parent in pom.xml.",
	"CI - Packaging - Resolution - Classes - Starters - spring-boot-starter-web": "POM Dependency",
	"CI - Packaging - Resolution - Classes - Starters - spring-boot-starter-webflux": "POM Dependency",
	"CI - Packaging - Resolution - Classes - Starters - spring-boot-starter-jersey": "POM Dependency",
	"CI - Packaging - Resolution - Classes - Starters - spring-boot-starter-integration": "POM Dependency",
	"CI - Packaging - Resolution - Classes - Starters - spring-boot-starter-test": "POM Dependency",
	"CI - Packaging - Resolution - Classes - Basic Example": "(1) Add spring-boot-starter-parent as parent in pom (2) add spring-boot-starter-web as dependency in pom",
	"CI - Packaging - Resolution - PropertyValues - application.properties": "",
	"CI - Packaging - Resolution - PropertyValues - ResourceLoader": "from Spring Core",
	"CI - Packaging - Resolution - PropertyValues - ResourceLoader#getResourceLoader()": "The ResourceLoader that will be used in the ApplicationContext.",
	"CI - Packaging - Resolution - PropertyValues - ResourceLoader#setResourceLoader(ResourceLoader resourceLoader)": "Sets the ResourceLoader that should be used when loading resources.",
	"CI - Packaging - Resolution - PropertyValues - application.properties - Hierarchy": "Spring Boot uses a very particular PropertySource order that is designed to allow sensible overriding of values. Properties are considered in the following order:",
	"CI - Packaging - Resolution - PropertyValues - application.properties - Hierarchy - (1) Devtools": "(1) Devtools global settings properties on your home directory (~/.spring-boot-devtools.properties when devtools is active).",
	"CI - Packaging - Resolution - PropertyValues - application.properties - Hierarchy - (2) @TestPropertySource": "(2) @TestPropertySource annotations on your tests.",
	"CI - Packaging - Resolution - PropertyValues - application.properties - Hierarchy - (3) properties": "(3) properties attribute on your tests. Available on @SpringBootTest and the test annotations for testing a particular slice of your application.",
	"CI - Packaging - Resolution - PropertyValues - application.properties - Hierarchy - (4) CommandLineArguments": "(4) Command line arguments.",
	"CI - Packaging - Resolution - PropertyValues - application.properties - Hierarchy - (5) SPRING_APPLICATION_JSON": "(5) Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property).",
	"CI - Packaging - Resolution - PropertyValues - application.properties - Hierarchy - (6) ServletConfig": "(6) ServletConfig init parameters.",
	"CI - Packaging - Resolution - PropertyValues - application.properties - Hierarchy - (7) ServletContext": "(7) ServletContext init parameters.",
	"CI - Packaging - Resolution - PropertyValues - application.properties - Hierarchy - (8) JNDI": "(8) JNDI attributes from java:comp/env.",
	"CI - Packaging - Resolution - PropertyValues - application.properties - Hierarchy - (9) JavaSystemProperties": "(9) Java System properties (System.getProperties()).",
	"CI - Packaging - Resolution - PropertyValues - application.properties - Hierarchy - (10) EnvVars": "(10) OS environment variables.",
	"CI - Packaging - Resolution - PropertyValues - application.properties - Hierarchy - (11) RandomValuePropertySource": "(11) A RandomValuePropertySource that has properties only in random.*.",
	"CI - Packaging - Resolution - PropertyValues - application.properties - Hierarchy - (12) ProfileSpecificApplicationProperties": "(12) Profile-specific application properties outside of your packaged jar (application-{profile}.properties and YAML variants).",
	"CI - Packaging - Resolution - PropertyValues - application.properties - Hierarchy - (13) ProfileSpecificInJAR": "(13) Profile-specific application properties packaged inside your jar (application-{profile}.properties and YAML variants).",
	"CI - Packaging - Resolution - PropertyValues - application.properties - Hierarchy - (14) ProfileSpecificOutOfJAR": "(14) Application properties outside of your packaged jar (application.properties and YAML variants).",
	"CI - Packaging - Resolution - PropertyValues - application.properties - Hierarchy - (15) ApplicationProperties": "(15) Application properties packaged inside your jar (application.properties and YAML variants).",
	"CI - Packaging - Resolution - PropertyValues - application.properties - Hierarchy - (16) @PropertySource": "(16) @PropertySource annotations on your @Configuration classes.",
	"CI - Packaging - Resolution - PropertyValues - application.properties - Hierarchy - (17) setDefaultProperties": "(17) Default properties (specified by setting SpringApplication.setDefaultProperties).",
	"CI - Packaging - Resolution - PropertyValues - application.properties - CommandLineProperties": "By default, SpringApplication converts any command line option arguments (that is, arguments starting with --, such as --server.port=9000) to a property and adds them to the Spring Environment. As mentioned previously, command line properties always take precedence over other property sources. If you do not want command line properties to be added to the Environment, you can disable them by using SpringApplication.setAddCommandLineProperties(false).",
	"CI - Packaging - Resolution - PropertyValues - application.properties - PropfileSpecificProperties": "In addition to application.properties files, profile-specific properties can also be defined by using the following naming convention: application-{profile}.properties. The Environment has a set of default profiles (by default, [default]) that are used if no active profiles are set. In other words, if no profiles are explicitly activated, then properties from application-default.properties are loaded. Profile-specific properties are loaded from the same locations as standard application.properties, with profile-specific files always overriding the non-specific ones, whether or not the profile-specific files are inside or outside your packaged jar..",
	"CI - Packaging - Resolution - PropertyValues - application.properties - Claspath": "SpringBootApplication loads properties from application.properties files in the following locations and adds them to the Spring Environment: (1) A /config subdirectory of the current director (2) The current directory (3) A classpath /config package (4) The classpath root (5) The list is ordered by precedence (properties defined in locations higher in the list override those defined in lower locations).",
	"CI - Packaging - Resolution - PropertyValues - application.properties - Placeholders": "The values in application.properties are filtered through the existing Environment when they are used, so you can refer back to previously defined values (for example, from System properties). app.name=MyApp app.description=${app.name}.",
	"CI - Packaging - Resolution - PropertyValues - @ConfigurationProperties Claspath": "If you define a set of configuration keys for your own components, we recommend you group them in a POJO annotated with @ConfigurationProperties.",
	"CI - Packaging - Resolution - PropertyValues - @ConfigurationProperties - RelaxedBinding": "Spring Boot uses some relaxed rules for binding Environment properties to @ConfigurationProperties beans, so there does not need to be an exact match between the Environment property name and the bean property name. Common examples where this is useful include dash-separated environment properties (for example, context-path binds to contextPath), and capitalized environment properties (for example, PORT binds to port).",
	"CI - Packaging - Resolution - PropertyValues - @ConfigurationProperties - Conversion": "If you need custom type conversion, you can provide a ConversionService bean (with a bean named conversionService) or custom property editors (through a CustomEditorConfigurer bean) or custom Converters (with bean definitions annotated as @ConfigurationPropertiesBinding).",
	"CI - Packaging - Resolution - PropertyValues - @ConfigurationProperties - Conversion - @DurationUnit": "Spring Boot has dedicated support for expressing durations. If you expose a java.time.Duration property, the following formats in application properties are available: (1) A regular long representation (using milliseconds as the default unit unless a @DurationUnit has been specified) (2) The standard ISO-8601 format used by java.util.Duration (3) A more readable format where the value and the unit are coupled (e.g. 10s means 10 seconds).",
	"CI - Packaging - Resolution - PropertyValues - @ConfigurationProperties - Conversion - @DataSizeUnit": "Spring Framework has a DataSize value type that allows to express size in bytes. If you expose a DataSize property, the following formats in application properties are available: (1) A regular long representation (using bytes as the default unit unless a @DataSizeUnit has been specified) (2) A more readable format where the value and the unit are coupled (e.g. 10MB means 10 megabytes)",
	"CI - Packaging - Resolution - PropertyValues - @ConfigurationProperties - @Validated": "Spring Boot attempts to validate @ConfigurationProperties classes whenever they are annotated with Spring’s @Validated annotation. You can use JSR-303 javax.validation constraint annotations directly on your configuration class. To do so, ensure that a compliant JSR-303 implementation is on your classpath and then add constraint annotations to your fields",
	"CI - Packaging - Resolution - PropertyValues - @ConfigurationProperties vs @Value (Spring Core)": "@ConfigurationProperties adds MetaData support and Relaxed Binging. @Value instead allows SpEL",

  "CI - Building": "SECTION",
	"CI - Building - BuildSystem - maven (with parent POM)": "Maven users can inherit from the spring-boot-starter-parent project to obtain sensible defaults (parent POM). < parent >< artifactId >spring-boot-starter-parent</artifactId > < /parent >",
	"CI - Building - BuildSystem - maven (without parent POM)": "If you do not want to use the spring-boot-starter-parent, you can still keep the benefit of the dependency management (but not the plugin management) by using a scope=import dependency,",	
	"CI - Building - BuildSystem - maven - spring-boot-maven-plugin": "The spring-boot-maven-plugin can be used to create an executable “fat” JAR.",
	"CI - Building - BuildSystem - gradle": "The Spring Boot Gradle Plugin provides Spring Boot support in Gradle, allowing you to package executable jar or war archives, run Spring Boot applications, and use the dependency management provided by spring-boot-dependencies. ",
	"CI - Building - BuildSystem - ant": "It is possible to build a Spring Boot project using Apache Ant+Ivy. The spring-boot-antlib “AntLib” module is also available to help Ant create executable jars.",
	"CI - Building - BuildSystem - BuildPacks": "Spring Boot builds plugins for Maven or Gradle are integrated with Cloud Native Buildpacks to create docker images. In this way, we do not need to provide a Dockerfile, but we do need a Docker daemon, and also, we don't need to change the pom.xml file in our services. ",
	"CI - Building - BuildSystem - BuildPacks - SpringBoot3.5": "Spring Boot 3.5 introduced several key improvements to Cloud Native Buildpacks support, focusing on better image optimization, enhanced logging, and updated default builders.",

	"CD - Deployment": "SECTION",
	"CD - Deployment - EverythingAsCode": "https://medium.com/@vermatanisha666/spring-boot-3-5-the-update-that-fixed-everything-wrong-with-java-microservices-db71c45814d4",
	"CD - Deployment - EverythingAsCode - SoC": "Critics argue this approach violates separation of concerns, creating tighter coupling between application code and infrastructure. Supporters counter that this unified model allows for true infrastructure-as-code with compile-time validation and version-controlled changes.",

	"CI - Integration": "SECTION",
	"CI - Integration - Threads - Multiplicity": "The thread pool uses 8 core threads that can grow and shrink according to the load.",
	"CI - Integration - Threads - Configure": "The thread pool uses one thread by default and those settings can be fine-tuned using the spring.task.scheduling namespace.",
	"CI - Integration - Threads - Configure - @EnableAsync": "The @EnableAsync annotation is defined in the Spring Framework as part of the spring-context module. It enables Spring's asynchronous method execution capability, allowing methods annotated with @Async to run in a separate thread.",
	"CI - Integration - Threads - Configure - @EnableAsync - @Async": ".",
	"CI - Integration - Threads - Configure - Executor": "",
	"CI - Integration - Threads - Configure - Executor - PlatformThreads - ThreadPoolTaskExecutor": "",
	"CI - Integration - Threads - Configure - Executor - PlatformThreads - ThreadPoolTaskExecutor - default": "In the absence of a TaskExecutor bean in the context, Spring Boot auto-configures a ThreadPoolTaskExecutor with sensible defaults that can be automatically associated to asynchronous task execution (@EnableAsync) and Spring MVC asynchronous request processing.",
	"CI - Integration - Threads - Configure - Executor - VirtuaThreads": "@Bean(name = 'virtualExecutor') public Executor virtualExecutor() { return Executors.newVirtualThreadPerTaskExecutor(); }",
	"CI - Integration - Threads - Configure - Scheduling": "Scheduling tasks in your Spring applications can be an effective way to automate processes, perform maintenance, and enhance your application’s functionality.",
	"CI - Integration - Threads - Configure - Scheduling - @EnableScheduling": ".",
	"CI - Integration - Threads - Configure - Scheduling - @Scheduled": "This annotation can be applied to any method, which will then be executed according to the specified schedule. @Scheduled(fixedRate = 5000)",
	"CI - Integration - Threads - Configure - Scheduling - TaskScheduler": "Spring 3.0 introduced TaskScheduler with a variety of methods designed to run at some point in the future.",
	"CI - Integration - Threads - Configure - Scheduling - TaskScheduler - Impl": "Consider your application’s requirements when choosing the right scheduler.",
	"CI - Integration - Threads - Configure - Scheduling - TaskScheduler - Impl - ThreadPoolTaskScheduler": "A ThreadPoolTaskScheduler can also be auto-configured if need to be associated to scheduled task execution (@EnableScheduling).",
	"CI - Integration - Threads - Configure - Scheduling - TaskScheduler - Impl - ThreadPoolTaskScheduler - setPoolSize": "Pool size: The number of threads in the thread pool",
	"CI - Integration - Threads - Configure - Scheduling - TaskScheduler - Impl - ThreadPoolTaskScheduler - setThreadNamePrefix": "Thread name prefix: A prefix for thread names, useful for debugging",
	"CI - Integration - Threads - Configure - Scheduling - TaskScheduler - Impl - ThreadPoolTaskScheduler - setWaitForTasksToCompleteOnShutdown": "Wait for tasks to complete on shutdown: A flag to indicate whether the scheduler should wait for scheduled tasks to complete before shutting down",
	"CI - Integration - Threads - Configure - Scheduling - TaskScheduler - Impl - ConcurrentTaskScheduler": "ConcurrentTaskScheduler: a lightweight scheduler that delegates to a single-threaded ScheduledExecutorService and is suitable for simple use cases",
	"CI - Integration - Threads - Configure - Scheduling - TaskScheduler - Impl - CronTaskScheduler": "CronTaskScheduler: a scheduler that supports cron expressions for scheduling tasks",
	"CI - Integration - Threads - Configure - Scheduling - ScheduledFuture": "TaskScheduler also returns a representation object of the ScheduledFuture interface, which we can use to cancel scheduled tasks and check to see if they’re done or not.",
	"CI - Integration - Threads - Configure - Scheduling - custom": "Both a TaskExecutorBuilder bean and a TaskSchedulerBuilder bean are made available in the context if a custom executor or scheduler needs to be created.",
	"CI - Integration - Environment - Environment": "from Spring Core",
	"CI - Integration - Environment - Environment - SpringApplication#configureEnvironment(ConfigurableEnvironment environment, String[] args)": "Template method delegating to configurePropertySources(ConfigurableEnvironment, String[]) and configureProfiles(ConfigurableEnvironment, String[]) in that order.",
	"CI - Integration - Environment - Environment - SpringApplication#bindToSpringApplication(ConfigurableEnvironment environment)": "Bind the environment to the SpringApplication.",
	"CI - Integration - Environment - Environment - SpringApplication#setEnvironment(ConfigurableEnvironment environment)": "Sets the underlying environment that should be used with the created application context.",
	"CI - Integration - Environment - Environment - SpringApplication#setWebEnvironment(boolean webEnvironment)": "since 2.0.0 in favor of setWebApplicationType(WebApplicationType)",
	"CI - Integration - Environment - Environment - SpringApplication#isWebEnvironment()": "since 2.0.0 in favor of getWebApplicationType()",
	"CI - Integration - Environment - Environment - SpringApplication#setDefaultProperties(Properties defaultProperties)": "Convenient alternative to setDefaultProperties(Map).",
	"CI - Integration - Environment - Environment - SpringApplication#setDefaultProperties(Map<String,Object> defaultProperties)": "Set default environment properties which will be used in addition to those in the existing Environment.",
	"CI - Integration - Environment - Profiles": "from Spring Core",
	"CI - Integration - Environment - Profiles - SpringApplication.setAdditionalProfiles(…​)": "Set additional profile values to use (on top of those set in system or command line properties).",
	"CI - Integration - Environment - Profiles - SpringApplication.configureProfiles(ConfigurableEnvironment environment, String[] args)": "Configure which profiles are active (or active by default) for this application environment.",
	"CI - Integration - Environment - PropertySources": "from Spring Core",
	"CI - Integration - Environment - PropertySources - SpringApplication#addPrimarySources(Collection<Class< ?>> additionalPrimarySources)": "Add additional items to the primary sources that will be added to an ApplicationContext when run(String...) is called.",
	"CI - Integration - Environment - PropertySources - SpringApplication#configurePropertySources(ConfigurableEnvironment environment, String[] args)": "Add, remove or re-order any PropertySources in this application's environment.",
	"CI - Integration - Environment - PropertySources - SpringApplication#getAllSources()": "Return an immutable set of all the sources that will be added to an ApplicationContext when run(String...) is called.",
	"CI - Integration - Environment - PropertySources - SpringApplication#getSources()": "Returns a mutable set of the sources that will be added to an ApplicationContext when run(String...) is called.",
	"CI - Integration - Environment - PropertySources - SpringApplication#setSources(Set<String> sources)": "Set additional sources that will be used to create an ApplicationContext.",
	"CI - Integration - Environment - PropertySources - SpringApplication#load(ApplicationContext context, Object[] sources)": "Load beans into the application context.",

	"CI - Testing": "SECTION",
	"CI - Testing - Modules": "Spring Boot provides a number of utilities and annotations to help when testing your application. Test support is provided by two modules: spring-boot-test contains core items, and spring-boot-test-autoconfigure supports auto-configuration for tests. Most developers use the spring-boot-starter-test “Starter”, which imports both Spring Boot test modules as well as JUnit, AssertJ, Hamcrest, and a number of other useful libraries.",
	"CI - Testing - @SpringBootTest": "Spring Boot provides a @SpringBootTest annotation, which can be used as an alternative to the standard spring-test @ContextConfiguration annotation when you need Spring Boot features. The annotation works by creating the ApplicationContext used in your tests through SpringApplication.",
	"CI - Testing - @SpringBootTest - webEnvironment": "By default, @SpringBootTest will not start a server. You can use the webEnvironment attribute of @SpringBootTest to further refine how your tests run: MOCK, RANDOM_PORT, DEFINED_PORT, NONE",
	"CI - Testing - @SpringBootTest - webEnvironment - MOCK (default)": "Loads a web ApplicationContext and provides a mock web environment. Embedded servers are not started when using this annotation. If a web environment is not available on your classpath, this mode transparently falls back to creating a regular non-web ApplicationContext. It can be used in conjunction with @AutoConfigureMockMvc or @AutoConfigureWebTestClient for mock-based testing of your web application.",
	"CI - Testing - @SpringBootTest - webEnvironment - RANDOM_PORT": "Loads a WebServerApplicationContext and provides a real web environment. Embedded servers are started and listen on a random port.",
	"CI - Testing - @SpringBootTest - webEnvironment - DEFINED_PORT": "Loads a WebServerApplicationContext and provides a real web environment. Embedded servers are started and listen on a defined port (from your application.properties or on the default port of 8080).",
	"CI - Testing - @SpringBootTest - webEnvironment - NONE": "Loads an ApplicationContext by using SpringApplication but does not provide any web environment (mock or otherwise).",
	"CI - Testing - AutoConfigured": "Spring Boot’s auto-configuration system works well for applications but can sometimes be a little too much for tests. It often helps to load only the parts of the configuration that are required to test a “slice” of your application. For example, you might want to test that Spring MVC controllers are mapping URLs correctly, and you do not want to involve database calls in those tests, or you might want to test JPA entities, and you are not interested in the web layer when those tests run. The spring-boot-test-autoconfigure module includes a number of annotations that can be used to automatically configure such “slices”. Each of them works in a similar way, providing a @…​Test annotation that loads the ApplicationContext and one or more @AutoConfigure…​ annotations that can be used to customize auto-configuration settings..",
	"CI - Testing - AutoConfigured - @AutoConfigureWebMvc": "Auto-configuration imports for typical Spring MVC tests. Most tests should consider using @WebMvcTest rather than using this annotation directly.",
	"CI - Testing - AutoConfigured - @AutoConfigureMockMvc": "Annotation that can be applied to a test class to enable and configure auto-configuration of MockMvc",
	"CI - Testing - AutoConfigured - @AutoConfigureTestDatabase": "Annotation that can be applied to a test class to configure a test database to use instead of any application defined or auto-configured DataSource.",
	"CI - Testing - AutoConfigured - TestSlices - SpringBoot1.4": "Test slicing is about segmenting the ApplicationContext that is created for your test. Typically, if you want to test a controller using MockMvc, surely you don’t want to bother with the data layer. Instead you’d probably want to mock the service that your controller uses and validate that all the web-related interaction works as expected.",
	"CI - Testing - AutoConfigured - TestSlices - @WebFluxTest": "Annotation that can be used in combination with @RunWith(SpringRunner.class) for a typical Spring WebFlux test. Can be used when a test focuses only on Spring WebFlux components Using this annotation will disable full auto-configuration and instead apply only configuration relevant to WebFlux tests (i.e. @Controller, @ControllerAdvice, @JsonComponent, Converter/GenericConverter, and WebFluxConfigurer beans but not @Component, @Service or @Repository beans). By default, tests annotated with @WebFluxTest will also auto-configure a WebTestClient. For more fine-grained control of WebTestClient the @AutoConfigureWebTestClient annotation can be used. Typically @WebFluxTest is used in combination with @MockBean or @Import to create any collaborators required by your @Controller beans. If you are looking to load your full application configuration and use WebTestClient, you should consider @SpringBootTest combined with @AutoConfigureWebTestClient rather than this annotation.",
	"CI - Testing - AutoConfigured - TestSlices - @RestClientTest": "Annotation that can be used in combination with @RunWith(SpringRunner.class) for a typical Spring rest client test. Can be used when a test focuses only on beans that use RestTemplateBuilder. Using this annotation will disable full auto-configuration and instead apply only configuration relevant to rest client tests (i.e. Jackson or GSON auto-configuration and @JsonComponent beans, but not regular @Component beans). By default, tests annotated with RestClientTest will also auto-configure a MockRestServiceServer. For more fine-grained control the @AutoConfigureMockRestServiceServer annotation can be used. If you are testing a bean that doesn't use RestTemplateBuilder but instead injects a RestTemplate directly, you can add @AutoConfigureWebClient(registerRestTemplate=true).",
	"CI - Testing - AutoConfigured - TestSlices - @WebMvcTest": "Annotation that can be used in combination with @RunWith(SpringRunner.class) for a typical Spring MVC test. Can be used when a test focuses only on Spring MVC components. Using this annotation will disable full auto-configuration and instead apply only configuration relevant to MVC tests (i.e. @Controller, @ControllerAdvice, @JsonComponent, Converte /GenericConverter, Filter, WebMvcConfigurer and HandlerMethodArgumentResolver beans but not @Component, @Service or @Repository beans). By default, tests annotated with @WebMvcTest will also auto-configure Spring Security and MockMvc (include support for HtmlUnit WebClient and Selenium WebDriver). For more fine-grained control of MockMVC the @AutoConfigureMockMvc annotation can be used. Typically @WebMvcTest is used in combination with @MockBean or @Import to create any collaborators required by your @Controller beans. If you are looking to load your full application configuration and use MockMVC, you should consider @SpringBootTest combined with @AutoConfigureMockMvc rather than this annotation. @AutoConfigureWebMvc + @AutoConfigureMockMvc + @ImportAutoConfiguration + .... ",
	"CI - Testing - AutoConfigured - TestSlices - @DataJPATest": "Annotation that can be used in combination with @RunWith(SpringRunner.class) for a typical JPA test. Can be used when a test focuses only on JPA components. Using this annotation will disable full auto-configuration and instead apply only configuration relevant to JPA tests. By default, tests annotated with @DataJpaTest will use an embedded in-memory database (replacing any explicit or usually auto-configured DataSource). The @AutoConfigureTestDatabase annotation can be used to override these settings. If you are looking to load your full application configuration, but use an embedded database, you should consider @SpringBootTest combined with @AutoConfigureTestDatabase rather than this annotation. provides some standard setup needed for testing the persistence layer: configuring H2, an in-memory databas setting Hibernate, Spring Data, and the DataSource performing an @EntityScan turning on SQL logging",
	"CI - Testing - AutoConfigured - TestSlices - @DataLdapTest": "Annotation that can be used in combination with @RunWith(SpringRunner.class) for a typical LDAP test. Can be used when a test focuses only on LDAP components. Using this annotation will disable full auto-configuration and instead apply only configuration relevant to LDAP tests. By default, tests annotated with @DataLdapTest will use an embedded in-memory LDAP process (if available).",
	"CI - Testing - AutoConfigured - TestSlices - @DataMongoTest": "Annotation that can be used in combination with @RunWith(SpringRunner.class) for a typical MongoDB test. Can be used when a test focuses only on MongoDB components. Using this annotation will disable full auto-configuration and instead apply only configuration relevant to MongoDB tests. By default, tests annotated with @DataMongoTest will use an embedded in-memory MongoDB process (if available).",
	"CI - Testing - AutoConfigured - TestSlices - @DataNeo4jTest": "Annotation that can be used in combination with @RunWith(SpringRunner.class) for a typical Neo4j test. Can be used when a test focuses only on Neo4j components. nUsing this annotation will disable full auto-configuration and instead apply only configuration relevant to Neo4j tests. By default, tests annotated with @DataNeo4jTest will use an embedded in-memory Neo4j process (if available). They will also be transactional with the usual test-related semantics (i.e. rollback by default).",
	"CI - Testing - AutoConfigured - TestSlices - @DataRedisTest": "Annotation that can be used in combination with @RunWith(SpringRunner.class) for a typical Data Redis test. Can be used when a test focuses only on Redis components. Using this annotation will disable full auto-configuration and instead apply only configuration relevant to Redis tests.",
	"CI - Testing - AutoConfigured - TestSlices - @JdbcTest": "Annotation that can be used in combination with @RunWith(SpringRunner.class) for a typical jdbc test. Can be used when a test focuses only on jdbc-based components. Using this annotation will disable full auto-configuration and instead apply only configuration relevant to jdbc tests. By default, tests annotated with @JdbcTest will use an embedded in-memory database (replacing any explicit or usually auto-configured DataSource). The @AutoConfigureTestDatabase annotation can be used to override these settings. If you are looking to load your full application configuration, but use an embedded database, you should consider @SpringBootTest combined with @AutoConfigureTestDatabase rather than this annotation.",
	"CI - Testing - AutoConfigured - TestSlices - @JooqTest": "Annotation that can be used in combination with @RunWith(SpringRunner.class) for a typical jOOQ test. Can be used when a test focuses only on jOOQ-based components. Using this annotation will disable full auto-configuration and instead apply only configuration relevant to jOOQ tests. By default, tests annotated with @JooqTest use the configured database. If you want to replace any explicit or usually auto-configured DataSource by an embedded in-memory database, the @AutoConfigureTestDatabase annotation can be used to override these settings.",
	"CI - Testing - AutoConfigured - TestSlices - @JsonTest": "Annotation that can be used in combination with @RunWith(SpringRunner.class) for a typical JSON test. Can be used when a test focuses only on JSON serialization. Using this annotation will disable full auto-configuration and instead apply only configuration relevant to JSON tests (i.e. @JsonComponent, Jackson Module) By default, tests annotated with JsonTest will also initialize JacksonTester, JsonbTester and GsonTester fields. More fine-grained control can be provided via the @AutoConfigureJsonTesters annotation.",
	"CI - Testing - Mockito - @MockBean": "Define a Mockito mock for a bean inside your ApplicationContext. The annotation can be used directly on test classes, on fields within your test, or on @Configuration classes and fields. When used on a field, the instance of the created mock is also injected. Mock beans are automatically reset after each test method.",
	"CI - Testing - Mockito - @SpyBean": "Annotation that can be used to apply Mockito spies to a Spring ApplicationContext. Can be used as a class level annotation or on fields in either @Configuration classes, or test classes that are @RunWith the SpringRunner. Spies can be applied by type or by bean name. All beans in the context of the same type will be wrapped with the spy. If no existing bean is defined a new one will be added. Dependencies that are known to the application context but are not beans (such as those registered directly) will not be found and a spied bean will be added to the context alongside the existing dependency. When @SpyBean is used on a field, as well as being registered in the application context, the spy will also be injected into the field..",
	"CI - Testing - Utils": "A few test utility classes that are generally useful when testing your application are packaged as part of spring-boot.",
	"CI - Testing - Utils - TestPropertyValues": "TestPropertyValues lets you quickly add properties to a ConfigurableEnvironment or ConfigurableApplicationContext. You can call it with key=value strings, as follows: TestPropertyValues.of('org=Spring', 'name=Boot').applyTo(env)",
	"CI - Testing - Utils - OutputCapture": "OutputCapture is a JUnit Rule that you can use to capture System.out and System.err output. You can declare the capture as a @Rule and then use toString() for assertions.",
	"CI - Testing - Utils - TestRestTemplate": "TestRestTemplate is a convenience alternative to Spring’s RestTemplate that is useful in integration tests. You can get a vanilla template or one that sends Basic HTTP authentication (with a username and password). In either case, the template behaves in a test-friendly way by not throwing exceptions on server-side errors. It is recommended, but not mandatory, to use the Apache HTTP Client (version 4.3.2 or better). If you have that on your classpath, the TestRestTemplate responds by configuring the client appropriately. If you do use Apache’s HTTP client, some additional test-friendly features are enabled: Redirects are not followed (so you can assert the response location). Cookies are ignored (so the template is stateless)..",
	"CI - Testing - Utils - TestContainers - @DynamicPropertySource - <SpringBoot3.1": "Before introducing the Service Connection, In order to write an integration test using Testcontainers in Spring Boot, we needed to configure the application using the @DynamicPropertySource to connect to the service running in the container",
	"CI - Testing - Utils - TestContainers - @ServiceConnection - SpringBoot3.1": "improve the integration of Spring Boot with Testcontainers in both integration tests and development time..",
	"CI - Testing - Utils - TestContainers - @ServiceConnection - SSL - SpringBoot3.5": "",
	"CI - Testing - Utils - TestContainers - @ServiceConnection - SSL - @Ssl": "",
	"CI - Testing - Utils - TestContainers - @ServiceConnection - SSL - @JksKeyStore": "",
	"CI - Testing - Utils - TestContainers - @ServiceConnection - SSL - @JksTrustStore": "",
	"CI - Testing - Utils - TestContainers - @ServiceConnection - SSL - @PemKeyStore": "",
	"CI - Testing - Utils - TestContainers - @ServiceConnection - SSL - @PemTrusStore": "",
	"CI - Testing - Utils - TestContainers - @ServiceConnection - ContainerConnectionDetailsFactory": "The ContainerConnectionDetailsFactory bean is responsible for creating this ConnectionDetails",
	"CI - Testing - Utils - TestContainers - @ServiceConnection - ContainerConnectionDetailsFactory - ConnectionDetails": "A Service Connection needs a ConnectionDetails to connect to a remote service (e.g., Kafka, ActiveMQ, PostgreSQL or …).",
	"CI - Testing - Utils - TestContainers - @ServiceConnection - ContainerConnectionDetailsFactory - ConnectionDetails - ActiveMQConnectionDetails": "",
	"CI - Testing - Utils - TestContainers - @ServiceConnection - ContainerConnectionDetailsFactory - ConnectionDetails - CassandraConnectionDetails": "",
	"CI - Testing - Utils - TestContainers - @ServiceConnection - ContainerConnectionDetailsFactory - ConnectionDetails - CouchbaseConnectionDetails": "",
	"CI - Testing - Utils - TestContainers - @ServiceConnection - ContainerConnectionDetailsFactory - ConnectionDetails - ElasticsearchConnectionDetails": "",
	"CI - Testing - Utils - TestContainers - @ServiceConnection - ContainerConnectionDetailsFactory - ConnectionDetails - JdbcConnectionDetails": "",
	"CI - Testing - Utils - TestContainers - @ServiceConnection - ContainerConnectionDetailsFactory - ConnectionDetails - KafkaConnectionDetails": "",
	"CI - Testing - Utils - TestContainers - @ServiceConnection - ContainerConnectionDetailsFactory - ConnectionDetails - MongoConnectionDetails": "",
	"CI - Testing - Utils - TestContainers - @ServiceConnection - ContainerConnectionDetailsFactory - ConnectionDetails - Neo4jConnectionDetails": "",
	"CI - Testing - Utils - TestContainers - @ServiceConnection - ContainerConnectionDetailsFactory - ConnectionDetails - R2dbcConnectionDetails": "",
	"CI - Testing - Utils - TestContainers - @ServiceConnection - ContainerConnectionDetailsFactory - ConnectionDetails - RabbitConnectionDetails": "",
	"CI - Testing - Utils - TestContainers - @ServiceConnection - ContainerConnectionDetailsFactory - ConnectionDetails - RedisConnectionDetails": "",
	"CI - Testing - Utils - TestContainers - @ServiceConnection - ContainerConnectionDetailsFactory - ConnectionDetails - ZipkinConnectionDetails": "",
	"CD - Testing - DevTools": "Spring Boot 1.3 introduced Spring Boot Dev Tools module. The spring-boot-devtools module can be included in any project to provide additional development-time features: reload and remote debugging",
	"CD - Testing - DevTools - Include": "To include devtools support, add the module dependency to your build: spring-boot-devtools",
	"CD - Testing - DevTools - Configure - Standard": "DevTools are usually configured by settings in your application.properties file.",
	"CD - Testing - DevTools - Configure - Global": "Ability to provide a global configuration which is not specific to any application.This can be achieved by adding a file named .spring-boot-devtools.properties in the $HOME.These configurations will be applicable to all the Spring Boot application on our machine. The spring-devtools.properties file can contain properties prefixed with restart.exclude and restart.include. The include elements are items that should be pulled up into the “restart” classloader, and the exclude elements are items that should be pushed down into the “base” classloader.",
	"CD - Testing - DevTools - Configure - Defaults": "If you don’t want property defaults to be applied you can set spring.devtools.add-properties to false in your application.properties.",
	"CD - Testing - DevTools - Caching": "Several of the libraries supported by Spring Boot use caches to improve performance. For example, template engines cache compiled templates to avoid repeatedly parsing template files. Also, Spring MVC can add HTTP caching headers to responses when serving static resources. While caching is very beneficial in production, it can be counter-productive during development, preventing you from seeing the changes you just made in your application. For this reason, spring-boot-devtools disables the caching options by default..",
	"CD - Testing - DevTools - Update - Restart": "DevTools monitors classpath resources, the only way to trigger a restart is to update the classpath",
	"CD - Testing - DevTools - Update - Restart - 2 classloaders": "The restart technology provided by Spring Boot works by using two classloaders, the restart classloader and the reload classloader. Classes that do not change are loaded into a base classloader. Classes that you are actively developing are loaded into a restart classloader. When the application is restarted, the restart classloader is thrown away and a new one is created. This approach means that application restarts are typically much faster than “cold starts”, since the base classloader is already available and populated.",
	"CD - Testing - DevTools - Update - Restart - enable": "spring.devtools.restart.enabled - If you do not want to use the restart feature, you can disable it by using the spring.devtools.restart.enabled property. In most cases, you can set this property in your application.properties (doing so still initializes the restart classloader, but it does not watch for file changes). If you need to completely disable restart support (for example, because it does not work with a specific library), you need to set the spring.devtools.restart.enabled System property to false before calling SpringApplication.run(…​),",
	"CD - Testing - DevTools - Update - Restart - trigger by file": "spring.devtools.restart.trigger-file - If you work with an IDE that continuously compiles changed files, you might prefer to trigger restarts only at specific times. To do so, you can use a “trigger file”, which is a special file that must be modified when you want to actually trigger a restart check. Changing the file only triggers the check and the restart only occurs if Devtools has detected it has to do something. The trigger file can be updated manually or with an IDE plugin. To use a trigger file, set the spring.devtools.restart.trigger-file property to the path of your trigger file. You might want to set spring.devtools.restart.trigger-file as a global setting, so that all your projects behave in the same way.",
	"CD - Testing - DevTools - Update - Restart - trigger by additional files": "spring.devtools.restart.additional-paths - You may want your application to be restarted or reloaded when you make changes to files that are not on the classpath. To do so, use the spring.devtools.restart.additional-paths property to configure additional paths to watch for changes. You can use the spring.devtools.restart.exclude property described earlier to control whether changes beneath the additional paths trigger a full restart or a live reload.",
	"CD - Testing - DevTools - Update - Restart - exclude": "spring.devtools.restart.exclude - Certain resources do not necessarily need to trigger a restart when they are changed. For example, Thymeleaf templates can be edited in-place. By default, changing resources in /META-INF/maven, /META-INF/resources, /resources, /static, /public, or /templates does not trigger a restart but does trigger a live reload. If you want to customize these exclusions, you can use the spring.devtools.restart.exclude property. For example, to exclude only /static and /public you would set the following property:",
	"CD - Testing - DevTools - Update - Restart - exclude additional": "spring.devtools.restart.additional-exclude - If you want to keep those defaults and add additional exclusions, use the spring.devtools.restart.additional-exclude property instead.",
	"CD - Testing - DevTools - Update - Restart - enable ": "spring.devtools.restart.log-condition-evaluation-delta - By default, each time your application restarts, a report showing the condition evaluation delta is logged. The report shows the changes to your application’s auto-configuration as you make changes such as adding or removing beans and setting configuration properties. To disable the logging of the report, set the following property: spring.devtools.restart.log-condition-evaluation-delta=false",
	"CD - Testing - DevTools - Update - Restart - limitations": "Restart functionality does not work well with objects that are deserialized by using a standard ObjectInputStream. If you need to deserialize data, you may need to use Spring’s ConfigurableObjectInputStream in combination with Thread.currentThread().getContextClassLoader(). Unfortunately, several third-party libraries deserialize without considering the context classloader. If you find such a problem, you need to request a fix with the original authors.",
	"CD - Testing - DevTools - Update - Restart - remote": "The remote client monitors your application classpath for changes in the same way as the local restart. Any updated resource is pushed to the remote application and (if required) triggers a restart. This can be helpful if you iterate on a feature that uses a cloud service that you do not have locally. Generally, remote updates and restarts are much quicker than a full rebuild and deploy cycle. Files are only monitored when the remote client is running. If you change a file before starting the remote client, it is not pushed to the remote server.",
	"CD - Testing - DevTools - Update - Reload - LiveReload": "spring.devtools.livereload.enabled - The spring-boot-devtools module includes an embedded LiveReload server that can be used to trigger a browser refresh when a resource is changed. LiveReload browser extensions are freely available for Chrome, Firefox and Safari from livereload.com. If you do not want to start the LiveReload server when your application runs, you can set the spring.devtools.livereload.enabled property to false. You can only run one LiveReload server at a time. Before starting your application, ensure that no other LiveReload servers are running. If you start multiple applications from your IDE, only the first has LiveReload support.",
	"CD - Testing - DevTools - DebugRemote": "The Spring Boot developer tools are not limited to local development. You can also use several features when running applications remotely. Remote support is opt-in.",
	"CD - Testing - DevTools - DebugRemote - parts": "Remote devtools support is provided in two parts: a server-side endpoint that accepts connections and a client application that you run in your IDE.",
	"CD - Testing - DevTools - DebugRemote - enabling": "spring.devtools.remote.secret - The server component is automatically enabled when the spring.devtools.remote.secret property is set.",
	"CD - Testing - DevTools - DebugRemote - acccessing": "spring.devtools.remote.proxy.host, spring.devtools.remote.proxy.port - If you need to use a proxy to access the remote application, configure the spring.devtools.remote.proxy.host and spring.devtools.remote.proxy.port properties.",
	"CI - Testing - SliceTesting - Spring3.2": "Spring Boot 3’s support for Slice Testing and Testcontainers integration made my test suite run 3x faster. No more waiting for the whole context to load for every test. Each layer was isolated and fast.",

	"CD - Operate": "SECTION",
	"CD - Operate - JMX": "Java Management Extensions (JMX) provide a standard mechanism to monitor and manage applications. By default, Spring Boot creates an MBeanServer bean with an ID of mbeanServer and exposes any of your beans that are annotated with Spring JMX annotations (@ManagedResource, @ManagedAttribute, or @ManagedOperation).",
	"CD - Operate - JMX - MBeanServer": "It is possible to enable admin-related features for the application by specifying the spring.application.admin.enabled property. This exposes the SpringApplicationAdminMXBean on the platform MBeanServer. You could use this feature to administer your Spring Boot application remotely. This feature could also be useful for any service wrapper implementation.",

	"CD - Monitor": "SECTION",
	"CD - Monitor - ByApp - Listeners - getListeners()": "Returns read-only ordered Set of the ApplicationListeners that will be applied to the SpringApplication and registered with the ApplicationContext .",
	"CD - Monitor - ByApp - Listeners - addListeners(ApplicationListener< ?>... listeners": "Add ApplicationListeners to be applied to the SpringApplication and registered with the ApplicationContext.)",
	"CD - Monitor - ByApp - Listeners - setListeners(Collection< ? extends ApplicationListener< ?>> listeners)": "Sets the ApplicationListeners that will be applied to the SpringApplication and registered with the ApplicationContext.",
	"CD - Monitor - ByApp - Listeners - order": "Application events are sent in the following order, as your application runs: (1) An ApplicationStartingEvent is sent at the start of a run but before any processing, except for the registration of listeners and initializers. (2) An ApplicationEnvironmentPreparedEvent is sent when the Environment to be used in the context is known but before the context is created. (3) An ApplicationPreparedEvent is sent just before the refresh is started but after bean definitions have been loaded. (4) An ApplicationStartedEvent is sent after the context has been refreshed but before any application and command-line runners have been called. (5) An ApplicationReadyEvent is sent after any application and command-line runners have been called. It indicates that the application is ready to service requests. (6) An ApplicationFailedEvent is sent if there is an exception on startup.",
	"CD - Monitor - ByApp - Listeners - ApplicationStartingEvent": "An ApplicationStartingEvent is sent at the start of a run but before any processing, except for the registration of listeners and initializers.",
	"CD - Monitor - ByApp - Listeners - ApplicationEnvironmentPreparedEvent": "An ApplicationEnvironmentPreparedEvent is sent when the Environment to be used in the context is known but before the context is created.",
	"CD - Monitor - ByApp - Listeners - ApplicationPreparedEvent": "An ApplicationPreparedEvent is sent just before the refresh is started but after bean definitions have been loaded.",
	"CD - Monitor - ByApp - Listeners - ApplicationStartedEvent": "An ApplicationStartedEvent is sent after the context has been refreshed but before any application and command-line runners have been called.",
	"CD - Monitor - ByApp - Listeners - ApplicationReadyEvent": "An ApplicationReadyEvent is sent after any application and command-line runners have been called. It indicates that the application is ready to service requests.",
	"CD - Monitor - ByApp - Listeners - ApplicationFailedEvent": "An ApplicationFailedEvent is sent if there is an exception on startup.",
	"CD - Monitor - ByApp - FailureAnalyzers": "If your application fails to start, registered FailureAnalyzers get a chance to provide a dedicated error message and a concrete action to fix the problem.",
	"CD - Monitor - ByApp - FailureAnalyzers - PortInUseFailureAnalyzer": "",
	"CD - Monitor - ByApp - FailureAnalyzers - NoUniqueBeanDefinitionFailureAnalyzer": "",
	"CD - Monitor - ByApp - FailureAnalyzers - BeanCurrentlyInCreationFailureAnalyzer": "",
	"CD - Monitor - ByApp - FailureAnalyzers - custom": "",
	"CD - Monitor - ByLog - Tracing - Spring3.2": "Spring Boot 3.2 has native support for Micrometer + OpenTelemetry. That meant traces, logs, and metrics flowed into Grafana and Jaeger with almost no extra code. management.tracing.enabled: true - management.tracing.enabled.sampling.probability: 1.0",
	"CD - Monitor - ByLog - StructuredLogging - Spring3.4": "Structured logging enables us to produce log outputs in a clear and machine-readable style.",
	"CD - Monitor - ByLog - StructuredLogging - Formats": "Spring Boot 3.4 introduces built-in support for structured logging and out-of-the-box supports the following JSON formats: ecs, gelf, logstash",
	"CD - Monitor - ByLog - StructuredLogging - Formats - ecs": "Elastic Common Schema (ecs)",
	"CD - Monitor - ByLog - StructuredLogging - Formats - gelf": "Graylog Extended Log Format (gelf)",
	"CD - Monitor - ByLog - StructuredLogging - Formats - logstash": "Logstash (logstash)",
	"CD - Monitor - ByLog - StructuredLogging - Content - SpringBoot3.5": "We can now control stack trace output in structured logs*. ",
	"CD - Monitor - ByLog - StructuredLogging - Content - logging.structured.json.stacktrace.*": "Using several new configuration properties under logging.structured.json.stacktrace.*. ",
	"CD - Monitor - ByLog - StructuredLogging - Content - order": "Change the order of stack frames (e.g., root first or last)",
	"CD - Monitor - ByLog - StructuredLogging - Content - Limit": "Limit the maximum length of the stack trace string",
	"CD - Monitor - ByLog - StructuredLogging - Content - Restrict": "Restrict the number of frames included per stack trace",
	"CD - Monitor - ByLog - StructuredLogging - Content - Frames": "Decide whether to include or exclude common frames",
	"CD - Monitor - ByLog - StructuredLogging - Content - Hash": "Add a hash of the stack trace for easier deduplication or correlation",
	"CD - Monitor - ByUser - Actuators": "",
	"CD - Monitor - ByUser - Actuators - spring-boot-actuator module": "",
	"CD - Monitor - ByUser - Actuators - spring-boot-starter-actuator": "Starter for using Spring Boot’s Actuator which provides production ready features to help you monitor and manage your application",
	"CD - Monitor - ByUser - Actuators - enabling endpoints": "management.endpoint.shutdown.enabled=true",
	"CD - Monitor - ByUser - Actuators - endpoint auditevents": "Exposes audit events information for the current application.",
	"CD - Monitor - ByUser - Actuators - endpoint beans": "Displays a complete list of all the Spring beans in your application.",
	"CD - Monitor - ByUser - Actuators - endpoint caches": "Exposes available caches.",
	"CD - Monitor - ByUser - Actuators - endpoint conditions": "Shows the conditions that were evaluated on configuration and auto-configuration classes and the reasons why they did or did not match.",
	"CD - Monitor - ByUser - Actuators - endpoint configprops": "Displays a collated list of all @ConfigurationProperties.",
	"CD - Monitor - ByUser - Actuators - endpoint env": "Exposes properties from Spring’s ConfigurableEnvironment.",
	"CD - Monitor - ByUser - Actuators - endpoint flyway": "Shows any Flyway database migrations that have been applied.",
	"CD - Monitor - ByUser - Actuators - endpoint health": "Shows application health information.",
	"CD - Monitor - ByUser - Actuators - endpoint httptrace": "Displays HTTP trace information (by default, the last 100 HTTP request-response exchanges).",
	"CD - Monitor - ByUser - Actuators - endpoint info": "Displays arbitrary application info.",
	"CD - Monitor - ByUser - Actuators - endpoint integrationgraph": "Shows the Spring Integration graph.",
	"CD - Monitor - ByUser - Actuators - endpoint loggers": "Shows and modifies the configuration of loggers in the application.",
	"CD - Monitor - ByUser - Actuators - endpoint liquibase": "Shows any Liquibase database migrations that have been applied.",
	"CD - Monitor - ByUser - Actuators - endpoint metrics": "Shows ‘metrics’ information for the current application.",
	"CD - Monitor - ByUser - Actuators - endpoint mappings": "Displays a collated list of all @RequestMapping paths.",
	"CD - Monitor - ByUser - Actuators - endpoint quartz - SpringBoot3.5": "We can trigger a specific Quartz job by making a POST request to the following endpoint: /actuator/quartz/jobs/{groupName}/{jobName}",
	"CD - Monitor - ByUser - Actuators - endpoint scheduledtasks": "Displays the scheduled tasks in your application.",
	"CD - Monitor - ByUser - Actuators - endpoint sessions": "Allows retrieval and deletion of user sessions from a Spring Session-backed session store. Not available when using Spring Session’s support for reactive web applications.",
	"CD - Monitor - ByUser - Actuators - endpoint shutdown": "Lets the application be gracefully shutdown.",
	"CD - Monitor - ByUser - Actuators - endpoint threaddump": "Performs a thread dump.",
	"CD - Monitor - ByUser - Actuators - endpoint heapdump": "Returns a GZip compressed hprof heap dump file.",
	"CD - Monitor - ByUser - Actuators - endpoint jolokia": "Exposes JMX beans over HTTP (when Jolokia is on the classpath, not available for WebFlux).",
	"CD - Monitor - ByUser - Actuators - endpoint logfile": "Returns the contents of the logfile (if logging.file or logging.path properties have been set). Supports the use of the HTTP Range header to retrieve part of the log file’s content.",
	"CD - Monitor - ByUser - Actuators - endpoint prometheus": "Exposes metrics in a format that can be scraped by a Prometheus server."
}