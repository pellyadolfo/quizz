{			

	"RPC": "SECTION",

	"GWT": "SECTION",

	"EJB": "SECTION",

	"XML-RPC": "SECTION",

	"JAX-RPC": "SECTION",

	"RMI": "SECTION",

	"CORBA": "SECTION",

	"Protocols - GraphQL": "SECTION",
	"Protocols - GraphQL - History": "GraphQL, a query language and execution engine originally created at Facebook in 2012",
	"Protocols - GraphQL - Features - Transport": "GraphQL and REST typically use HTTP as their transport layer, and they both leverage the standard HTTP POST method to send and receive data.",
	"Protocols - GraphQL - Features - Formats": "GraphQL and REST use standard data formats for communication. JSON is the most commonly used format, but other formats, like XML or HTML, can also be used, especially in REST.",
	"Protocols - GraphQL - Features - Response": "GraphQL uses the 200 status code for all responses, including error responses. The error response is typically included in the response payload itself.",
	"Protocols - GraphQL - Features - Stateless": "the server does not save response history between requests",
	"Protocols - GraphQL - Schema": "GraphQL requires a schema that defines the data types and relationships between each type. The schema provides clients with a description of the data that is available to them.",
	"Protocols - GraphQL - Schema - Introspection": "GraphQL APIs are self-documenting. Clients can query the API schema to discover the types, queries, mutations, and fields it supports. This introspective capability makes it easier to understand and explore the capabilities of a GraphQL API.",
	"Protocols - GraphQL - Requests - Queries": "Queries allow the client to request the specific data it needs using a defined data schema. They can be used to fetch data from multiple data sources—or even other APIs—without the need to make multiple round-trip calls to the server.",
	"Protocols - GraphQL - Requests - Mutations": "Mutations in GraphQL allow the client to mutate data on the server. This includes creating or updating existing data objects. GraphQL mutations are in fact RPC.",
	"Protocols - GraphQL - Requests - Subscriptions": "Subscriptions facilitate bi-directional, real-time communication between the client and the server. The client can subscribe to events and get updated as soon as these events are published, or vice versa.",

	"Protocols - REST": "SECTION",
	"Protocols - REST - Requirements - Richardson Maturity Model": "",
	"Protocols - REST - Requirements - Richardson Maturity Model - Level0": "Level 0: Swamp of POX. Level 0 uses its implementing protocol (normally HTTP, but it doesn't have to be) like a transport protocol.",
	"Protocols - REST - Requirements - Richardson Maturity Model - Level1": "Level 1: Resources. When your API can distinguish between different resources, it might be level 1. This level uses multiple URIs, where every URI is the entry point to a specific resource.",
	"Protocols - REST - Requirements - Richardson Maturity Model - Level2": "Level 2: HTTP verbs. This level indicates that your API should use the protocol properties in order to deal with scalability and failures. Don't use a single POST method for all, but make use of GET when you are requesting resources, and use the DELETE method when you want to delete a resources. Also, use the response codes of your application protocol. Don't use 200 (OK) code when something went wrong for instance. ",
	"Protocols - REST - Requirements - Richardson Maturity Model - Level3": "Level 3: Hypermedia controls Level 3, the highest level, uses HATEOAS to deal with discovering the possibilities of your API towards the clients.",
	"Protocols - REST - Requirements - REST Constraints": "",
	"Protocols - REST - Requirements - REST Constraints (6 from thesis)": "Uniform Interface, Stateless, Cacheable, Client-Server, Layered System, Code on Demand (optional)",
	"Protocols - REST - Requirements - REST Constraint. 1. Uniform Interface": "*(1) Resource-Based (Individual resources are identified in requests using URIs as resource identifiers), (2) Manipulation of Resources Through Representations (When a client holds a representation of a resource, including any metadata attached, it has enough information to modify or delete the resource on the server, provided i has permission to do so). (3) Self-descriptive Messages (Each message includes enough information to describe how to process the message). (4) Hypermedia as the Engine of Application State (HATEOAS) (Clients deliver state via body contents, query-string parameters, request headers and the requested URI (the resource name). Services deliver state to clients via body content, response codes, and response headers. This is technically referred-to as hypermedia (or hyperlinks within hypertext).",
	"Protocols - REST - Requirements - REST Constraint. 2. Stateless": "As REST is an acronym for REpresentational State Transfer, statelessness is key. Essentially, what this means is that the necessary state to handle the request is contained within the request itself, whether as part of the URI, query-string parameters, body, or headers. The URI uniquely identifies the resource and the body contains the state (or state change) of that resource. Then after the server does it's processing, the appropriate state, or the piece(s) of state that matter, are communicated back to the client via headers, status and response body.",
	"Protocols - REST - Requirements - REST Constraint. 3. Cacheable": "As on the World Wide Web, clients can cache responses. Responses must therefore, implicitly or explicitly, define themselves as cacheable, or not, to prevent clients reusing stale or inappropriate data in response to further requests. Well-managed caching partially or completely eliminates some client–server interactions, further improving scalability and performance.",
	"Protocols - REST - Requirements - REST Constraint. 4. Client-Server": "The uniform interface separates clients from servers. This separation of concerns means that, for example, clients are not concerned with data storage, which remains internal to each server, so that the portability of client code is improved. Servers are not concerned with the user interface or user state, so that servers can be simpler and more scalable. Servers and clients may also be replaced and developed independently, as long as the interface is not altered.",
	"Protocols - REST - Requirements - REST Constraint. 5. Layered System": "A client cannot ordinarily tell whether it is connected directly to the end server, or to an intermediary along the way. Intermediary servers may improve system scalability by enabling load-balancing and by providing shared caches. Layers may also enforce security policies.",
	"Protocols - REST - Requirements - REST Constraint. 6. Code on Demand (optional)": "Servers are able to temporarily extend or customize the functionality of a client by transferring logic to it that it can execute. Examples of this may include compiled components such as Java applets and client-side scripts such as JavaScript. Complying with these constraints, and thus conforming to the REST architectural style, will enable any kind of distributed hypermedia system to have desirable emergent properties, such as performance, scalability, simplicity, modifiability, visibility, portability and reliability. NOTE: The only optional constraint of REST architecture is code on demand. If a service violates any other constraint, it cannot strictly be referred to as RESTful.",
	"Protocols - REST - DesigningRESTAPi - Steps": ".",
	"Protocols - REST - DesigningRESTAPi - Steps - 1-ObjectModel": "(1) Identify Object Model. The very first step in designing a REST API based application is – identifying the objects which will be presented as resources.",
	"Protocols - REST - DesigningRESTAPi - Steps - 2-ResourceURIs": "(2) Now when object model is ready, it’s time to decide the resource URIs. At this step, while designing the resource URIs – focus on the relationship between resources and its sub-resources. These resource URIs are endpoints for RESTful services. These URIs do not use any verb or operation. It’s very important to not include any verb in URIs. URIs should all be nouns only.",
	"Protocols - REST - DesigningRESTAPi - Steps - 3-Representations": "(3) Determine Representations Now when resource URIs have been decided, let’s work on their representations. Mostly representations are defined in either XML or JSON format.",
	"Protocols - REST - DesigningRESTAPi - Steps - 4-HTTPMethods": "(4) Assign HTTP Methods So our resource URIs and their representation are fixed now. Let’s decide the possible operations in application and map these operations on resource URIs. A user of network application can perform browse, create, update or delete operations. So let’s map them.",
	"Protocols - REST - DesigningRESTAPi - Steps - 5-Other": "(5) You need to work on other aspects of the application as well: Logging, Security, Discovery etc.",
	"Protocols - REST - Methods - Are REST and HTTP the same thing?": "There is nothing in the REST constraints that makes the usage of HTTP as a transfer protocol mandatory. It's perfectly possible to use other transfer protocols like SNMP, SMTP and others to use, and your API could still very well be a RESTful API In practice, most - if not all - RESTful APIs currently use HTTP as a transport layer, since the infrastructure, servers and client libraries for HTTP are widely available already",
	"Protocols - REST - Methods - idempotency and safety contract": "It is a contract defined by the HTTP standard that developers must adhere to when implementing RESTful APIs over HTTP. An operation doesn’t automatically become idempotent or safe just because it is invoked using the GET method, if it isn’t implemented in an idempotent manner",
	"Protocols - REST - Methods - safe methods": "Some idempotent operations have an additional, special property: they do not modify the state on the server side at all. Simply put, these methods are read-only and have absolutely zero side-effects. These types of operations are given a special name: safe or nullipotent methods. Safe HTTP method are GET and HEAD, which doesn't change the resource representation on the Server, but all other HTTP methods e.g. POST, PUT, or DELETE are non-safe.",
	"Protocols - REST - Methods - Idempotent methods": "In the context of REST APIs, when making multiple identical requests has the same effect as making a single request – then that REST API is called idempotent. If you follow REST principles in designing API, you will have automatically idempotent REST APIs for GET, PUT, DELETE, HEAD, OPTIONS and TRACE HTTP methods. Only POST APIs will not be idempotent. Idempotency in REST does not mean that consecutive calls to the same method and resource must return the same response, but rather that consecutive calls to the same method and resource MUST have the same intended effect on the server.",
	"Protocols - REST - Methods - HTTP GET": "Use GET requests to retrieve resource representation/information only – and not to modify it in any way. As GET requests do not change the state of the resource, these are said to be safe methods. Additionally, GET APIs should be idempotent. Responses if item: 200 (OK), single user. 404 (Not Found), if ID not found or invalid. Responses if collection: 200 (OK), list of users. Use pagination, sorting and filtering to navigate big lists.",
	"Protocols - REST - Methods - HTTP POST": "POST methods are used to create a new resource into the collection of resources. Responses to this method are not cacheable. POST is neither safe nor idempotent and invoking two identical POST requests will result in two different resources containing the same information (except resource ids). Responses if item: Avoid using POST on single resource. Responses if collection: 201 (Created), ‘Location’ header with link to /users/{id} containing new ID.",
	"Protocols - REST - Methods - HTTP PUT": "Use PUT APIs primarily to update existing resource (if the resource does not exist then API may decide to create a new resource or not). If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale. Responses to this method are not cacheable. Responses if item: 200 (OK) or 204 (No Content). Use 404 (Not Found), if ID not found or invalid.. Responses if collection: 404 (Not Found), unless you want to update every resource in the entire collection of resource.",
	"Protocols - REST - Methods - HTTP DELETE": "As the name applies, DELETE APIs are used to delete resources (identified by the Request-URI). DELETE operations are idempotent. If you DELETE a resource, it’s removed from the collection of resource. Repeatedly calling DELETE API on that resource will not change the outcome – however calling DELETE on a resource a second time will return a 404 (NOT FOUND) since it was already removed. Some may argue that it makes DELETE method non-idempotent. It’s a matter of discussion and personal opinion. If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale. Responses to this method are not cacheable. Responses if item: 200 (OK). 404 (Not Found), if ID not found or invalid. Responses if collection: 404 (Not Found), unless you want to delete the whole collection — use with caution.",
	"Protocols - REST - Methods - HTTP PATCH": "HTTP PATCH requests are to make partial update on a resource. If you see PUT requests also modify a resource entity so to make more clear – PATCH method is the correct choice for partially updating an existing resource and PUT should only be used if you’re replacing a resource in its entirety. Support for PATCH in browsers, servers, and web application frameworks is not universal. PATCH method is not a replacement for the POST or PUT methods. It applies a delta (diff) rather than replacing the entire resource. Responses if item: 200 (OK) or 204 (No Content). Use 404 (Not Found), if ID not found or invalid. Responses if collection: 404 (Not Found), unless you want to modify the collection itself.",
	"Protocols - REST - Methods - HTTP OPTIONS": "This method allows the client of the REST API to determine, which HTTP method ( GET, HEAD, POST, PUT, DELETE ) can be used for a resource identified by requested URI, without initiating a resource request by using any particular HTTP method. Response to this method are not cacheable.",
	"Protocols - REST - Methods - HTTP HEAD": "Simply put, HEAD returns all of the HTTP headers, just like GET, but provides no body content. All of the same rules regarding content caching can be applied, regarding headers in the request/response.",
	"Protocols - REST - Methods - HTTP POST vs HTTP PUT vs HTTP PATCH": "PUT is for creating or conmpletely updating a single resource when you know the URL (e.g. create update object). It is idempotent. POST is to create when you do not know the URL (e.g.adding item to a collection). No idempotent, PATCH is to update part of a resource when you know the URL. Idempotent",
	"Protocols - REST - Features": "The basic purpose of HTTP caching is to provide a mechanism for applications to scale better and perform faster.",
	"Protocols - REST - Features ": "HTTP caching involves the client, the proxy, and the server. In this post, we will discuss mainly the proxy, which sits between the client and server. Typically, reverse proxies are deployed close to the server, and forward proxies close to the client.",
	"Protocols - REST - Features - Caching - proxy": "A typical proxy caches idempotent requests. HTTP caching is applicable by default only to idempotent requests, only idempotent and nullipotent requests yield the same result when run multiple times. In the HTTP world, this fact means that GET requests can be cached but POST requests cannot.",
	"Protocols - REST - Features - Caching - idempotent calls": "A typical proxy caches idempotent requests. The proxy gets the request, examines it for cache headers, and sends it to the server. Then the proxy examines the response and, if it is cacheable, caches it with the URL as the key (along with some headers in certain cases) and the response as the value.  This scheme works well with GET requests, because for the same URL repeated invocation does not change the response. Intermediaries can make use of this idempotency to safely cache GET requests. But this is not the case with an idempotent POST request. The URL (and headers) cannot be used as the key because the response could be different – the same URL, but with a different body.",
	"Protocols - REST - Features - Caching - no idempotent calls (POST)": "Responses to POST method are not cacheable, UNLESS the response includes appropriate Cache-Control or Expires header fields.",
	"Protocols - REST - Features - Caching - headers": "HTTP response headers: Expires, Cache-Control, ETag, Last-Modified",
	"Protocols - REST - Features - Compression": "HTTP response headers: Accept-Encoding, Content-Encoding",
	"Protocols - REST - Features - Content Negotiation": "HTTP response headers: Content-Type, Accept",
	"Protocols - REST - Features - Versioning": "(1) Using URI: /api/v1/customer/{id}, (2) Using Custom Request Header: Accept-version: v1, (3) Using Accept header: Accept: application/vnd.example.v1+json",
	"Protocols - REST - Features - Security - Authentication": "",
	"Protocols - REST - Features - Security - Authentication - HTTP Basic Authentication": "",
	"Protocols - REST - Features - Security - Authentication - HTTP Digest Authentication": "",
	"Protocols - REST - Features - Security - Authentication - Token Based Authentication": "",
	"Protocols - REST - Features - Security - Authorization": "",
	"Protocols - REST - Features - Security - Input Validation": "",
	"Protocols - REST - Features - Security - Encryption": "",

	"Protocols - NgRx": "SECTION",
	"Protocols - NgRx - goal": " define an entity with the URL and the interface that represents the API contract, and you have a CRUD implemented for you with Store and also caching.",
	"Protocols - NgRx - ngrx/data": ".",

	"Protocols - JAX-RS": "SECTION",

	"Protocols - JAX-WS": "SECTION",

	"Protocols - SOAP": "SECTION",

	"Protocols - HTTP": "SECTION",
	"Protocols - HTTP - 2": "HTTP/2 began as the SPDY protocol, developed primarily at Google",
	"Protocols - HTTP - 2 - Goal": "Reducing server latency",
	"Protocols - HTTP - 2 - Features - Binary": "binary framing layer. As opposed to HTTP/1.1, which keeps all requests and responses in plain text format, HTTP/2 uses the binary framing layer to encapsulate all messages in binary format, while still maintaining HTTP semantics, such as verbs, methods, and headers.",
	"Protocols - HTTP - 2 - Features - Headers - compression": "Small files load more quickly than large ones. To speed up web performance, both HTTP/1.1 and HTTP/2 compress HTTP messages to make them smaller. However, HTTP/2 uses a more advanced compression method called HPACK that eliminates redundant information in HTTP header packets. This eliminates a few bytes from every HTTP packet. Given the volume of HTTP packets involved in loading even a single webpage, those bytes add up quickly, resulting in faster loading.",
	"Protocols - HTTP - 2 - Features - Prioritization": "Stream prioritization not only solves the possible issue of requests competing for the same resource, but also allows developers to customize the relative weight of requests to better optimize application performance.",
	"Protocols - HTTP - 2 - Features - Multiplexing": "HTTP/1.1 loads resources one after the other, so if one resource cannot be loaded, it blocks all the other resources behind it. In contrast, HTTP/2 is able to use a single TCP connection to send multiple streams of data at once so that no one resource blocks any other resource. HTTP/2 does this by splitting data into binary-code messages and numbering these messages so that the client knows which stream each binary message belongs to.",
	"Protocols - HTTP - 2 - Features - Push": "Server push: Typically, a server only serves content to a client device if the client asks for it. However, this approach is not always practical for modern webpages, which often involve several dozen separate resources that the client must request. HTTP/2 solves this problem by allowing a server to 'push' content to a client before the client asks for it. The server also sends a message letting the client know what pushed content to expect – like if Bob had sent Alice a Table of Contents of his novel before sending the whole thing.",
	"Protocols - HTTP - 3 - Transport": "Both HTTP/1.1 and HTTP/2 use TCP as their transport, whereas HTTP/3 is based on Google’s QUIC – a transport layer network protocol that implements user space congestion control over UDP (User Datagram Protocol)."


}