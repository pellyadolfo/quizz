{
	"DataTypes": "SECTION",
	"DataTypes - Types - Primitives - Scalar": "Despite the value of a unit type being a tuple, it is not considered a compound type because it does not contain multiple values.",
	"DataTypes - Types - Primitives - Scalar - Integers - signed": "Signed integers: i8, i16, i32, i64, i128 and isize (pointer size)",
	"DataTypes - Types - Primitives - Scalar - Integers - unsigned": "Unsigned integers: u8, u16, u32, u64, u128 and usize (pointer size)",
	"DataTypes - Types - Primitives - Scalar - Floating": "Floating point: f32, f64",
	"DataTypes - Types - Primitives - Scalar - char": "char Unicode scalar values like 'a', 'α' and '∞' (4 bytes each)",
	"DataTypes - Types - Primitives - Scalar - bool": "bool either true or false",
	"DataTypes - Types - Primitives - Scalar - ()": "The unit type (), whose only possible value is an empty tuple: ()",
	"DataTypes - Types - Primitives - Compound": ".",
	"DataTypes - Types - Primitives - Compound - Arrays": "Arrays like [1, 2, 3].",
	"DataTypes - Types - Primitives - Compound - Tuples": "Tuples like (1, true).",
	"DataTypes - Types - Custom Types": "",
	"DataTypes - Types - Custom Types - struct": "struct: define a structure",
	"DataTypes - Types - Custom Types - enum": "enum: define an enumeration",
	"DataTypes - Variables - Binding": "Values (like literals) can be bound to variables, using the let binding.  let an_integer = 1u32;",
	"DataTypes - Variables - Binding - mut": "Variable bindings are immutable by default, but this can be overridden using the mut modifier.",
	"DataTypes - Operations - Casting": "",
	"DataTypes - Operations - Inference": "",
	"DataTypes - Operations - Aliasing": "",
	"DataTypes - Operations - Conversion": "",
	"DataTypes - Std Types": "",
	"DataTypes - Collections": "",
	"DataTypes - Generics": "Generics is the topic of generalizing types and functionalities to broader cases.",
	"DataTypes - Generics - types- Functions": "",
	"DataTypes - Generics - types- Implementations": "",
	"DataTypes - Generics - types- Traits": "",
	"DataTypes - Generics - bound": "",
	"DataTypes - Generics - where": "",
	"DataTypes - Generics - newtype": "",
	"DataTypes - Generics - phantom": "",

	"Logic": "SECTION",
	"Logic - Expressions": "",
	"Logic - Unsafe Operations": "",
	"Logic - Control Flow": "",
	"Logic - Traits": "",
	"Logic - Iterators": "",
	"Logic - Closures": "Closures are powerful anonymous functions that capture their own environment and can be saved in a variable and also passed to other functions as arguments.",
	"Logic - Error Handling": "",
	"Logic - Async": "",
	"Logic - Multithreading": "",
	"Logic - Multithreading - Concurrency": "Rust’s type system prevents data races at compile-time, making it easier to write safe, concurrent programs.",
	"Logic - Resources": "",

	"CICD - Architecture": "SECTION",
	"CICD - Architecture - Workspaces": "",
	"CICD - Architecture - Patterns": "",
	"CICD - Architecture - OO": "",

	"CICD - Applications - Web - Wasm": "Rust’s compatibility with WebAssembly (Wasm) has opened up new avenues for web development, allowing Rust code to run at near-native speed in web browsers.",

	"CICD - Packaging": "SECTION",
	"CICD - Packaging - Manager - cargo": "Cargo is the Rust package manager. It is a tool that allows Rust packages to declare their various dependencies and ensure that you’ll always get a repeatable build.",
	"CICD - Packaging - Workspace": "A workspace is a collection of one or more packages, called workspace members, that are managed together.",
	"CICD - Packaging - Package": "A package is a bundle of one or more crates that provides a set of functionality.",
	"CICD - Packaging - Package - Cargo": "Cargo is actually a package that contains the binary crate for the command-line tool you’ve been using to build your code. The Cargo package also contains a library crate that the binary crate depends on. Other projects can depend on the Cargo library crate to use the same logic the Cargo command-line tool uses.",
	"CICD - Packaging - Package - Cargo - Cargo.toml": "A package contains a Cargo.toml file that describes how to build those crates.",
	"CICD - Packaging - Crate": "A crate is the smallest amount of code that the Rust compiler considers at a time.",
	"CICD - Packaging - Crate - root": "The crate root is a source file that the Rust compiler starts from and makes up the root module of your crate usually src/lib.rs for a library crate or src/main.rs for a binary crate.",
	"CICD - Packaging - Crate - types": "A crate can come in one of two forms: a binary crate or a library crate. A package can contain as many binary crates as you like, but at most only one library crate. A package must contain at least one crate, whether that’s a library or binary crate..",
	"CICD - Packaging - Crate - types - binary": "Binary crates are programs you can compile to an executable that you can run, such as a command-line program or a server. Each must have a function called main that defines what happens when the executable runs. All the crates we’ve created so far have been binary crates.",
	"CICD - Packaging - Crate - types - library": "Library crates don’t have a main function, and they don’t compile to an executable. Instead, they define functionality intended to be shared with multiple projects. Most of the time when Rustaceans say “crate”, they mean library crate, and they use “crate” interchangeably with the general programming concept of a “library“.",
	"CICD - Packaging - Crate - Attributes": "",
	"CICD - Packaging - Modules": "Crates can contain modules, and the modules may be defined in other files that get compiled with the crate.",
	"CICD - Packaging - Modules - declare": "In the crate root file, you can declare new modules; say you declare a “garden” module with mod garden;. The compiler will look for the module’s code in these places 1. Inline, within curly brackets that replace the semicolon following mod garden 2. In the file src/garden.rs 3. In the file src/garden/mod.rs",
	"CICD - Packaging - Modules - refer": "Paths to code in modules: Once a module is part of your crate, you can refer to code in that module from anywhere else in that same crate, as long as the privacy rules allow, using the path to the code. For example, an Asparagus type in the garden vegetables module would be found at crate::garden::vegetables::Asparagus.",
	"CICD - Packaging - Submodules": "Crates can contain modules, and the modules may be defined in other files that get compiled with the crate.",
	"CICD - Packaging - Submodules - declare": "Declaring submodules: In any file other than the crate root, you can declare submodules. For example, you might declare mod vegetables; in src/garden.rs. The compiler will look for the submodule’s code within the directory named for the parent module in these places: 1. Inline, directly following mod vegetables, within curly brackets instead of the semicolon 2. In the file src/garden/vegetables.rs 3. In the file src/garden/vegetables/mod.rs",
	"CICD - Packaging - Functions": "",
	"CICD - Packaging - Functions - format - fn": "Functions are declared using the fn keyword.",
	"CICD - Packaging - Functions - format - arguments": "Its arguments are type annotated, just like variables.",
	"CICD - Packaging - Functions - format - returndec": "if the function returns a value the return type must be specified after an arrow ->. Functions that don't return a value, actually return the unit type `()`",
	"CICD - Packaging - Functions - format - return": "The final expression in the function will be used as return value. Alternatively, the return statement can be used to return a value earlier from within the function, even from inside loops or if statements.",
	"CICD - Packaging - AssociatedFunctions": "Associated functions are functions that are defined on a type generally",
	"CICD - Packaging - AssociatedFunctions - example": "struct Point { x: f64, y: f64, } impl Point { fn origin() -> Point { Point { x: 0.0, y: 0.0 } } }",
	"CICD - Packaging - Methods": "methods are associated functions that are called on a particular instance of a type.",
	"CICD - Packaging - Methods - example": "methods are associated functions that are called on a particular instance of a type.",
	"CICD - Packaging - Closures": "Closures are functions that can capture the enclosing environment.",
	"CICD - Packaging - HOF": "Rust provides Higher Order Functions (HOF). These are functions that take one or more functions and/or produce a more useful function. HOFs and lazy iterators give Rust its functional flavor.",
	"CICD - Packaging - DivergingFunctions": "Diverging functions never return. They are marked using !, which is an empty type.",
	"CICD - Packaging - Macros": "Rust provides a powerful macro system that allows metaprogramming. As you've seen in previous chapters, macros look like functions, except that their name ends with a bang !, but instead of generating a function call, macros are expanded into source code that gets compiled with the rest of the program. However, unlike macros in C and other languages, Rust macros are expanded into abstract syntax trees, rather than string preprocessing, so you don't get unexpected precedence bugs.",

	"CICD - Compilation": "SECTION",
	"CICD - Compilation - Crate": "When compiling a crate, the compiler first looks in the crate root file for code to compile.",

	"CICD - Execution": "SECTION",
	"CICD - Execution - Scopes": "",
	"CICD - Execution - Memory": "",
	"CICD - Execution - Memory - undefined": "Undefined behaviour in Rust refers to actions that the Rust compiler and runtime do not guarantee to behave predictably or correctly. A foundational goal of Rust is to ensure that your programs never have undefined behavior.",
	"CICD - Execution - Memory - safety": "Ownership model prevents undefined behaviour which thus ensures memory-safety.",
	"CICD - Execution - Memory - Heap": "Heap memory is for dynamic memory allocation, suitable for objects that need to persist beyond the scope of a single function call.",
	"CICD - Execution - Memory - Heap - size": ".",
	"CICD - Execution - Memory - Heap - objects": "Rust data structures like Vec, String, and HashMap use the heap memory by default.",
	"CICD - Execution - Memory - Heap - Box": "Rust also provides you the Box construct for putting data on the heap.",
	"CICD - Execution - Memory - Heap - lifecycle": "Rust automatically frees a box’s heap memory when it deallocates the variable’s stack frame that owns the box.",
	"CICD - Execution - Memory - Stack": "Stack memory is for static memory allocation, typically used for variables with a known lifetime and scope.",
	"CICD - Execution - Memory - Stack - frame": "used to store all of the local variables and function parameters.",
	"CICD - Execution - Memory - Stack - frame - lifecycle": "When you call a function in Rust, it allocates a stack frame for it. Once main has exited, the stack frame allocated on entry will be released.",
	"CICD - Execution - Memory - Stack - variables": "Variables Live in the Stack. When you call a function in Rust, it allocates a stack frame for it. You can think of a stack frame as a mapping from variables to their values within a single scope, such as a function.",
	"CICD - Execution - Memory - Stack - variables - copy": "When an expression reads a variable (for example is assignments and function calls), the variable’s value is copied from its slot in the stack frame.",
	"CICD - Execution - Memory - Ownership": "Each piece of data in Rust has a single owner, and the data is automatically deallocated when the owner goes out of scope. This prevents memory leaks and dangling pointers.",
	"CICD - Execution - Memory - Ownership - GC": "Rust does not use a garbage collector (Java) nor does it rely on manual memory management (C). Instead, Rust employs a unique memory management system based on ownership with the help of the borrow checker.",
	"CICD - Execution - Memory - Pointers": "A pointer is a value that describes a location in memory.",
	"CICD - Execution - Memory - Pointers - References": "A reference points to the memory of another value. A reference means you borrow the value, but you don't own it.",
	"CICD - Execution - Memory - Pointers - Borrowing": "The variable still lives in the stack but its value is stored in the heap.",
	"CICD - Execution - Memory - Pointers - Slice": "",
	"CICD - Testing": ""

}