{
	"Rust": "SECTION",
	"Rust - description": "Rust is a systems programming language that focuses on safety, concurrency, and performance. It was developed by Mozilla Research and first appeared in 2010. Rust aims to address common pitfalls in programming, such as memory safety issues, data races, and undefined behavior, often found in languages like C and C++.",

	"Variables": "SECTION",
	"Variables - DataTypes - std": "The Rust Standard Library is the foundation of portable Rust software",
	"Variables - DataTypes - std - Primitives - Scalar": "Despite the value of a unit type being a tuple, it is not considered a compound type because it does not contain multiple values.",
	"Variables - DataTypes - std - Primitives - Scalar - Integers - signed": "Signed integers: i8, i16, i32, i64, i128 and isize (pointer size)",
	"Variables - DataTypes - std - Primitives - Scalar - Integers - unsigned": "Unsigned integers: u8, u16, u32, u64, u128 and usize (pointer size)",
	"Variables - DataTypes - std - Primitives - Scalar - Floating": "Floating point: f32, f64",
	"Variables - DataTypes - std - Primitives - Scalar - char": "char Unicode scalar values like 'a', 'α' and '∞' (4 bytes each)",
	"Variables - DataTypes - std - Primitives - Scalar - String": "The String type is the most common string type in rust and it has ownership over the content of the string. It is heap-allocated, growable, and not null-terminated. A String is stored as a vector of bytes(Vec<u8>), and guaranteed to be a valid UTF-8 sequence.",
	"Variables - DataTypes - std - Primitives - Scalar - str": "str is simply a reference and will most commonly be seen as &str. String literals or str is the most primitive string type. A Rust &str is like a char*. str is an immutable sequence of UTF-8 bytes of dynamic length somewhere in memory. Since the size is unknown, one can only handle it behind a pointer, hence it most commonly appears as &str: a reference to some UTF-8 data, normally called a 'string slice'",
	"Variables - DataTypes - std - Primitives - Scalar - bool": "bool either true or false",
	"Variables - DataTypes - std - Primitives - Scalar - ()": "The unit type (), whose only possible value is an empty tuple: ()",
	"Variables - DataTypes - std - Primitives - Compound": ".",
	"Variables - DataTypes - std - Primitives - Compound - Arrays": "Arrays like [1, 2, 3].",
	"Variables - DataTypes - std - Primitives - Compound - Tuples": "Tuples like (1, true).",
	"Variables - DataTypes - std - Custom Types": "",
	"Variables - DataTypes - std - Custom Types - struct": "Struct is a user-defined data type that can hold different types of data together. struct the keyword is used to create structure in Rust. struct: define a structure",
	"Variables - DataTypes - std - Custom Types - enum": "enum: define an enumeration",
	"Variables - DataTypes - std - Collectons - vector": "A vector allows you to store a variable number of values next to each other.",
	"Variables - DataTypes - std - Collectons - string": "A string is a collection of characters. We’ve mentioned the String type previously, but in this chapter we’ll talk about it in depth. The String type, which is provided by Rust’s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type. When Rustaceans refer to “strings” in Rust, they might be referring to either the String or the string slice &str types, not just one of those types. Although this section is largely about String, both types are used heavily in Rust’s standard library, and both String and string slices are UTF-8 encoded.",
	"Variables - DataTypes - std - Collectons - hash map": "A hash map allows you to associate a value with a specific key. It’s a particular implementation of the more general data structure called a map.",
	"Variables - DataTypes - Generics": "Generics is the topic of generalizing types and functionalities to broader cases.",
	"Variables - DataTypes - Generics - types- Functions": "",
	"Variables - DataTypes - Generics - types- Implementations": "",
	"Variables - DataTypes - Generics - types- Traits": "",
	"Variables - DataTypes - Generics - bound": "",
	"Variables - DataTypes - Generics - where": "",
	"Variables - DataTypes - Generics - newtype": "",
	"Variables - DataTypes - Generics - phantom": "",
	"Variables - DataTypes - Operations - Copy": "The Copy trait in Rust defines the ability to implicitly copy an object. The behavior Copy is not overloadable. It is always a simple bitwise copy. This is available for the types that have a fixed size and are stored entirely on the stack.",
	"Variables - DataTypes - Operations - Clone": "The Clone trait defines the ability to explicitly create a deep copy of an object T. When we call Clone for type T, it does all the arbitrarily complicated operations required to create a new T.",
	"Variables - DataTypes - Operations - Casting": "",
	"Variables - DataTypes - Operations - Inference": "",
	"Variables - DataTypes - Operations - Aliasing": "",
	"Variables - DataTypes - Operations - Conversion": "",
	"Variables - DataTypes - Implementations - Traits": "The Rust traits are a set of methods that can be defined for particular types. Traits allow you to define shared behavior that can be used by multiple types. A trait method is able to access other methods within that trait.",
	"Variables - DataTypes - Implementations - Traits - impl Trait": "The impl keyword is primarily used to define implementations on types.",
	"Variables - DataTypes - Implementations - Traits - impl Trait - fun": "Functions and consts can both be defined in an implementation. A function defined in an impl block can be standalone, meaning it would be called like Foo::bar().",
	"Variables - DataTypes - Implementations - Traits - impl Trait - fun - self": "If the function takes self, &self, or &mut self as its first argument, it can also be called using method-call syntax, a familiar feature to any object oriented programmer, like foo.bar().",
	"Variables - DataTypes - Implementations - Traits - impl Trait - fun - &self": "If the function takes self, &self, or &mut self as its first argument, it can also be called using method-call syntax, a familiar feature to any object oriented programmer, like foo.bar().",
	"Variables - DataTypes - Implementations - Traits - impl Trait - fun - &mut self": "If the function takes self, &self, or &mut self as its first argument, it can also be called using method-call syntax, a familiar feature to any object oriented programmer, like foo.bar().",
	"Variables - DataTypes - Implementations - Traits - where": "where can be used for constraints with traits.",
	"Variables - DataTypes - Implementations - Traits - #[derive]": "The compiler is capable of providing basic implementations for some traits via the #[derive] attribute. These traits can still be manually implemented if a more complex behavior is required.",
	"Variables - DataTypes - Implementations - Traits - dyn": "The dyn keyword is used to highlight that calls to methods on the associated Trait are dynamically dispatched. To use the trait this way, it must be ‘object safe’.",
	"Variables - DataTypes - Implementations - Traits - Drop": "The Drop trait only has one method: drop, which is called automatically when an object goes out of scope. The main use of the Drop trait is to free the resources that the implementor instance owns. Box, Vec, String, File, and Process are some examples of types that implement the Drop trait to free resources. The Drop trait can also be manually implemented for any custom data type.",
	"Variables - DataTypes - Implementations - Traits - Iterator": "The Iterator trait is used to implement iterators over collections such as arrays. The trait requires only a method to be defined for the next element, which may be manually defined in an impl block or automatically defined (as in arrays and ranges).",
	"Variables - DataTypes - Implementations - Traits - Clone": "When dealing with resources, the default behavior is to transfer them during assignments or function calls. However, sometimes we need to make a copy of the resource as well. The Clone trait helps us do exactly this. Most commonly, we can use the .clone() method defined by the Clone trait.",
	"Variables - DataTypes - Implementations - Traits - supertrait": "Rust doesn't have inheritance, but you can define a trait as being a superset of another trait.",
	"Variables - Declaration - Typing - static": "Rust provides type safety via static typing. Variable bindings can be type annotated when declared. However, in most cases, the compiler will be able to infer the type of the variable from the context, heavily reducing the annotation burden.",
	"Variables - Declaration - Typing - let": "Values (like literals) can be bound to variables, using the let binding.  let an_integer = 1u32;",
	"Variables - Declaration - Naming": "",
	"Variables - Declaration - Assignment": "",
	"Variables - Declaration - Assignment - declare first": "It's possible to declare variable bindings first, and initialize them later. However, this form is seldom used, as it may lead to the use of uninitialized variables.",
	"Variables - Declaration - Assignment - uninitialized": "The compiler forbids use of uninitialized variables, as this would lead to undefined behavior.",
	"Variables - Declaration - Mutation": "Variable bindings are immutable by default, but this can be overridden using the mut modifier.",
	"Variables - Declaration - Mutation - mut": "Variable bindings are immutable by default, but this can be overridden using the mut modifier.",
	"Variables - Declaration - Mutation - freezing": "When data is bound by the same name immutably, it also freezes. Frozen data can't be modified until the immutable binding goes out of scope.",

	"Logic": "SECTION",
	"Logic - Sync - Imperative - ControlFlow": "",
	"Logic - Sync - Imperative - ControlFlow - Expressions": "",
	"Logic - Sync - Imperative - ControlFlow - if/else": "Branching with if-else is similar to other languages. Unlike many of them, the boolean condition doesn't need to be surrounded by parentheses, and each condition is followed by a block. if-else conditionals are expressions, and, all branches must return the same type.",
	"Logic - Sync - Imperative - ControlFlow - if/let": "Another benefit is that if let allows us to match non-parameterized enum variants.",
	"Logic - Sync - Imperative - ControlFlow - let/else": "With let-else, a refutable pattern can match and bind variables in the surrounding scope like a normal let, or else diverge (e.g. break, return, panic!) when the pattern doesn't match.",
	"Logic - Sync - Imperative - ControlFlow - match": "Rust provides pattern matching via the match keyword, which can be used like a C switch. The first matching arm is evaluated and all possible values must be covered.",
	"Logic - Sync - Imperative - ControlFlow - Iterators - loop": "Rust provides a loop keyword to indicate an infinite loop.",
	"Logic - Sync - Imperative - ControlFlow - Iterators - while": "The while keyword can be used to run a loop while a condition is true.",
	"Logic - Sync - Imperative - ControlFlow - Iterators - while/let": ".",
	"Logic - Sync - Imperative - ControlFlow - Iterators - for": "The for in construct can be used to iterate through an Iterator. One of the easiest ways to create an iterator is to use the range notation a..b. This yields values from a (inclusive) to b (exclusive) in steps of one.",
	"Logic - Sync - Imperative - ControlFlow - Iterators - break": "The break statement can be used to exit a loop at anytime.",
	"Logic - Sync - Imperative - ControlFlow - Iterators - continue": "continue statement can be used to skip the rest of the iteration and start a new one.",
	"Logic - Sync - Imperative - ControlFlow - UnsafeOperations": "",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling": "",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - Recoverable": "Most errors aren’t serious enough to require the program to stop entirely. Sometimes when a function fails it’s for a reason that you can easily interpret and respond to. For example, if you try to open a file and that operation fails because the file doesn’t exist, you might want to create the file instead of terminating the process.",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - Unrecoverable - panic!": "Sometimes bad things happen in your code, and there’s nothing you can do about it. In these cases, Rust has the panic! macro.",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - Unrecoverable - panic! - automatic": "by taking an action that causes our code to panic (such as accessing an array past the end)",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - Unrecoverable - panic! - explicitly": "by explicitly calling the panic! macro",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - Unrecoverable - panic! - message": "By default, these panics will print a failure message, unwind, clean up the stack, and quit. Via an environment variable, you can also have Rust display the call stack when a panic occurs to make it easier to track down the source of the panic.",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - Unrecoverable - Option<T>": "Sometimes it's desirable to catch the failure of some parts of a program instead of calling panic!; this can be accomplished using the Option enum. ",
	"Logic - Sync - Imperative - OOP": "Some people say that Rust is Object-Oriented and others say that it is not. Rust: Implement Inheritance 3 Ways",
	"Logic - Sync - Imperative - OOP - enum": "",
	"Logic - Sync - Imperative - OOP - trait": "",
	"Logic - Sync - Imperative - OOP - struct": "Struct Composition",
	"Logic - Async - Frameworks - Tokio": "https://medium.com/@anon.quant/why-one-should-avoid-using-asynchronous-frameworks-like-tokio-in-real-time-trading-systems-663edbf4e961",
	"Logic - Multithreading": "",
	"Logic - Multithreading - Concurrency": "Rust’s type system prevents data races at compile-time, making it easier to write safe, concurrent programs.",
	"Logic - Resources": "",
	"Logic - IO - CommandLine": "",
	"Logic - IO - EnvVars": "",
	"Logic - IO - stdout": "",
	"Logic - IO - stderr": "",

	"CICD - Architecture": "SECTION",
	"CICD - Architecture - Structure - Workspace": "A workspace is basically a series of packages that share the same output directory as well as cargo.lock.",
	"CICD - Architecture - Structure - Package": "A package is a bundle of one or more crates that provides a set of functionality.",
	"CICD - Architecture - Structure - Crate": "A crate is the smallest amount of code that the Rust compiler considers at a time.",
	"CICD - Architecture - Structure - Crate - root": "The crate root is a source file that the Rust compiler starts from and makes up the root module of your crate usually src/lib.rs for a library crate or src/main.rs for a binary crate.",
	"CICD - Architecture - Structure - Crate - types": "A crate can come in one of two forms: a binary crate or a library crate. A package can contain as many binary crates as you like, but at most only one library crate. A package must contain at least one crate, whether that’s a library or binary crate..",
	"CICD - Architecture - Structure - Crate - types - binary": "Binary crates are programs you can compile to an executable that you can run, such as a command-line program or a server. Each must have a function called main that defines what happens when the executable runs. All the crates we’ve created so far have been binary crates.",
	"CICD - Architecture - Structure - Crate - types - library": "Library crates don’t have a main function, and they don’t compile to an executable. Instead, they define functionality intended to be shared with multiple projects. Most of the time when Rustaceans say “crate”, they mean library crate, and they use “crate” interchangeably with the general programming concept of a “library“.",
	"CICD - Architecture - Structure - Crate - Attributes": "",
	"CICD - Architecture - Structure - Modules": "Crates can contain modules, and the modules may be defined in other files that get compiled with the crate.",
	"CICD - Architecture - Structure - Modules - declare": "In the crate root file, you can declare new modules; say you declare a “garden” module with mod garden;. The compiler will look for the module’s code in these places 1. Inline, within curly brackets that replace the semicolon following mod garden 2. In the file src/garden.rs 3. In the file src/garden/mod.rs",
	"CICD - Architecture - Structure - Modules - refer": "Paths to code in modules: Once a module is part of your crate, you can refer to code in that module from anywhere else in that same crate, as long as the privacy rules allow, using the path to the code. For example, an Asparagus type in the garden vegetables module would be found at crate::garden::vegetables::Asparagus.",
	"CICD - Architecture - Structure - Submodules": "Crates can contain modules, and the modules may be defined in other files that get compiled with the crate.",
	"CICD - Architecture - Structure - Submodules - declare": "Declaring submodules: In any file other than the crate root, you can declare submodules. For example, you might declare mod vegetables; in src/garden.rs. The compiler will look for the submodule’s code within the directory named for the parent module in these places: 1. Inline, directly following mod vegetables, within curly brackets instead of the semicolon 2. In the file src/garden/vegetables.rs 3. In the file src/garden/vegetables/mod.rs",
	"CICD - Architecture - Structure - Functions": "",
	"CICD - Architecture - Structure - Functions - format - fn": "Functions are declared using the fn keyword.",
	"CICD - Architecture - Structure - Functions - format - arguments": "Its arguments are type annotated, just like variables.",
	"CICD - Architecture - Structure - Functions - format - returndec": "if the function returns a value the return type must be specified after an arrow ->. Functions that don't return a value, actually return the unit type `()`",
	"CICD - Architecture - Structure - Functions - format - returndec - Result<T, E>": "Result<T, E> is the type used for returning and propagating errors. It is an enum with the variants, Ok(T), representing success and containing a value, and Err(E), representing error and containing an error value.",
	"CICD - Architecture - Structure - Functions - format - returndec - Result<T, E> - Ok(T) ": "Ok(T), representing success and containing a value",
	"CICD - Architecture - Structure - Functions - format - returndec - Result<T, E> - Err(E) ": "Err(E), representing error and containing an error value",
	"CICD - Architecture - Structure - Functions - format - return": "The final expression in the function will be used as return value. Alternatively, the return statement can be used to return a value earlier from within the function, even from inside loops or if statements.",
	"CICD - Architecture - Structure - AssociatedFunctions": "Associated functions are functions that are defined on a type generally",
	"CICD - Architecture - Structure - AssociatedFunctions - example": "struct Point { x: f64, y: f64, } impl Point { fn origin() -> Point { Point { x: 0.0, y: 0.0 } } }",
	"CICD - Architecture - Structure - HOF": "Rust provides Higher Order Functions (HOF). These are functions that take one or more functions and/or produce a more useful function. HOFs and lazy iterators give Rust its functional flavor.",
	"CICD - Architecture - Structure - DivergingFunctions": "Diverging functions never return. They are marked using !, which is an empty type.",
	"CICD - Architecture - Structure - Macros": "Rust provides a powerful macro system that allows metaprogramming. As you've seen in previous chapters, macros look like functions, except that their name ends with a bang !, but instead of generating a function call, macros are expanded into source code that gets compiled with the rest of the program. However, unlike macros in C and other languages, Rust macros are expanded into abstract syntax trees, rather than string preprocessing, so you don't get unexpected precedence bugs.",
	"CICD - Architecture - Structure - Macros - macro_rules!": "Macros are created using the macro_rules! macro.",
	"CICD - Architecture - Structure - Macros - invocation": "macros look like functions, except that their name ends with a bang !, but instead of generating a function call, macros are expanded into source code that gets compiled with the rest of the program.",
	"CICD - Architecture - Structure - Methods": "methods are associated functions that are called on a particular instance of a type.",
	"CICD - Architecture - Structure - Methods - example": "methods are associated functions that are called on a particular instance of a type.",
	"CICD - Architecture - Structure - Closures": "Closures are functions that can capture the enclosing environment. Closures are powerful anonymous functions that capture their own environment and can be saved in a variable and also passed to other functions as arguments.",
	"CICD - Architecture - Patterns": "",
	"CICD - Architecture - OO": "",

	"CICD - Applications - Web - Wasm": "Rust’s compatibility with WebAssembly (Wasm) has opened up new avenues for web development, allowing Rust code to run at near-native speed in web browsers.",
	"CICD - Applications - Systems - Linux Kernel": "",
	"CICD - Applications - Systems - Blockchain": "",
	"CICD - Applications - Systems - Browsers": "At Google, we are driving the adoption of Rust in platforms like Android and Chromium to reduce memory safety vulnerabilities.",
	"CICD - Applications - Systems - Android": "Google recently rewrote the protected virtual machine firmware within the Android virtualization framework using the Rust programming language.",
	"CICD - Applications - Web - frameworks - Actix": "",
	"CICD - Applications - Web - frameworks - Loco": "",

	"CICD - Bundling": "SECTION",
	"CICD - Bundling - PackageManager - Cargo": "Cargo is the Rust package manager. It is a tool that allows Rust packages to declare their various dependencies and ensure that you’ll always get a repeatable build.",
	"CICD - Bundling - PackageManager - Cargo - cargo": "Cargo is actually a package that contains the binary crate for the command-line tool you’ve been using to build your code. The Cargo package also contains a library crate that the binary crate depends on. Other projects can depend on the Cargo library crate to use the same logic the Cargo command-line tool uses.",
	"CICD - Bundling - PackageManager - Cargo - Cargo.toml": "A package contains a Cargo.toml file that describes how to build those crates. The Cargo.toml file is a manifest file where we can specify metadata such as name, version, etc, project settings, and dependencies(crates) for our project.",
	"CICD - Bundling - PackageManager - Cargo - Cargo.lock": "The Cargo.lock file contains exact information about dependencies and Cargo maintains it. If we are building a rust library, then put Cargo.lock in the .gitignore but if we are building end products application then Cargo.lock should be checked into the git repo.",
	"CICD - Bundling - PackageManager - Cargo - newExecutable": "Create a new package that builds an executable: cargo new IntmainApp.",
	"CICD - Bundling - PackageManager - Cargo - newLib": "Create a new package that builds a library: cargo new --lib IntmainLib.",
	"CICD - Bundling - PackageManager - Cargo - tree": "Display a tree of dependencies in the project: cargo tree",
	"CICD - Bundling - C": "Rust supports interoperability with C code without introducing any additional overhead.",

	"CICD - Building": "SECTION",
	"CICD - Building - Crate": "When compiling a crate, the compiler first looks in the crate root file for code to compile.",
	"CICD - Building - rustc": ".",
	"CICD - Building - cargo - build": "Build a package and all its dependencies: cargo build",
	"CICD - Building - cargo - release": "Build a package with optimization: cargo build -- release",

	"CICD - Execution": "SECTION",
	"CICD - Execution - Scopes": "Rust’s name resolution operates on a global hierarchy of namespaces. Each level in the hierarchy can be thought of as some item. The items are one of those mentioned above, but also include external crates. Declaring or defining a new module can be thought of as inserting a new tree into the hierarchy at the location of the definition. To control whether interfaces can be used across modules, Rust checks each use of an item to see whether it should be allowed or not. This is where privacy warnings are generated, or otherwise “you used a private item of another module and weren’t allowed to.",
	"CICD - Execution - Scopes - default": "By default, everything is private, with two exceptions: Associated items in a pub Trait are public by default; Enum variants in a pub enum are also public by default. If an item is private, it may be accessed by the current module and its descendants.",
	"CICD - Execution - Scopes - pub": "When an item is declared as pub, it can be thought of as being accessible to the outside world. If an item is public, then it can be accessed externally from some module m if you can access all the item’s ancestor modules from m. You can also potentially be able to name the item through re-exports. See below.",
	"CICD - Execution - Scopes - pub (in path)": "pub(in path) makes an item visible within the provided path. path must be an ancestor module of the item whose visibility is being declared. Starting with the 2018 edition, paths for pub(in path) must start with crate, self, or super. The 2015 edition may also use paths starting with :: or modules from the crate root.",
	"CICD - Execution - Scopes - pub (crate)": "pub(crate) makes an item visible within the current crate.",
	"CICD - Execution - Scopes - pub (super)": "pub(super) makes an item visible to the parent module. This is equivalent to pub(in super).",
	"CICD - Execution - Scopes - pub (self)": "pub(self) makes an item visible to the current module. This is equivalent to pub(in self) or not using pub at all.",
	"CICD - Execution - Scopes - pub use": "Rust allows publicly re-exporting items through a pub use directive. Because this is a public directive, this allows the item to be used in the current module through the rules above. It essentially allows public access into the re-exported item.",
	"CICD - Execution - Memory": "",
	"CICD - Execution - Memory - undefined": "Undefined behaviour in Rust refers to actions that the Rust compiler and runtime do not guarantee to behave predictably or correctly. A foundational goal of Rust is to ensure that your programs never have undefined behavior.",
	"CICD - Execution - Memory - safety": "Ownership model prevents undefined behaviour which thus ensures memory-safety.",
	"CICD - Execution - Memory - Heap": "Heap memory is for dynamic memory allocation, suitable for objects that need to persist beyond the scope of a single function call.",
	"CICD - Execution - Memory - Heap - size": ".",
	"CICD - Execution - Memory - Heap - objects": "Rust data structures like Vec, String, and HashMap use the heap memory by default.",
	"CICD - Execution - Memory - Heap - Box<T>": "Rust also provides you the Box construct for putting data on the heap. Values can be boxed (allocated on the heap) by creating a Box<T>. A box is a smart pointer to a heap allocated value of type T. When a box goes out of scope, its destructor is called, the inner object is destroyed, and the memory on the heap is freed.",
	"CICD - Execution - Memory - Heap - *": "Boxed values can be dereferenced using the * operator; this removes one layer of indirection. let unboxed_point: Point = *boxed_point;",
	"CICD - Execution - Memory - Heap - lifecycle": "Rust automatically frees a box’s heap memory when it deallocates the variable’s stack frame that owns the box.",
	"CICD - Execution - Memory - Stack": "Stack memory is for static memory allocation, typically used for variables with a known lifetime and scope.",
	"CICD - Execution - Memory - Stack - frame": "used to store all of the local variables and function parameters.",
	"CICD - Execution - Memory - Stack - frame - lifecycle": "When you call a function in Rust, it allocates a stack frame for it. Once main has exited, the stack frame allocated on entry will be released.",
	"CICD - Execution - Memory - Stack - variables": "Variables Live in the Stack. When you call a function in Rust, it allocates a stack frame for it. You can think of a stack frame as a mapping from variables to their values within a single scope, such as a function.",
	"CICD - Execution - Memory - Stack - variables - copy": "When an expression reads a variable (for example is assignments and function calls), the variable’s value is copied from its slot in the stack frame.",
	"CICD - Execution - Memory - Ownership": "Each piece of data in Rust has a single owner, and the data is automatically deallocated when the owner goes out of scope. This prevents memory leaks and dangling pointers.",
	"CICD - Execution - Memory - Ownership - GC": "Rust does not use a garbage collector (Java) nor does it rely on manual memory management (C). Instead, Rust employs a unique memory management system based on ownership with the help of the borrow checker.",
	"CICD - Execution - Memory - Pointers": "A pointer is a value that describes a location in memory.",
	"CICD - Execution - Memory - Pointers - References": "A reference points to the memory of another value. A reference means you borrow the value, but you don't own it.",
	"CICD - Execution - Memory - Pointers - References - immutable": "These are read-only references that allow you to borrow an immutable view of a value. When you have an immutable reference to a value, you cannot mutate the value through that reference. Immutable references are created using the & symbol followed by the value you want to borrow.",
	"CICD - Execution - Memory - Pointers - References - mutable": ": These are references that allow you to borrow a mutable view of a value. When you have a mutable reference to a value, you can mutate the value through that reference. Mutable references are created using the &mut keyword followed by the value you want to borrow.",
	"CICD - Execution - Memory - Pointers - Borrowing": "The variable still lives in the stack but its value is stored in the heap.",
	"CICD - Execution - Memory - Pointers - Slice": "Slices in Rust are references to consecutive elements in memory, allowing you to reference parts of a collection without copying the entire data, providing a view into arrays, vectors, or other sequences for focused data manipulation. A Rust slice is a data type used to access portions of data stored in collections like arrays, vectors and strings.",
	"CICD - Execution - cargo - run": "Run a binary of local package: cargo run.  Arguments to the binary are followed by two dashes (--): cargo run -- args",
	"CICD - Execution - cargo - clean": "Remove generated artifacts from the target directory: cargo clean",

	"CICD - Audit": "SECTION",
	"CICD - Audit - Testing": "SECTION",
	"CICD - Audit - Testing - UnitTesting - #[cfg(test)]": "Most unit tests go into a tests mod with the #[cfg(test)] attribute.",
	"CICD - Audit - Testing - UnitTesting - #[test]": "Test functions are marked with the #[test] attribute.",
	"CICD - Audit - Testing - UnitTesting - #[ignore]": "Tests can be marked with the #[ignore] attribute to exclude some tests.",
	"CICD - Audit - Testing - UnitTesting - fail": "Tests fail when something in the test function panics.",
	"CICD - Audit - Testing - UnitTesting - assert - assert!(expression)": "assert!(expression) - panics if expression evaluates to false.",
	"CICD - Audit - Testing - UnitTesting - assert - assert_eq!(left, right)": "testing left and right expressions for equality.",
	"CICD - Audit - Testing - UnitTesting - assert - assert_ne!(left, right)": "testing left and right expressions for inequality.",
	"CICD - Audit - Testing - UnitTesting - cargo": "Compile and execute unit, integration, and documentation tests: cargo test",
	"CICD - Audit - Testing - UnitTesting - cargo - ignore": "Or to run them with command cargo test -- --ignored",
	"CICD - Audit - Testing - IntegrationTesting": "Integration tests are external to your crate and use only its public interface in the same way any other code would. Their purpose is to test that many parts of your library work correctly together.",
	"CICD - Audit - Testing - IntegrationTesting - test folder": "Cargo looks for integration tests in tests directory next to src."

}