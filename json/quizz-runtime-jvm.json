{
	"JDK": "SECTION",
	"JDK - root certificates": "",
	"JDK - Root Certificates (Java 10)": "One of the enhancements to JDK 10 includes, for the first time, a set of root CA (Certificate Authority) certificates incorporated into the OpenJDK source. As specified by Java Enhancement Proposal (JEP 319), providing root CA certificates makes 'OpenJDK builds more attractive to developers' and 'reduces [sic] the differences between those builds and Oracle JDK builds.'",
	"JDK - Root Certificates - cacert": "Root certificates are stored, by default, in a keystore file called cacerts. Prior to JDK 10, the source code contained an empty cacerts file, disabling the ability to establish trust and effectively rendering many important security protocols unuseable. To work around this shortcoming, developers had to roll their own cacerts keystore by manually populating it with a set of root certificates. ",
	"JDK - Unified Logging (Java 9)": "The JVM-internal, unified logging infrastructure is very similar to known logging frameworks like Log4j or Logback that you might have used for your application. It generates textual messages, attaches some meta information like tags (describing the originating subsystem), a log level (describing the importance of the message), and time stamps before printing them somewhere. The logging output can be configured according to your needs.",
	"JDK - Unified Logging - -Xlog": "Logging can be activated with the java option -Xlog. This is the only flag regarding this mechanism – any further configuration is immediately appended to that option. Configurable aspects of logging are: which messages to log (by tag and/or by log level), which information to include (for example time stamps and process IDs), which output to use (for example a file)",
	"JDK - Packaging - Multi-release JARs (Java 9)": "Multi-release JARs allow you to create a single JAR that contains bytecode for several Java versions. JVMs will then load the code that was included for their version.",

	"VM": "SECTION",
	"VM - Bytecode": "",
	"VM - Bytecode - execution": "To execute a class’ bytecode, the JVM needs to perform a couple of preparatory steps. Given a class name, it looks the class up in a JAR, loads it, verifies the bytecode, and pulls it into an internal data structure. That takes some time of course, which is most noticeable when the JVM launches and needs to load at least a few hundred, more likely a couple of thousand classes. The thing is, as long as the application’s JARs do not change, this class-data is always the same. The JVM executes the same steps and comes to the same result every time it runs the app.",
	"VM - Bytecode - AppCDS (Java 10)": "Application Class-Data Sharing. Enter application class-data sharing! The idea behind it is to create this data once, dump it into an archive, and then reuse that in future launches and even share it across simultaneously running JVM instances: (1) create a list of classes to include in the archive (possibly with -XX:DumpLoadedClassList) (2) create an archive with the option -Xshare:dump (3) use the archive with the option -Xshare:on. When launching with -Xshare:on, the JVM maps the archive file into its own memory and thus has most classes it needs readily available and does not have to muck around with JARs. The memory region can even be shared between concurrently running JVM instances, which frees up memory that would otherwise be wasted on replicating the same information in each instance.",
	"VM - Bytecode - AppCDS - advantages": "AppCDS significantly reduces the time the JVM has to spend on class loading, which is most noticeable during launch. It also prevents long response times in the case where a user is the first to access a feature that requires a lot of classes that weren’t loaded yet.",
	"VM - Bytecode - XX:DumpLoadedClassList": "List of classes to include in the archive",
	"VM - JRockitVM ": "",
	"VM - JRockitVM": "",
	"VM - JRockitVM - Diagnostic Commands": "You can use diagnostic commands to communicate with a running Oracle JRockit JVM process. These commands tell the JRockit JVM to perform tasks such as printing a heap report or a garbage collection activity report, or enabling a specific verbose module. You can send diagnostic commands to a running JVM process in several ways: (1) By using jrcmd, a command-line tool that sends the commands to a given JRockit JVM process. (2) By pressing Ctrl-Break, the JVM will search for the ctrlhandler.act file and execute the commands in it. (3) By using the JRockit Management Console in Oracle JRockit Mission Control to send diagnostic commands to a running JRockit JVM process. You can enable or disable diagnostic command by using the system property -Djrockit.ctrlbreak.enable<name>=<true|false>, where name is the name of the diagnostic command. The run_class handler is not enabled by default. To enable it, enter the following: -Djrockit.ctrlbreak.enablerun_class=true",
	"VM - JRockitVM - Diagnostic Commands - jrcmd": "Enter jrcmd at the command line with the appropriate parameters. jrcmd <jrockit pid> [<command> [<arguments>]] [-l] [-f file] [-p] -h]",
	"VM - HotSpotVM ": "",
	"VM - HotSpotVM": "The Java HotSpot Virtual Machine is a core component of the Java SE platform. It implements the Java Virtual Machine Specification, and is delivered as a shared library in the Java Runtime Environment. As the Java bytecode execution engine, it provides Java runtime facilities, such as thread and object synchronization, on a variety of operating systems and architectures. It includes dynamic compilers that adaptively compile Java bytecodes into optimized machine instructions and efficiently manages the Java heap using garbage collectors, optimized for both low pause time and throughput. It provides data and information to profiling, monitoring and debugging tools and applications.",
	"VM - HotSpotVM - JITCompiler - Java9": "",
	"VM - HotSpotVM - JITCompiler - Compiler (Java 9)": "An AOT compiler was added to the OpenJDK as part of the Java 9 release. The main goal was to improve the start-up time of Java applications with minimum impact to the application’s peak performance. Whilst not as fast as a warmed up JIT compilation AOT avoids incurring performance penalties from having to repeat interpreted invocations.",
	"VM - HotSpotVM - JITCompiler - Compilation": "JIT compilation is a form of dynamic compilation which combines the use of Ahead-Of-Time (AOT) compilation and interpretation, and thus has advantages and disadvantages from both technologies. JIT compilation combines the start-up speed of AOT compiled code with the flexibility of interpretation to create a faster solution. The main difference between JIT and AOT is that instead of interpreting bytecode every time a method is invoked, a JIT compiler will compile the bytecode into the machine code instructions of the running machine, and then invoke this object code instead. Another difference is that AOT also turns the bytecode of a virtual machine into native machine code so the interpreted code can be executed.",
	"VM - HotSpotVM - JITCompiler - CompileCommand": "The HotSpot JVM provides several command-line arguments related to Just In Time (JIT) compilation. In this post, I look at the steps needed to start applying the command-line flag -XX:CompileCommand to see the just-in-time compilation being performed on individual methods.",
	"VM - HotSpotVM - JITCompiler - CompilerControl (Java 9)": "Compiler Control provides a way to control Java Virtual Machine (JVM) compilation through compiler directive options. The level of control is runtime-manageable and method specific. Compiler Control supersedes and is backward compatible with CompileCommand.",
	"VM - HotSpotVM - JITCompiler - CompilerControl - directives": "A compiler directive is an instruction that tells the JVM how compilation should occur. A directive provides method-context precision in controlling the compilation process. Directives are a powerful tool for writing small, contained, JVM compiler tests because tests can be run without restarting the entire JVM. Compiler Control is also very useful for creating workarounds for bugs in the JVM compilers. You can specify a file that contains compiler directives while starting a program through the command line. You can also add or remove directives from an already running program through diagnostic commands.",
	"VM - HotSpotVM - JITCompiler - enable": "It is very easy to enable the experimental JIT compiler though as it is already included as part of the JDK. You just have to set the following options when running Java from the command line: -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler",
	"VM - HotSpotVM - JITCompiler - codecache": "The Java Virtual Machine (JVM) generates native code and stores it in a memory area called the codecache.",
	"VM - HotSpotVM - JITCompiler - codecache - segments (Java 9)": "Divide the code cache into distinct segments, each of which contains compiled code of a particular type, in order to improve performance and enable future extensions.",
	"VM - HotSpotVM - JITCompiler - Compiler Interface (Java 9)": "Java 9 specifies a new interface for JIT compilers that’s written in Java (JVMCI). This means that anybody can ship a JIT compiler that can be easily attached to a VM. The compiler can be the exclusive JIT compiler in a system, or it can work hand-in-hand with a built-in JIT compiler in tiered mode. In the first case, the compiler (which is just Java code, just like any application), interprets and eventually compiles itself. In the latter case however, the compiled code can be used for any compilation tier. Hotspot, like many other VMs, already defaults to a tiered compilation mode. In this mode, a method starts out by being interpreted, but after reaching a specific number of executions, it is compiled by the client compiler (which generates code quickly, but only with rather simple optimizations). Finally once enough executions have occurred, the code is compiled by the server compiler (which is comparably slow, but applies aggressive optimizations) for maximum performance. The custom JIT can be inserted at any level. This means it can be used both as a middle tier or as the final tier. a Java based JVM compiler interface (JVMCI) enabling a compiler written in Java to be used by the JVM as a dynamic compiler.",
	"VM - HotSpotVM - JITCompiler - javac": "",
	"VM - HotSpotVM - JITCompiler - sjavac (Java 9)": "The sjavac tool is an (allegedly smart) wrapper around javac, developed at Oracle and intended to provide the following features: incremental compiles - recompile only what's necessar, parallel compilation - utilize more than one core during compilation, keep compiler in a hot VM - reuse a JIT'ed javac instance for consecutive invocations",
	"VM - GraalVM ": "",

	"Memory": "SECTION",
	"Memory - Stack": "Stores method calls and local variables.",
	"Memory - Stack - Features - size": "The size of the stack will vary as methods and functions create and delete local variables as needed. Stack has size limits, which can vary according to the operating system you use.",
	"Memory - Stack - Features - Lifecycle": "Memory is allocated and then subsequently freed without you needing to manage the memory allocation. Variables that are stored on the stack exist for as long as the function that created them are running.",
	"Memory - Stack - Features - LIFO": "Follows LIFO (Last In, First Out) – The last method added is removed first.",
	"Memory - Stack - Features - FastAccess": "Fast Access – Stack memory is very fast compared to heap memory.",
	"Memory - Stack - Features - ThreadSpecific": "Thread-Specific – Each thread gets its own stack.",
	"Memory - Stack - Stores": ".",
	"Memory - Stack - Stores - MethodExecution": "Method execution (stores method calls).",
	"Memory - Stack - Stores - LocalVariables": "Local variables (primitives & references to objects).",
	"Memory - Stack - Stores - FunctionCallManagement": "Function call management (each method has its own stack frame).",
	"Memory - Stack - Reserved Areas - Java9": "Reserve extra space on thread stacks for use by critical sections, so that they can complete even when stack overflows occur..",
	"Memory - Stack - StackTrace": "Java 1.4 also introduced the StackTraceElement[] getStackTrace() method to the java.lang.Thread and java.lang.Throwable classes. This method respectively returns an array of stack trace elements representing the invoking thread's stack dump and provides programmatic access to the stack trace information printed by printStackTrace().",
	"Memory - Stack - StackTrace - StackWalker": "StackWalker provides four static getInstance() methods that return StackWalkers. The methods differ in whether or not the walkers also access hidden frames or refective frames (a subset of hidden frames) and retain Class references:",
	"Memory - Stack - StackTrace - StackWalker - Walking": "Once you have a StackWalker instance, you can access stack frames by invoking the forEach() and walk() methods.",
	"Memory - PermGen - Java7": "Permanent Generation or Perm Gen contains the application metadata required by the JVM to describe the classes and methods used in the application. Note that Perm Gen is not part of Java Heap memory. Perm Gen is populated by JVM at runtime based on the classes used by the application. Perm Gen also contains Java SE library classes and methods. Perm Gen objects are garbage collected in a full garbage collection.",
	"Memory - PermGen - MethodArea": "Method Area is part of space in the Perm Gen and used to store class structure (runtime constants and static variables) and code for methods and constructors.",
	"Memory - PermGen - MemoryPool": "Memory Pools are created by JVM memory managers to create a pool of immutable objects, if implementation supports it. String Pool is a good example of this kind of memory pool. Memory Pool can belong to Heap or Perm Gen, depending on the JVM memory manager implementation.",
	"Memory - PermGen - Runtime Constant Pool": "Runtime constant pool is per-class runtime representation of constant pool in a class. It contains class runtime constants and static methods. Runtime constant pool is the part of method area.",
	"Memory - PermGen - Java Stack Memory": "Java Stack memory is used for execution of a thread. They contain method specific values that are short-lived and references to other objects in the heap that are getting referred from the method.",
	"Memory - PermGen - Size - -XX:PermGen": "For setting the initial heap size when JVM starts",
	"Memory - PermGen - Size - -XX:MaxPermGen": "For setting the maximum size of Perm Gen",
	"Memory - PermGen - Size - -XX:SurvivorRatio": "For providing ratio of Eden space and Survivor Space, for example if Young Generation size is 10m and VM switch is -XX:SurvivorRatio=2 then 5m will be reserved for Eden Space and 2.5m each for both the Survivor spaces. The default value is 8",
	"Memory - PermGen - Size - -XX:NewRatio": "For providing ratio of old/new generation sizes. The default value is 2.",
	"Memory - MetaSpace - Stores": "It is used to store metadata such as class definitions, method data, and field data.",
	"Memory - MetaSpace - Java8": "The PermGen has been removed completely and replaced by MetaSpace. Metaspace is no more part of the heap memory, but of the native memory allocated to the process.",
	"Memory - MetaSpace - Capacity": "By default class metadata allocation is limited by the amount of available native memory (capacity will of course depend if you use a 32-bit JVM vs. 64-bit along with OS virtual memory availability).",
	"Memory - MetaSpace - MaxMetaspaceSize": "A new flag is available (MaxMetaspaceSize), allowing you to limit the amount of native memory used for class metadata. If you don’t specify this flag, the Metaspace will dynamically re-size depending of the application demand at runtime.",
	"Memory - MetaSpace - GC": "Garbage collection of the dead classes and classloaders is triggered once the class metadata usage reaches the “MaxMetaspaceSize.",
	"Memory - Heap": "Stores objects and instance variables.",
	"Memory - Heap - Features": ".",
	"Memory - Heap - Features - shared": "Shared by all threads – Unlike the stack, the heap is common for all threads.",
	"Memory - Heap - Features - slower": "Slower than stack – Since it requires garbage collection.",
	"Memory - Heap - Features - GC": "Garbage Collection (GC) – Objects that are no longer referenced are removed.",
	"Memory - Heap - Features - dynamic": "Used for Dynamic Memory Allocation – Objects remain in memory as long as needed.",
	"Memory - Heap - Stores - Objects": "All Java objects (instance variables, arrays, collections).",
	"Memory - Heap - Stores - new": "Objects created with new keyword.",
	"Memory - Heap - Stores - long": "Long-lived data (remains until garbage collection).",
	"Memory - Heap - Parts": "JVM Heap memory is physically divided into two parts – Young Generation and Old Generation.",
	"Memory - Heap - Parts - YoungGeneration": "Young generation is the place where all the new objects are created. When young generation is filled, garbage collection is performed. This garbage collection is called Minor GC.",
	"Memory - Heap - Parts - YoungGeneration - Parts": "Young Generation is divided into three parts – Eden Memory and two Survivor Memory spaces S0 and S1.",
	"Memory - Heap - Parts - YoungGeneration - Eden": "Most of the newly created objects are located in the Eden memory space.",
	"Memory - Heap - Parts - YoungGeneration - S0": "When Eden space is filled with objects, Minor GC is performed and all the survivor objects are moved to one of the survivor spaces.",
	"Memory - Heap - Parts - YoungGeneration - S1": "Minor GC also checks the survivor objects and move them to the other survivor space. So at a time, one of the survivor space is always empty.",
	"Memory - Heap - Parts - YoungGeneration - Eden ": "Most of the newly created objects are located in the Eden memory space.",
	"Memory - Heap - Parts - OldGeneration.": "Objects that are survived after many cycles of GC, are moved to the Old generation memory space. Usually it’s done by setting a threshold for the age of the young generation objects before they become eligible to promote to Old generation.",
	"Memory - Heap - Parts - OldGeneration": "Old Generation memory contains the objects that are long lived and survived after many rounds of Minor GC. Usually garbage collection is performed in Old Generation memory when it’s full. Old Generation Garbage Collection is called Major GC and usually takes longer time.",
	"Memory - Heap - Size - -Xms": "For setting the initial heap size when JVM starts",
	"Memory - Heap - Size - -Xmx": "For setting the maximum heap size.",
	"Memory - Heap - Size - -Xmn": "For setting the size of the Young Generation, rest of the space goes for Old Generation.",
	"Memory - Heap - XX:AllocateHeapAt=<path> (Java 10)": "Some operating systems already expose non-DRAM memory through the file system. Examples are NTFS DAX mode and ext4 DAX. Memory-mapped files in these file systems bypass the page cache and provide a direct mapping of virtual memory to the physical memory on the device. To allocate the heap in such memory we can add a new option, -XX:AllocateHeapAt=<path>. This option would take a path to the file system and use memory mapping to achieve the desired result of allocating the object heap on the memory device. The JEP does not intend to share a non-volatile region between multiple running JVMs or re-use the same region for further invocations of the JVM.",
	"Memory - Heap - GC - GarbageCollector": "Garbage Collector is the program running in the background that looks into all the objects in the memory and find out objects that are not referenced by any part of the program. All these unreferenced objects are deleted and space is reclaimed for allocation to other objects.",
	"Memory - Heap - GC - Gc. Stop the World": "All the Garbage Collections are “Stop the World” events because all application threads are stopped until the operation completes.",
	"Memory - Heap - GC - Gc. Duration": "The duration taken by garbage collector depends on the strategy used for garbage collection. That’s why it’s necessary to monitor and tune the garbage collector to avoid timeouts in the highly responsive applications.",
	"Memory - Heap - GC - Minor Gc": "Since Young generation keeps short-lived objects, Minor GC is very fast and the application doesn’t get affected by this.",
	"Memory - Heap - GC - Major Gc": "However Major GC takes longer time because it checks all the live objects. Major GC should be minimized because it will make your application unresponsive for the garbage collection duration. So if you have a responsive application and there are a lot of Major Garbage Collection happening, you will notice timeout errors.",
	"Memory - Heap - GC - GarbageCollector - Types": "There are five types of garbage collection: Serial GC, Parallel GC, Parallel Old GC, Concurrent Mark Sweep (CMS) Collector, G1 Garbage Collector. We just need to use JVM switch to enable the garbage collection strategy for the application. Let’s look at each of them one by one.",
	"Memory - Heap - GC - GarbageCollector - Serial GC (-XX:+UseSerialGC)": "Serial GC uses the simple mark-sweep-compact approach for young and old generations garbage collection i.e Minor and Major GC. Serial GC is useful in client-machines such as our simple stand alone applications and machines with smaller CPU. It is good for small applications with low memory footprint.",
	"Memory - Heap - GC - GarbageCollector - Parallel GC (-XX:+UseParallelGC)": "Parallel GC is same as Serial GC except that is spawns N threads for young generation garbage collection where N is the number of CPU cores in the system. We can control the number of threads using -XX:ParallelGCThreads=n JVM option. Parallel Garbage Collector is also called throughput collector because it uses multiple CPUs to speed up the GC performance. Parallel GC uses single thread for Old Generation garbage collection.",
	"Memory - Heap - GC - GarbageCollector - Parallel Old GC (-XX:+UseParallelOldGC)": "This is same as Parallel GC except that it uses multiple threads for both Young Generation and Old Generation garbage collection.",
	"Memory - Heap - GC - GarbageCollector - Concurrent Mark Sweep (CMS) Collector (-XX:+UseConcMarkSweepGC)": "CMS Collector is also referred as concurrent low pause collector. It does the garbage collection for Old generation. CMS collector tries to minimize the pauses due to garbage collection by doing most of the garbage collection work concurrently with the application threads. CMS collector on young generation uses the same algorithm as that of the parallel collector. This garbage collector is suitable for responsive applications where we can’t afford longer pause times. We can limit the number of threads in CMS collector using -XX:ParallelCMSThreads=n JVM option.",
	"Memory - Heap - GC - GarbageCollector - Concurrent Mark Sweep (CMS) Collector - deprecated (Java 9)": "Deprecate the Concurrent Mark Sweep (CMS) garbage collector, with the intent to stop supporting it in a future major release.",
	"Memory - Heap - GC - GarbageCollector - G1 Garbage Collector (-XX:+UseG1GC)": "The Garbage First or G1 garbage collector is available from Java 7 and it’s long term goal is to replace the CMS collector. The G1 collector is a parallel, concurrent, and incrementally compacting low-pause garbage collector. Garbage First Collector doesn’t work like other collectors and there is no concept of Young and Old generation space. It divides the heap space into multiple equal-sized heap regions. When a garbage collection is invoked, it first collects the region with lesser live data, hence “Garbage First”. ",
	"Memory - Heap - GC - GC Interface (Java 10)": "Before Java10, the garbage collector code was fragmented in places scattered all over the HotSpot sources. As the JEP states: Adding a new garbage collector should be a matter of implementing a well documented set of interfaces, rather than figuring out all the places in HotSpot that needs changing. The aim is to refactor the HotSpot code so that GC implementations are mostly contained within source files in their respective directories, with as little code as possible outside of them. This code should also be used minimally outside of these directories (any code shared between GC’s should be placed in a helper class), and there should be very few GC specific if-else branches. Finally, as is usually the case, performance should not regress because of any changes made. This should also greatly improve the overall code quality.",
	"Memory - Heap - GC - GC1 - default (Java 9)": "Make G1 the default garbage collector on 32- and 64-bit server configurations.",
	"Memory - Heap - GC - GC1 - Parallel G1 (Java 10)": "The aim of this JEP is pretty much what it says on the tin – to parallelise G1’s full GC algorithm to improve performance. Due to the fact that G1 divides the memory up into regions, this change will most likely result in a little more wasted space (compared to a single-threaded algorithm), but in return you get a little boost to throughput and potentially your application’s performance as it’ll be spending less time performing full collections.",
	"Memory - Heap - GC - GC1 - XX:ParallelGCThreads (Java 10)": "You can also customise how many threads are used with the option -XX:ParallelGCThreads, though keep in mind that this will also affect the number of threads used for the Young and Mixed / minor collections too.",
	"Memory - Heap - GC - References": "",
	"Memory - Heap - GC - References - StrongReference": "The strong reference is the most common kind of reference. We use this kind of reference every day.",
	"Memory - Heap - GC - References - WeakReference": "WeakReference is the type of references that will be removed by the garbage collector on the next pass, if there are no other type references to the object. You can get an object value from the WeakReference until the GC decides to collect the object. As soon as the GC decides to do it — not after the GC finalize the object and clear an allocated memory—, you will get the NULL from the WeakReference. This happens when the GC is just marking the object for a further processing. It is important to understand that all finalization actions are executed only after this. When we look at the PhantomReference, we’ll return to this point. WeakReference<String> reference = new WeakReference<>(instance)",
	"Memory - Heap - GC - References - WeakReference - WeakHashMap": "Java provides us with the WeakHashMap data structure. It’s something like a HashMap, which uses the WeakReference as a key of the Map. If a key of the WeakHashMap becomes garbage, its entry is removed automatically. WeakHashMap<String, Boolean> map = new WeakHashMap<>(),",
	"Memory - Heap - GC - References - SoftReference": "The behavior of SoftReference is similar to WeakReference, but the GC collect this kind of reference only when our application does not have enough of memory. The GC collects our SoftReference before we get the OutOfMemoryError. This behavior is a good reason to use SoftReferences as a cache for a data that is difficult to build in memory. SoftReference<String> softReference = new SoftReference<>(instance)",
	"Memory - Heap - GC - References - PhantomReference": "The PhantomReferences are enqueued only when the object is physically removed from memory. The get() method of the PhantomReference always returns NULL, especially to prevent you from being able to resurrect an almost removed object. The PhantomReference provides you with the ability to determine exactly when an object was removed from memory. In order for implementation, we need to work with a ReferenceQueue. When the referent object of a PhantomReference is removed from a memory, then the GC enqueues the  phantomReference in the  referenceQueue, and we can poll this reference from this queue.    ReferenceQueue<Foo> referenceQueue = new ReferenceQueue<>(),    PhantomReference<Foo> phantomReference = new PhantomReference<>(foo, referenceQueue),",
	"Memory - jstat": "We can use jstat command line tool to monitor the JVM memory and garbage collection activities. It ships with standard JDK, so you don’t need to do anything else to get it. For executing jstat you need to know the process id of the application, you can get it easily using ps -eaf | grep java command.",
	"Memory - jvisualvm + Visual GC": "If you want to see memory and GC operations in GUI, then you can use jvisualvm tool. Java VisualVM is also part of JDK, so you don’t need to download it separately. Just run jvisualvm command in the terminal to launch the Java VisualVM application. Once launched, you need to install Visual GC plugin from Tools -< Plugins option, as shown in below image."

}