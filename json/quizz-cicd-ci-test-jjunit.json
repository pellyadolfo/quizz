{
	"JUnit": "SECTION",
	"JUnit Modules": "JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage",
	"JUnit Modules. JUnit Platform (1/3)": "The JUnit Platform serves as a foundation for launching testing frameworks on the JVM. It also defines the TestEngine API for developing a testing framework that runs on the platform. Furthermore, the platform provides a Console Launcher to launch the platform from the command line and build plugins for Gradle and Maven as well as a JUnit 4 based Runner for running any TestEngine on the platform.",
	"JUnit Modules. JUnit Jupiter (2/3)": "JUnit Jupiter is the combination of the new programming model and extension model for writing tests and extensions in JUnit 5. The Jupiter sub-project provides a TestEngine for running Jupiter based tests on the platform.",
	"JUnit Modules. JUnit Vintage (3/3)": "JUnit Vintage provides a TestEngine for running JUnit 3 and JUnit 4 based tests on the platform.",
	"@RunWith(XXXX.class)": "In JUnit 5, the @RunWith annotation has been replaced by the more powerful @ExtendWith annotation. However, the @RunWith annotation can still be used in JUnit5 for the sake of the backward compatibility.",
	"@RunWith(JUnitPlatform.class)": "Runs with JUnit 4 based Runner included in JUnitPlatform.",
	"@RunWith(SpringJUnit4ClassRunner.class)": "SpringJUnit4ClassRunner is a custom extension of JUnit's BlockJUnit4ClassRunner which provides functionality of the Spring TestContext Framework to standard JUnit tests by means of the TestContextManager and associated support classes and annotations. To use this class, simply annotate a JUnit 4 based test class with @RunWith(SpringJUnit4ClassRunner.class) or @RunWith(SpringRunner.class).",

	"tests classes": "SECTION",
	"Test Class": "A test class is any top level or static member class that contains at least one test method.",
	"Nested Tests": "Only non-static nested classes (i.e. inner classes) can serve as @Nested test classes. Nesting can be arbitrarily deep, and those inner classes are considered to be full members of the test class family with one exception: @BeforeAll and @AfterAll methods do not work by default. The reason is that Java does not allow static members in inner classes. However, this restriction can be circumvented by annotating a @Nested test class with @TestInstance(Lifecycle.PER_CLASS).",
	"@Nested": "Denotes that the annotated class is a nested, non-static test class. @BeforeAll and @AfterAll methods cannot be used directly in a @Nested test class unless the per-class test instance lifecycle is used. Such annotations are not inherited.",
	
	"static test methods": "SECTION",
	"Static Tests": "@Test in JUnit Jupiter is very similar to @Test in JUnit 4 are static test cases in the sense that they are fully specified at compile time, and their behavior cannot be changed by anything happening at runtime.",
	"Static Tests - @DisplayName": "Declares a custom display name for the test class or test method. Such annotations are not inherited.",
	"Static Tests - Test Method": "A test method is any instance method that is directly or meta-annotated with @Test, @RepeatedTest, @ParameterizedTest, @TestFactory, or @TestTemplate",
	"Static Tests - @Test in Junit 4": "Denotes that a method is a test method. 2 attributes: expected (Optionally specify expected, a Throwable, to cause a test method to succeed iff an exception of the specified class is thrown by the method.) and timeout (Optionally specify timeout in milliseconds to cause a test method to fail if it takes longer than that number of milliseconds.)",
	"Static Tests - @Test in JUnit 5 (Jupiter)": "Denotes that a method is a test method. In JUnit 5, does not declare any attributes",
	"Static Tests - Returned Value": "Methods annotated with @Test, @TestTemplate, @RepeatedTest, @BeforeAll, @AfterAll, @BeforeEach, or @AfterEach annotations must not return a value.",
	"Static Tests - Assertions": "JUnit Jupiter comes with many of the assertion methods that JUnit 4 has and adds a few that lend themselves well to being used with Java 8 lambdas. All JUnit Jupiter assertions are static methods in the org.junit.jupiter.api.Assertions class.",
	"Static Tests - Assertions List": "assertAll, assertArrayEquals/assertIterableEquals, assertEquals/assertNotEquals, assertFalse/assertTrue, assertLinesMatch, assertNull/assertNotNull, assertNotSame/assertSame, assertTimeout/assertTimeoutPreemptively, assertThrows/fail",
	"Static Tests - Assertions. Third-party Assertion Libraries": "JUnit team recommends the use of third-party assertion libraries such as AssertJ, Hamcrest, Truth, etc.",
	"Static Tests - Assumptions": "Sometimes our test fails due to an external environment configuration or a date or time zone issue that we don’t have control over. We can defend our tests by using the org.junit.Assume class. This class offers many static methods, such as assumeTrue(condition) or assumeNotNull(condition) and etc. Before executing a test, we can check our assumption using the static methods of the Assume class. If our assumption fails, then the JUnit runner ignores the tests with failing assumptions. assumeTrue(isServerRunning),",
	"Static Tests - Assumptions JUnit Jupiter": "JUnit Jupiter comes with a subset of the assumption methods that JUnit 4 provides and adds a few that lend themselves well to being used with Java 8 lambdas. All JUnit Jupiter assumptions are static methods in the org.junit.jupiter.api.Assumptions class.",
	"Static Tests - Assumptions List": "assumeFalse/assumeTrue, assumeThat",
	"Static Tests - @Tag": "Used to declare tags for filtering tests, either at the class or method level, analogous to test groups in TestNG or Categories in JUnit 4. Such annotations are inherited at the class level but not at the method level.",
	"Static Tests - Disabling Tests": "Entire test classes or individual test methods may be disabled (1) via the @Disabled annotation, (2) via one of the annotations discussed in Conditional Test Execution, or (3) via a custom ExecutionCondition.",
	"Static Tests - @Disabled": "Used to disable a test class or test method, analogous to JUnit 4’s @Ignore. Such annotations are not inherited.",
	"Static Tests - Test Interfaces and Interface Default Methods": "JUnit Jupiter allows @Test, @RepeatedTest, @ParameterizedTest, @TestFactory, @TestTemplate, @BeforeEach, and @AfterEach to be declared on interface default methods. @BeforeAll and @AfterAll can either be declared on static methods in a test interface or on interface default methods if the test interface or test class is annotated with @TestInstance(Lifecycle.PER_CLASS). @ExtendWith and @Tag can be declared on a test interface so that classes that implement the interface automatically inherit its tags and extensions.",
	"Static Tests - Meta-Annotations": "JUnit Jupiter annotations can be used as meta-annotations. That means that you can define your own composed annotation that will automatically inherit the semantics of its meta-annotations. For example, instead of copying and pasting @Tag('fast') throughout your code base, you can create a custom composed annotation named @Fast.",
	"Static Tests - Exception Handling Options": "(1) try/catch{} (2) @Test(expected = NullPointerException.class) (3) assertThrows(IllegalArgumentException.class, closureContainingCodeToTest, 'a message'), (4) @Rule public ExpectedException exception = ExpectedException.none() as JUnit4 Rule, (5) TestExecutionExceptionHandler as JUnit5 Extension",
	"Test Lifecycle - @TestInstance": "Used to configure the test instance lifecycle for the annotated test class. Such annotations are inherited.",
	"Test Lifecycle - Default": "If a test class or test interface is not annotated with @TestInstance, JUnit Jupiter will use a default lifecycle mode. The standard default mode is PER_METHOD",
	"Test Lifecycle - per-method": "In order to allow individual test methods to be executed in isolation and to avoid unexpected side effects due to mutable test instance state, JUnit creates a new instance of each test class before executing each test method. This 'per-method' test instance lifecycle is the default behavior in JUnit Jupiter and is analogous to all previous versions of JUnit. Please note that the test class will still be instantiated if a given test method is disabled via a condition (e.g., @Disabled, @DisabledOnOs, etc.) even when the 'per-method' test instance lifecycle mode is active.",
	"Test Lifecycle - per-class": "If you would prefer that JUnit Jupiter execute all test methods on the same test instance, simply annotate your test class with @TestInstance(Lifecycle.PER_CLASS). When using this mode, a new test instance will be created once per test class. Thus, if your test methods rely on state stored in instance variables, you may need to reset that state in @BeforeEach or @AfterEach methods. The 'per-class' mode has some additional benefits over the default 'per-method' mode. Specifically, with the 'per-class' mode it becomes possible to declare @BeforeAll and @AfterAll on non-static methods as well as on interface default methods. The 'per-class' mode therefore also makes it possible to use @BeforeAll and @AfterAll methods in @Nested test classes.",
	"Test Lifecycle - Changing the Default Test Instance Lifecycle": "Configure Test Instance Lifecycle: (1) via system property -Djunit.jupiter.testinstance.lifecycle.default=per_class (2) via config file, create a file named junit-platform.properties in the root of the class path (e.g., src/test/resources) with the following content. junit.jupiter.testinstance.lifecycle.default = per_class",
	"Test Lifecycle - @BeforeEach": "Denotes that the annotated method should be executed before each @Test, @RepeatedTest, @ParameterizedTest, or @TestFactory method in the current class, analogous to JUnit 4’s @Before. Such methods are inherited unless they are overridden.",
	"Test Lifecycle - @AfterEach": "Denotes that the annotated method should be executed after each @Test, @RepeatedTest, @ParameterizedTest, or @TestFactory method in the current class, analogous to JUnit 4’s @After. Such methods are inherited unless they are overridden.",
	"Test Lifecycle - @BeforeAll": "Denotes that the annotated method should be executed before all @Test, @RepeatedTest, @ParameterizedTest, and @TestFactory methods in the current class, analogous to JUnit 4’s @BeforeClass. Such methods are inherited (unless they are hidden or overridden) and must be static (unless the 'per-class' test instance lifecycle is used).",
	"Test Lifecycle - @AfterAll": "Denotes that the annotated method should be executed after all @Test, @RepeatedTest, @ParameterizedTest, and @TestFactory methods in the current class, analogous to JUnit 4’s @AfterClass. Such methods are inherited (unless they are hidden or overridden) and must be static (unless the 'per-class' test instance lifecycle is used).",
	"Test Lifecycle - Extensions. Test Lifecycle Callbacks.": "The following interfaces define the APIs for extending tests at various points in the test execution lifecycle. BeforeAllCallback, BeforeEachCallback, BeforeTestExecutionCallback, AfterTestExecutionCallback, AfterEachCallback, AfterAllCallback",
	"Test Lifecycle - Extensions. Test Lifecycle Callbacks. BeforeTestExecutionCallback and AfterTestExecutionCallback": "BeforeTestExecutionCallback and AfterTestExecutionCallback define the APIs for Extensions that wish to add behavior that will be executed immediately before and immediately after a test method is executed, respectively. As such, these callbacks are well suited for timing, tracing, and similar use cases. If you need to implement callbacks that are invoked around @BeforeEach and @AfterEach methods, implement BeforeEachCallback and AfterEachCallback instead.",
	"ExecutionCondition": "The ExecutionCondition extension API in JUnit Jupiter allows developers to either enable or disable a container or test based on certain conditions programmatically. The simplest example of such a condition is the built-in DisabledCondition which supports the @Disabled annotation. In addition to @Disabled, JUnit Jupiter also supports several other annotation-based conditions in the org.junit.jupiter.api.condition package that allow developers to enable or disable containers and tests declaratively. See the following sections for details.",
	"ExecutionCondition. Operating System Conditions": "A container or test may be enabled or disabled on a particular operating system via the @EnabledOnOs and @DisabledOnOs annotations.",
	"ExecutionCondition. Java Runtime Environment Conditions": "A container or test may be enabled or disabled on a particular version of the Java Runtime Environment (JRE) via the @EnabledOnJre and @DisabledOnJre annotations.",
	"ExecutionCondition. System Property Conditions": "A container or test may be enabled or disabled based on the value of the named JVM system property via the @EnabledIfSystemProperty and @DisabledIfSystemProperty annotations. The value supplied via the matches attribute will be interpreted as a regular expression.",
	"ExecutionCondition. Environment Variable Conditions": "A container or test may be enabled or disabled based on the value of the named environment variable from the underlying operating system via the @EnabledIfEnvironmentVariable and @DisabledIfEnvironmentVariable annotations. The value supplied via the matches attribute will be interpreted as a regular expression.",
	"ExecutionCondition. Script-based Conditions": "JUnit Jupiter provides the ability to either enable or disable a container or test depending on the evaluation of a script configured via the @EnabledIf or @DisabledIf annotation. Scripts can be written in JavaScript, Groovy, or any other scripting language for which there is support for the Java Scripting API, defined by JSR 223. An accessor provides access to a map-like structure via a simple String get(String name) method: systemEnvironment, systemProperty, junitConfigurationParameter, junitDisplayName, junitTags, junitUniqueId",
	"Dependency Injection for Constructors and Methods": "In all prior JUnit versions, test constructors or methods were not allowed to have parameters (at least not with the standard Runner implementations). As one of the major changes in JUnit Jupiter, both test constructors and methods are now permitted to have parameters. This allows for greater flexibility and enables Dependency Injection for constructors and methods.",
	"Dependency Injection for Constructors and Methods. ParameterResolver": "ParameterResolver defines the API for test extensions that wish to dynamically resolve parameters at runtime. If a test constructor or a @Test, @TestFactory, @BeforeEach, @AfterEach, @BeforeAll, or @AfterAll method accepts a parameter, the parameter must be resolved at runtime by a registered ParameterResolver. There are currently three built-in resolvers that are registered automatically: TestInfoParameterResolver, RepetitionInfoParameterResolver, TestReporterParameterResolver",
	"Dependency Injection for Constructors and Methods. ParameterResolver. (1) TestInfoParameterResolver": "TestInfoParameterResolver: if a method parameter is of type TestInfo, the TestInfoParameterResolver will supply an instance of TestInfo corresponding to the current test as the value for the parameter. The TestInfo can then be used to retrieve information about the current test such as the test’s display name, the test class, the test method, or associated tags. The display name is either a technical name, such as the name of the test class or test method, or a custom name configured via @DisplayName. TestInfo acts as a drop-in replacement for the TestName rule from JUnit 4.",
	"Dependency Injection for Constructors and Methods. ParameterResolver. (2) RepetitionInfoParameterResolver": "RepetitionInfoParameterResolver: if a method parameter in a @RepeatedTest, @BeforeEach, or @AfterEach method is of type RepetitionInfo, the RepetitionInfoParameterResolver will supply an instance of RepetitionInfo. RepetitionInfo can then be used to retrieve information about the current repetition and the total number of repetitions for the corresponding @RepeatedTest. Note, however, that RepetitionInfoParameterResolver is not registered outside the context of a @RepeatedTest.",
	"Dependency Injection for Constructors and Methods. ParameterResolver. (3) TestReporterParameterResolver": "TestReporterParameterResolver: if a method parameter is of type TestReporter, the TestReporterParameterResolver will supply an instance of TestReporter. The TestReporter can be used to publish additional data about the current test run. The data can be consumed through TestExecutionListener.reportingEntryPublished() and thus be viewed by IDEs or included in reports. In JUnit Jupiter you should use TestReporter where you used to print information to stdout or stderr in JUnit 4. Using @RunWith(JUnitPlatform.class) will even output all reported entries to stdout.",
	
	"test template": "SECTION",
	"Test Templates": "A @TestTemplate method is not a regular test case but rather a template for test cases. As such, it is designed to be invoked multiple times depending on the number of invocation contexts returned by the registered providers. Thus, it must be used in conjunction with a registered TestTemplateInvocationContextProvider extension. Each invocation of a test template method behaves like the execution of a regular @Test method with full support for the same lifecycle callbacks and extensions.",
	"Test Templates - @TestTemplate": "Denotes that a method is a template for test cases designed to be invoked multiple times depending on the number of invocation contexts returned by the registered providers. Such methods are inherited unless they are overridden.",			
	"Test Templates - Extensions. Invocation Contexts for Test Templates.": "A @TestTemplate method can only be executed when at least one TestTemplateInvocationContextProvider is registered. Each such provider is responsible for providing a Stream of TestTemplateInvocationContext instances. Each context may specify a custom display name and a list of additional extensions that will only be used for the next invocation of the @TestTemplate method.",
	
	"parameterized tests": "SECTION",
	"Parameterized Tests": "Parameterized tests make it possible to run a test multiple times with different arguments. Use the @ParameterizedTest annotation  Must declare at least one source that will provide the arguments for each invocation and then consume the arguments in the test method.",
	"Parameterized Tests. Lifecycle": "Each invocation of a parameterized test has the same lifecycle as a regular @Test method. For example, @BeforeEach methods will be executed before each invocation. Similar to Dynamic Tests, invocations will appear one by one in the test tree of an IDE.",
	"@ParameterizedTest": "Denotes that a method is a parameterized test. Such methods are inherited unless they are overridden.",
	"Test Arguments": "Parameterized test methods consume arguments from different possible sources (1) directly from the configured source (2) aggregate arguments from the source into a single object )3) be provided by a ParameterResolver..",
	"Test Arguments. Customizing Display Names": "By default, the display name of a parameterized test invocation contains the invocation index and the String representation of all arguments for that specific invocation. However, you can customize invocation display names via the name attribute of the @ParameterizedTest annotation.",
	"Test Arguments. Sources": "Out of the box, JUnit Jupiter provides quite a few source annotations: @ValueSource, @ArgumentsSource, @EnumSource, @MethodSource, @CsvSource, @CsvFileSource",
	"Test Arguments. Sources. @ValueSource": "@ValueSource lets you specify a single array of literal values and can only be used for providing a single parameter per parameterized test invocation. The following types of literal values are supported by @ValueSource. short, byte, int, long, float, double, char, java.lang.String, java.lang.Class",
	"Test Arguments. Sources. @ArgumentsSource": "@ArgumentsSource can be used to specify a custom, reusable ArgumentsProvider.",
	"Test Arguments. Sources. @EnumSource": "@EnumSource provides a convenient way to use Enum constants. The annotation provides an optional names parameter that lets you specify which constants shall be used. The @EnumSource annotation also provides an optional mode parameter that enables fine-grained control over which constants are passed to the test method.",
	"Test Arguments. Sources. @MethodSource": "@MethodSource allows you to refer to one or more factory methods of the test class or external classes. Such factory methods must return a Stream, Iterable, Iterator, or array of arguments. In addition, such factory methods must not accept any arguments. Factory methods within the test class must be static unless the test class is annotated with @TestInstance(Lifecycle.PER_CLASS), whereas, factory methods in external classes must always be static. If you do not explicitly provide a factory method name via @MethodSource, JUnit Jupiter will search for a factory method that has the same name as the current @ParameterizedTest method by convention. Streams for primitive types (DoubleStream, IntStream, and LongStream) are also supported as demonstrated by the following example. If a test method declares multiple parameters, you need to return a collection or stream of Arguments instances as shown below. Note that Arguments.of(Object…​) is a static factory method defined in the Arguments interface.",
	"Test Arguments. Sources. @CsvSource": "@CsvSource allows you to express argument lists as comma-separated values (i.e., String literals). @CsvSource uses a single quote ' as its quote character. An empty, quoted value '' results in an empty String, whereas, an entirely empty value is interpreted as a null reference. An ArgumentConversionException is raised if the target type of a null reference is a primitive type.",
	"Test Arguments. Sources. @CsvFileSource": "@CsvFileSource lets you use CSV files from the classpath. Each line from a CSV file results in one invocation of the parameterized test. In contrast to the syntax used in @CsvSource, @CsvFileSource uses a double quote as the quote character. An empty, quoted value '' results in an empty String, whereas, an entirely empty value is interpreted as a null reference. An ArgumentConversionException is raised if the target type of a null reference is a primitive type.",
	"Test Arguments. Conversion. Widening Conversion": "JUnit Jupiter supports Widening Primitive Conversion for arguments supplied to a @ParameterizedTest. For example, a parameterized test annotated with @ValueSource(ints = { 1, 2, 3 }) can be declared to accept not only an argument of type int but also an argument of type long, float, or double.",
	"Test Arguments. Conversion. Implicit Conversion": "JUnit Jupiter provides a number of built-in implicit type converters. The conversion process depends on the declared type of each method parameter. For example, if a @ParameterizedTest declares a parameter of type TimeUnit and the actual type supplied by the declared source is a String, the string will be automatically converted into the corresponding TimeUnit enum constant.",
	"Test Arguments. Conversion. Fallback String-to-Object Conversion": "In addition to implicit conversion from strings to the target types listed in the above table, JUnit Jupiter also provides a fallback mechanism for automatic conversion from a String to a given target type if the target type declares exactly one suitable factory method or a factory constructor as defined below. factory method: a non-private, static method declared in the target type that accepts a single String argument and returns an instance of the target type. The name of the method can be arbitrary and need not follow any particular convention., factory constructor: a non-private constructor in the target type that accepts a single String argument. If multiple factory methods are discovered, they will be ignored. If a factory method and a factory constructor are discovered, the factory method will be used instead of the constructor.",
	"Test Arguments. Conversion. Explicit Conversion": "Instead of relying on implicit argument conversion you may explicitly specify an ArgumentConverter to use for a certain parameter using the @ConvertWith annotation like in the following example. Explicit argument converters are meant to be implemented by test and extension authors. Thus, junit-jupiter-params only provides a single explicit argument converter that may also serve as a reference implementation: JavaTimeArgumentConverter. It is used via the composed annotation JavaTimeConversionPattern.",
	"Test Arguments. Aggregation with ArgumentsAccessor": "ArgumentsAccessor allows access the provided arguments through a single argument passed to your test methodcan be used instead of passing multiple parameters. An instance of ArgumentsAccessor is automatically injected into any parameter of type ArgumentsAccessor.",
	"Test Arguments. Aggregation. Custom Aggregators": "To use a custom aggregator simply implement the ArgumentsAggregator interface and register it via the @AggregateWith annotation on a compatible parameter in the @ParameterizedTest method. The result of the aggregation will then be provided as an argument for the corresponding parameter when the parameterized test is invoked.",
	"Extensions. ParameterResolver.": "ParameterResolver defines the Extension API for dynamically resolving parameters at runtime. If a test constructor or a @Test, @RepeatedTest, @ParameterizedTest, @TestFactory, @BeforeEach, @AfterEach, @BeforeAll, or @AfterAll method accepts a parameter, the parameter must be resolved at runtime by a ParameterResolver. A ParameterResolver can either be built-in or registered by the user. Generally speaking, parameters may be resolved by name, type, annotation, or any combination thereof.",	

	"repeated test": "SECTION",
	"Repeated Tests": "JUnit Jupiter provides the ability to repeat a test a specified number of times simply by annotating a method with @RepeatedTest and specifying the total number of repetitions desired.",
	"@RepeatedTest": "Denotes that a method is a test template for a repeated test. Such methods are inherited unless they are overridden.",
	"Repeated Tests. Name": "A custom display name can be configured for each repetition via the name attribute of the @RepeatedTest annotation. Furthermore, the display name can be a pattern composed of a combination of static text and dynamic placeholders. The following placeholders are currently supported. {displayName}: display name of the @RepeatedTest method, {currentRepetition}: the current repetition count, {totalRepetitions}: the total number of repetitions. The default display name for a given repetition is generated based on the following pattern: 'repetition {currentRepetition} of {totalRepetitions}'. Thus, the display names for individual repetitions of the previous repeatedTest() example would be: repetition 1 of 10, repetition 2 of 10, etc. If you would like the display name of the @RepeatedTest method included in the name of each repetition, you can define your own custom pattern or use the predefined RepeatedTest.LONG_DISPLAY_NAME pattern. The latter is equal to '{displayName} :: repetition {currentRepetition} of {totalRepetitions}' which results in display names for individual repetitions like repeatedTest() :: repetition 1 of 10, repeatedTest() :: repetition 2 of 10, etc. ",
	"Repeated Tests. RepetitionInfo": "In order to retrieve information about the current repetition and the total number of repetitions programmatically, a developer can choose to have an instance of RepetitionInfo injected into a @RepeatedTest, @BeforeEach, or @AfterEach method.",
	"Repeated Tests. Lifecycle": "Each invocation of a repeated test behaves like the execution of a regular @Test method with full support for the same lifecycle callbacks and extensions.",
	
	"dynamic tests": "SECTION",
	"Dynamic Tests": "Introduced in JUnit Jupiter. This new kind of test is a dynamic test which is generated at runtime by a factory method annotated with @TestFactory. A DynamicTest is a test case generated at runtime.",
	"@TestFactory": "Denotes that a method is a test factory for dynamic tests. Such methods are inherited unless they are overridden. Technically speaking, a @TestFactory method must return a Stream, Collection, Iterable, or Iterator of DynamicNode instances. Any Stream returned by a @TestFactory will be properly closed by calling stream.close(), making it safe to use a resource such as Files.lines().",
	"Dynamic Tests. Structure": "It is composed of a display name and an Executable. Executable is a @FunctionalInterface which means that the implementations of dynamic tests can be provided as lambda expressions or method references.",	
	"Dynamic Tests. Creation": "As of JUnit Jupiter 5.2.0, dynamic tests must always be created by factory methods annotated with @TestFactory",
	"Dynamic Tests. Paremeters": "As with @Test methods, @TestFactory methods must not be private or static and may optionally declare parameters to be resolved by ParameterResolvers. ",			
	"Dynamic Tests. Lifecycle": "No lifecycle callbacks for individual dynamic tests.",			
	"Dynamic Tests. Status": "Dynamic tests are currently an experimental feature",
	"Dynamic Tests. Dynamic Node": "Instantiable subclasses of DynamicNode are DynamicContainer and DynamicTest.",
	"Dynamic Tests. Dynamic Container": "DynamicContainer instances are composed of a display name and a list of dynamic child nodes, enabling the creation of arbitrarily nested hierarchies of dynamic nodes.",
	"Dynamic Tests. Dynamic Test": "DynamicTest instances will then be executed lazily, enabling dynamic and even non-deterministic generation of test cases",
			
	"JUnit4 Rules": "SECTION",

	"JUnit5 Extensions": "SECTION",
	"Extensions. JUnit4 Rules vs JUnit5 Extensions": "In JUnit 5 rules haven been replaced with a new concept called extensions",
	"Extensions. Registering Extensions": "Extensions can be registered declaratively (1) via @ExtendWith, (2) programmatically via @RegisterExtension, or (3) automatically via Java’s ServiceLoader mechanism.",
	"Extensions. Registering Extensions with @ExtendWith.": "Developers can register one or more extensions declaratively by annotating a test interface, test class, test method, or custom composed annotation with @ExtendWith({ FooExtension.class, BarExtension.class }). Will be executed in the order in which they are declared.",
	"Extensions. Registering Extensions with @RegisterExtension": "Developers can register extensions programmatically by annotating fields in test classes with @RegisterExtension. @RegisterExtension fields must not be private or null (at evaluation time) but may be either static or non-static.",
	"Extensions. Registering Extensions with @RegisterExtension. Static Fields": "If a @RegisterExtension field is static, the extension will be registered after extensions that are registered at the class level via @ExtendWith. Such static extensions are not limited in which extension APIs they can implement. Extensions registered via static fields may therefore implement class-level and instance-level extension APIs such as BeforeAllCallback, AfterAllCallback, and TestInstancePostProcessor as well as method-level extension APIs such as BeforeEachCallback, etc.",
	"Extensions. Registering Extensions with @RegisterExtension. Instance Fields": "If a @RegisterExtension field is non-static (i.e., an instance field), the extension will be registered after the test class has been instantiated and after each registered TestInstancePostProcessor has been given a chance to post-process the test instance (potentially injecting the instance of the extension to be used into the annotated field). Thus, if such an instance extension implements class-level or instance-level extension APIs such as BeforeAllCallback, AfterAllCallback, or TestInstancePostProcessor, those APIs will not be honored. By default, an instance extension will be registered after extensions that are registered at the method level via @ExtendWith, however, if the test class is configured with @TestInstance(Lifecycle.PER_CLASS) semantics, an instance extension will be registered before extensions that are registered at the method level via @ExtendWith.",
	"Extensions. Registering Extensions with ServiceLoader.": "JUnit Jupiter supports global extension registration via Java’s java.util.ServiceLoader mechanism, allowing third-party extensions to be auto-detected and automatically registered based on what is available in the classpath. Specifically, a custom extension can be registered by supplying its fully qualified class name in a file named org.junit.jupiter.api.extension.Extension within the /META-INF/services folder in its enclosing JAR file. For example, to enable auto-detection of extensions, you can start your JVM with the following system property. -Djunit.jupiter.extensions.autodetection.enabled=true",
	"Extensions. Registering Extensions. Extension Inheritance.": "Registered extensions are inherited within test class hierarchies with top-down semantics. Similarly, extensions registered at the class-level are inherited at the method-level. Furthermore, a specific extension implementation can only be registered once for a given extension context and its parent contexts. Consequently, any attempt to register a duplicate extension implementation will be ignored.",
	"Extensions. ExecutionCondition.": "ExecutionCondition defines the Extension API for programmatic, conditional test execution. An ExecutionCondition is evaluated for each container (e.g., a test class) to determine if all the tests it contains should be executed based on the supplied ExtensionContext. Similarly, an ExecutionCondition is evaluated for each test to determine if a given test method should be executed based on the supplied ExtensionContext.",
	"Extensions. ExecutionCondition Multiple.": "When multiple ExecutionCondition extensions are registered, a container or test is disabled as soon as one of the conditions returns disabled. Thus, there is no guarantee that a condition is evaluated because another extension might have already caused a container or test to be disabled. In other words, the evaluation works like the short-circuiting boolean OR operator. For example, to deactivate JUnit’s @Disabled condition, you can start your JVM with the following system property. -Djunit.jupiter.conditions.deactivate=org.junit.*DisabledCondition",
	"Extensions. Test Instance Post-processing.": "TestInstancePostProcessor defines the API for Extensions that wish to post process test instances. Common use cases include injecting dependencies into the test instance, invoking custom initialization methods on the test instance, etc.",
	"Extensions. Exception Handling.": "TestExecutionExceptionHandler defines the API for Extensions that wish to handle exceptions thrown during test execution.",
	"Extensions. ExtensionContext": "An extension is instantiated only once. The ExtensionContext API provides a Store for the state of one extension. Extensions may put values into a store for later retrieval.",
	"Extensions. ExtensionContext Nesting": "Values stored in an ExtensionContext during test execution will not be available in the surrounding ExtensionContext. Since ExtensionContexts may be nested, the scope of inner contexts may also be limited.",
	"Extensions. ExtensionContext Lifecycle": "An extension context store is bound to its extension context lifecycle. When an extension context lifecycle ends it closes its associated store. All stored values that are instances of CloseableResource are notified by an invocation of their close() method.",
	"Extensions. Supported Utilities in Extensions": "The junit-platform-commons artifact exposes a package named org.junit.platform.commons.support that contains maintained utility methods for working with annotations, classes, reflection, and classpath scanning tasks. TestEngine and Extension authors are encouraged to use these supported methods in order to align with the behavior of the JUnit Platform.",
	"Extensions. Supported Utilities in Extensions. Annotation Support": "AnnotationSupport provides static utility methods that operate on annotated elements (e.g., packages, annotations, classes, interfaces, constructors, methods, and fields). These include methods to check whether an element is annotated or meta-annotated with a particular annotation, to search for specific annotations, and to find annotated methods and fields in a class or interface. Some of these methods search on implemented interfaces and within class hierarchies to find annotations. Consult the JavaDoc for AnnotationSupport for further details.",
	"Extensions. Supported Utilities in Extensions. Class Support": "ClassSupport provides static utility methods for working with classes (i.e., instances of java.lang.Class).",
	"Extensions. Supported Utilities in Extensions. Reflection Support": "ReflectionSupport provides static utility methods that augment the standard JDK reflection and class-loading mechanisms. These include methods to scan the classpath in search of classes matching specified predicates, to load and create new instances of a class, and to find and invoke methods. Some of these methods traverse class hierarchies to locate matching methods."
}