{

	"Environments": "SECTION",
	"Environments ": "",
	"Environments - Dev Local Environment": "DEV environment allows developers to make code changes in to the application for fixing an existing bug. Once the fix is applied it is unit tested by the developer. We already know by now that testers are not advised to perform testing in DEV.",
	"Environments - Integration Testing Environment": "When different bug fixes related to different modules are done with successful unit testing then integration testing is performed. This environment is where all different modules are integrated and hit with plethora of test cases to bring the code up to speed after integration.",
	"Environments - Staging Environment (QA)": "A pre-prod deployment area that serves a quality assurance check by providing a platform almost identical to Production.  To build a robust staging or QA environment, make sure that you replicate production as closely as possible in terms of hardware and software.",
	"Environments - Partial Production Rollout": "Develop a rollout plan for thorough testing in Production, including the following mentioned major areas related to code migration: Canarying, Monitoring, Exploration, Distributed Tracing, Dynamic Instrumentation, Feature Flagging, Exception Tracking, Traffic Shaping, A/B Testing, Chaos Testing, Profiling, Teeing, Load Testing, Shadowing, Load Testing, Usability Testing, Cross Browser Testing, Accessibility Testing",
	"Environments - Production": "After validation in QA environment you push your changes to Prod. Go-live environment that is used by your customers. This environment is not to be messed with! A developers without proper approvals cannot implement any change in it, not even a minor fix is advised without a relevant sign-off.",
	"Environments - Disaster Recovery": "This is where you keep a backup ready of your Production before making any change into it. If things go south you can execute a rollback to previous version in a fly.",

	"testing goals": "SECTION",
	"Testing Goal - Unit Testing - DAO": "",
	"Testing Goal - Unit Testing - Transformation": "",
	"Testing Goal - Unit Testing - Service - from standalone - with spring": "(1) inject @Autowired service (2) Populate new Criteria() (3) do invokation (4) do Assertions",
	"Testing Goal - Unit Testing - Service - from server - MockMVC": "",
	"Testing Goal - Unit Testing - Server - SOAP - WebServiceTemplate": "",
	"Testing Goal - Unit Testing - Server - REST - RestTemplate": "",

	"Instrumentation": "Instrumentation is a process to prepare the application for testing or automation. Part of the instrumentation process, may add 'instruments' that allow the testing framework to gain access to parts of the application. Android instrumentation is a set of control methods, or hooks, in the Android system, which control Android components and how the Android system loads apps.",
	"Instrumentation Testing": "Normally the system runs all the components of an app in the same process. You can allow some components, such as content providers, to run in a separate process, but you typically can't force an app onto the same process as another running app. Instrumentation tests, however, can load both a test package and the app into the same process. Since the app components and their tests are in the same process, your tests can invoke methods in the components, and modify and examine fields in the components Instrumentation allows you to monitor all of the interaction the Android system has with the application, and makes it possible for tests to invoke methods in the app, and modify and examine fields in the app, independently of the app's normal lifecycle.",
	"Instrumentation Testing - Where": "Instrumentation tests run on a device or an emulator.",
	"Instrumentation Testing - Products": "",
	"Instrumentation Testing - Products - Selendroid": "",
	"Instrumentation Testing - Products - Appium": "",
	
	"manual testing types": "SECTION",
	"Unit Testing": "",
	"Unit Testing - Requirements": "",
	"Unit Testing - Requirements - Independent": "Each test is independent of other unit tests, external data or the environment.",
	"Unit Testing - Requirements - Repeatable": "A unit test should not cause external or side effects. For example you do not want a test to be sending out e-mails or updating records in a database.",
	"Unit Testing - Requirements - Conceptual": "Each test makes assertions about only one logical concept or unit of work.",
	"Unit Testing - Requirements - Full": "If you want a good unit test, you at least have to make sure that all your code is executed at least once, including that strange exception handling condition you have somewhere and edge cases.",
	"Unit Testing - Requirements - Fast": "The test executes fast.",
	"Unit Testing - Requirements - Small": "Code in each test is as small as possible.",
	"Unit Testing - Benefits": "",
	"Unit Testing - Benefits - Fail fast": "Having tests that fails as soon as something doesn’t behave as expected will allow you to easily find problems with your code.",
	"Unit Testing - Benefits - Easier refactoring": "So you’ve refactored your code and its all cleaner now. Does all the tests passes? If yes, missing accomplished. Otherwise, you’ve introduced regression in your system. Tests on a unit you are refactoring will provide you the peace of mind that whatever you did, it still works. You will find yourself refactoring much more often as the confidence in your code (and tests) will increase.",
	"Unit Testing - Benefits - Code documentation": "If your tests are named properly, they will indicate what kind of behaviors you are testing. This will allow other developers to know exactly what they broke when one of them failed. However, it provides great documentation for developers that just joined your team and is wondering how to use your class. With a whole set of test, they can just see what kind of behavior that class has.",
	"Unit Testing - Benefits - Design": "If you do TDD or any other type of Test First code, tests will help you design your class in the way the user of the class is meant to use it. This might sound funny but by starting by _How to use it _rather than the implementation, it will lead you to simpler code and easier to setup.",
	"Unit Testing - AAA": "AAA is Arrange-Act-Assert. https://drpicox.medium.com/improve-your-testing-7-the-checklist-of-aaa-12eec62f8474",
	"Unit Testing - xUnit": "xUnit is the collective name for several unit testing frameworks that derive their structure and functionality from Smalltalk's SUnit. SUnit, designed by Kent Beck in 1998, was written in a highly structured object-oriented style, which lent easily to contemporary languages such as Java and C#. Following its introduction in Smalltalk the framework was ported to Java by Kent Beck and Erich Gamma and gained wide popularity, eventually gaining ground in the majority of programming languages in current use. The names of many of these frameworks are a variation on 'SUnit', usually replacing the 'S' with the first letter (or letters) in the name of their intended language ('JUnit' for Java, 'RUnit' for R etc.). These frameworks and their common architecture are collectively known as 'xUnit'.",
	"Unit Testing - xUnit Architecture ": "All xUnit frameworks share the following basic component architecture, with some varied implementation details.[1]",
	"Unit Testing - xUnit Architecture - Test runner": "A test runner is an executable program that runs tests implemented using an xUnit framework and reports the test results.[2]",
	"Unit Testing - xUnit Architecture - Test case": "A test case is the most elemental class. All unit tests are inherited from here.",
	"Unit Testing - xUnit Architecture - Test fixtures": "A test fixture (also known as a test context) is the set of preconditions or state needed to run a test. The developer should set up a known good state before the tests, and return to the original state after the tests.",
	"Unit Testing - xUnit Architecture - Test suites": "A test suite is a set of tests that all share the same fixture. The order of the tests shouldn't matter.",
	"Unit Testing - xUnit Architecture - Test execution": "The execution of an individual unit test proceeds as follows:  setup, /* First, we should prepare our 'world' to make an isolated environment for testing */ ... /* Body of test - Here we make all the tests */ ... teardown, /* At the end, whether we succeed or fail, we should clean up our 'world' to  not disturb other tests or code */ The setup and teardown methods serve to initialize and clean up test fixtures.",
	"Unit Testing - xUnit Architecture - Test result formatter": "A test runner produces results in one or more output formats. In addition to a plain, human-readable format, there is often a test result formatter that produces XML output. The XML test result format originated with JUnit but is also used by some other xUnit testing frameworks, for instance build tools such as Jenkins and Atlassian Bamboo.",
	"Unit Testing - xUnit Architecture - Assertions": "An assertion is a function or macro that verifies the behavior (or the state) of the unit under test. Usually an assertion expresses a logical condition that is true for results expected in a correctly running system under test (SUT). Failure of an assertion typically throws an exception, aborting the execution of the current test.",
	"Unit Testing - xUnit Architecture": "",
	"Unit Testing - Products - JUnit": "",
	"Unit Testing - Products - Mockito": "",
	"Unit Testing - Products - PowerMock": "",
	"Integration Testing": "Integration tests validate how your code interacts with other parts of the system.",
	"E2E Testing": "",
	"Smoke Testing": "",

	"automated testing": "SECTION",
	"Automated Testing": "",
	"Automated Testing - Products": "",
	"Automated Testing - Products - Selenium": "",

	"Patterns": "SECTION",
	"Patterns": "https://medium.com/@ashishps/leetcode-was-hard-until-i-learned-these-15-patterns-19d15f6d71f1",

	"TDD": "SECTION",
	"TDD ": "Test-driven development is a programming technique that moves unit tests to the front row. In test-driven development tests are written as specification before writing production code: we must describe the problem we are trying to solve. In other words, TDD requires us to think about the results before providing the solution.",
	"TDD - Steps": "(1) Describe the process you trying to solve (2) Write the unit test for the function you’re going to implement, the unit test should be short and focus on a single behavior of a function. Tests describe the object you are implementing, and it should not be necessary to change them unless the object itself changes, (3) Watch the test fail without writing the passing code allows us to confirm our theories about the current state of our code, (4) Make the test pass by providing the simplest solution that could possibly work, (4) Refactor to remove duplication. At the end, we need to review the work  and make necessary adjustments to remove duplication and improve design. There is only one rule to obey during this step: tests should stay green,",
	"TDD - Benefits": "The strongest benefits of TDD is that it produces code that works and forces us to think about our code before writing it. The TDD process describes specialized components in isolation  and that honors the single responsibility principle.",
	
	"BDD": "SECTION",
	"BDD ": "Instead of TDD, I prefer a similar approach called “BDD” (Behavior Driven Development). Instead of writing test cases for every function in the implementation, write test cases for the behaviors. Of course the definition of “behavior” can be different: It can be story level behavior, making one test case for each component in the story, or it can be more granular, making test cases for all the actions such as API calls and DB queries. Choose what fits your project best. The important thing here is, focus on the behavior, not the implementation. If a behavior consists of three functions, the test case should not care about the input and output of each function, instead, treat them as a whole functionality. In this way the implementation can be changed without affecting the test case, as long as it keeps the same interface.",
	"BDD - ": ""
}