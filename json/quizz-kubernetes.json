{

	"Arch": "SECTION",
  "Arch - Cluster": "",
  "Arch - Cluster - Structure": "A Cluster is a group of nodes.",
  "Arch - Cluster - Structure - namespaces": "A cluster can contain many pods, related or unrelated [and] grouped under the tight logical borders called namespaces.",
  "Arch - Node": "",
  "Arch - Node - definition": "A node is a virtual or bare-metal machine in a Kubernetes cluster.",
  "Arch - Node - Components - kubelet": "The kubelet is the primary node agent that runs on each node. It can register the node with the apiserver using one of: the hostname; a flag to override the hostname; or specific logic for a cloud provider.",
  "Arch - Node - Components - kube-proxy": "This reflects services as defined in the Kubernetes API on each node and can do simple TCP, UDP, and SCTP stream forwarding or round robin TCP, UDP, and SCTP forwarding across a set of backends",
  "Arch - Node - Components - CRI": "The Container Runtime Interface (CRI) is the main protocol for the communication between the kubelet and Container Runtime.",
  "Arch - Node - Components - CRI - container runtime": "You need a working container runtime on each Node in your cluster, so that the kubelet can launch Pods and their containers.",
  "Arch - Node - Types - Master Node": "The Kubernetes Master is a collection of three processes that run on a single node in your cluster, which is designated as the master node. Those processes are: kube-apiserver, kube-controller-manager and kube-scheduler.",
  "Arch - Node - Types - Master Node - kube-apiserver": "",
  "Arch - Node - Types - Master Node - kube-controller-manager": "",
  "Arch - Node - Types - Master Node - kube-scheduler": "",
  "Arch - Node - Types - Worker Nodes": "The worker node(s) host the Pods that are the components of the application workload. Every cluster has at least one worker node.",
  "Arch - Node - Status": "A node’s status contains the following information: Addresses, Condition, Capacity, Info",
  "Arch - Node - Status - Addresses": "",
  "Arch - Node - Status - Condition": "",
  "Arch - Node - Status - Capacity": "",
  "Arch - Node - Status - Info": "",
  "Arch - Pod": "",
	"Arch - Pod - definition": "Pods are the smallest deployable units of computing that can be created and managed in Kubernetes. basic scalable units that Kubernetes works with are called pods. A pod is one or more containers deployed together on one host, and the smallest compute unit that can be defined, deployed, and managed.",
  "Arch - Pod - Features - sizing": "Scalability and namespaces are probably the main items to consider when determining what goes in a pod.",
  "Arch - Pod - Lifecyle": "A Pod’s status field is a PodStatus object, which has a phase field. The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle. The phase is not intended to be a comprehensive rollup of observations of Container or Pod state, nor is it intended to be a comprehensive state machine. The number and meanings of Pod phase values are tightly guarded. Other than what is documented here, nothing should be assumed about Pods that have a given phase value. Here are the possible values for phase:.",
  "Arch - Pod - Lifecyle - create": "To create a pod using the nginx image, run the command kubectl run nginx --image=nginx --restart=Never . This will create a pod named nginx, running with the nginx image on Docker Hub. And by setting the flag --restart=Never we tell Kubernetes to create a single pod rather than a Deployment.",
  "Arch - Pod - Lifecyle - update": "Since Pods are intended to be disposable and replaceable, you cannot add a container to a Pod once it has been created.",
  "Arch - Pod - Lifecyle - Pending": "The Pod has been accepted by the Kubernetes system, but one or more of the Container images has not been created. This includes time before being scheduled as well as time spent downloading images over the network, which could take a while..",
  "Arch - Pod - Lifecyle - Running": "The Pod has been bound to a node, and all of the Containers have been created. At least one Container is still running, or is in the process of starting or restarting..",
  "Arch - Pod - Lifecyle - Succeeded": "All Containers in the Pod have terminated in success, and will not be restarted.",
  "Arch - Pod - Lifecyle - Failed": "All Containers in the Pod have terminated, and at least one Container has terminated in failure. That is, the Container either exited with non-zero status or was terminated by the system.",
  "Arch - Pod - Lifecyle - Unknown": "For some reason the state of the Pod could not be obtained, typically due to an error in communicating with the host of the Pod.",
	"Arch - Pod - Comms": "",
  "Arch - Pod - Comms - IP": "Every Pod in a cluster gets its own unique cluster-wide IP address. This means you do not need to explicitly create links between Pods and you almost never need to deal with mapping container ports to host ports.",
  "Arch - Pod - Comms - interpod": "pods can communicate with all other pods on any other node without NAT",
  "Arch - Pod - Comms - agent2pod": "agents on a node (e.g. system daemons, kubelet) can communicate with all pods on that node",
	"Arch - Container": "A Kubernetes pod is a collection of containers. The word container is defined as a specific running or paused instance of a container image.",
  "Arch - Container - Container Image": "A container image is a ready-to-run software package containing everything needed to run an application: the code and any runtime it requires, application and system libraries, and default values for any essential settings.",
  "Arch - Container - Container Image Registry": "An image registry is a content server that can store and serve container images.",
	"Arch - Container - Features - decouple": "Containers decouple applications from the underlying host infrastructure. This makes deployment easier in different cloud or OS environments.",
  "Arch - Container - Features - repeatable": "Each container that you run is repeatable; the standardization from having dependencies included means that you get the same behavior wherever you run it.",
  "Arch - Container - Features - neighbours": "Containers in a Pod are co-located and co-scheduled to run on the same node.",
  "Arch - Container - hooks": "The hooks enable Containers to be aware of events in their management lifecycle and run code implemented in a handler when the corresponding lifecycle hook is executed.",
  "Arch - Container - hooks - PostStart": "This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. No parameters are passed to the handler.",
  "Arch - Container - hooks - PreStop": "This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod's termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period. No parameters are passed to the handler.",
  "Arch - Container - hooks handlers": "Containers can access a hook by implementing and registering a handler for that hook.",
  "Arch - Container - hooks handlers - exec": "Executes a specific command, such as pre-stop.sh, inside the cgroups and namespaces of the Container. Resources consumed by the command are counted against the Container.",
  "Arch - Container - hooks handlers - http": "Executes an HTTP request against a specific endpoint on the Container.",
  "Arch - Machine - machine": "A fundamental unit that describes the host for a node. The nodes in a cluster are the machines (VMs, physical servers, etc) that run your applications and cloud workflows. The Kubernetes master controls each node, you’ll rarely interact with nodes directly.",
  "Arch - machines - machine set": "MachineSet resources are groups of machines. Machine sets are to machines as replica sets are to pods.",
  "Arch - machines - machine config pool": "A MCP is used to group machines together so the MCO can manage their configurations and facilitate their upgrades.",
	"Arch - Storage - Volume": "On-disk files in a Container are ephemeral, which presents some problems for non-trivial applications when running in Containers. First, when a Container crashes, kubelet will restart it, but the files will be lost - the Container starts with a clean state. Second, when running Containers together in a Pod it is often necessary to share files between those Containers. The Kubernetes Volume abstraction solves both of these problems.",
  "Arch - Storage - volumes": "At its core, a volume is a directory, possibly with some data in it, which is accessible to the containers in a pod.",
  "Arch - Storage - volumes - persistent": "",
  "Arch - Storage - volumes - persistent - snapshots": "In Kubernetes, a VolumeSnapshot represents a snapshot of a volume on a storage system.",
  "Arch - Storage - volumes - projected": "",
  "Arch - Storage - volumes - ephemeral": "",

  "Value": "SECTION",
  "Value - Workloads": "A workload is an application running on Kubernetes..",
  "Value - Workloads - autoscaling": "In Kubernetes, you can scale a workload depending on the current demand of resources. This allows your cluster to react to changes in resource demand more elastically and efficiently.",
  "Value - Workloads - autoscaling - horizontal": "Running multiple instances of your app.",
  "Value - Workloads - autoscaling - vertical": "Resizing CPU and memory resources assigned to containers.",
  "Value - Workloads - BuiltIn - Deployment": "A Deployment provides declarative updates for Pods and ReplicaSets.",
  "Value - Workloads - BuiltIn - StatefulSet": "A StatefulSet = PVC bound to a pod.",
  "Value - Workloads - BuiltIn - ReplicaSet": "A ReplicaSet's purpose is to maintain a stable set of replica Pods running at any given time. As such, it is often used to guarantee the availability of a specified number of identical Pods.",
  "Value - Workloads - BuiltIn - DaemonSet": "A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created.",
  "Value - Workloads - BuiltIn - Job": "A Job creates one or more Pods and will continue to retry execution of the Pods until a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. Suspending a Job will delete its active Pods until the Job is resumed again..",
  "Value - Workloads - BuiltIn - CronJob": "A CronJob creates Jobs on a repeating schedule. One CronJob object is like one line of a crontab (cron table) file. It runs a job periodically on a given schedule, written in Cron format.",
	"Value - Service - definition": "A service is something that exposes a workload to the rest of the cluster (or via ingress to the outside world).",
	"Value - Service - topology": "A service provides a means of grouping together a set of pods to create a complete, stable application. A Service resource doesn�t run our containers. It merely provides and maintains a network identity for our Pod resource. A Kubernetes Service is an abstraction which defines a logical set of Pods and a policy by which to access them - sometimes called a micro-service.",
  "Value - Service - network identity": "Service network identity provides both a static IP address and a DNS name. Services listen on a static address that doesn�t change and forwards the request to the unreliable container address. It internally keeps a map that always contains the latest IP address of the Pod. So, whenever a Pod restarts, it updates that map automatically so you get a seamless connection.",
  "Value - Service - load": "Services have an integrated load-balancer that will distribute network traffic to all Pods of an exposed Deployment.",
  "Value - Service - ingress": "An API object that manages external access to the services in a cluster, typically HTTP. Ingress exposes HTTP and HTTPS routes from outside the cluster to services within the cluster.",
  "Value - Service - ingress - features": "Ingress may provide load balancing, SSL termination and name-based virtual hosting.",
  "Value - Service - ingress - routing": "Traffic routing is controlled by rules defined on the Ingress resource.",
  "Value - Service - Label Selector": "The set of Pods targeted by a Service is (usually) determined by a Label Selector",
  "Value - Service - Container Runtime": "Each node runs a container runtime, which is responsible for downloading images and running containers. Kubernetes supports several runtimes: Docker, rkt, runc and any OCI runtime-spec implementation.",
  "Value - Service - Container Runtime - Docker": "",
  "Value - Service - Container Runtime - rkt": "",
  "Value - Service - Container Runtime - runc": "",
  "Value - Service - Container Runtime - any OCI runtime-spec implementation": "",
  "Value - Service - kubelet": "An agent that runs on each node in the cluster. It makes sure that containers are running in a pod. The kubelet takes a set of PodSpecs that are provided through various mechanisms and ensures that the containers described in those PodSpecs are running and healthy. The kubelet doesn’t manage containers which were not created by Kubernetes.",
  "Value - Service - kube-proxy": "The Kube-proxy is an implementation of a network proxy and a load balancer, and it supports the service abstraction along with other networking operation. It is responsible for routing traffic to the appropriate container based on IP and port number of the incoming request.",

	"Admin": "SECTION",
  "Admin - Objects - definition": "Kubernetes objects are persistent entities in the Kubernetes system.",
  "Admin - Objects - yaml": "Kubernetes objects can be expressed in .yaml format.",
  "Admin - Objects - yaml - fields - apiVersion": "Which version of the Kubernetes API you're using to create this object.",
  "Admin - Objects - yaml - fields - kind": "What kind of object you want to create.",
  "Admin - Objects - yaml - fields - metadata": "Data that helps uniquely identify the object, including a name string, UID, and optional namespace",
  "Admin - Objects - yaml - fields - spec": "What state you desire for the object. The precise format of the object spec is different for every Kubernetes object",
  "Admin - Objects - manage": "To work with Kubernetes objects--whether to create, modify, or delete them--you'll need to use the Kubernetes API. When you use the kubectl command-line interface, for example, the CLI makes the necessary Kubernetes API calls for you.",
	"Admin - Controllers": "A controller tracks at least one Kubernetes resource type. These objects have a spec field that represents the desired state. The controller(s) for that resource are responsible for making the current state come closer to that desired state.",
  "Admin - Controllers - BuiltIn - Node": "Node Controller: Responsible for managing Worker Nodes. It will monitor the new Nodes connecting to the cluster, validate the Node's health status based on metrics reported by the Node's Kubelet component, and update the Node's .status field. If a Kubelet stops posting health checks to the API Server, the Node Controller will be responsible for triggering Pod eviction from the missing Node before removing the Node from the cluster.",
  "Admin - Controllers - BuiltIn - ReplicaSet": "ReplicaSet Controller: Responsible for creating/modifying Pods based on the ReplicaSet object configuration.",
  "Admin - Controllers - BuiltIn - Replication": "A replication controller is a Kubernetes resource that ensures a pod (or multiple copies of the same pod) is always up and running. If the pod disappears for any reason (like in the event of a node disappearing from the cluster), the replication controller creates a new pod immediately",
  "Admin - Controllers - BuiltIn - Deployment": "Deployment Controller: Responsible for managing Deployment objects and creating/modifying ReplicaSet objects.",
  "Admin - Controllers - BuiltIn - Service": "Service Controller: Responsible for configuring ClusterIP, NodePort, and LoadBalancer configuration based on Service objects.",
  "Admin - Controllers - BuiltIn - StatefulSet": "StatefulSet Controller: Responsible for creating Pods in a guaranteed order with a sticky identity.",
  "Admin - Controllers - BuiltIn - DaemonSet": "DaemonSet - A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Common for system processes like CNI, Monitor agents, proxies, etc.",
  "Admin - Controllers - BuiltIn - Garbage Collection": "",
  "Admin - Controllers - BuiltIn - Job": "Job - A Job creates one or more short-lived Pods and expects them to successfully terminate.",
  "Admin - Controllers - BuiltIn - CronJob": "CronJob Controller: Responsible for creating Job objects based on the Cron schedule defined in CronJob objects.",
  "Admin - Controllers - Addons": "Extensions or plugins. Addons are pods and services that implement cluster features extending the functionality and capabilities of Kubernetes.",
  "Admin - Controllers - Addons - DNS": "While the other addons are not strictly required, all Kubernetes clusters should have cluster DNS, as many examples rely on it. Cluster DNS is a DNS server, in addition to the other DNS server(s) in your environment, which serves DNS records for Kubernetes services. Containers started by Kubernetes automatically include this DNS server in their DNS searches.",
  "Admin - Controllers - Addons - Web UI": "Dashboard is a general purpose, web-based UI for Kubernetes clusters. It allows users to manage and troubleshoot applications running in the cluster, as well as the cluster itself.",
  "Admin - Controllers - Addons - Container Resource Monitoring": "Container Resource Monitoring records generic time-series metrics about containers in a central database, and provides a UI for browsing that data..",
  "Admin - Controllers - Addons - Cluster-level Logging": "A Cluster-level logging mechanism is responsible for saving container logs to a central log store with search/browsing interface.",
  "Admin - Controllers - Operators": "Custom controllers. Operators are an advanced functionality of Kubernetes, enabling users to extend the features of their clusters with custom resources. Kubernetes' operator pattern concept lets you extend the cluster's behaviour without modifying the code of Kubernetes itself by linking controllers to one or more custom resources. Operators are clients of the Kubernetes API that act as controllers for a Custom Resource",
  "Admin - Controllers - Operators - Helm": "The Helm Operator is a Kubernetes operator, allowing one to declaratively manage Helm chart releases. Combined with Flux this can be utilized to automate releases in a GitOps manner, but the usage of Flux is not a strict requirement.",
	"Admin - ControlPane": "The controlPane manages your cluster.",
  "Admin - ControlPane - machines": "The control plane machines manage workloads on the compute machines, which are also known as worker machines.",
  "Admin - ControlPane - components - kube-apiserver": "The API server is a component of the Kubernetes control plane that exposes the Kubernetes API. The API server is the front end for the Kubernetes control plane. The main implementation of a Kubernetes API server is kube-apiserver. kube-apiserver is designed to scale horizontally—that is, it scales by deploying more instances. You can run several instances of kube-apiserver and balance traffic between those instances.",
  "Admin - ControlPane - components - etcd": "Consistent and highly-available key value store used as Kubernetes' backing store for all cluster data.",
  "Admin - ControlPane - components - kube-scheduler": "Control plane component that watches for newly created Pods with no assigned node, and selects a node for them to run on.",
  "Admin - ControlPane - components - kube-controller-manager": "Control plane component that runs controller processes. Logically, each controller is a separate process, but to reduce complexity, they are all compiled into a single binary and run in a single process.",
  "Admin - ControlPane - components - cloud-controller-manager": "A Kubernetes control plane component that embeds cloud-specific control logic. The cloud controller manager lets you link your cluster into your cloud provider's API, and separates out the components that interact with that cloud platform from components that only interact with your cluster. The cloud-controller-manager only runs controllers that are specific to your cloud provider. If you are running Kubernetes on your own premises, or in a learning environment inside your own PC, the cluster does not have a cloud controller manager.",
	"Admin - Tools - kubectl": "The Kubernetes command-line tool, kubectl, allows you to run commands against Kubernetes clusters.",
  "Admin - Tools - kubectl - create": "kubectl create namespace default-mem-example",
  "Admin - Tools - kubectl - delete": "kubectl delete namespace default-mem-example",
	"Admin - Tools - kubeadm": "You can use the kubeadm tool to create and manage Kubernetes clusters. It performs the actions necessary to get a minimum viable, secure cluster up and running in a user friendly way.",

  "K8s - Implementations": "SECTION",
  "K8s - Implementations - Providers": "You can set up a Kubernetes cluster.",
  "K8s - Implementations - Providers - Minikube": "It’s not suitable for production but can be used in a test environment. Maintained by main Kubernetes project..",
  "K8s - Implementations - Providers - K3S/K3D": "Developed by Rancher, for mainly IoT and Edge devices. It uses SQLite as a default storage backend rather than etcd3.",
  "K8s - Implementations - Providers - MicroK8S": "It is lightweight K8S, developed by Canonical(a.k.a. Ubuntu). It is suitable for Edge and IoT devices.",
  "K8s - Implementations - Providers - KinD": "It means Kubernetes-IN-Docker. It runs k8s inside a docker container.",
  "K8s - Implementations - Providers - K0S": "It is certificated(CNCF) Kubernetes distribution works on any infrastructure (Cloud, Edge, IoT…)",
  "K8s - Implementations - Providers - Docker Desktop": ".",
  "K8s - Implementations - Cloud": ".",
  "K8s - Implementations - Cloud - GKE": "Google Kubernetes Engine.",
  "K8s - Implementations - Cloud - EKS": "Amazon Elastic Kubernetes Service.",
  "K8s - Implementations - Cloud - AKS": "Microsoft Azure Kubernetes Service.",
  "K8s - Implementations - Cloud - OCP": "Redhat OpenShift Container Platform."

}