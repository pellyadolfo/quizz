{
  "k8s": "SECTION",
  "k8s - objects": "Kubernetes objects are persistent entities in the Kubernetes system.",
  "k8s - objects - yaml": "Kubernetes objects can be expressed in .yaml format.",
  "k8s - objects - yaml - fields - apiVersion": "Which version of the Kubernetes API you're using to create this object.",
  "k8s - objects - yaml - fields - kind": "What kind of object you want to create.",
  "k8s - objects - yaml - fields - metadata": "Data that helps uniquely identify the object, including a name string, UID, and optional namespace",
  "k8s - objects - yaml - fields - spec": "What state you desire for the object. The precise format of the object spec is different for every Kubernetes object",
  "k8s - objects - manage": "To work with Kubernetes objects--whether to create, modify, or delete them--you'll need to use the Kubernetes API. When you use the kubectl command-line interface, for example, the CLI makes the necessary Kubernetes API calls for you.",
 
  "k8s - cluster": "SECTION",
  "k8s - cluster": "An OpenShift Cluster is a group of nodes or machines running together.",
  "k8s - cluster - components - worked node": "The worker node(s) host the Pods that are the components of the application workload. Every cluster has at least one worker node.",
  "k8s - cluster - components - control plane": "The control plane manages your cluster.",
  "k8s - cluster - components - control plane - machines": "The control plane machines manage workloads on the compute machines, which are also known as worker machines.",
  "k8s - cluster - components - control plane - components - kube-apiserver": "The API server is a component of the Kubernetes control plane that exposes the Kubernetes API. The API server is the front end for the Kubernetes control plane. The main implementation of a Kubernetes API server is kube-apiserver. kube-apiserver is designed to scale horizontally—that is, it scales by deploying more instances. You can run several instances of kube-apiserver and balance traffic between those instances.",
  "k8s - cluster - components - control plane - components - etcd": "Consistent and highly-available key value store used as Kubernetes' backing store for all cluster data.",
  "k8s - cluster - components - control plane - components - kube-scheduler": "Control plane component that watches for newly created Pods with no assigned node, and selects a node for them to run on.",
  "k8s - cluster - components - control plane - components - kube-controller-manager": "Control plane component that runs controller processes. Logically, each controller is a separate process, but to reduce complexity, they are all compiled into a single binary and run in a single process.",
  "k8s - cluster - components - control plane - components - cloud-controller-manager": "A Kubernetes control plane component that embeds cloud-specific control logic. The cloud controller manager lets you link your cluster into your cloud provider's API, and separates out the components that interact with that cloud platform from components that only interact with your cluster. The cloud-controller-manager only runs controllers that are specific to your cloud provider. If you are running Kubernetes on your own premises, or in a learning environment inside your own PC, the cluster does not have a cloud controller manager.",
  "k8s - cluster - kubectl": "The Kubernetes command-line tool, kubectl, allows you to run commands against Kubernetes clusters.",
  "k8s - cluster - kubeadm": "You can use the kubeadm tool to create and manage Kubernetes clusters. It performs the actions necessary to get a minimum viable, secure cluster up and running in a user friendly way.",
  "k8s - cluster - namespaces": "A cluster can contain many pods, related or unrelated [and] grouped under the tight logical borders called namespaces.",
  "k8s - cluster - namespaces - create": "kubectl create namespace default-mem-example",
  "k8s - cluster - namespaces - delete": "kubectl delete namespace default-mem-example",
  "k8s - cluster - operators": "Kubernetes' operator pattern concept lets you extend the cluster's behaviour without modifying the code of Kubernetes itself by linking controllers to one or more custom resources. Operators are clients of the Kubernetes API that act as controllers for a Custom Resource",
  "k8s - cluster - operators - Helm": "The Helm Operator is a Kubernetes operator, allowing one to declaratively manage Helm chart releases. Combined with Flux this can be utilized to automate releases in a GitOps manner, but the usage of Flux is not a strict requirement.",
  "k8s - Cluster - Master": "The Kubernetes Master is a collection of three processes that run on a single node in your cluster, which is designated as the master node. Those processes are: kube-apiserver, kube-controller-manager and kube-scheduler.",
  "k8s - Cluster - Master - kube-apiserver": "",
  "k8s - Cluster - Master - kube-controller-manager": "",
  "k8s - Cluster - Master - kube-scheduler": "",
  "k8s - Cluster - Addons": "Addons are pods and services that implement cluster features. The pods may be managed by Deployments, ReplicationControllers, and so on. Namespaced addon objects are created in the kube-system namespace.",
  "k8s - Cluster - Addons - DNS": "While the other addons are not strictly required, all Kubernetes clusters should have cluster DNS, as many examples rely on it. Cluster DNS is a DNS server, in addition to the other DNS server(s) in your environment, which serves DNS records for Kubernetes services. Containers started by Kubernetes automatically include this DNS server in their DNS searches.",
  "k8s - Cluster - Addons - Web UI": "Dashboard is a general purpose, web-based UI for Kubernetes clusters. It allows users to manage and troubleshoot applications running in the cluster, as well as the cluster itself.",
  "k8s - Cluster - Addons - Container Resource Monitoring": "Container Resource Monitoring records generic time-series metrics about containers in a central database, and provides a UI for browsing that data..",
  "k8s - Cluster - Addons - Cluster-level Logging": "A Cluster-level logging mechanism is responsible for saving container logs to a central log store with search/browsing interface.",

  "k8s - infr": "SECTION",
  "k8s - infr - machines - machine": "A fundamental unit that describes the host for a node.",
  "k8s - infr - machines - machine set": "MachineSet resources are groups of machines. Machine sets are to machines as replica sets are to pods.",
  "k8s - infr - machines - machine config pool": "A MCP is used to group machines together so the MCO can manage their configurations and facilitate their upgrades.",
  "k8s - infr - node": "A node is a virtual or bare-metal machine in a Kubernetes cluster.",
  "k8s - infr - node - components": "The components on a node include the kubelet, a container runtime, and the kube-proxy.",
  "k8s - infr - node - components - kubelet": "The kubelet is the primary node agent that runs on each node. It can register the node with the apiserver using one of: the hostname; a flag to override the hostname; or specific logic for a cloud provider.",
  "k8s - infr - node - components - kube-proxy": "This reflects services as defined in the Kubernetes API on each node and can do simple TCP, UDP, and SCTP stream forwarding or round robin TCP, UDP, and SCTP forwarding across a set of backends",
  "k8s - infr - node - components - container runtime": "The container runtime is the software that is responsible for running containers.",
  "k8s - Node": "The nodes in a cluster are the machines (VMs, physical servers, etc) that run your applications and cloud workflows. The Kubernetes master controls each node, you’ll rarely interact with nodes directly.",
  "k8s - Node - Status": "A node’s status contains the following information: Addresses, Condition, Capacity, Info",
  "k8s - Node - Status - Addresses": "",
  "k8s - Node - Status - Condition": "",
  "k8s - Node - Status - Capacity": "",
  "k8s - Node - Status - Info": "",

  "k8s - storage": "SECTION",
  "k8s - storage - volumes": "At its core, a volume is a directory, possibly with some data in it, which is accessible to the containers in a pod.",
  "k8s - storage - volumes - persistent": "",
  "k8s - storage - volumes - persistent - snapshots": "In Kubernetes, a VolumeSnapshot represents a snapshot of a volume on a storage system.",
  "k8s - storage - volumes - projected": "",
  "k8s - storage - volumes - ephemeral": "", 

  "k8s - arch": "SECTION",
  "k8s - arch - Image": "Container image is the basic unit with docker",
  "k8s - arch - Image Registry": "An image registry is a content server that can store and serve container images.",
  "k8s - arch - Container": "The word container is defined as a specific running or paused instance of a container image.",
  "k8s - arch - Container - hooks": "The hooks enable Containers to be aware of events in their management lifecycle and run code implemented in a handler when the corresponding lifecycle hook is executed.",
  "k8s - arch - Container - hooks - PostStart": "This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. No parameters are passed to the handler.",
  "k8s - arch - Container - hooks - PreStop": "This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod's termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period. No parameters are passed to the handler.",
  "k8s - arch - Container - hooks handlers": "Containers can access a hook by implementing and registering a handler for that hook.",
  "k8s - arch - Container - hooks handlers - exec": "Executes a specific command, such as pre-stop.sh, inside the cgroups and namespaces of the Container. Resources consumed by the command are counted against the Container.",
  "k8s - arch - Container - hooks handlers - http": "Executes an HTTP request against a specific endpoint on the Container.",
  "k8s - Pod": "Pods are the smallest deployable units of computing that can be created and managed in Kubernetes.",
  "k8s - Pod - Pod phase": "A Pod’s status field is a PodStatus object, which has a phase field. The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle. The phase is not intended to be a comprehensive rollup of observations of Container or Pod state, nor is it intended to be a comprehensive state machine. The number and meanings of Pod phase values are tightly guarded. Other than what is documented here, nothing should be assumed about Pods that have a given phase value. Here are the possible values for phase:.",
  "k8s - Pod - Pod phase - Pending": "The Pod has been accepted by the Kubernetes system, but one or more of the Container images has not been created. This includes time before being scheduled as well as time spent downloading images over the network, which could take a while..",
  "k8s - Pod - Pod phase - Running": "The Pod has been bound to a node, and all of the Containers have been created. At least one Container is still running, or is in the process of starting or restarting..",
  "k8s - Pod - Pod phase - Succeeded": "All Containers in the Pod have terminated in success, and will not be restarted.",
  "k8s - Pod - Pod phase - Failed": "All Containers in the Pod have terminated, and at least one Container has terminated in failure. That is, the Container either exited with non-zero status or was terminated by the system.",
  "k8s - Pod - Pod phase - Unknown": "For some reason the state of the Pod could not be obtained, typically due to an error in communicating with the host of the Pod.",
  "k8s - arch - Pod": "basic scalable units that Kubernetes works with are called pods. A pod is one or more containers deployed together on one host, and the smallest compute unit that can be defined, deployed, and managed.",
  "k8s - arch - Pod - sizing": "Scalability and namespaces are probably the main items to consider when determining what goes in a pod.",
  "k8s - arch - Pod - lifecyle - create": "To create a pod using the nginx image, run the command kubectl run nginx --image=nginx --restart=Never . This will create a pod named nginx, running with the nginx image on Docker Hub. And by setting the flag --restart=Never we tell Kubernetes to create a single pod rather than a Deployment.",
  "k8s - arch - Pod - lifecyle - update": "Since Pods are intended to be disposable and replaceable, you cannot add a container to a Pod once it has been created.",
  "k8s - arch - Pod - comms": "",
  "k8s - arch - Pod - comms - IP": "Every Pod in a cluster gets its own unique cluster-wide IP address. This means you do not need to explicitly create links between Pods and you almost never need to deal with mapping container ports to host ports.",
  "k8s - arch - Pod - comms - interpod": "pods can communicate with all other pods on any other node without NAT",
  "k8s - arch - Pod - comms - agent2pod": "agents on a node (e.g. system daemons, kubelet) can communicate with all pods on that node",
  "k8s - arch - Workloads - Deployment": "A Deployment provides declarative updates for Pods and ReplicaSets.",
  "k8s - arch - Workloads - StatefulSet": "A StatefulSet = PVC bound to a pod.",
  "k8s - arch - Workloads - ReplicaSet": "A ReplicaSet's purpose is to maintain a stable set of replica Pods running at any given time. As such, it is often used to guarantee the availability of a specified number of identical Pods.",
  "k8s - arch - Workloads - DaemonSet": "A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created.",
  "k8s - arch - Workloads - Job": "A Job creates one or more Pods and will continue to retry execution of the Pods until a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. Suspending a Job will delete its active Pods until the Job is resumed again..",
  "k8s - arch - Workloads - CronJob": "A CronJob creates Jobs on a repeating schedule. One CronJob object is like one line of a crontab (cron table) file. It runs a job periodically on a given schedule, written in Cron format.",
  "k8s - arch - Service": "A service provides a means of grouping together a set of pods to create a complete, stable application. A Service resource doesn�t run our containers. It merely provides and maintains a network identity for our Pod resource.",
  "k8s - arch - Service - network identity": "Service network identity provides both a static IP address and a DNS name. Services listen on a static address that doesn�t change and forwards the request to the unreliable container address. It internally keeps a map that always contains the latest IP address of the Pod. So, whenever a Pod restarts, it updates that map automatically so you get a seamless connection.",
  "k8s - arch - Service - load": "Services have an integrated load-balancer that will distribute network traffic to all Pods of an exposed Deployment.",
  "k8s - arch - Service - ingress": "An API object that manages external access to the services in a cluster, typically HTTP. Ingress exposes HTTP and HTTPS routes from outside the cluster to services within the cluster.",
  "k8s - arch - Service - ingress - features": "Ingress may provide load balancing, SSL termination and name-based virtual hosting.",
  "k8s - arch - Service - ingress - routing": "Traffic routing is controlled by rules defined on the Ingress resource.",
  "Kubernetes - Services": "The services on a node include the container runtime, kubelet and kube-proxy.",
  "Kubernetes - Services": "A Kubernetes Service is an abstraction which defines a logical set of Pods and a policy by which to access them - sometimes called a micro-service.",
  "Kubernetes - Services - Label Selector": "The set of Pods targeted by a Service is (usually) determined by a Label Selector",
  "Kubernetes - Services - Container Runtime": "Each node runs a container runtime, which is responsible for downloading images and running containers. Kubernetes supports several runtimes: Docker, rkt, runc and any OCI runtime-spec implementation.",
  "Kubernetes - Services - Container Runtime - Docker": "",
  "Kubernetes - Services - Container Runtime - rkt": "",
  "Kubernetes - Services - Container Runtime - runc": "",
  "Kubernetes - Services - Container Runtime - any OCI runtime-spec implementation": "",
  "Kubernetes - Services - kubelet": "An agent that runs on each node in the cluster. It makes sure that containers are running in a pod. The kubelet takes a set of PodSpecs that are provided through various mechanisms and ensures that the containers described in those PodSpecs are running and healthy. The kubelet doesn’t manage containers which were not created by Kubernetes.",
  "Kubernetes - Services - kube-proxy": "The Kube-proxy is an implementation of a network proxy and a load balancer, and it supports the service abstraction along with other networking operation. It is responsible for routing traffic to the appropriate container based on IP and port number of the incoming request.",
  "Kubernetes - Controllers": "In addition, Kubernetes contains a number of higher-level abstractions called Controllers. Controllers build upon the basic objects, and provide additional functionality and convenience features. They include: ReplicaSet, Deployment, StatefulSet, DaemonSet, Job",
  "Kubernetes - Controllers - ReplicaSet": "ReplicaSet is the next-generation Replication Controller. The only difference between a ReplicaSet and a Replication Controller right now is the selector support. ReplicaSet supports the new set-based selector requirements as described in the labels user guide whereas a Replication Controller only supports equality-based selector requirements.",
  "Kubernetes - Controllers - ReplicationController": "A replication controller is a Kubernetes resource that ensures a pod (or multiple copies of the same pod) is always up and running. If the pod disappears for any reason (like in the event of a node disappearing from the cluster), the replication controller creates a new pod immediately",
  "Kubernetes - Controllers - Deployment": "",
  "Kubernetes - Controllers - StatefulSet": "",
  "Kubernetes - Controllers - DaemonSet": "",
  "Kubernetes - Controllers - Garbage Collection": "",
  "Kubernetes - Controllers - Job": "",
  "Kubernetes - Controllers - CronJob": "",
  "Kubernetes - Volume": "On-disk files in a Container are ephemeral, which presents some problems for non-trivial applications when running in Containers. First, when a Container crashes, kubelet will restart it, but the files will be lost - the Container starts with a clean state. Second, when running Containers together in a Pod it is often necessary to share files between those Containers. The Kubernetes Volume abstraction solves both of these problems."
}