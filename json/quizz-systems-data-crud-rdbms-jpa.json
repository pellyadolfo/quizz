{

	"JPA": "SECTION",
	"JPA ": "",

	"App": "SECTION",
	"App - Fetching ": "Fetching, essentially, is the process of grabbing data from the database and making it available to the application.",
	"App - Fetching - Strategies - Static": "Static definition of fetching strategies is done in the mappings. The statically-defined fetch strategies is used in the absence of any dynamically defined strategies.",
	"App - Fetching - Strategies - Static - @Fetch": "FetchType",
	"App - Fetching - Strategies - Static - @Fetch - JPA - FetchType": "FetchType, on the other hand, defines whether will load data eagerly or lazily.",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY": "When you load an entity with lazy associations, Hibernate doesn't load the associated entities immediately. Instead, it creates dynamic proxy objects that stand in for the real entities",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - SubClass": "Proxies look like real entities but contain no actual data initially. These proxies are subclasses of your entity classes generated at runtime",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - Initialization": "When you access any method of the proxy (except the identifier), Hibernate triggers a database query to load the real data. This is called 'initialization' of the proxy",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - Mechanisms": "",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - Mechanisms - BytecodeEnhancement": "Hibernate uses bytecode instrumentation (via libraries like Javassist or Byte Buddy) to: Generate proxy classes at runtime Intercept method calls to trigger lazy loading Maintain the illusion of a fully-loaded object",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - Mechanisms - SessionBoundProxies": "Proxies are only valid while the Hibernate Session is open. Accessing a proxy after session closure throws LazyInitializationException",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - Patterns": "",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - Patterns - RuntimeProxies": "Runtime proxies (default): Dynamic subclass generation",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - Patterns - BytecodeEnhancedProxies": "Bytecode-enhanced proxies: More efficient but requires build-time weaving",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - @Proxy": "Define a custom entity proxy. By default, when it needs to use a proxy instead of the actual Pojo, Hibernate is going to use a Bytecode manipulation library like Javassist or Byte Buddy. However, if the entity class is final, Javassist will not create a proxy and you will get a Pojo even when you only need a proxy reference. The @Proxy annotation is used to specify a custom proxy implementation for the current annotated entity. @Proxy(proxyClass = Identifiable.class)",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - @Proxy - Custom": "The @Proxy annotation is used to specify a custom proxy implementation for the current annotated entity. @Proxy(proxyClass = Identifiable.class)",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - @Proxy - Bytecode": "Hibernate is going to use a Bytecode manipulation library like Javassist or Byte Buddy.",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - @Proxy - final": "If the entity class is final, Javassist will not create a proxy and you will get a Pojo even when you only need a proxy reference.",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - NoProxy": "No-proxy Lazy Loading: @LazyToOne(LazyToOneOption.NO_PROXY) private Customer customer;",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - FieldLevel": "Allows lazy loading of basic fields (not just associations)",
	"App - Fetching - Strategies - Static - @Fetch - JPA - EAGER - default": "In the eager loading strategy, if we load the User data, it will also load up all orders associated with it and will store it in memory.",
	"App - Fetching - Strategies - Dynamic": "Dynamic definition is really use-case centric. There are multiple ways to define dynamic fetching: fetch profiles, HQL/JPQL, entity graphs",
	"App - Fetching - Strategies - Dynamic - JPA - EntityGraphs": "JPA 2.1 introduced entity graphs so the application developer has more control over fetch plans.",
	"App - Fetching - Strategies - Dynamic - JPA - EntityGraphs - Types": ".",
	"App - Fetching - Strategies - Dynamic - JPA - EntityGraphs - Types - FetchGraphs": "Strict specification - only listed attributes are eager.",
	"App - Fetching - Strategies - Dynamic - JPA - EntityGraphs - Types - FetchGraphs - javax.persistence.fetchgraph": "JPA standard specifies that you can override an EAGER fetching association at runtime using the javax.persistence.fetchgraph hint",
	"App - Fetching - Strategies - Dynamic - JPA - EntityGraphs - Types - LoadGraphs": "Additive specification - listed attributes + default eager ones.",
	"App - Fetching - Strategies - Dynamic - JPA - EntityGraphs - Types - LoadGraphs - javax.persistence.loadgraph": "JPA standard specifies that you can override an EAGER fetching association at runtime using the javax.persistence.fetchgraph hint",
	"App - Fetching - Strategies - Dynamic - JPA - EntityGraphs - Types - NamedEntityGraph": ".",
	"App - Fetching - Strategies - Dynamic - JPA - EntityGraphs - Types - DynamicEntityGraphs": "Created programmatically using createEntityGraph():",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems": "Hibernate generates SQL queries automatically based on your entity mappings and operations, but provides several ways to customize this behavior.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - SQLQueries": "JPA also supports executing SQL queries through the javax.persistence.Query interface",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - SQLQueries - @NamedNativeQuery - JPA": "Defines a reusable SQL query.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - JPA": "Criteria queries are a programmatic, type-safe way to express a query. They are type-safe in terms of using interfaces and classes to represent various structural parts of a query such as the query itself, the select clause, or an order-by, etc. They can also be type-safe in terms of referencing attributes as we will see in a bit",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaBuilder": "Criteria queries are essentially an object graph, where each part of the graph represents an increasing (as we navigate down this graph) more atomic part of the query. The first step in performing a criteria query is building this graph. The javax.persistence.criteria.CriteriaBuilder interface is the first thing with which you need to become acquainted with begin using criteria queries. Its role is that of a factory for all the individual pieces of the criteria. You obtain a javax.persistence.criteria.CriteriaBuilder instance by CriteriaBuilder builder = entityManager.getCriteriaBuilder(),",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Typed": "The type of the criteria query (aka the <T>) indicates the expected types in the query result. This might be an entity, an Integer, or any other object.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Create Criteria": "The next step is to obtain a javax.persistence.criteria.CriteriaQuery. This is accomplished using one of the three methods on javax.persistence.criteria.CriteriaBuilder for this purpose: (1) <T> CriteriaQuery<T> createQuery( Class<T> resultClass ) (2) CriteriaQuery<Tuple> createTupleQuery() (3) CriteriaQuery<Object> createQuery() Each serves a different purpose depending on the expected type of the query results.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Create - createCriteria(Class.class)": "Criteria crit = sess.createCriteria(Cat.class), (hibernate) vs Session#createCriteria(String entityName) or StatelessSession#createCriteria(String entityName) (JPA)",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Create - CriteriaQuery<Tuple> createTupleQuery()": "A better approach to Selecting multiple values is to use either a wrapper (which we just saw in Selecting a wrapper) or using the javax.persistence.Tuple contract. The javax.persistence.Tuple contract provides three forms of access to the underlying elements: typed, positional, aliased",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Create - DetachedCriteria": "The DetachedCriteria class allows you to create a query outside the scope of a session and then execute it using an arbitrary Session. DetachedCriteria.forClass(Cat.class)",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Restrictions": ".add( Restrictions.like('name', 'Fritz%') ) and .add(Restrictions.eq('fullName.lastName', 'Cattington')) (embedded)",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Fetching": ".setFetchMode('mate', FetchMode.EAGER)",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Projections": ".setProjection( Projections.rowCount() )",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Projections - Aggregation": "Projections.projectionList().add( Projections.rowCount() ) .add( Projections.avg('weight') )",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - criteria.groupBy(root.get('address'))": "Specify the expressions that are used to form groups over the query results.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - having(Expression<Boolean> restriction)": "Specify a restriction over the groups of the query.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - distinct(boolean distinct)": "Specify whether duplicate query results will be eliminated.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Ordering": ".addOrder( Order.asc('catName') )",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - By Natural Id": "add( Restrictions.naturalId().set('name', 'gavin').set('org', 'hb'))",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - from(Class<X> entityClass)": "Create and add a query root corresponding to the given entity, forming a cartesian product with any existing roots.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - where(Expression<Boolean> restriction)": "Modify the query to restrict the query results according to the specified boolean expression.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Roots": "Roots define the basis from which all joins, paths and attributes are available in the query. A root is always an entity type. Roots are defined and added to the criteria by the overloaded from methods on javax.persistence.criteria.CriteriaQuery:",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Joins": "Joins allow navigation from other javax.persistence.criteria.From to either association or embedded attributes. Joins are created by the numerous overloaded join methods of the javax.persistence.criteria.From interface.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Fetches": "Just like in HQL and JPQL, criteria queries can specify that associated data be fetched along with the owner. Fetches are created by the numerous overloaded fetch methods of the javax.persistence.criteria.From interface.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPQLQueries": "JPQL stands for Java Persistence Query Language. Used by Spring Data JPA.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPQLQueries - @NamedQuery": "Defines a reusable JPQL query.",
	"App - Fetching - Strategies - Dynamic - Querying - QueryExecution": "",
	"App - Fetching - Strategies - Dynamic - Querying - QueryExecution - 1. Parse": "Parse operation (HQL/Criteria/API call)",
	"App - Fetching - Strategies - Dynamic - Querying - QueryExecution - 2. AST": "Generate abstract syntax tree",
	"App - Fetching - Strategies - Dynamic - Querying - QueryExecution - 3. Optimizations": "Apply optimizations",
	"App - Fetching - Strategies - Dynamic - Querying - QueryExecution - 4. SQL": "Convert to SQL (with dialect)",
	"App - Fetching - Strategies - Dynamic - Querying - QueryExecution - 5. PrepareStatement": "",
	"App - Fetching - Strategies - Dynamic - Querying - QueryExecution - 6. Execute": "Execute and return results",
	"App - Caching - L1Cache": "In Hibernate, the first-level cache (L1 cache) is a session-level cache that is enabled by default and exists for the duration of a Hibernate Session.",
	"App - Caching - L1Cache - Features - Mandatory": "Automatic & Mandatory – Enabled by default; cannot be disabled.",
	"App - Caching - L1Cache - Features - NoConfig": "No Configuration Needed – Works out of the box.",
	"App - Caching - L1Cache - Lifecycle - Create": "When an entity is loaded via session.get(), session.load(), or queries, Hibernate stores it in the L1 cache.",
	"App - Caching - L1Cache - Lifecycle - Run": "Session-Scoped – Exists only while the Session is open. Once the session is closed, the cache is destroyed.",
	"App - Caching - L1Cache - Lifecycle - Delete": "Short-Lived – Cleared when session.evict(), session.clear(), or session.close() is called.",
	"App - Caching - L2Cache": "It is possible to configure a JVM-level (SessionFactory-level) or even a cluster cache on a class-by-class and collection-by-collection basis. Be aware that caches are not aware of changes made to the persistent store by other applications. They can, however, be configured to regularly expire cached data.",
	"App - Caching - L2Cache - CacheableObjects - Entity": "JPA supports basic entity caching (@Cacheable) but not collections or queries..",
	"App - Caching - L2Cache - @Cacheable - JPA": "The @Cacheable annotation is used to specify whether an entity should be stored in the second-level cache.",
	"App - Caching - L2Cache - @Cacheable - Java - ENABLE_SELECTIVE": "If the persistence.xml shared-cache-mode XML attribute is set to ENABLE_SELECTIVE, then only the entities annotated with the @Cacheable are going to be stored in the second-level cache.",
	"App - Caching - L2Cache - @Cacheable - Java - DISABLE_SELECTIVE": "If shared-cache-mode XML attribute value is DISABLE_SELECTIVE, then the entities marked with the @Cacheable annotation are not going to be stored in the second-level cache, while all the other entities are stored in the cache.",
	"App - Caching - L2Cache - CacheManagement - JPA": "JPA split cache modes by storage and retrieval. JPA provides basic caching support (@Cacheable), but advanced features require provider extensions.",
	"App - Caching - L2Cache - CacheManagement - JPA - CacheStoreMode": "USE, REFRESH, BYPASS",
	"App - Caching - L2Cache - CacheManagement - JPA - CacheStoreMode - USE": "",
	"App - Caching - L2Cache - CacheManagement - JPA - CacheStoreMode - REFRESH": "",
	"App - Caching - L2Cache - CacheManagement - JPA - CacheStoreMode - BYPASS": "",
	"App - Caching - L2Cache - CacheManagement - JPA - CacheAppMode": "USE, BYPASS",
	"App - Caching - L2Cache - CacheManagement - JPA - CacheAppMode - USE": "",
	"App - Caching - L2Cache - CacheManagement - JPA - CacheAppMode - BYPASS": "",
	"App - Performance": "Tuning how an application does fetching is one of the biggest factors in determining how an application will perform. Fetching too much data, in terms of width (values/columns) and/or depth (results/rows), adds unnecessary overhead in terms of both JDBC communication and ResultSet processing. Fetching too little data might cause additional fetching to be needed. Tuning how an application fetches data presents a great opportunity to influence the application overall performance.",
	"App - Performance - N+1": "The N+1 problem is a common performance issue in Hibernate (and other ORMs) where the framework executes many more SQL queries than necessary to fetch associated entities. (1) Execute 1 query to get N entities (the '1' in N+1) (2) Then Hibernate executes N additional queries (the 'N' in N+1) to fetch associated entities for each of the original N entities",
	"App - Performance - N+1 - Solutions - JOIN FETCH": "Eager Fetching with JOIN FETCH List<Author> authors = session.createQuery('SELECT a FROM Author a JOIN FETCH a.books', Author.class).list(); This generates a single SQL query with a JOIN.",
	"App - Performance - N+1 - Solutions - JOIN FETCH - drawback": "JOIN FETCH can lead to Cartesian product explosions with multiple collections.",
	"App - Performance - N+1 - Solutions - @BatchSize": "Configuring Hibernate to load collections in batches. This fetches associations in batches rather than one-by-one.: @BatchSize(size = 10) private Set<Book> books; ",
	"App - Performance - N+1 - Solutions - @BatchSize - drawback": "Batch fetching still involves multiple queries, albeit fewer than the pure N+1 scenario.",
	"App - Performance - N+1 - Solutions - FetchMode.SUBSELECT": "This executes a second query that fetches all collections at once: @Fetch(FetchMode.SUBSELECT) private Set<Book> books;. FetchMode.SUBSELECT is useful as it solves the N+1 query¹ issue of FetchMode.SELECT. But FetchMode.SUBSELECT leads to increased memory usage.",
	"App - Performance - N+1 - Solutions - EntityGraph": "EntityGraph<Author> graph = session.createEntityGraph(Author.class); Defining fetch plans using JPA’s @EntityGraph annotation.",
	"App - Performance - N+1 - Solutions - EntityGraph - drawback": "require careful configuration",
	"App - Performance - N+1 - Solutions - DTOProjections": "Instead of fetching entire entity graphs, select only the data you need. Use DTO projections when you only need a subset of data",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - SpringBoot3.5": "This feature intelligently analyzes your application’s data access patterns at runtime and automatically optimizes fetching strategies based on observed behavior.",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - BasedOn - DynamicQueryRewriting": "When Spring Boot 3.5 detects potential N+1 scenarios, it dynamically rewrites subsequent queries into efficient batch queries. This happens transparently without requiring developer intervention. For instance, if your code first loads all orders and then accesses their line items, Spring Boot’s enhanced EntityManager intercepts the individual line item access operations and consolidates them into a single optimized query.",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - BasedOn - PredictiveDataLoading": "@EnablePredictiveEntityLoading Spring Boot 3.5 introduces a learning algorithm that analyzes access patterns across requests. After observing that a particular entity relationship is consistently accessed together, it begins preemptively loading the related entities in an optimal way. With this configuration, Spring Boot automatically adapts to your application’s specific data access needs, optimizing queries based on real usage patterns rather than static configuration.",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - BasedOn - TransparentCachingLayer": "@EnableJpaRepositories(enableRelationshipCache = true) The framework now includes a transparent second-level cache specifically designed to eliminate redundant N+1 queries. This cache is context-aware and understands entity relationships, ensuring that related entities are stored and retrieved together. What makes this solution particularly powerful is how little developer intervention it requires. In many cases, it “just works” without additional configuration.",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - Steps - QueryPlanAnalysis": "The enhanced JPA implementation analyzes SQL query plans before execution. When it detects patterns indicative of N+1 scenarios, it intercepts and optimizes the execution plan.",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - Steps - BytecodeEnhancement": "@EnableEnhancedJpaEntities For maximum performance, Spring Boot now offers enhanced bytecode instrumentation that makes relationship traversal operations more efficient:",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - Steps - AdaptiveRepositoryImplementation": "Spring Data repositories now leverage this enhanced infrastructure automatically. The standard repository methods are implemented with awareness of relationship loading patterns:",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - Adoption": "spring.jpa.properties.hibernate.batch_fetch_style=DYNAMIC - spring.jpa.properties.hibernate.query.optimizer.enabled=true - spring.jpa.properties.hibernate.query.relation_aware_loading=true",

	"Persistence": "SECTION",
	"Persistence - PersistenceContext": "Both the org.hibernate.Session API and javax.persistence.EntityManager API represent a context for dealing with persistent data. This concept is called a persistence context. Persistent data has a state in relation to both a persistence context and the underlying database.",
	"Persistence - PersistenceContext - @PersistenceUnit - JPA": "The @PersistenceUnit annotation is used to specify the EntityManagerFactory that needs to be injected as a dependency.",
	"Persistence - PersistenceContext - @PersistenceUnits - JPA": "The @PersistenceUnits annotation is used to group multiple @PersistenceUnit annotations.",
	"Persistence - PersistenceContext - @PersistenceContext - JPA": "The @PersistenceContext annotation is used to specify the EntityManager that needs to be injected as a dependency.",
	"Persistence - PersistenceContext - @PersistenceContexts - JPA": "The @PersistenceContexts annotation is used to group multiple @PersistenceContext annotations.",
	"Persistence - PersistenceContext - @PersistenceProperty - JPA": "The @PersistenceProperty annotation is used by the @PersistenceContext annotation to declare JPA provider properties that are passed to the underlying container when the EntityManager instance is created.",
	"Persistence - EntityManagement - JPA - EntityManager - EntityManagerFactory": "A thread-safe (and immutable) representation of the mapping of the application domain model to a database. Acts as a factory for org.hibernate.Session instances. The EntityManagerFactory is the JPA equivalent of a SessionFactory and basically those two converge into the same SessionFactory implementation. A SessionFactory is very expensive to create, so, for any given database, the application should have only one associated SessionFactory. The SessionFactory maintains services that Hibernate uses across all Session(s) such as second level caches, connection pools, transaction system integrations, etc.",
	"Persistence - EntityManagement - JPA - EntityManager - EntityManager": "A single-threaded, short-lived object conceptually modeling a Unit of Work PoEAA. In JPA nomenclature, the Session is represented by an EntityManager. Behind the scenes, the Hibernate Session wraps a JDBC java.sql.Connection and acts as a factory for org.hibernate.Transaction instances. It maintains a generally repeatable read persistence context (first level cache) of the application domain model.",
	"Persistence - EntityManagement - JPA - EntityManager - EntityTransaction": "A single-threaded, short-lived object used by the application to demarcate individual physical transaction boundaries. EntityTransaction is the JPA equivalent and both act as an abstraction API to isolate the application from the underlying transaction system in use (JDBC or JTA).",
	"Persistence - EntityManagement - JPA - EntityManager - Clearing": "entityManager.clear(), (JPA)",
	"Persistence - Transactions": "",
	"Persistence - Transactions - Features - Flush": "Hibernate does not automatically flush on rollback",
	"Persistence - Transactions - Features - ThreadSafe": "Transactions are not thread-safe by default",
	"Persistence - Transactions - Features - JTA": "For distributed transactions, use JTA with proper XA datasources",
	"Persistence - Transactions - Features - L2Cache": "Second-level cache updates happen during transaction commit",
	"Persistence - Transactions - lifecycle - JPA - start": "Hibernate starts the transactions by calling getTransaction() (JPA's implementation)",
	"Persistence - Transactions - lifecycle - JPA - instance": "According to used persistence mechanism, a transaction can be an instance of javax.persistence.EntityTransaction (for JPA)",
	"Persistence - Transactions - lifecycle - JPA - transaction.rollback()": "",
	"Persistence - Transactions - lifecycle - JPA - transaction.commit()": "",
	"Persistence - Transactions - lifecycle - Spring - @Transactional": "When using Spring, transaction management is typically delegated to Spring:",
	"Persistence - Transactions - Isolation": "",
	"Persistence - Transactions - Isolation - Levels - JDBC - Connection.TRANSACTION_NONE": "It is represented by integer value 0 does not support transactions.",
	"Persistence - Transactions - Isolation - Levels - JDBC - Connection.TRANSACTION_READ_UNCOMMITTED": "It is represented by integer value 2 supports transactions allowing Non-Repeatable Reads and, Phantom Reads.",
	"Persistence - Transactions - Isolation - Levels - JDBC - Connection.TRANSACTION_READ_COMMITTED": "It is represented by integer value 1 supports transactions allowing Dirty Reads, Non-Repeatable Reads and, Phantom Reads.",
	"Persistence - Transactions - Isolation - Levels - JDBC - Connection.TRANSACTION_REPEATABLE_READ": "It is represented by integer value 4 supports transactions allowing only Phantom Reads.",
	"Persistence - Transactions - Isolation - Levels - JDBC - Connection.TRANSACTION_SERIALIZABLE": "It is represented by integer value 8 supports transactions without allowing Dirty Reads, Non-Repeatable Reads and, Phantom Reads.",
	"Persistence - Transactions - Isolation - Levels - Spring - Isolation.DEFAULT": "Use the default isolation level of the underlying data store.",
	"Persistence - Transactions - Isolation - Levels - Spring - Isolation.READ_UNCOMMITTED": "A constant indicating that dirty reads, non-repeatable reads, and phantom reads can occur.",
	"Persistence - Transactions - Isolation - Levels - Spring - Isolation.READ_COMMITTED": "A constant indicating that dirty reads are prevented; non-repeatable reads and phantom reads can occur.",
	"Persistence - Transactions - Isolation - Levels - Spring - Isolation.REPEATABLE_READ": "A constant indicating that dirty reads and non-repeatable reads are prevented; phantom reads can occur.",
	"Persistence - Transactions - Isolation - Levels - Spring - Isolation.SERIALIZABLE": "A constant indicating that dirty reads, non-repeatable reads, and phantom reads are prevented.",
	"Persistence - Transactions - Locking": "Locking is a mechanism that prevents concurrent access to data to maintain consistency.",
	"Persistence - Transactions - Locking - Config - LockModeType - JPA": "FORCE, NONE, OPTIMISTIC, OPTIMISTIC_FORCE_INCREMENT, PESSIMISTIC_FORCE_INCREMENT, PESSIMISTIC_READ, PESSIMISTIC_WRITE, READ, UPGRADE, UPGRADE_NOWAIT, UPGRADE_SKIPLOCKED, WRITE",
	"Persistence - Transactions - Locking - Types": "Your locking strategy can be either optimistic or pessimistic.",
	"Persistence - Transactions - Locking - Types - Optimistic": "Assumes that multiple transactions can complete without affecting each other, and that therefore transactions can proceed without locking the data resources that they affect.",
	"Persistence - Transactions - Locking - Types - Optimistic - Rollback": "Before committing, each transaction verifies that no other transaction has modified its data. If the check reveals conflicting modifications, the committing transaction rolls back.",
	"Persistence - Transactions - Locking - Types - Optimistic - @OptimisticLocking - JPA": "The @OptimisticLock annotation is used to specify if the currently annotated attribute will trigger an entity version increment upon being modified.",
	"Persistence - Transactions - Locking - Types - Optimistic - @OptimisticLocking - Strategies": "NONE, VERSION, ALL, DIRTY",
	"Persistence - Transactions - Locking - Types - Optimistic - @OptimisticLocking - Strategies - NONE": "NONE The implicit optimistic locking mechanism is disabled.",
	"Persistence - Transactions - Locking - Types - Optimistic - @OptimisticLocking - Strategies - VERSION": "VERSION The implicit optimistic locking mechanism is using a dedicated version column.",
	"Persistence - Transactions - Locking - Types - Optimistic - @OptimisticLocking - Strategies - VERSION - @Version": "Uses versioning (a version number or timestamp). Implemented using @Version annotation",
	"Persistence - Transactions - Locking - Types - Optimistic - @OptimisticLocking - Strategies - ALL": "ALL The implicit optimistic locking mechanism is using all attributes as part of an expanded WHERE clause restriction for the Update and Delete SQL statements.",
	"Persistence - Transactions - Locking - Types - Optimistic - @OptimisticLocking - Strategies - DIRTY": "DIRTY The implicit optimistic locking mechanism is using the dirty attributes (the attributes that were modified) as part of an expanded WHERE clause restriction for the Update and Delete SQL statements.",
	"Persistence - Transactions - Locking - Types - Pessimistic": "Pessimistic locking assumes that concurrent transactions will conflict with each other, and requires resources to be locked after they are read and only unlocked after the application has finished using the data.",
	"Persistence - Entity - JPA - Locate - Reference": "Obtain an entity reference without initializing its data: book.setAuthor( entityManager.getReference( Person.class, personId ) ) (JPA)",
	"Persistence - Entity - JPA - Locate - ReferenceBySimpleNaturalId": "session.bySimpleNaturalId( Book.class ).getReference( isbn ) (hibernate)",
	"Persistence - Entity - JPA - Locate - ReferenceByNaturalId": "session.byNaturalId( Book.class ).using( 'isbn', isbn ).load( ), (hibernate)",
	"Persistence - Entity - JPA - Locate - Find": "Person person = entityManager.find( Person.class, personId ) (JPA)",
	"Persistence - Entity - JPA - Locate - Contains": "entityManager.contains( person ) (JPA)",
	"Persistence - Entity - JPA - Persist - Persist": "entityManager.persist( person ) (JPA)",
	"Persistence - Entity - JPA - Persist - Merging": "Merging detached data: entityManager.merge( person ) (JPA)",
	"Persistence - Entity - JPA - Persist - Remove": "entityManager.remove( person ) (JPA)",
	"Persistence - Entity - JPA - Persist - Refresh": "Refresh entity state entityManager.refresh( person ) (JPA)",
	"Persistence - Entity - JPA - Persist - Evicting": "entityManager.detach( person ) (JPA)",
	"Persistence - Entity - JPA - Persist - Laziness": "persistenceUnitUtil.isLoaded( person ) (JPA)",
	"Persistence - Entity - JPA - Cascade": "Cascading refers to the propagation of operations from a parent entity to its associated child entities.",
	"Persistence - Entity - JPA - Cascade - @Cascade - JPA": "JPA allows you to propagate the state transition from a parent entity to a child. The JPA javax.persistence.CascadeType defines various cascade types: ALL, PERSIST, MERGE, REMOVE, REFRESH, DETACH.",
	"Persistence - Entity - JPA - Cascade - CascadeType - ALL (Hibernate/JPA)": "CascadeType.ALL will propagate any Hibernate-specific operation, which is defined by the org.hibernate.annotations.CascadeType enum: SAVE_Update, REPLICATE, LOCK.",
	"Persistence - Entity - JPA - Cascade - CascadeType - MERGE (Hibernate/JPA)": "The CascadeType.MERGE allows us to merge a child entity along with the parent one.",
	"Persistence - Entity - JPA - Cascade - CascadeType - PERSIST (Hibernate/JPA)": "The CascadeType.PERSIST allows us to persist a child entity along with the parent one.",
	"Persistence - Entity - JPA - Cascade - CascadeType - REMOVE (Hibernate/JPA)": "The CascadeType.REMOVE allows us to remove a child entity along with the parent one. Traditionally, Hibernate called this operation Delete, that's why the org.hibernate.annotations.CascadeType provides a Delete cascade option. However, CascadeType.REMOVE and org.hibernate.annotations.CascadeType.Delete are identical.",
	"Persistence - Entity - JPA - Cascade - CascadeType - REFRESH (Hibernate/JPA)": "The CascadeType.REFRESH is used to propagate the refresh operation from a parent entity to a child. The refresh operation will discard the current entity state, and it will override it using the one loaded from the database.",
	"Persistence - Entity - JPA - Cascade - CascadeType - DETACH (Hibernate/JPA)": "CascadeType.DETACH is used to propagate the detach operation from a parent entity to a child.",
	"Persistence - Entity - JPA - Cascade - CascadeType - LOCK (Hibernate)": "Although unintuitively, CascadeType.LOCK does not propagate a lock request from a parent entity to its children. Such a use case requires the use of the PessimisticLockScope.EXTENDED value of the javax.persistence.lock.scope property. However, CascadeType.LOCK allows us to reattach a parent entity along with its children to the currently running Persistence Context.",
	"Persistence - Entity - JPA - Cascade - CascadeType - REPLICATE (Hibernate)": "The CascadeType.REPLICATE is to replicate both the parent and the child entities. The replicate operation allows you to synchronize entities coming from different sources of data.",
	"Persistence - Entity - JPA - Cascade - CascadeType - SAVE_Update (Hibernate)": "Either save() or Update() the given instance, depending upon the value of its identifier property. By default the instance is always saved. This behaviour may be adjusted by specifying an unsaved-value attribute of the identifier property mapping. This operation cascades to associated instances if the association is mapped with cascade='save-Update'.",
	"Persistence - Entity - JPA - Cascade - OrphanRemoval": "Use orphanRemoval = true to automatically delete child entities when they're removed from the collection.",
	"Persistence - States": "Transient, managed or persistent, detached, removed",
	"Persistence - States - Transient": "new or transient. The entity has just been instantiated and is not associated with a persistence context. It has no persistent representation in the database and typically no identifier value has been assigned (unless the assigned generator was used).",
	"Persistence - States - Persistent": "managed or persistent. The entity has an associated identifier and is associated with a persistence context. It may or may not physically exist in the database yet.",
	"Persistence - States - Detached": "The entity has an associated identifier, but is no longer associated with a persistence context (usually because the persistence context was closed or the instance was evicted from the context).",
	"Persistence - States - Removed": "The entity has an associated identifier and is associated with a persistence context, however it is scheduled for removal from the database.",
	"Persistence - States - JPA - Modifying": "person.setName('John Doe'), entityManager.flush(), (JPA)",
	"Persistence - Flushing": "Flushing is the process of synchronizing the state of the persistence context with the underlying database. The EntityManager and the Hibernate Session expose a set of methods, through which the application developer can change the persistent state of an entity. The persistence context acts as a transactional write-behind cache, queuing any entity state change. Like any write-behind cache, changes are first applied in-memory and synchronized with the database during flush time. The flush operation takes every entity state change and translates it to an INSERT, Update or Delete statement.",
	"Persistence - Flushing - ChangeDetection - InitialState": "Initial State Capture: When an entity is loaded, Hibernate takes a 'snapshot' of all its persistent state",
	"Persistence - Flushing - ChangeDetection - DeepComparison": "During flush operations, compares current state with the original snapshot.",
	"Persistence - Flushing - ChangeDetection - GranularTracking": "Works at the individual property level.",
	"Persistence - Flushing - ChangeDetection - DirtyChecking": "Hibernate's dirty checking is the process of detecting which entity properties have changed since they were loaded from the database, so only those changes are persisted.",
	"Persistence - Flushing - ChangeDetection - DirtyChecking - SnapshotMechanism": "When an entity is loaded, Hibernate takes a snapshot of its state. At flush time (before query execution or transaction commit), Hibernate compares",
	"Persistence - Flushing - ChangeDetection - DirtyChecking - BytecodeEnhancement": "For better performance, Hibernate can use bytecode enhancement to: Add tracking at the field level, Replace collections with smart proxies that track modifications",
	"Persistence - Flushing - Strategies - JTA": "JPA defines only two flushing strategies (AUTO and COMMIT)",
	"Persistence - Flushing - Strategies - JTA - AUTO": "",
	"Persistence - Flushing - Strategies - JTA - COMMIT": "",
	"Persistence - Flushing - Process": "When changes are detected.",
	"Persistence - Flushing - Process - 1. IdentifyDirtyEntities": "Compare all managed entities with snapshots.",
	"Persistence - Flushing - Process - 2. Processcollections:": "Apply collection updates first.",
	"Persistence - Flushing - Process - 3. GenerateSQL": "Hibernate generates appropriate SQL: INSERT for new entities, UPDATE for changed entities, DELETE for removed entities",
	"Persistence - Flushing - Process - 4. ExecuteSQL": "Execute SQL in optimal order: Inserts (to generate IDs needed for FKs), Updates, Deletes",
	"Persistence - Flushing - Process - 5. ReferentialIntegrity": "Maintains referential integrity: Handles foreign key updates, Processes cascading operations",
	"Persistence - Flushing - Process - 6. OrderOptimally": "Orders operations optimally: Inserts before updates (to generate IDs), Deletes last",
	"Persistence - Flushing - Process - 7. BatchOperations": "When enabled via hibernate.jdbc.batch_size",
	"Persistence - Events": "Both interceptors and event listeners allow you to hook into Hibernate's lifecycle events, making them powerful tools for implementing auditing functionality.",
	"Persistence - Events - JPA - Listeners": "The JPA specification provides two related mechanisms for this purpose: callback method and entity listener",
	"Persistence - Events - JPA - Listeners - JPA Callbacks": "JPA also defines a more limited set of callbacks through annotations: @PrePersist, @PreRemove, @PostPersist, @PostRemove, @PreCUpdate, @PostUpdate, @PostLoad",
	"Persistence - Events - JPA - Listeners - JPA Callbacks - @PrePersist - JPA": "Executes before entity insertion.",
	"Persistence - Events - JPA - Listeners - JPA Callbacks - @PostPersist - JPA": "Executes after entity insertion.",
	"Persistence - Events - JPA - Listeners - JPA Callbacks - @PreUpdate - JPA": "Executes before entity update.",
	"Persistence - Events - JPA - Listeners - JPA Callbacks - @PostUpdate - JPA": "Executes after entity update.",
	"Persistence - Events - JPA - Listeners - JPA Callbacks - @PreRemove - JPA": "Executes before entity deletion.",
	"Persistence - Events - JPA - Listeners - JPA Callbacks - @PostRemove - JPA": "Executes after entity deletion.",
	"Persistence - Events - JPA - Listeners - JPA Callbacks - @PostLoad - JPA": "Executes after loading an entity.",
	"Persistence - Events - JPA - Listeners - JPA EntityListeners - @EntityListeners": "The @EntityListeners annotation is used to specify an array of callback listener classes that are used by the currently annotated entity.",
	"Persistence - Events - JPA - Listeners - JPA EntityListeners - @ExcludeDefaultListeners": "The @ExcludeDefaultListeners annotation is used to specify that the currently annotated entity skips the invocation of any default listener.",
	"Persistence - Events - JPA - Listeners - JPA EntityListeners - @ExcludeSuperclassListeners": "The @ExcludeSuperclassListeners annotation is used to specify that the currently annotated entity skips the invocation of listeners declared by its superclass.",

	"Types": "SECTION",
	"Types - All - Immutability": "Immutability can be specified for both entities and collections.",			
	"Types - All - Immutability - @Updatable - JPA": "@Updatable(false)",			
	"Types - All - Immutability - Entity": "If a specific entity is immutable, it is good practice to mark it with the @Immutable annotation. @Immutable means is till ignore Updates and throw Exceptions for Deletes",
	"Types - All - Immutability - Collection": "Just like entities, collections can also be marked with the @Immutable annotation. This means is till throw Exceptions for Updates and Deletes",
	"Types - All - Java - @Target": "Defines the allowed locations where an annotation can be used.",
	"Types - All - Java - @Target - Syntax": "Takes an array of ElementType values (e.g., TYPE, FIELD, METHOD, etc.).",
	"Types - All - Java - @Target - Entities": "@Entity → @Target(TYPE) (can only be applied to classes).",
	"Types - All - Java - @Target - Identifiers": "@Id → @Target({METHOD, FIELD}) (can be on fields or getter methods).",
	"Types - All - Java - @Target - Associations": "The @ManyToOne, @OneToOne, @OneToMany, and @ManyToMany feature a targetEntity attribute to specify the actual class of the entiity association when an interface is used for the mapping.",
	"Types - All - Java - @Target - BasicTypes": "@Column → @Target({METHOD, FIELD}).",
	"Types - All - Java - @Target - Embeddable": "For simple embeddable types, use the Hibernate-specific @Target annotation instead.",
	"Types - All - Java - @Target - @ElementCollection": "The @ElementCollection association has a targetClass attribute for the same purpose.",
	"Types - Entities": "Entities, by nature of their unique identifier, exist independently of other objects whereas values do not. Entities are domain model classes which correlate to rows in a database table, using a unique identifier. Because of the requirement for a unique identifier, entities exist independently and define their own lifecycle. The Contact class itself would be an example of an entity.",
	"Types - Entities - Requirements JPA 2.1": "Section 2.1 The Entity Class of the JPA 2.1 specification defines its requirements for an entity class.",
	"Types - Entities - Requirements JPA 2.1 - @Entity": "(1) The entity class must be annotated with the @Entity annotation (or be denoted as such in XML mapping),",
	"Types - Entities - Requirements JPA 2.1 - constructor": "(2) The entity class must have a public or protected no-argument constructor.",
	"Types - Entities - Requirements JPA 2.1 - class": "(3) The entity class must be a top-level class. An enum or interface may not be designated as an entity.",
	"Types - Entities - Requirements JPA 2.1 - nofinal": "(4) The entity class must not be final. No methods or persistent instance variables of the entity class may be final.",
	"Types - Entities - Requirements JPA 2.1 - Serializable": "(5) If an entity instance is to be used remotely as a detached object, the entity class must implement the Serializable interface.",
	"Types - Entities - Requirements JPA 2.1 - abstract": "(6) Both abstract and concrete classes can be entities.",
	"Types - Entities - Requirements JPA 2.1 - extend": "(7) Entities may extend non-entity classes as well as entity classes, and non-entity classes may extend entity classes.",
	"Types - Entities - Requirements JPA 2.1 - JavaBean": "(8) The persistent state of an entity is represented by instance variables, which may correspond to JavaBean-style properties.",
	"Types - Entities - Requirements JPA 2.1 - within": "(9) An instance variable must be directly accessed only from within the methods of the entity by the entity instance itself.",
	"Types - Entities - Requirements JPA 2.1 - Accessors": "(10) The state of the entity is available to clients only through the entity’s accessor methods (getter/setter methods) or other business methods.",
	"Types - Entities - Class": ".",
	"Types - Entities - Class - Config - JPA - @Entity": "@Entity anno defines just one attribute name which is used to give a specific entity name for use in JPQL queries. By default, the entity name represents the unqualified name of the entity class itself. An entity models a database table. The identifier uniquely identifies each row in that table. By default, the name of the table is assumed to be the same as the name of the entity. To explicitly give the name of the table or to specify other information about the table, we would use the javax.persistence.Table annotation.",
	"Types - Entities - Class - Config - JPA - @Table": "The @Table annotation is used to specify the primary table of the currently annotated entity.",
	"Types - Entities - Class - Config - JPA - @Tables": "The @Tables annotation is used to group multiple @Table annotations.",
	"Types - Entities - Class - Config - JPA - @SecondaryTable": "The @SecondaryTable annotation is used to specify a secondary table for the currently annotated entity. = you want to map a single entity to multiple tables in database such that some fields from entity are stored in one table and other fields into other table. Attribute pkJoinColumns specifies the PK/FK",
	"Types - Entities - Class - Config - JPA - @SecondaryTables": "The @SecondaryTables annotation is used to group multiple @SecondaryTable annotations.",
	"Types - Entities - Class - Config - JPA - @Transient": "Excludes a field from persistence.",
	"Types - Entities - Class - Inheritance": "Although relational database systems don’t provide support for inheritance, Hibernate provides several strategies to leverage this object-oriented trait onto domain model entities: MappedSuperclass, Single table, Joined table, Table per class",
	"Types - Entities - Class - Inheritance - JPA - @Inheritance": "The @Inheritance annotation is used to specify the inheritance strategy of a given entity class hierarchy.",
	"Types - Entities - Class - Inheritance - JPA - @MappedSuperclass": "Inheritance is implemented in domain model only without reflecting it in the database schema. When using MappedSuperclass, the inheritance is visible in the domain model only and each database table contains both the base class and the subclass properties. Because the @MappedSuperclass inheritance model is not mirrored at database level, it’s not possible to use polymorphic queries (fetching subclasses by their base class).",
	"Types - Entities - Class - Inheritance - JPA - @PrimaryKeyJoinColumn": "The @PrimaryKeyJoinColumn annotation is used to specify that the primary key column of the currently annotated entity is also a foreign key to some other entity (e.g. a base class table in a JOINED inheritance strategy, the primary table in a secondary table mapping, or the parent table in a @OneToOne relationship).",
	"Types - Entities - Class - Inheritance - JPA - @PrimaryKeyJoinColumns": "The @PrimaryKeyJoinColumns annotation is used to group multiple @PrimaryKeyJoinColumn annotations.",
	"Types - Entities - Class - Inheritance - PolymorphicQueries": "Querying across inheritance hierarchies",
	"Types - Entities - Class - Inheritance - PolymorphicQueries - @Inheritance - JPA": "Inheritance Mapping Strategies.",
	"Types - Entities - Class - Inheritance - PolymorphicQueries - @Inheritance - SINGLE_TABLE": "The domain model class hierarchy is materialized into a single table which contains entities belonging to different class types. The single table inheritance strategy maps all subclasses to only one database table. Each subclass declares its own persistent properties. Version and id properties are assumed to be inherited from the root class. When omitting an explicit inheritance strategy (e.g. @Inheritance), JPA will choose the SINGLE_TABLE strategy by default.",
	"Types - Entities - Class - Inheritance - PolymorphicQueries - @Inheritance - JOINED": "The base class and all the subclasses have their own database tables and fetching a subclass entity requires a join with the parent table as well. Each subclass can also be mapped to its own table. This is also called table-per-subclass mapping strategy. An inherited state is Appd by joining with the table of the superclass. A discriminator column is not required for this mapping strategy. Each subclass must, however, declare a table column holding the object identifier. The primary key of this table is also a foreign key to the superclass table and described by the @PrimaryKeyJoinColumns. The table name still defaults to the non-qualified class name. Also, if @PrimaryKeyJoinColumn is not set, the primary key / foreign key columns are assumed to have the same names as the primary key columns of the primary table of the superclass.",
	"Types - Entities - Class - Inheritance - PolymorphicQueries - @Inheritance - TABLE_PER_CLASS": "Each subclass has its own table containing both the subclass and the base class properties. A third option is to map only the concrete classes of an inheritance hierarchy to tables. This is called the table-per-concrete-class strategy. Each table defines all persistent states of the class, including the inherited state. In Hibernate, it is not necessary to explicitly map such inheritance hierarchies. You can map each class as a separate entity root. However, if you wish use polymorphic associations (e.g. an association to the superclass of your hierarchy), you need to use the union subclass mapping.",
	"Types - Entities - Access - Strategies - JPA": "As a JPA provider, Hibernate can introspect both the entity attributes (instance fields) or the accessors (instance properties). When @Id placed on a field, Hibernate will assume field-based access. When @Id placed on the identifier getter, Hibernate will use property-based access.",
	"Types - Entities - Access - Strategies - FieldBasedAccess": "When using field-based access, adding other entity-level methods is much more flexible because Hibernate won’t consider those part of the persistence state. To exclude a field from being part of the entity persistent state, the field must be marked with the @Transient annotation.",
	"Types - Entities - Access - Strategies - PropertyBasedAccess": "get/set. When using property-based access, Hibernate uses the accessors for both reading and writing the entity state. Every other method that will be added to the entity (e.g. helper methods for synchronizing both ends of a bidirectional one-to-many association) will have to be marked with the @Transient annotation.",
	"Types - Entities - Access - Strategies - Overriding": "The default access strategy mechanism can be overridden with the JPA @Access annotation. In the following example, the @Version attribute is accessed by its field and not by its getter, like the rest of entity attributes.",
	"Types - Entities - Access - Strategies - EmbeddableTypes": "Because embeddables are managed by their owning entities, the access strategy is therefore inherited from the entity too. This applies to both simple embeddable types as well as for collection of embeddables. The embeddable types can overrule the default implicit access strategy (inherited from the owning entity). In the following example, the embeddable uses property-based access, no matter what access strategy the owning entity is choosing:",
	"Types - Identifiers": "Identifiers model the primary key of an entity. They are used to uniquely identify each specific entity. Hibernate and JPA both make the following assumptions about the corresponding database column(s): unique, not-null, immutable. Every entity must define an identifier. For entity inheritance hierarchies, the identifier must be defined just on the entity that is the root of the hierarchy. ",
	"Types - Identifiers - Types": "An identifier might be simple (single value) or composite (multiple values).",
	"Types - Identifiers - Types - Unique": "",
	"Types - Identifiers - Types - Unique - Column": "@Column(unique = true) Adds a single-column unique constraint to the database schema.",
	"Types - Identifiers - Types - Unique - Columns": "@Table(uniqueConstraints = ...) Defines multi-column unique constraints at the table level.",
	"Types - Identifiers - Types - Unique - Relationships": "Use @JoinColumn(unique = true) to enforce uniqueness in relationships (e.g., one-to-one).",
	"Types - Identifiers - Types - Simple": "Simple identifiers map to a single basic attribute, and are denoted using the javax.persistence.Id annotation. According to JPA only the following types should be used as identifier attribute types: * any Java primitive type * any primitive wrapper type * java.lang.String * java.util.Date (TemporalType#DATE) * java.sql.Date * java.math.BigDecimal * java.math.BigInteger Any types used for identifier attributes beyond this list will not be portable.",
	"Types - Identifiers - Types - Simple - JPA - @Id": "Assigned identifiers (@Id) and Generated identifiers (@GeneratedValue)",
	"Types - Identifiers - Types - Simple - JPA - @GeneratedValue": "Hibernate will generate the value when the save/persist occurs.",
	"Types - Identifiers - Types - Simple - JPA - @GeneratedValue - AUTO - default": "JPA picks the best strategy (default).",
	"Types - Identifiers - Types - Simple - JPA - @GeneratedValue - IDENTITY": "Database auto-increments the ID (e.g., MySQL AUTO_INCREMENT).",
	"Types - Identifiers - Types - Simple - JPA - @GeneratedValue - SEQUENCE": "Uses a database sequence (e.g., PostgreSQL SEQUENCE).",
	"Types - Identifiers - Types - Simple - JPA - @GeneratedValue - TABLE": "Indicates that a database table should be used for obtaining primary key values.",
	"Types - Identifiers - Types - Simple - JPA - @GeneratedValue - UUID": "Generates a UUID (e.g., 550e8400-e29b-41d4-a716-446655440000)",
	"Types - Identifiers - Types - Composite": "Composite identifiers correspond to one or more persistent attributes.",
	"Types - Identifiers - Types - Composite - JPA": "JPA spec says",
	"Types - Identifiers - Types - Composite - JPA - PrimaryKey": "(1) The composite identifier must be represented by <b> a primary key class</b>.",
	"Types - Identifiers - Types - Composite - JPA - Definition": "(2) The primary key class may be defined using the @EmbeddedId or @IdClass.",
	"Types - Identifiers - Types - Composite - JPA - Definition - @EmbeddedId": "Modeling a composite identifier using an EmbeddedId simply means defining an embeddable to be a composition for the one or more attributes making up the identifier, and then exposing an attribute of that embeddable type on the entity.",
	"Types - Identifiers - Types - Composite - JPA - Definition - @IdClass": "Modeling a composite identifier using an IdClass differs from using an EmbeddedId in that the entity defines each individual attribute making up the composition. The IdClass simply acts as a shadow. @Entity@IdClass(EmployeeId.class) public class Employee {@Id private String branchName,@Id private int idEmployee, ... }",
	"Types - Identifiers - Types - Composite - JPA - Definition - @MapsId": "JPA 2.0 added support for derived identifiers which allow an entity to borrow the identifier from a many-to-one or one-to-one association.",
	"Types - Identifiers - Types - Composite - JPA - Constructor": "(3) The primary key class must be public and must have a public no-arg constructor.",
	"Types - Identifiers - Types - Composite - JPA - Serializable": "(4) The primary key class must be serializable.",
	"Types - Identifiers - Types - Composite - JPA - Hascode": "(5) The primary key class must define equals and hashCode methods",
	"Types - Identifiers - Generate - JPA - @TableGenerator": "The @TableGenerator annotation is used to specify the database table used by the identity generator of the currently annotated entity.",
	"Types - Identifiers - Generate - JPA - @SequenceGenerator": "The @SequenceGenerator annotation is used to specify the database sequence used by the identifier generator of the currently annotated entity.",
	"Types - Associations": ".",
	"Types - Associations ": "Associations describe how two or more entities form a relationship based on a database joining semantics.",
	"Types - Associations - JPA - Config - @JoinColumn": "The @JoinColumn annotation is used to specify the FOREIGN KEY column used when joining an entity association or an embeddable collection.",
	"Types - Associations - JPA - KeyPoints - ClassToColumn": "First part of the relationship is the containing class (Table), second part is the column of the other table.",
	"Types - Associations - JPA - KeyPoints - Changes": "Only changes made to the owning side will be persisted to the database. Changes to the inverse side will be ignored unless you synchronize both sides.",
	"Types - Associations - JPA - Unidirectional": "Only one entity has a reference to the other.",
	"Types - Associations - JPA - Unidirectional - KeyPoints - Direction": "creates a foreign key in the Order table",
	"Types - Associations - JPA - Unidirectional - KeyPoints - Direction - Owner": "the only one",
	"Types - Associations - JPA - Unidirectional - KeyPoints - Direction - Uses - OneToMany": "When you only need to navigate from parent to children",
	"Types - Associations - JPA - Unidirectional - KeyPoints - Direction - Uses - ManyToOne": "When you only need to navigate from child to parent",
	"Types - Associations - JPA - Unidirectional - KeyPoints - Direction - Uses - complexity": "When you want to avoid the complexity of bidirectional relationships",
	"Types - Associations - JPA - Unidirectional - KeyPoints - Direction - Uses - know": "When the child entity doesn't need to know about its parent",
	"Types - Associations - JPA - Unidirectional - KeyPoints - Direction - @JoinColumn": "@JoinColumn indicates that this entity is the owner of the relationship.",
	"Types - Associations - JPA - Unidirectional - Cases - @OneToOne": "One entity is associated with exactly one instance of another entity.",
	"Types - Associations - JPA - Unidirectional - Cases - @OneToOne - Config": ".",
	"Types - Associations - JPA - Unidirectional - Cases - @OneToOne - Example": "Customer -> CustomerDetails",
	"Types - Associations - JPA - Unidirectional - Cases - @OneToOne - From": "                    Class Customer        - @OneToOne @JoinColumn(name='customer_detail_id')   CustomerDetail customerDetail",
	"Types - Associations - JPA - Unidirectional - Cases - @OneToOne - To": "                      Class CustomerDetail  -",
	"Types - Associations - JPA - Unidirectional - Cases - @OneToMany": "Only the 'one' side has a reference to the 'many' side",
	"Types - Associations - JPA - Unidirectional - Cases - @OneToMany - Example": "Customer -=> Order",
	"Types - Associations - JPA - Unidirectional - Cases - @OneToMany - Syntax - From": "          Class Customer        - @OneToMany @JoinColumn(name = 'customer_id')       List<Order> orders",
	"Types - Associations - JPA - Unidirectional - Cases - @OneToMany - Syntax - To": "            Class Order           -",
	"Types - Associations - JPA - Unidirectional - Cases - @ManyToOne": "multiple instances are associated with a single instance",
	"Types - Associations - JPA - Unidirectional - Cases - @ManyToOne - Example": "Customer <-= Order",
	"Types - Associations - JPA - Unidirectional - Cases - @ManyToOne - Syntax - To": "            Class Customer        -",
	"Types - Associations - JPA - Unidirectional - Cases - @ManyToOne - Syntax - From": "          Class Order           - @ManyToOne @JoinColumn(name = 'customer_id')       Customer customer",
	"Types - Associations - JPA - Unidirectional - Cases - @ManyToOne - BestPractices - lazy": "Use lazy loading unless you specifically need eager loading",
	"Types - Associations - JPA - Unidirectional - Cases - @ManyToOne - BestPractices - indexing": "Consider indexing the foreign key column for better performance",
	"Types - Associations - JPA - Unidirectional - Cases - @ManyToMany": "Has an owning and a mappedBy side - Only one entity maintains the relationship.",
	"Types - Associations - JPA - Unidirectional - Cases - @ManyToMany - Example": "Order => Items",
	"Types - Associations - JPA - Unidirectional - Cases - @ManyToMany - Syntax - From": "         Class Order           - @ManyToMany @JoinTable(name = 'order_items', joinColumns = @JoinColumn(name = 'order_id'), inverseJoinColumns = @JoinColumn(name = 'item_id'))            Set<Item> items",
	"Types - Associations - JPA - Unidirectional - Cases - @ManyToMany - Syntax - To": "           Class Items           -",
	"Types - Associations - JPA - Bidirectional": "Both entities have references to each other.",
	"Types - Associations - JPA - Bidirectional - KeyPoints - Owner": "The entity that contains the foreign key in the database (the 'many') is typically the owner.",
	"Types - Associations - JPA - Bidirectional - KeyPoints - @JoinColumn": "@JoinColumn indicates that this entity is the owner of the relationship.",
	"Types - Associations - JPA - Bidirectional - KeyPoints - mappedBy": "mappedBy indicates that the entity in this side is the inverse of the relationship",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToOne": "One entity is associated with exactly one instance of another entity.",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToOne - Example": "Customer <--> CustomerDetails",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToOne - Syntax - From": "            Class Customer        - @OneToOne(mappedBy = 'customer'                    CustomerDetail customerDetail",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToOne - Syntax - To": "              Class CustomerDetail  - @OneToOne @JoinColumn(name = 'id')                 Customer customer",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToOne - BestPractices - lazy": "Use lazy loading unless you specifically need eager loading",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToOne - BestPractices - key": "Choose the appropriate strategy (foreign key vs shared primary key) based on your requirements",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToManyManyToOne": "",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToManyManyToOne - Example": "Customer <-=-> Order",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToManyManyToOne - Syntax - From": "  Class Customer        - @OneToMany(mappedBy = 'customer' ... )             List<Order> orders",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToManyManyToOne - Syntax - To": "    Class Order           - @ManyToOne @JoinColumn(name = 'customer_id')       Customer customer", 
	"Types - Associations - JPA - Bidirectional - Cases - @OneToManyManyToOne - BestPractices - helper": "Use helper methods (like addOrder()) to maintain relationship consistency",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToManyManyToOne - BestPractices - Initialize": "Initialize collections to avoid NullPointerException",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToManyManyToOne - BestPractices - Lazy": "Lazy loading is generally preferred for performance",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToManyManyToOne - BestPractices - indexing": "Consider indexing the foreign key column for better performance",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToManyManyToOne - BestPractices - pagination": "For large collections, consider: Pagination (setFirstResult(), setMaxResults())",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToManyManyToOne - BestPractices - BatchFetching": "For large collections, consider: Batch fetching (@BatchSize)",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany": "",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Example": "Order <==> Items",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Syntax - From": "          Class Order            - @ManyToMany @JoinTable(name = 'order_items', joinColumns = @JoinColumn(name = 'order_id'), inverseJoinColumns = @JoinColumn(name = 'item_id'))            Set<Item> items",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Syntax - To": "            Class Item             - @ManyToMany(mappedBy = 'items')                   Set<Order> orders",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - BestPractices - @JoinedTable": "In Many-To-Many association, an extra table is used (known as Joined table) whose primary key is the combination of primary key of both the associated tables.",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - BestPractices - Sets": "Use Sets instead of Lists to avoid duplicate entries",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - BestPractices - equals": "Implement proper equals() and hashCode() methods for both entities",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - BestPractices - Initialize": "Initialize collections to avoid NullPointerException",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - BestPractices - helper": "Use helper methods to maintain relationship consistency",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - BestPractices - lazy": "Consider lazy loading (default for @ManyToMany) for performance",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - BestPractices - pagination": "For large collections, consider: Pagination",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - BestPractices - separated": "For large collections, consider: Using a separate entity for the join table", 
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Limitations - Attributes": "No Additional Attributes on Join Table. The join table can only contain the two foreign keys. You cannot store additional metadata about the relationship (like creation date, status, etc.)",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Limitations - JoinTable": "Limited Control Over Join Table. Hibernate automatically manages the join table. Difficult to add custom constraints or indexes. Hard to implement soft-Deletes on relationships",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Limitations - Performance": "Performance Issues. Can lead to inefficient queries with large datasets. Hibernate may load entire collections when you only need a subset. Pagination is more complex to implement",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Limitations - Cascade": "Cascade Challenges. Cascade operations can be tricky to configure correctly. May accidentally Delete more entities than intended",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Limitations - Complexity": "Bidirectional Management Complexity. Requires careful synchronization of both sides of the relationship. Easy to get into inconsistent state if not managed properly",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Limitations - Querying": "Limited Querying Capabilities. Difficult to query based on relationship attributes (since there aren't any). Complex to filter relationships based on conditions",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Limitations - Evolution": "Schema Evolution Difficulties. Hard to modify the relationship later if requirements change. Converting to a more complex relationship requires migration",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Limitations - Lifecycle": "Limited ability to intercept relationship changes. Hard to add business logic during association/disassociation",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Alternative - 2xManyToOne": "You can replace a @ManyToMany relationship between two entities with a separate join table that has two @ManyToOne relationships. This is actually a recommended approach when you need to: Add additional attributes to the relationship, Have more control over the join table, Avoid the limitations of @ManyToMany",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Alternative - 2xManyToOne - AdditionalAttributes": "You can store metadata about the relationship (like enrollment date, grade, status, etc.)",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Alternative - 2xManyToOne - BetterControl": "More explicit control over the relationship",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Alternative - 2xManyToOne - EasierQueries": "Simpler to write complex queries involving relationship attributes",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Alternative - 2xManyToOne - Performance": "Often better performance for certain operations",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Alternative - 2xManyToOne - Flexibility": "Easier to evolve the model later",
	"Types - EntityCollections": "If value type collections can only form a one-to-many association between an owner entity and multiple basic or embeddable types, entity collections can represent both @OneToMany and @ManyToMany associations.",
	"Types - EntityCollections - Types": "By underlying collection typebags: indexed lists, sets, sorted sets, maps, sorted maps, arrays",
	"Types - EntityCollections - Types - JPA - OrderedList": "Although they use the List interface on the Java side, bags don’t retain element order. To preserve the collection element order, there are two possibilities: @OrderBy (the collection is ordered upon retrieval using a child entity property), @OrderColumn (the collection uses a dedicated order column in the collection link table)",
	"Types - EntityCollections - Types - JPA - OrderedList - Unidirectional ": "When using the @OrderBy annotation",
	"Types - EntityCollections - Types - JPA - OrderedList - Bidirectional": "The mapping is similar with the Bidirectional bags example, just that the parent side is going to be annotated with either @OrderBy or @OrderColumn.",
	"Types - EntityCollections - Types - JPA - Sets": "Sets are collections that don’t allow duplicate entries and Hibernate supports both the unordered Set and the natural-ordering SortedSet.",
	"Types - EntityCollections - Types - JPA - Sets - Unidirectional": "The unidirectional set uses a link table to hold the parent-child associations",
	"Types - EntityCollections - Types - JPA - Sets - Bidirectional": "Just like bidirectional bags, the bidirectional set doesn’t use a link table, and the child table has a foreign key referencing the parent table primary key. The lifecycle is just like with bidirectional bags except for the duplicates which are filtered out.",
	"Types - EntityCollections - Types - JPA - Sets - Sorted": "For sorted sets, the entity mapping must use the SortedSet interface instead. According to the SortedSet contract, all elements must implement the Comparable interface and therefore provide the sorting logic.",
	"Types - EntityCollections - Types - JPA - Sets - Sorted - UnidirectionalSorted": "A SortedSet that relies on the natural sorting order given by the child element Comparable implementation logic must be annotated with the @SortNatural Hibernate annotation. The lifecycle and the database mapping are identical to the Unidirectional bags, so they are intentionally omitted. To provide a custom sorting logic, Hibernate also provides a @SortComparator annotation",
	"Types - EntityCollections - Types - JPA - Sets - Sorted - BidirectionalSorted": "The @SortNatural and @SortComparator work the same for bidirectional sorted sets too",
	"Types - EntityCollections - Types - JPA - Sets - Sorted - BidirectionalSorted - @SortNatural": "",
	"Types - EntityCollections - Types - JPA - Sets - Sorted - BidirectionalSorted - @SortComparator": "",
	"Types - EntityCollections - Types - JPA - Maps": "A java.util.Map is a ternary association because it requires a parent entity, a map key and a value. An entity can either be a map key or a map value, depending on the mapping:",
	"Types - EntityCollections - Types - JPA - Maps - @MapKey": "MapKey(the map key is either the primary key or another property of the entity stored as a map entry value), ",
	"Types - EntityCollections - Types - JPA - Maps - @MapKeyColumn": "MapKeyColumn (for value type maps, the map key is a column in the link table that defines the grouping logic)",
	"Types - EntityCollections - Types - JPA - Maps - @MapKeyEnumerated": "MapKeyEnumerated (the map key is an Enum of the target child entity)",
	"Types - EntityCollections - Types - JPA - Maps - @MapKeyTemporal": "MapKeyTemporal (the map key is a Date or a Calendar of the target child entity)",
	"Types - EntityCollections - Types - JPA - Maps - @MapKeyJoinColumn": "MapKeyJoinColumn (the map key is an entity mapped as an association in the child entity that’s stored as a map entry key)",
	"Types - EntityCollections - Types - JPA - Maps - Unidirectional": "A unidirectional map exposes a parent-child association from the parent-side only.",
	"Types - EntityCollections - Types - JPA - Maps - Bidirectional": "Like most bidirectional associations, this relationship is owned by the child-side while the parent is the inverse side and can propagate its own state transitions to the child entities.",
	"Types - ValueTypes": "A value type is a piece of data that does not define its own lifecycle. It is, in effect, owned by an entity, which defines its lifecycle.",
	"Types - ValueTypes - PersistentAttributes": "All the state of an entity is made up entirely of value types. These state fields or JavaBean properties are termed persistent attributes.",
	"Types - ValueTypes - Config - JPA - @Convert": "Customize how entity attribute values are mapped to database columns. It allows you to define custom conversion logic between your Java object model and database representation. e.g. @Convert(converter = BooleanToYNConverter.class)",
	"Types - ValueTypes - Types": "Value types are further classified into three sub-categories: Basic types, Embeddable types, Collection types" ,
	"Types - ValueTypes - Types - BasicTypes": "Basic value types usually map a single database column, to a single, non-aggregated Java type. Hibernate provides a number of built-in basic types, which follow the natural mappings recommended by the JDBC specifications. Internally Hibernate uses a registry of basic types when it needs to resolve a specific org.hibernate.type.Type. Strictly speaking, a basic type is denoted by the @Basic annotation. @Basic annotation can be ignored, as it is assumed by default.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Basic": "Attributes: (1) optional - boolean (defaults to true) Defines whether this attribute allows nulls. JPA defines this as a hint, which essentially means that it effect is specifically required. As long as the type is not primitive, Hibernate takes this to mean that the underlying column should be NULLABLE. (2) fetch - FetchType (defaults to EAGER) Defines whether this attribute should be fetched eagerly or lazily. JPA says that EAGER is a requirement to the provider (Hibernate) that the value should be fetched when the owner is fetched, while LAZY is merely a hint that the value be fetched when the attribute is accessed. Hibernate ignores this setting for basic types unless you are using bytecode enhancement.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Column": "For basic type attributes, the implicit naming rule is that the column name is the same as the attribute name. If that implicit naming rule does not meet your requirements, you can explicitly tell Hibernate (and other providers) the column name to use.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Column - table": "the name of the database table that hosts the JPA mapped column.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Column - columnDefinition": "the name of an SQL fragment that contains DDL for the column.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Column - updatable": "whether the column can be used with SQL UPDATE statements.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Column - insertable": "whether the column should allow SQL INSERT statements.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Column - unique": "whether the column represents a unique database key.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Column - precision": "decimal precision for the column.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Column - nullable": "whether the column can contain null values.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Column - length": "how many characters the database column must support.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Columns": "The @Columns annotation is used to group multiple JPA @Column annotations.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Enumerated": "Hibernate supports the mapping of Java enums as basic value types in a number of different ways. @Enumerated The original JPA-compliant way to map enums was via the @Enumerated and @MapKeyEnumerated for map keys annotations which works on the principle that the enum values are stored according to one of 2 strategies indicated by javax.persistence.EnumType: ORDINAL (stored according to the enum value’s ordinal position within the enum class, as indicated by java.lang.Enum#ordinal), STRING (stored according to the enum value’s name, as indicated by java.lang.Enum#name)",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Lob": "Mapping LOBs (database Large Objects) come in 2 forms, those using the JDBC locator types and those materializing the LOB data. Materialized deals with the entire LOB contents in memory, whereas LOB locators (in theory) allow streaming parts of the LOB contents into memory as needed.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Lob - locators": "JDBC LOB locators exist to allow efficient access to the LOB data. They allow the JDBC driver to stream parts of the LOB data as needed, potentially freeing up memory space. However they can be unnatural to deal with and have certain limitations. For example, a LOB locator is only portably valid during the duration of the transaction in which it was obtained.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Lob - locators - Types": "The JDBC LOB locator types include: java.sql.Blob, java.sql.Clob, java.sql.NClob.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Lob - materialized": "The idea of materialized LOBs is to trade-off the potential efficiency (not all drivers handle LOB data efficiently) for a more natural programming paradigm using familiar Java types such as String or byte[], etc for these LOBs.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Lob - materialized - Types": "Mapping materialized forms of these LOB values would use more familiar Java types such as String, char[], byte[], etc. The trade off for more familiar is usually performance.",
	"Types - ValueTypes - Types - @EmbeddableTypes": "Historically Hibernate called these components. JPA calls them embeddables. Either way the concept is the same: a composition of values. An embeddable type is another form of value type, and its lifecycle is bound to a parent entity type, therefore inheriting the attribute access from its parent (for details on attribute access, see Access strategies). Embeddable types can be made up of basic values as well as associations, with the caveat that, when used as collection elements, they cannot define collections themselves.",
	"Types - ValueTypes - Types - @EmbeddableTypes - JPA - @Embeddable": "The @Embeddable annotation is used to specify embeddable types. Like basic types, embeddable types do not have any identity, being managed by their owning entity.",
	"Types - ValueTypes - Types - @EmbeddableTypes - JPA - @Embedded": "The @Embedded annotation is used to specify that a given entity attribute represents an embeddable type.",
	"Types - ValueTypes - Types - @EmbeddableTypes - JPA - @EmbeddedId": "The @EmbeddedId annotation is used to specify the entity identifier is an embeddable type.",
	"Types - ValueTypes - Types - @EmbeddableTypes - JPA - Compound": "Most often, embeddable types are used to group multiple basic type mappings and reuse them across several entities.",
	"Types - ValueTypes - Types - @EmbeddableTypes - JPA - Multiple": "Although from an object-oriented perspective, it’s much more convenient to work with embeddable types, this example doesn’t work as-is. When the same embeddable type is included multiple times in the same parent entity type, the JPA specification demands setting the associated column names explicitly. This requirement is due to how object properties are mapped to database columns. By default, JPA expects a database column having the same name with its associated object property. When including multiple embeddables, the implicit name-based mapping rule doesn’t work anymore because multiple object properties could end-up being mapped to the same database column.",
	"Types - ValueTypes - Types - @EmbeddableTypes - JPA - @AttributeOverride": "JPA defines the @AttributeOverride annotation to handle this scenario. This way, the mapping conflict is resolved by setting up explicit name-based property-column type mappings. If an Embeddabe type is used multiple times in some entity, you need to use the @AttributeOverride and @AssociationOverride annotations to override the default column names definied by the Embeddable.",
	"Types - ValueTypes - Types - ValueTypeCollections": "The owner of the collection is always an entity, even if the collection is defined by an embeddable type. Collections form one/many-to-many associations between types so there can be: value type collections, embeddable type collections, entity collections",
	"Types - ValueTypes - Types - ValueTypeCollections - Config -  JPA - @OrderBy": "The @OrderBy annotation is used to specify the entity attributes used for sorting when fetching the currently annotated collection.",
	"Types - ValueTypes - Types - ValueTypeCollections - Config -  JPA - @OrderColumn": "The @OrderColumn annotation is used to specify that the current annotation collection order should be materialized in the database.",
	"Types - ValueTypes - Types - ValueTypeCollections - Types": "Collections of value type include basic and embeddable types. Collections cannot be nested, and, when used in collections, embeddable types are not allowed to define other collections.",
	"Types - ValueTypes - Types - ValueTypeCollections - Types - ValueTypes": ".",
	"Types - ValueTypes - Types - ValueTypeCollections - Types - ValueTypes - Config - JPA - @ElementCollection": "Defines a collection of instances of a basic type or embeddable class (i.e. not entities). Must be specified if the collection is to be mapped by means of a collection table.",
	"Types - ValueTypes - Types - ValueTypeCollections - Types - ValueTypes - BasicTypes": ".",
	"Types - ValueTypes - Types - ValueTypeCollections - Types - ValueTypes - EmbeddableTypes": ".",
	"Types - ValueTypes - Types - ValueTypeCollections - CustomCollections": "If you wish to use other collection types than List, Set or Map, like Queue for instance, you have to use a custom collection type. The custom collection type can still be customized as long as the base type is one of the aformentioned persistent types.",
	"Types - ValueTypes - Types - ValueTypeCollections - CustomCollections - JPA - AttributeConverter": "AttributeConverter (JPA 2.1+) – For simple custom collections (e.g., converting a List to a JSON string in the DB)."

}