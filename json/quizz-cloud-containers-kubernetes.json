{

	"BuildingBlocks": "SECTION",
  "BuildingBlocks - CLUSTER": "A Cluster is a group of nodes managed by a control pane.",
	"BuildingBlocks - CLUSTER - Admin": "",
	"BuildingBlocks - CLUSTER - Admin - External - Clients - CommandLine - kubectl": "The Kubernetes command-line tool, kubectl, allows you to run commands against Kubernetes clusters. kubectl is the primary Kubernetes CLI — you use it for all interactions with a Kubernetes cluster, no matter how the cluster was created.",
  "BuildingBlocks - CLUSTER - Admin - External - Clients - CommandLine - kubectl - create": "kubectl create namespace default-mem-example",
  "BuildingBlocks - CLUSTER - Admin - External - Clients - CommandLine - kubectl - delete": "kubectl delete namespace default-mem-example",
	"BuildingBlocks - CLUSTER - Admin - External - Clients - CommandLine - kubeadm": "You can use the kubeadm tool to create and manage Kubernetes clusters. It performs the actions necessary to get a minimum viable, secure cluster up and running in a user friendly way.",
	"BuildingBlocks - CLUSTER - Admin - External - Clients - Dashboard - Kubernetes Dashboard": ".",
	"BuildingBlocks - CLUSTER - Admin - External - Clients - Dashboard - Lens": ".",
	"BuildingBlocks - CLUSTER - Admin - External - Clients - Dashboard - Octant": ".",
	"BuildingBlocks - CLUSTER - Admin - External - Clients - Dashboard - Skooner": ".",
	"BuildingBlocks - CLUSTER - Admin - External - Clients - Dashboard - Kubevious": "https://kubevious.io/.",
	"BuildingBlocks - CLUSTER - Admin - External - Clients - Dashboard - K9s": "https://k9scli.io/.",
	"BuildingBlocks - CLUSTER - Admin - ControlPane": "The controlPane manages your cluster. The control plane manages the worker nodes and the Pods in the cluster. In production environments, the control plane usually runs across multiple computers and a cluster usually runs multiple nodes, providing fault-tolerance and high availability.",
  "BuildingBlocks - CLUSTER - Admin - ControlPane - Components - kube-apiserver": "The API server is a component of the Kubernetes control plane that exposes the Kubernetes API. The API server is the front end for the Kubernetes control plane. The main implementation of a Kubernetes API server is kube-apiserver. kube-apiserver is designed to scale horizontally—that is, it scales by deploying more instances. You can run several instances of kube-apiserver and balance traffic between those instances.",
  "BuildingBlocks - CLUSTER - Admin - ControlPane - Components - etcd": "Consistent and highly-available key value backing store for all cluster data. Primary datastore of Kubernetes",
  "BuildingBlocks - CLUSTER - Admin - ControlPane - Components - kube-scheduler": "Control plane component that watches for newly created Pods with no assigned node, and selects a node for them to run on.",
  "BuildingBlocks - CLUSTER - Admin - ControlPane - Components - kube-controller-manager": "Control plane component that runs controller processes. Logically, each controller is a separate process, but to reduce complexity, they are all compiled into a single binary and run in a single process.",
  "BuildingBlocks - CLUSTER - Admin - ControlPane - Components - cloud-controller-manager": "The cloud controller manager lets you link your cluster into your cloud provider's API, and separates out the components that interact with that cloud platform from components that only interact with your cluster. The cloud-controller-manager only runs controllers that are specific to your cloud provider. If you are running Kubernetes on your own premises, or in a learning environment inside your own PC, the cluster does not have a cloud controller manager.",
  "BuildingBlocks - CLUSTER - Admin - ControlPane - WorkerMachines": "The control pane machines manage workloads on the compute machines, which are also known as worker machines.",
	"BuildingBlocks - CLUSTER - Runners - Controllers": "A controller tracks at least one Kubernetes resource type. These objects have a spec field that represents the desired state. The controller(s) for that resource are responsible for making the current state come closer to that desired state.",
  "BuildingBlocks - CLUSTER - Runners - Controllers - BuiltIn - Node": "Node Controller: Responsible for managing Worker Nodes. It will monitor the new Nodes connecting to the cluster, validate the Node's health status based on metrics reported by the Node's Kubelet component, and update the Node's .status field. If a Kubelet stops posting health checks to the API Server, the Node Controller will be responsible for triggering Pod eviction from the missing Node before removing the Node from the cluster.",
  "BuildingBlocks - CLUSTER - Runners - Controllers - BuiltIn - ReplicaSet": "ReplicaSet Controller: Responsible for creating/modifying Pods based on the ReplicaSet object configuration.",
  "BuildingBlocks - CLUSTER - Runners - Controllers - BuiltIn - Replication": "A replication controller ensures a pod (or multiple copies) is always up and running. If the pod disappears for any reason (like in the event of a node disappearing from the cluster), the replication controller creates a new pod immediately",
  "BuildingBlocks - CLUSTER - Runners - Controllers - BuiltIn - Deployment": "Deployment Controller: Responsible for managing Deployment objects and creating/modifying ReplicaSet objects.",
  "BuildingBlocks - CLUSTER - Runners - Controllers - BuiltIn - SERVICE": "Service Controller: Responsible for configuring ClusterIP, NodePort, and LoadBalancer configuration based on Service objects.",
  "BuildingBlocks - CLUSTER - Runners - Controllers - BuiltIn - StatefulSet": "StatefulSet Controller: Responsible for creating Pods in a guaranteed order with a sticky identity.",
  "BuildingBlocks - CLUSTER - Runners - Controllers - BuiltIn - DaemonSet": "DaemonSet - A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Common for system processes like CNI, Monitor agents, proxies, etc.",
  "BuildingBlocks - CLUSTER - Runners - Controllers - BuiltIn - Garbage Collection": "Garbage collection is a collective term for the various mechanisms Kubernetes uses to clean up cluster resources.",
  "BuildingBlocks - CLUSTER - Runners - Controllers - BuiltIn - Job": "Job - A Job creates one or more short-lived Pods and expects them to successfully terminate.",
  "BuildingBlocks - CLUSTER - Runners - Controllers - BuiltIn - CronJob": "CronJob Controller: Responsible for creating Job objects based on the Cron schedule defined in CronJob objects.",
	"BuildingBlocks - CLUSTER - Objects - definition": "Kubernetes objects are persistent entities in the Kubernetes system.",
	"BuildingBlocks - CLUSTER - Objects - namespaces": "In Kubernetes, namespaces provide a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc.) and not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc.).",
  "BuildingBlocks - CLUSTER - Objects - yaml": "Kubernetes objects can be expressed in .yaml format.",
  "BuildingBlocks - CLUSTER - Objects - yaml - fields - apiVersion": "Which version of the Kubernetes API you're using to create this object.",
  "BuildingBlocks - CLUSTER - Objects - yaml - fields - kind": "What kind of object you want to create.",
  "BuildingBlocks - CLUSTER - Objects - yaml - fields - metadata": "Data that helps uniquely identify the object, including a name string, UID, and optional namespace",
  "BuildingBlocks - CLUSTER - Objects - yaml - fields - spec": "What state you desire for the object. The precise format of the object spec is different for every Kubernetes object",
  "BuildingBlocks - CLUSTER - Objects - manage": "To work with Kubernetes objects--whether to create, modify, or delete them--you'll need to use the Kubernetes API. When you use the kubectl command-line interface, for example, the CLI makes the necessary Kubernetes API calls for you.",
  "BuildingBlocks - NODE": "",
  "BuildingBlocks - NODE - definition": "A node is a virtual or bare-metal machine in a Kubernetes cluster.",
  "BuildingBlocks - NODE - Types - MasterNode": "The Kubernetes Master is a collection of three processes that run on a single node in your cluster, which is designated as the master node. Those processes are: kube-apiserver, kube-controller-manager and kube-scheduler.",
  "BuildingBlocks - NODE - Types - MasterNode - kube-apiserver": "The Kubernetes API server validates and configures data for the api objects which include pods, services, replicationcontrollers, and others. The API Server services REST operations and provides the frontend to the cluster's shared state through which all other components interact.",
  "BuildingBlocks - NODE - Types - MasterNode - kube-controller-manager": "The Kubernetes controller manager is a daemon that embeds the core control loops shipped with Kubernetes.",
  "BuildingBlocks - NODE - Types - MasterNode - kube-scheduler": "The Kubernetes scheduler is a control plane process which assigns Pods to Nodes.",
  "BuildingBlocks - NODE - Types - WorkerNodes": "The worker node(s) host the Pods that are the components of the application workload. Every cluster has at least one worker node.",
	"BuildingBlocks - NODE - Operation - Scheduling": "Scheduling refers to making sure that Pods are matched to Nodes so that the kubelet can run them.",
  "BuildingBlocks - NODE - Operation - Preemption": "Preemption is the process of terminating Pods with lower Priority so that Pods with higher Priority can schedule on Nodes.",
  "BuildingBlocks - NODE - Operation - Eviction": "Eviction is the process of terminating one or more Pods on Nodes.",
	"BuildingBlocks - NODE - Status": "A node’s status contains the following information: Addresses, Condition, Capacity, Info",
  "BuildingBlocks - NODE - Status - Addresses": "The usage of these fields varies depending on your cloud provider or bare metal configuration.",
  "BuildingBlocks - NODE - Status - Condition": "The conditions field describes the status of all Running nodes.",
  "BuildingBlocks - NODE - Status - Capacity": "Describes the resources available on the node: CPU, memory, and the maximum number of pods that can be scheduled onto the node.",
  "BuildingBlocks - NODE - Status - Info": "Describes general information about the node, such as kernel version, Kubernetes version (kubelet and kube-proxy version), container runtime details, and which operating system the node uses. The kubelet gathers this information from the node and publishes it into the Kubernetes API.",
  "BuildingBlocks - NODE - Status - Heartbeats": "Heartbeats, sent by Kubernetes nodes, help your cluster determine the availability of each node, and to take action when failures are detected.",
	"BuildingBlocks - NODE - Components - kubelet": "The kubelet is the primary node agent that runs on each node. It can register the node with the apiserver using one of: the hostname; a flag to override the hostname; or specific logic for a cloud provider. An agent that runs on each node in the cluster. It makes sure that containers are running in a pod. The kubelet takes a set of PodSpecs that are provided through various mechanisms and ensures that the containers described in those PodSpecs are running and healthy. The kubelet doesn’t manage containers which were not created by Kubernetes.",
  "BuildingBlocks - NODE - Components - kube-proxy": "The Kube-proxy is an implementation of a network proxy and a load balancer, and it supports the service abstraction along with other networking operation. It is responsible for routing traffic to the appropriate container based on IP and port number of the incoming request. This reflects services as defined in the Kubernetes API on each node and can do simple TCP, UDP, and SCTP stream forwarding or round robin TCP, UDP, and SCTP forwarding across a set of backends",
  "BuildingBlocks - NODE - Components - CRI": "The Container Runtime Interface (CRI) is the main protocol for the communication between the kubelet and Container Runtime.",
  "BuildingBlocks - NODE - Components - CRI - CONTAINERRuntime": "You need a working container runtime on each Node in your cluster, so that the kubelet can launch Pods and their containers.",
	"BuildingBlocks - POD": "Pods are the smallest deployable units of computing that can be created and managed in Kubernetes. basic scalable units that Kubernetes works with are called pods. A pod is one or more containers deployed together on one host, and the smallest compute unit that can be defined, deployed, and managed.",
	"BuildingBlocks - POD - Features - sizing": "Scalability and namespaces are probably the main items to consider when determining what goes in a pod.",
  "BuildingBlocks - POD - Lifecyle": "A Pod’s status field is a PodStatus object, which has a phase field. The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle. The phase is not intended to be a comprehensive rollup of observations of Container or Pod state, nor is it intended to be a comprehensive state machine. The number and meanings of Pod phase values are tightly guarded. Other than what is documented here, nothing should be assumed about Pods that have a given phase value. Here are the possible values for phase:.",
  "BuildingBlocks - POD - Lifecyle - create": "To create a pod use kubectl.",
  "BuildingBlocks - POD - Lifecyle - create - 1.CRI": "The Container Runtime Interface (CRI) creates the containers for the Pod.",
  "BuildingBlocks - POD - Lifecyle - create - 2.CNI": "The Container Network Interface (CNI) connects the containers to the cluster network and assigns IP addresses.",
  "BuildingBlocks - POD - Lifecyle - create - 3.CSI": "The Container Storage Interface (CSI) mounts volumes in your containers.",
  "BuildingBlocks - POD - Lifecyle - update": "Since Pods are intended to be disposable and replaceable, you cannot add a container to a Pod once it has been created.",
  "BuildingBlocks - POD - Lifecyle - delete": "When the Pod is deleted by using kubectl, you must follow the same steps but reversely.",
  "BuildingBlocks - POD - Lifecyle - delete - 3.CSI": "Unmounting any volumes from the container to the Container Storage Interface (CSI).",
  "BuildingBlocks - POD - Lifecyle - delete - 3.CNI": "Detaching the container from the network and releasing the IP address to the Container Network Interface (CNI).",
  "BuildingBlocks - POD - Lifecyle - delete - 3.CRI": "Destroying the container to the Container Runtime Interface (CRI).",
  "BuildingBlocks - POD - Lifecyle - PodPhase - Pending": "The Pod has been accepted by the Kubernetes system, but one or more of the Container images has not been created. This includes time before being scheduled as well as time spent downloading images over the network, which could take a while..",
  "BuildingBlocks - POD - Lifecyle - PodPhase - Running": "The Pod has been bound to a node, and all of the Containers have been created. At least one Container is still running, or is in the process of starting or restarting..",
  "BuildingBlocks - POD - Lifecyle - PodPhase - Succeeded": "All Containers in the Pod have terminated in success, and will not be restarted.",
  "BuildingBlocks - POD - Lifecyle - PodPhase - Failed": "All Containers in the Pod have terminated, and at least one Container has terminated in failure. That is, the Container either exited with non-zero status or was terminated by the system.",
  "BuildingBlocks - POD - Lifecyle - PodPhase - Unknown": "For some reason the state of the Pod could not be obtained, typically due to an error in communicating with the host of the Pod.",
  "BuildingBlocks - POD - Lifecyle - PodStatus": "A Pod has a PodStatus, which has an array of PodConditions.",
  "BuildingBlocks - POD - Lifecyle - PodStatus - PodConditions": "PodConditions through which the Pod has or has not passed. Kubelet manages the following PodConditions",
  "BuildingBlocks - POD - Lifecyle - PodStatus - PodConditions - PodScheduled": "the Pod has been scheduled to a node.",
  "BuildingBlocks - POD - Lifecyle - PodStatus - PodConditions - PodReadyToStartContainers": "PodReadyToStartContainers: (beta feature; enabled by default) the Pod sandbox has been successfully created and networking configured.",
  "BuildingBlocks - POD - Lifecyle - PodStatus - PodConditions - CONTAINERsReady": "ContainersReady: all containers in the Pod are ready.",
  "BuildingBlocks - POD - Lifecyle - PodStatus - PodConditions - Initialized": "Initialized: all init containers have completed successfully.",
  "BuildingBlocks - POD - Lifecyle - PodStatus - PodConditions - Ready": "Ready: the Pod is able to serve requests and should be added to the load balancing pools of all matching Services.",
	"BuildingBlocks - POD - QoS": "Kubernetes assigns a QoS class to each Pod as a consequence of the resource constraints that you specify for the containers in that Pod. Kubernetes relies on this classification to make decisions about which Pods to evict when there are not enough available resources on a Node.",
	"BuildingBlocks - POD - QoS - Guaranteed": "Pods that are Guaranteed have the strictest resource limits and are least likely to face eviction. They are guaranteed not to be killed until they exceed their limits or there are no lower-priority Pods that can be preempted from the Node. They may not acquire resources beyond their specified limits. These Pods can also make use of exclusive CPUs using the static CPU management policy.",
	"BuildingBlocks - POD - QoS - Burstable": "Pods that are Burstable have some lower-bound resource guarantees based on the request, but do not require a specific limit. If a limit is not specified, it defaults to a limit equivalent to the capacity of the Node, which allows the Pods to flexibly increase their resources if resources are available. In the event of Pod eviction due to Node resource pressure, these Pods are evicted only after all BestEffort Pods are evicted. Because a Burstable Pod can include a Container that has no resource limits or requests, a Pod that is Burstable can try to use any amount of node resources.",
	"BuildingBlocks - POD - QoS - BestEffort": "Pods in the BestEffort QoS class can use node resources that aren't specifically assigned to Pods in other QoS classes. For example, if you have a node with 16 CPU cores available to the kubelet, and you assign 4 CPU cores to a Guaranteed Pod, then a Pod in the BestEffort QoS class can try to use any amount of the remaining 12 CPU cores. The kubelet prefers to evict BestEffort Pods if the node comes under resource pressure.",
	"BuildingBlocks - POD - Comms": "",
  "BuildingBlocks - POD - Comms - IP": "Every Pod in a cluster gets its own unique cluster-wide IP address. This means you do not need to explicitly create links between Pods and you almost never need to deal with mapping container ports to host ports.",
  "BuildingBlocks - POD - Comms - interpod": "pods can communicate with all other pods on any other node without NAT",
  "BuildingBlocks - POD - Comms - agent2pod": "agents on a node (e.g. system daemons, kubelet) can communicate with all pods on that node",
	"BuildingBlocks - CONTAINER": "A Kubernetes pod is a collection of containers. The word container is defined as a specific running or paused instance of a container image.",
	"BuildingBlocks - CONTAINER - Features - decoupled": "Containers decouple applications from the underlying host infrastructure. This makes deployment easier in different cloud or OS environments.",
  "BuildingBlocks - CONTAINER - Features - repeatable": "Each container that you run is repeatable; the standardization from having dependencies included means that you get the same behavior wherever you run it.",
  "BuildingBlocks - CONTAINER - Features - neighbours": "Containers in a Pod are co-located and co-scheduled to run on the same node.",
	"BuildingBlocks - CONTAINER - Image": "A container image is a ready-to-run software package containing everything needed to run an application: the code and any runtime it requires, application and system libraries, and default values for any essential settings.",
  "BuildingBlocks - CONTAINER - Image - Image Registry": "An image registry is a content server that can store and serve container images.",
	"BuildingBlocks - CONTAINER - Environment": "The Kubernetes Container environment provides several important resources to Containers:.",
  "BuildingBlocks - CONTAINER - Environment - filesystem": "A filesystem, which is a combination of an image and one or more volumes.",
  "BuildingBlocks - CONTAINER - Environment - CONTAINER info": "The hostname of a Container is the name of the Pod in which the Container is running. It is available through the hostname command or the gethostname function call in libc. The Pod name and namespace are available as environment variables through the downward API. User defined environment variables from the Pod definition are also available to the Container, as are any environment variables specified statically in the container image.",
  "BuildingBlocks - CONTAINER - Environment - Cluster info": "A list of all services that were running when a Container was created is available to that Container as environment variables. This list is limited to services within the same namespace as the new Container's Pod and Kubernetes control plane services.",
  "BuildingBlocks - CONTAINER - Lifecycle - States": "Kubernetes tracks the state of each container inside a Pod",
  "BuildingBlocks - CONTAINER - Lifecycle - States - Waiting": "If a container is not in either the Running or Terminated state, it is Waiting. A container in the Waiting state is still running the operations it requires in order to complete start up: for example, pulling the container image from a container image registry, or applying Secret data. When you use kubectl to query a Pod with a container that is Waiting, you also see a Reason field to summarize why the container is in that state.",
  "BuildingBlocks - CONTAINER - Lifecycle - States - Running": "The Running status indicates that a container is executing without issues. If there was a postStart hook configured, it has already executed and finished. When you use kubectl to query a Pod with a container that is Running, you also see information about when the container entered the Running state.",
  "BuildingBlocks - CONTAINER - Lifecycle - States - Terminated": "A container in the Terminated state began execution and then either ran to completion or failed for some reason. When you use kubectl to query a Pod with a container that is Terminated, you see a reason, an exit code, and the start and finish time for that container's period of execution. If a container has a preStop hook configured, this hook runs before the container enters the Terminated state.",
  "BuildingBlocks - CONTAINER - Lifecycle - Hooks": "The hooks enable Containers to be aware of events in their management lifecycle and run code implemented in a handler when the corresponding lifecycle hook is executed.",
  "BuildingBlocks - CONTAINER - Lifecycle - Hooks - Types - PostStart": "This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. No parameters are passed to the handler.",
  "BuildingBlocks - CONTAINER - Lifecycle - Hooks - Types - PreStop": "This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod's termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period. No parameters are passed to the handler.",
  "BuildingBlocks - CONTAINER - Lifecycle - Hooks - Handlers": "Containers can access a hook by implementing and registering a handler for that hook.",
  "BuildingBlocks - CONTAINER - Lifecycle - Hooks - Handlers - exec": "Executes a specific command, such as pre-stop.sh, inside the cgroups and namespaces of the Container. Resources consumed by the command are counted against the Container.",
  "BuildingBlocks - CONTAINER - Lifecycle - Hooks - Handlers - http": "Executes an HTTP request against a specific endpoint on the Container.",
  "BuildingBlocks - CONTAINER - Types": "",
  "BuildingBlocks - CONTAINER - Types - InitContainers": "They are run before the app containers are started.",
  "BuildingBlocks - CONTAINER - Types - InitContainers - goal": "Init containers support all the fields and features of app containers, including resource limits, volumes, and security settings.",
  "BuildingBlocks - CONTAINER - Types - InitContainers - multiple": "If you specify multiple init containers for a Pod, kubelet runs each init container sequentially. Each init container must succeed before the next can run. When all of the init containers have run to completion, kubelet initializes the application containers for the Pod and runs them as usual.",
  "BuildingBlocks - CONTAINER - Types - InitContainers - fail": "If a Pod's init container fails, the kubelet repeatedly restarts that init container until it succeeds. However, if the Pod has a restartPolicy of Never, and an init container fails during startup of that Pod, Kubernetes treats the overall Pod as failed.",
  "BuildingBlocks - CONTAINER - Types - AppContainers": "Run the application in the Pod.",
  "BuildingBlocks - CONTAINER - Types - AppContainers - unique": "Typically, you only have one app container in a Pod.",
  "BuildingBlocks - CONTAINER - Types - SidecarContainers": "Sidecar containers are the secondary containers that run along with the main application container within the same Pod. These containers are used to enhance or to extend the functionality of the primary app container by providing additional services, or functionality such as logging, monitoring, security, or data synchronization, without directly altering the primary application code. For example, if you have a web application that requires a local webserver, the local webserver is a sidecar and the web application itself is the app container.",
  "BuildingBlocks - CONTAINER - Types - SidecarContainers - goal": "These containers are used to enhance or to extend the functionality of the primary app container by providing additional services, or functionality such as logging, monitoring, security, or data synchronization, without directly altering the primary application code.",
  "BuildingBlocks - CONTAINER - Types - EphemeralContainers": "You use ephemeral containers to inspect services rather than to build applications. Ephemeral containers differ from other containers in that they lack guarantees for resources or execution, and they will never be automatically restarted, so they are not appropriate for building applications.",
  "BuildingBlocks - CONTAINER - Communication - CNI": "A common interface between network plugins and container runtimes — a CNI acts like a bridge between them. ",
  "BuildingBlocks - CONTAINER - Communication - CNI - project": "CNI consists of a specification and libs for writing plugins to configure container network interfaces. The CNI focus is on network connectivity and removing resources allocated to containers when ther are deleted, so it has a wide range of support from applications and services. https://github.com/containernetworking/cni",
  "BuildingBlocks - CONTAINER - Communication - CNI - CNCF": "CNI is an initiative of the Cloud-Native Computing Foundation (CNCF), which specifies the configuration of Linux container network interfaces.",
  "BuildingBlocks - CONTAINER - Communication - CNI - mission": "The Container Network Interface (CNI) connects the containers to the cluster network and assigns IP addresses.",
  "BuildingBlocks - CONTAINER - Communication - CNI - CRI": "When the container runtime (like Kubernetes) expects to perform network operations on a container, it calls the CNI plugin with the desired command. The container runtime also provides related network configuration and container-specific data to the plugin, which performs the required operations and reports the result.",
	"BuildingBlocks - CONTAINER - Probes": "A probe is a diagnostic performed periodically by the kubelet on a container. To perform a diagnostic, the kubelet either executes code within the container, or makes a network request.",
  "BuildingBlocks - CONTAINER - Probes - check": "There are four different ways to check a container using a probe.: exec, grpc, httpGet, tcpSocket",
  "BuildingBlocks - CONTAINER - Probes - check - exec": "Executes a specified command inside the container. The diagnostic is considered successful if the command exits with a status code of 0.",
  "BuildingBlocks - CONTAINER - Probes - check - grpc": "Performs a remote procedure call using gRPC. The target should implement gRPC health checks. The diagnostic is considered successful if the status of the response is SERVING.",
  "BuildingBlocks - CONTAINER - Probes - check - httpGet": "Performs an HTTP GET request against the Pod's IP address on a specified port and path. The diagnostic is considered successful if the response has a status code greater than or equal to 200 and less than 400.",
  "BuildingBlocks - CONTAINER - Probes - check - tcpSocket": "Performs a TCP check against the Pod's IP address on a specified port. The diagnostic is considered successful if the port is open. If the remote system (the container) closes the connection immediately after it opens, this counts as healthy.",
  "BuildingBlocks - CONTAINER - Probes - outcome": "Each probe has one of three results:",
  "BuildingBlocks - CONTAINER - Probes - outcome - Success": "The container passed the diagnostic:",
  "BuildingBlocks - CONTAINER - Probes - outcome - Failure": "The container failed the diagnostic.",
  "BuildingBlocks - CONTAINER - Probes - outcome - Unknown": "The diagnostic failed (no action should be taken, and the kubelet will make further checks).",
  "BuildingBlocks - CONTAINER - Probes - Types": "The kubelet can optionally perform and react to three kinds of probes on running containers:",
  "BuildingBlocks - CONTAINER - Probes - Types - livenessProbe": "Indicates whether the container is running. If the liveness probe fails, the kubelet kills the container, and the container is subjected to its restart policy. If a container does not provide a liveness probe, the default state is Success.",
  "BuildingBlocks - CONTAINER - Probes - Types - readinessProbe": "Indicates whether the container is ready to respond to requests. If the readiness probe fails, the endpoints controller removes the Pod's IP address from the endpoints of all Services that match the Pod. The default state of readiness before the initial delay is Failure. If a container does not provide a readiness probe, the default state is Success.",
  "BuildingBlocks - CONTAINER - Probes - Types - startupProbe": "Indicates whether the application within the container is started. All other probes are disabled if a startup probe is provided, until it succeeds. If the startup probe fails, the kubelet kills the container, and the container is subjected to its restart policy. If a container does not provide a startup probe, the default state is Success.",
	"BuildingBlocks - STORAGE - Volume": "At its core, a volume is a directory, possibly with some data in it, which is accessible to the containers in a pod.",
  "BuildingBlocks - STORAGE - Volume - VolumeSnapshot": "In Kubernetes, a VolumeSnapshot represents a snapshot of a volume on a storage system.",
  "BuildingBlocks - STORAGE - Volume - types - persistent": "",
  "BuildingBlocks - STORAGE - Volume - types - persistent - snapshots": "In Kubernetes, a VolumeSnapshot represents a snapshot of a volume on a storage system.",
  "BuildingBlocks - STORAGE - Volume - types - projected": "",
  "BuildingBlocks - STORAGE - Volume - types - ephemeral": "On-disk files in a Container are ephemeral, which presents some problems for non-trivial applications when running in Containers. First, when a Container crashes, kubelet will restart it, but the files will be lost - the Container starts with a clean state. Second, when running Containers together in a Pod it is often necessary to share files between those Containers. The Kubernetes Volume abstraction solves both of these problems.",
  "BuildingBlocks - STORAGE - Volume - Communication - CSI": "Container Storage Interface was developed as a standard for exposing arbitrary block and file storage storage systems to Kubernetes. Container Storage Interface (CSI) is an initiative to unify the storage interface of Container Orchestrator Systems (COs) combined with storage vendors like Ceph, Portworx, NetApp etc.",
  "BuildingBlocks - STORAGE - Volume - Communication - CSI - project": "On introduction of CSI, Kubernetes team released some external components which are not part of the core and that can interact with vendor implemented external components. They communicate to each other over gRPC on domain sockets.",
  "BuildingBlocks - STORAGE - Volume - Communication - CSI - drivers": "Using CSI, third-party storage providers can write and deploy drivers exposing new storage systems in Kubernetes.",

  "Value": "SECTION",
  "Value - WORKLOADS": "A workload is an application running on Kubernetes composed by pods.",
  "Value - WORKLOADS - autoscaling": "In Kubernetes, you can scale a workload depending on the current demand of resources. This allows your cluster to react to changes in resource demand more elastically and efficiently.",
  "Value - WORKLOADS - autoscaling - horizontal": "Running multiple instances of your app.",
  "Value - WORKLOADS - autoscaling - vertical": "Resizing CPU and memory resources assigned to containers.",
  "Value - WORKLOADS - BuiltIn - ReplicaSet": "A ReplicaSet's purpose is to maintain a stable set of replica Pods running at any given time. As such, it is often used to guarantee the availability of a specified number of identical Pods.",
  "Value - WORKLOADS - BuiltIn - StatefulSet": "A StatefulSet = PVC bound to a pod.",
  "Value - WORKLOADS - BuiltIn - Deployment": "A Deployment provides declarative updates for Pods and ReplicaSets.",
  "Value - WORKLOADS - BuiltIn - DaemonSet": "A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created.",
  "Value - WORKLOADS - BuiltIn - Job": "A Job creates one or more Pods and will continue to retry execution of the Pods until a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. Suspending a Job will delete its active Pods until the Job is resumed again..",
  "Value - WORKLOADS - BuiltIn - CronJob": "A CronJob creates Jobs on a repeating schedule. One CronJob object is like one line of a crontab (cron table) file. It runs a job periodically on a given schedule, written in Cron format.",
	"Value - SERVICE": "A service exposes a workload in pods to the rest of the cluster (or via ingress to the outside world). Without a Service, workloads in pods cannot be accessed at all.",
	"Value - SERVICE - topology": "A service provides a means of grouping together a set of pods to create a complete, stable application. A Service resource doesn�t run our containers. It merely provides and maintains a network identity for our Pod resource. A Kubernetes Service is an abstraction which defines a logical set of Pods and a policy by which to access them - sometimes called a micro-service.",
  "Value - SERVICE - network identity": "Service network identity provides both a static IP address and a DNS name. Services listen on a static address that doesn�t change and forwards the request to the unreliable container address. It internally keeps a map that always contains the latest IP address of the Pod. So, whenever a Pod restarts, it updates that map automatically so you get a seamless connection.",
  "Value - SERVICE - load balancer": "Services have an integrated load-balancer that will distribute network traffic to all Pods of an exposed Deployment.",
  "Value - SERVICE - Ingress": "An API object that manages external access to the services in a cluster, typically HTTP.",
  "Value - SERVICE - Ingress - HTTP": "Ingress exposes HTTP and HTTPS routes from outside the cluster to services within the cluster.",
  "Value - SERVICE - Ingress - features": "Ingress may provide load balancing, SSL termination and name-based virtual hosting.",
  "Value - SERVICE - Ingress - routing": "Traffic routing is controlled by rules defined on the Ingress resource.",
  "Value - SERVICE - GatewayAPI": "Make network services available by using an extensible, role-oriented, protocol-aware configuration mechanism. Gateway API is an add-on containing API kinds that provide dynamic infrastructure provisioning and advanced traffic routing.",
  "Value - SERVICE - EndpointSliceAPI": "In Kubernetes, an EndpointSlice contains references to a set of network endpoints. The control plane automatically creates EndpointSlices for any Kubernetes Service that has a selector specified. These EndpointSlices include references to all the Pods that match the Service selector. EndpointSlices group network endpoints together by unique combinations of protocol, port number, and Service name. The name of a EndpointSlice object must be a valid DNS subdomain name.",
  "Value - SERVICE - Label Selector": "The set of Pods targeted by a Service is (usually) determined by a Label Selector",

  "K8s Market": "SECTION",
  "K8s Market - Extensions": "Extensions or plugins. Addons are pods and services that implement cluster features extending the functionality and capabilities of Kubernetes.",
  "K8s Market - Extensions - DNS": "While the other addons are not strictly required, all Kubernetes clusters should have cluster DNS, as many examples rely on it. Cluster DNS is a DNS server, in addition to the other DNS server(s) in your environment, which serves DNS records for Kubernetes services. Containers started by Kubernetes automatically include this DNS server in their DNS searches.",
  "K8s Market - Extensions - Web UI": "Dashboard is a general purpose, web-based UI for Kubernetes clusters. It allows users to manage and troubleshoot applications running in the cluster, as well as the cluster itself.",
  "K8s Market - Extensions - Container Resource Monitoring": "Container Resource Monitoring records generic time-series metrics about containers in a central database, and provides a UI for browsing that data..",
  "K8s Market - Extensions - Cluster-level Logging": "A Cluster-level logging mechanism is responsible for saving container logs to a central log store with search/browsing interface.",
  "K8s Market - Extensions - Operators": "Operators are software extensions to Kubernetes that make use of custom resources to manage applications and their components. Operators follow Kubernetes principles, notably the control loop.",
  "K8s Market - Extensions - Operators - Helm": "The Helm Operator is a Kubernetes operator, allowing one to declaratively manage Helm chart releases. Combined with Flux this can be utilized to automate releases in a GitOps manner, but the usage of Flux is not a strict requirement.",
  "K8s Market - Implementations": "https://collabnix.github.io/kubetools/",
  "K8s Market - Implementations - Minikube": "."

}