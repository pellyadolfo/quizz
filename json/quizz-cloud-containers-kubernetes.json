{
	"Kubernetes": "SECTION",


	"BuildingBlocks": "SECTION",
  "BuildingBlocks - CLUSTER": "A Cluster is a group of nodes managed by a control pane.",
  "BuildingBlocks - CLUSTER - MASTERNODE": "The Kubernetes Master is a collection of three processes that run on a single node in your cluster, which is designated as the master node. Those processes are: kube-apiserver, kube-controller-manager and kube-scheduler.",
  "BuildingBlocks - CLUSTER - MASTERNODE - ControlPlane": "The ControlPlane manages the cluster",
  "BuildingBlocks - CLUSTER - MASTERNODE - ControlPlane - processes": "The Kubernetes Master Node is a collection of three processes that run on a single node in your cluster, which is designated as the master node. Those processes are: kube-apiserver, kube-controller-manager and kube-scheduler.",
  "BuildingBlocks - CLUSTER - MASTERNODE - ControlPlane - processes - kube-apiserver": "Fron End of the ControlPlane, the brain of Kubernetes, frontend to the cluster's shared state through which all other components interact.",
  "BuildingBlocks - CLUSTER - MASTERNODE - ControlPlane - processes - kube-apiserver - REST": "exposes the Kubernetes API. The API Server services REST operations, validates and configures data for the api objects which include pods, services, ReplicationController, and others.",
  "BuildingBlocks - CLUSTER - MASTERNODE - ControlPlane - processes - kube-apiserver - HA": "its unavailability disrupts key functionalities. Run multiple API server replicas in an HA setup. kube-apiserver is designed to scale horizontally—that is, it scales by deploying more instances. You can run several instances of kube-apiserver and balance traffic between those instances.",
  "BuildingBlocks - CLUSTER - MASTERNODE - ControlPlane - processes - kube-controller-manager": "daemon that embeds the core control loops shipped with Kubernetes. Control plane component that runs controller processes. ",
  "BuildingBlocks - CLUSTER - MASTERNODE - ControlPlane - processes - kube-controller-manager - how": "watches the Kubernetes API server. If something deviates (e.g., a pod crashes), the appropriate controller takes action to fix it.",
  "BuildingBlocks - CLUSTER - MASTERNODE - ControlPlane - processes - kube-controller-manager - Controllers": "Logically, each controller is a separate process, but to reduce complexity, they are all compiled into a single binary and run in a single process.",
	"BuildingBlocks - CLUSTER - MASTERNODE - ControlPlane - processes - kube-controller-manager - Controllers - sync": "A controller tracks at least one Kubernetes resource type. These objects have a spec field that represents the desired state. The controller(s) for that resource are responsible for making the current state come closer to that desired state.",
  "BuildingBlocks - CLUSTER - MASTERNODE - ControlPlane - processes - kube-controller-manager - Controllers - Garbage Collection": "Garbage collection is a collective term for the various mechanisms Kubernetes uses to clean up cluster resources.",
  "BuildingBlocks - CLUSTER - MASTERNODE - ControlPlane - processes - kube-controller-manager - Controllers - ServiceController": "Responsible for configuring ClusterIP, NodePort, and LoadBalancer configuration based on Service objects.",
	"BuildingBlocks - CLUSTER - MASTERNODE - ControlPlane - processes - kube-scheduler": "The Kubernetes scheduler is a control plane process which schedules pods.",
  "BuildingBlocks - CLUSTER - MASTERNODE - ControlPlane - processes - kube-scheduler - NodeSelection": "",
	"BuildingBlocks - CLUSTER - MASTERNODE - ControlPlane - processes - cloud-controller-manager": "Connects Kubernetes with cloud providers (AWS, Azure, GCP).",
	"BuildingBlocks - CLUSTER - MASTERNODE - ControlPlane - processes - cloud-controller-manager - specific": "runs controllers that are specific to your cloud provider.",
	"BuildingBlocks - CLUSTER - MASTERNODE - ControlPlane - processes - cloud-controller-manager - optional": "If you are running Kubernetes on your own premises, or in a learning environment inside your own PC, the cluster does not have a cloud controller manager.",
  "BuildingBlocks - CLUSTER - MASTERNODE - ControlPlane - processes - etcd": "Primary datastore of Kubernetes",
  "BuildingBlocks - CLUSTER - MASTERNODE - ControlPlane - processes - etcd - HA": "highly-available",
  "BuildingBlocks - CLUSTER - MASTERNODE - ControlPlane - processes - etcd - keyvalue": " key value backing store for all cluster data",
	"BuildingBlocks - CLUSTER - Configuration": "",
	"BuildingBlocks - CLUSTER - Configuration - Charts": "recipe for deploying your application in a cluster, including deployments, services, and config maps, among others.",
	"BuildingBlocks - CLUSTER - Configuration - Charts - Deployments": "Let's say you have an application that consists of multiple Kubernetes resources, such as deployments, services, and config maps. Without Helm, you would need to manually create and manage each of these resources, which can be time-consuming and error-prone. With Helm, you can package all these resources into a single chart and deploy it with a single command. This means that Helm installs the whole dependency tree of a project if you run the install command for the top-level chart. You just a single command to install your entire application, instead of listing the files to install via kubectl.",
	"BuildingBlocks - CLUSTER - Configuration - Charts - Deployments - BlueGreen": "Blue-Green Deployment in Kubernetes is a deployment strategy that reduces downtime and risk by running two separate environments (Blue and Green) and switching traffic between them.",
	"BuildingBlocks - CLUSTER - Configuration - Charts - Deployments - Blue": "The currently running, stable version.",
	"BuildingBlocks - CLUSTER - Configuration - Charts - Deployments - Green": "The new version that you want to deploy.",
	"BuildingBlocks - CLUSTER - Configuration - Charts - Helm": "the package manager for Kubernetes.",
	"BuildingBlocks - CLUSTER - Configuration - Charts - Helm - components": ".",
	"BuildingBlocks - CLUSTER - Configuration - Charts - Helm - components - CLI": "The helm CLI is a command-line tool that you use to interact with Helm.",
	"BuildingBlocks - CLUSTER - Configuration - Charts - Helm - components - Tiller": "Tiller is a server-side component that is responsible for deploying and managing the resources in a chart on your Kubernetes cluster.",
	"BuildingBlocks - CLUSTER - Configuration - Charts - Structure": "A Helm chart is organized into a directory structure with a few key files.",
	"BuildingBlocks - CLUSTER - Configuration - Charts - Structure - Chart.yaml": "The Chart.yaml file contains the metadata for the chart, such as the chart name, version, and description.",
	"BuildingBlocks - CLUSTER - Configuration - Charts - Structure - values.yaml": "The values.yaml file contains the default configuration values for the chart.",
	"BuildingBlocks - CLUSTER - Configuration - Charts - Structure - /templates/": "The templates/ directory contains the Kubernetes resource definitions for the chart, written in YAML or JSON.",
	"BuildingBlocks - CLUSTER - Configuration - Charts - Structure - templates/deployment.yaml": ".",
	"BuildingBlocks - CLUSTER - Configuration - Charts - Structure - templates/service.yaml": ".",
	"BuildingBlocks - CLUSTER - Configuration - Objects": "Kubernetes objects are persistent entities in the Kubernetes system.",
	"BuildingBlocks - CLUSTER - Configuration - Objects - namespaces": "In Kubernetes, namespaces provide a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc.) and not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc.).",
  "BuildingBlocks - CLUSTER - Configuration - Objects - yaml": "Kubernetes objects can be expressed in .yaml format.",
  "BuildingBlocks - CLUSTER - Configuration - Objects - yaml - fields - apiVersion": "Which version of the Kubernetes API you're using to create this object.",
  "BuildingBlocks - CLUSTER - Configuration - Objects - yaml - fields - kind": "What kind of object you want to create.",
  "BuildingBlocks - CLUSTER - Configuration - Objects - yaml - fields - metadata": "Data that helps uniquely identify the object, including a name string, UID, and optional namespace",
  "BuildingBlocks - CLUSTER - Configuration - Objects - yaml - fields - spec": "What state you desire for the object. The precise format of the object spec is different for every Kubernetes object",
  "BuildingBlocks - CLUSTER - Configuration - Objects - manage": "To work with Kubernetes objects--whether to create, modify, or delete them--you'll need to use the Kubernetes API. When you use the kubectl command-line interface, for example, the CLI makes the necessary Kubernetes API calls for you.",
	"BuildingBlocks - CLUSTER - Configuration - ConfigMaps": "Stores non-sensitive configuration data",
	"BuildingBlocks - CLUSTER - Configuration - ConfigMaps - DataType": "Plain text",
	"BuildingBlocks - CLUSTER - Configuration - Secrets": "Stores sensitive data (passwords, API keys, certificates)",
	"BuildingBlocks - CLUSTER - Configuration - Secrets - DataType": "Base64-encoded text",
	"BuildingBlocks - CLUSTER - Monitoring - Prometheus-Graphana": "Prometheus collects Kubernetes metrics, while Grafana visualizes them in dashboards.",
	"BuildingBlocks - CLUSTER - Monitoring - KubernetesMetricsServer": "Built-in Kubernetes component that provides cluster-wide CPU and memory metrics.",
	"BuildingBlocks - CLUSTER - Monitoring - Loki-Fluentd/Fluent Bit": "Loki (by Grafana) is a lightweight log aggregation system. Fluentd and Fluent Bit collect logs from Pods and send them to Loki or Elasticsearch.",
	"BuildingBlocks - CLUSTER - Monitoring - KubeStateMetrics": "Exports detailed Kubernetes object metrics (Deployments, Pods, Nodes, etc.).",
	"BuildingBlocks - CLUSTER - Monitoring - Falco": "Falco is an open-source intrusion detection system (IDS) for Kubernetes.",
	"BuildingBlocks - CLUSTER - Monitoring - Jaeger-OpenTelemetry": "Jaeger provides distributed tracing to debug slow microservices. OpenTelemetry is a modern alternative for tracing across cloud environments.",
	"BuildingBlocks - CLUSTER - Clients": "Users interact with the API Server (via kubectl, Kubernetes Dashboard, or another tool).",
	"BuildingBlocks - CLUSTER - Clients - CommandLine - kubectl": "The Kubernetes command-line tool, kubectl, allows you to run commands against Kubernetes clusters. kubectl is the primary Kubernetes CLI — you use it for all interactions with a Kubernetes cluster, no matter how the cluster was created.",
  "BuildingBlocks - CLUSTER - Clients - CommandLine - kubectl - create": "kubectl create namespace default-mem-example",
  "BuildingBlocks - CLUSTER - Clients - CommandLine - kubectl - delete": "kubectl delete namespace default-mem-example",
	"BuildingBlocks - CLUSTER - Clients - CommandLine - kubeadm": "You can use the kubeadm tool to create and manage Kubernetes clusters. It performs the actions necessary to get a minimum viable, secure cluster up and running in a user friendly way.",
	"BuildingBlocks - CLUSTER - Clients - Dashboard - Kubernetes Dashboard": ".",
	"BuildingBlocks - CLUSTER - Clients - Dashboard - Lens": ".",
	"BuildingBlocks - CLUSTER - Clients - Dashboard - Octant": ".",
	"BuildingBlocks - CLUSTER - Clients - Dashboard - Skooner": ".",
	"BuildingBlocks - CLUSTER - Clients - Dashboard - Kubevious": "https://kubevious.io/.",
	"BuildingBlocks - CLUSTER - Clients - Dashboard - K9s": "https://k9scli.io/.",
  "BuildingBlocks - WORKERNODES": "The worker node(s) host the Pods that are the components of the application workload. Every cluster has at least one worker node.",
	"BuildingBlocks - WORKERNODES - Node": "A node is a virtual or bare-metal machine in a Kubernetes cluster.",
	"BuildingBlocks - WORKERNODES - Components - kubelet": "The kubelet is the primary node agent that runs on each worker node.",
	"BuildingBlocks - WORKERNODES - Components - kubelet - functions - register": "It can register the node with the apiserver using one of: the hostname; a flag to override the hostname; or specific logic for a cloud provider.",
	"BuildingBlocks - WORKERNODES - Components - kubelet - functions - pods": "Runs the pods as defined in their specifications.",
	"BuildingBlocks - WORKERNODES - Components - kubelet - functions - containers - PosSpec": "The kubelet takes a set of PodSpecs that are provided through various mechanisms and ensures that the containers described in those PodSpecs are running and healthy.",
	"BuildingBlocks - WORKERNODES - Components - kubelet - functions - containers - checks": "Runs health checks (liveness and readiness probes) to makes sure that containers are running in a pod.",
	"BuildingBlocks - WORKERNODES - Components - kubelet - functions - containers - crash": "If a container crashes, the kubelet restarts it automatically.",
	"BuildingBlocks - WORKERNODES - Components - CRI": "The Container Runtime Interface (CRI) is the main protocol for the communication between the kubelet and Container Runtime.",
  "BuildingBlocks - WORKERNODES - Components - CRI - ContainerRuntime": "You need a working container runtime on each Node in your cluster, so that the kubelet can launch Pods and their containers.",
	"BuildingBlocks - WORKERNODES - Components - kube-proxy": "The Kube-proxy is an implementation of a network proxy and a load balancer, and it supports the service abstraction along with other networking operation. It is responsible for routing traffic to the appropriate container based on IP and port number of the incoming request. This reflects services as defined in the Kubernetes API on each node and can do simple TCP, UDP, and SCTP stream forwarding or round robin TCP, UDP, and SCTP forwarding across a set of backends",
  "BuildingBlocks - WORKERNODES - Controllers - NodeController": "Responsible for managing Worker Nodes. It will monitor the new Nodes connecting to the cluster, validate the Node's health status based on metrics reported by the Node's Kubelet component, and update the Node's .status field. If a Kubelet stops posting health checks to the API Server, the Node Controller will be responsible for triggering Pod eviction from the missing Node before removing the Node from the cluster.",
  "BuildingBlocks - WORKERNODES - Controllers - DaemonSet": "DaemonSet - A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Common for system processes like CNI, Monitor agents, proxies, etc.",
	"BuildingBlocks - WORKERNODES - Status": "A node’s status contains the following information: Addresses, Condition, Capacity, Info",
  "BuildingBlocks - WORKERNODES - Status - Addresses": "The usage of these fields varies depending on your cloud provider or bare metal configuration.",
  "BuildingBlocks - WORKERNODES - Status - Condition": "The conditions field describes the status of all Running nodes.",
  "BuildingBlocks - WORKERNODES - Status - Capacity": "Describes the resources available on the node: CPU, memory, and the maximum number of pods that can be scheduled onto the node.",
  "BuildingBlocks - WORKERNODES - Status - Info": "Describes general information about the node, such as kernel version, Kubernetes version (kubelet and kube-proxy version), container runtime details, and which operating system the node uses. The kubelet gathers this information from the node and publishes it into the Kubernetes API.",
  "BuildingBlocks - WORKERNODES - Status - Heartbeats": "Heartbeats, sent by Kubernetes nodes, help your cluster determine the availability of each node, and to take action when failures are detected.",
	"BuildingBlocks - POD": "Pods are the smallest scalable units. A pod is one or more containers deployed together on one host.",
	"BuildingBlocks - POD - Features - PDB": "A Pod Disruption Budget (PDB) is a Kubernetes mechanism that helps protect applications from voluntary disruptions (like node upgrades, draining, or scaling operations). It defines how many Pods of a deployment, statefulset, or replicaset must always be available during such disruptions.",
	"BuildingBlocks - POD - Features - PDB - HA": "PDB ensures high availability by limiting the number of pods that can be disrupted at the same time.",
	"BuildingBlocks - POD - Features - Security - PSP": "PodSecurityPolicies (PSPs) were a Kubernetes feature used to control security settings for Pods before they were admitted into the cluster.",
	"BuildingBlocks - POD - Features - Security - PSP - deprecated": "PodSecurityPolicies were deprecated in Kubernetes v1.21 and removed in v1.25.",
	"BuildingBlocks - POD - Features - Security - PSA": "Pod Security Admission (PSA) (Built-in Replacement). Introduced in Kubernetes v1.23 as a lighter, simpler replacement for PSPs..",
	"BuildingBlocks - POD - Features - Security - OPA": "Open Policy Agent (OPA) & Gatekeeper. A more flexible, policy-driven alternative to PSPs.",
	"BuildingBlocks - POD - Features - Security - Kyverno": "Kyverno (Kubernetes-Native Policy Engine). Easier to use than OPA/Gatekeeper, with YAML-based policies.",
	"BuildingBlocks - POD - Lifecyle": "",
  "BuildingBlocks - POD - Lifecyle - Creation - Create": "",
  "BuildingBlocks - POD - Lifecyle - Creation - Actors - kubelet - ": "To create a pod manually use kubectl.",
  "BuildingBlocks - POD - Lifecyle - Creation - Actors - kube-controller-manager": "",
  "BuildingBlocks - POD - Lifecyle - Creation - Actors - Controllers - ReplicationController": "A replication controller ensures a pod (or multiple copies) is always up and running. If the pod disappears for any reason (like in the event of a node disappearing from the cluster), the replication controller creates a new pod immediately",
  "BuildingBlocks - POD - Lifecyle - Creation - Actors - Controllers - ReplicaSetController": " Improved version of ReplicationController. Responsible for creating/modifying Pods based on the ReplicaSet object configuration.",
  "BuildingBlocks - POD - Lifecyle - Creation - Actors - Controllers - DeploymentController": "Manages ReplicaSets.",
  "BuildingBlocks - POD - Lifecyle - Creation - Actors - Controllers - StatefulSetController": "Responsible for creating Pods in a guaranteed order with a sticky identity.",
  "BuildingBlocks - POD - Lifecyle - Creation - Actors - Controllers - Job": "Job - A Job creates one or more short-lived Pods and expects them to successfully terminate.",
  "BuildingBlocks - POD - Lifecyle - Creation - Actors - Controllers - CronJobController": "CronJob Controller: Responsible for creating Job objects based on the Cron schedule defined in CronJob objects.",
	"BuildingBlocks - POD - Lifecyle - Creation - Process - kubectl - 1.CRI": "The Container Runtime Interface (CRI) creates the containers for the Pod.",
  "BuildingBlocks - POD - Lifecyle - Creation - Process - kubectl - 2.CNI": "The Container Network Interface (CNI) connects the containers to the cluster network and assigns IP addresses.",
  "BuildingBlocks - POD - Lifecyle - Creation - Process - kubectl - 3.CSI": "The Container Storage Interface (CSI) mounts volumes in your containers.",
  "BuildingBlocks - POD - Lifecyle - Creation - Process - Delete": "When the Pod is deleted by using kubectl, you must follow the same steps but reversely.",
	"BuildingBlocks - POD - Lifecyle - Creation - Process - NoUpdate": "Since Pods are intended to be disposable and replaceable, you cannot add a container to a Pod once it has been created.",
  "BuildingBlocks - POD - Lifecyle - Management - Schedule": "kube-scheduler",
  "BuildingBlocks - POD - Lifecyle - Management - Schedule - Preemption": "Preemption is the process of terminating Pods with lower Priority so that Pods with higher Priority can schedule on Nodes.",
  "BuildingBlocks - POD - Lifecyle - Management - Schedule - Preemption - PodPriorityClasses": "Each Pod Priority Class has a numerical priority value (higher values mean higher priority). When scheduling, Kubernetes considers this priority value to decide whether a Pod should preempt others.",
	"BuildingBlocks - POD - Lifecyle - Management - Schedule - Preemption - PodPriorityClasses - Higher": "Higher-priority Pods get scheduled first.",
	"BuildingBlocks - POD - Lifecyle - Management - Schedule - Preemption - PodPriorityClasses - lower": "Lower-priority Pods may get evicted by the scheduler",
	"BuildingBlocks - POD - Lifecyle - Management - Schedule - Eviction": "Eviction is the process of terminating one or more Pods on Nodes.",
	"BuildingBlocks - POD - Lifecyle - Management - Autoscaling": "In Kubernetes, you can scale a workload depending on the current demand of resources. This allows your cluster to react to changes in resource demand more elastically and efficiently.",
	"BuildingBlocks - POD - Lifecyle - Management - Autoscaling - HPA": "HorizontalPodAutoscaler (HPA) - Running multiple instances of your app",
	"BuildingBlocks - POD - Lifecyle - Management - Autoscaling - VPA": "VerticalPodAutoscaler (VPA) - Resizing CPU and memory resources assigned to containers",
	"BuildingBlocks - POD - Lifecyle - Management - Autoscaling - VPA - Modes": "At the moment, the VPA can operate in four different modes: Auto, Recreate, Initial, Off",
	"BuildingBlocks - POD - Lifecyle - Management - Autoscaling - VPA - Modes - Auto": "Currently, Recreate might change to in-place updates in the future",
	"BuildingBlocks - POD - Lifecyle - Management - Autoscaling - VPA - Modes - Recreate": "The VPA assigns resource requests on pod creation as well as updates them on existing pods by evicting them when the requested resources differ significantly from the new recommendation",
	"BuildingBlocks - POD - Lifecyle - Management - Autoscaling - VPA - Modes - Initial": "The VPA only assigns resource requests on pod creation and never changes them later.",
	"BuildingBlocks - POD - Lifecyle - Management - Autoscaling - VPA - Modes - Off": "The VPA does not automatically change the resource requirements of the pods. The recommendations are calculated and can be inspected in the VPA object.",
	"BuildingBlocks - POD - Lifecyle - Monitoring - PodStatus": "A Pod has a PodStatus, which has an array of PodConditions and a phase field.",
  "BuildingBlocks - POD - Lifecyle - Monitoring - PodStatus - PodPhase": "The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle. The phase is not intended to be a comprehensive rollup of observations of Container or Pod state, nor is it intended to be a comprehensive state machine. The number and meanings of Pod phase values are tightly guarded. Other than what is documented here, nothing should be assumed about Pods that have a given phase value. Here are the possible values for phase:",
  "BuildingBlocks - POD - Lifecyle - Monitoring - PodStatus - PodPhase - Pending": "The Pod has been accepted by the Kubernetes system, but one or more of the Container images has not been created. This includes time before being scheduled as well as time spent downloading images over the network, which could take a while..",
  "BuildingBlocks - POD - Lifecyle - Monitoring - PodStatus - PodPhase - Running": "The Pod has been bound to a node, and all of the Containers have been created. At least one Container is still running, or is in the process of starting or restarting..",
  "BuildingBlocks - POD - Lifecyle - Monitoring - PodStatus - PodPhase - Succeeded": "All Containers in the Pod have terminated in success, and will not be restarted.",
  "BuildingBlocks - POD - Lifecyle - Monitoring - PodStatus - PodPhase - Failed": "All Containers in the Pod have terminated, and at least one Container has terminated in failure. That is, the Container either exited with non-zero status or was terminated by the system.",
  "BuildingBlocks - POD - Lifecyle - Monitoring - PodStatus - PodPhase - Unknown": "For some reason the state of the Pod could not be obtained, typically due to an error in communicating with the host of the Pod.",
  "BuildingBlocks - POD - Lifecyle - Monitoring - PodStatus - PodConditions": "PodConditions through which the Pod has or has not passed. Kubelet manages the following PodConditions",
  "BuildingBlocks - POD - Lifecyle - Monitoring - PodStatus - PodConditions - PodScheduled": "the Pod has been scheduled to a node.",
  "BuildingBlocks - POD - Lifecyle - Monitoring - PodStatus - PodConditions - PodReadyToStartContainers": "PodReadyToStartContainers: (beta feature; enabled by default) the Pod sandbox has been successfully created and networking configured.",
  "BuildingBlocks - POD - Lifecyle - Monitoring - PodStatus - PodConditions - CONTAINERsReady": "ContainersReady: all containers in the Pod are ready.",
  "BuildingBlocks - POD - Lifecyle - Monitoring - PodStatus - PodConditions - Initialized": "Initialized: all init containers have completed successfully.",
  "BuildingBlocks - POD - Lifecyle - Monitoring - PodStatus - PodConditions - Ready": "Ready: the Pod is able to serve requests and should be added to the load balancing pools of all matching Services.",
	"BuildingBlocks - POD - Lifecyle - Configuration - QoS": "Kubernetes assigns a QoS class to each Pod as a consequence of the resource constraints that you specify for the containers in that Pod. Kubernetes relies on this classification to make decisions about which Pods to evict when there are not enough available resources on a Node.",
	"BuildingBlocks - POD - Lifecyle - Configuration - QoS - Guaranteed": "Pods that are Guaranteed have the strictest resource limits and are least likely to face eviction. They are guaranteed not to be killed until they exceed their limits or there are no lower-priority Pods that can be preempted from the Node. They may not acquire resources beyond their specified limits. These Pods can also make use of exclusive CPUs using the static CPU management policy.",
	"BuildingBlocks - POD - Lifecyle - Configuration - QoS - Burstable": "Pods that are Burstable have some lower-bound resource guarantees based on the request, but do not require a specific limit. If a limit is not specified, it defaults to a limit equivalent to the capacity of the Node, which allows the Pods to flexibly increase their resources if resources are available. In the event of Pod eviction due to Node resource pressure, these Pods are evicted only after all BestEffort Pods are evicted. Because a Burstable Pod can include a Container that has no resource limits or requests, a Pod that is Burstable can try to use any amount of node resources.",
	"BuildingBlocks - POD - Lifecyle - Configuration - QoS - BestEffort": "Pods in the BestEffort QoS class can use node resources that aren't specifically assigned to Pods in other QoS classes. For example, if you have a node with 16 CPU cores available to the kubelet, and you assign 4 CPU cores to a Guaranteed Pod, then a Pod in the BestEffort QoS class can try to use any amount of the remaining 12 CPU cores. The kubelet prefers to evict BestEffort Pods if the node comes under resource pressure.",
	"BuildingBlocks - POD - Comms": "",
  "BuildingBlocks - POD - Comms - IP": "Every Pod in a cluster gets its own unique cluster-wide IP address. This means you do not need to explicitly create links between Pods and you almost never need to deal with mapping container ports to host ports.",
  "BuildingBlocks - POD - Comms - interpod": "pods can communicate with all other pods on any other node without NAT",
  "BuildingBlocks - POD - Comms - agent2pod": "agents on a node (e.g. system daemons, kubelet) can communicate with all pods on that node",
	"BuildingBlocks - CONTAINER": "A Kubernetes pod is a collection of containers. The word container is defined as a specific running or paused instance of a container image.",
	"BuildingBlocks - CONTAINER - Features - decoupled": "Containers decouple applications from the underlying host infrastructure. This makes deployment easier in different cloud or OS environments.",
  "BuildingBlocks - CONTAINER - Features - repeatable": "Each container that you run is repeatable; the standardization from having dependencies included means that you get the same behavior wherever you run it.",
  "BuildingBlocks - CONTAINER - Features - neighbours": "Containers in a Pod are co-located and co-scheduled to run on the same node.",
	"BuildingBlocks - CONTAINER - Image": "A container image is a ready-to-run software package containing everything needed to run an application: the code and any runtime it requires, application and system libraries, and default values for any essential settings.",
  "BuildingBlocks - CONTAINER - Image - Image Registry": "An image registry is a content server that can store and serve container images.",
	"BuildingBlocks - CONTAINER - Environment": "The Kubernetes Container environment provides several important resources to Containers:.",
  "BuildingBlocks - CONTAINER - Environment - filesystem": "A filesystem, which is a combination of an image and one or more volumes.",
  "BuildingBlocks - CONTAINER - Environment - Container info": "The hostname of a Container is the name of the Pod in which the Container is running. It is available through the hostname command or the gethostname function call in libc. The Pod name and namespace are available as environment variables through the downward API. User defined environment variables from the Pod definition are also available to the Container, as are any environment variables specified statically in the container image.",
  "BuildingBlocks - CONTAINER - Environment - Cluster info": "A list of all services that were running when a Container was created is available to that Container as environment variables. This list is limited to services within the same namespace as the new Container's Pod and Kubernetes control plane services.",
  "BuildingBlocks - CONTAINER - Lifecycle - States": "Kubernetes tracks the state of each container inside a Pod",
  "BuildingBlocks - CONTAINER - Lifecycle - States - Waiting": "If a container is not in either the Running or Terminated state, it is Waiting. A container in the Waiting state is still running the operations it requires in order to complete start up: for example, pulling the container image from a container image registry, or applying Secret data. When you use kubectl to query a Pod with a container that is Waiting, you also see a Reason field to summarize why the container is in that state.",
  "BuildingBlocks - CONTAINER - Lifecycle - States - Running": "The Running status indicates that a container is executing without issues. If there was a postStart hook configured, it has already executed and finished. When you use kubectl to query a Pod with a container that is Running, you also see information about when the container entered the Running state.",
  "BuildingBlocks - CONTAINER - Lifecycle - States - Terminated": "A container in the Terminated state began execution and then either ran to completion or failed for some reason. When you use kubectl to query a Pod with a container that is Terminated, you see a reason, an exit code, and the start and finish time for that container's period of execution. If a container has a preStop hook configured, this hook runs before the container enters the Terminated state.",
  "BuildingBlocks - CONTAINER - Lifecycle - Hooks": "The hooks enable Containers to be aware of events in their management lifecycle and run code implemented in a handler when the corresponding lifecycle hook is executed.",
  "BuildingBlocks - CONTAINER - Lifecycle - Hooks - Types - PostStart": "This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. No parameters are passed to the handler.",
  "BuildingBlocks - CONTAINER - Lifecycle - Hooks - Types - PreStop": "This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod's termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period. No parameters are passed to the handler.",
  "BuildingBlocks - CONTAINER - Lifecycle - Hooks - Handlers": "Containers can access a hook by implementing and registering a handler for that hook.",
  "BuildingBlocks - CONTAINER - Lifecycle - Hooks - Handlers - exec": "Executes a specific command, such as pre-stop.sh, inside the cgroups and namespaces of the Container. Resources consumed by the command are counted against the Container.",
  "BuildingBlocks - CONTAINER - Lifecycle - Hooks - Handlers - http": "Executes an HTTP request against a specific endpoint on the Container.",
  "BuildingBlocks - CONTAINER - Types": "",
  "BuildingBlocks - CONTAINER - Types - InitContainers": "They are run before the app containers are started.",
  "BuildingBlocks - CONTAINER - Types - InitContainers - goal": "Init containers support all the fields and features of app containers, including resource limits, volumes, and security settings.",
  "BuildingBlocks - CONTAINER - Types - InitContainers - multiple": "If you specify multiple init containers for a Pod, kubelet runs each init container sequentially. Each init container must succeed before the next can run. When all of the init containers have run to completion, kubelet initializes the application containers for the Pod and runs them as usual.",
  "BuildingBlocks - CONTAINER - Types - InitContainers - fail": "If a Pod's init container fails, the kubelet repeatedly restarts that init container until it succeeds. However, if the Pod has a restartPolicy of Never, and an init container fails during startup of that Pod, Kubernetes treats the overall Pod as failed.",
  "BuildingBlocks - CONTAINER - Types - AppContainers": "Run the application in the Pod.",
  "BuildingBlocks - CONTAINER - Types - AppContainers - unique": "Typically, you only have one app container in a Pod.",
  "BuildingBlocks - CONTAINER - Types - SidecarContainers": "Sidecar containers are the secondary containers that run along with the main application container within the same Pod. These containers are used to enhance or to extend the functionality of the primary app container by providing additional services, or functionality such as logging, monitoring, security, or data synchronization, without directly altering the primary application code. For example, if you have a web application that requires a local webserver, the local webserver is a sidecar and the web application itself is the app container.",
  "BuildingBlocks - CONTAINER - Types - SidecarContainers - goal": "These containers are used to enhance or to extend the functionality of the primary app container by providing additional services, or functionality such as logging, monitoring, security, or data synchronization, without directly altering the primary application code.",
  "BuildingBlocks - CONTAINER - Types - EphemeralContainers": "You use ephemeral containers to inspect services rather than to build applications. Ephemeral containers differ from other containers in that they lack guarantees for resources or execution, and they will never be automatically restarted, so they are not appropriate for building applications.",
	"BuildingBlocks - CONTAINER - Probes": "A probe is a diagnostic performed periodically by the kubelet on a container. To perform a diagnostic, the kubelet either executes code within the container, or makes a network request.",
  "BuildingBlocks - CONTAINER - Probes - check": "There are four different ways to check a container using a probe.: exec, grpc, httpGet, tcpSocket",
  "BuildingBlocks - CONTAINER - Probes - check - exec": "Executes a specified command inside the container. The diagnostic is considered successful if the command exits with a status code of 0.",
  "BuildingBlocks - CONTAINER - Probes - check - grpc": "Performs a remote procedure call using gRPC. The target should implement gRPC health checks. The diagnostic is considered successful if the status of the response is SERVING.",
  "BuildingBlocks - CONTAINER - Probes - check - httpGet": "Performs an HTTP GET request against the Pod's IP address on a specified port and path. The diagnostic is considered successful if the response has a status code greater than or equal to 200 and less than 400.",
  "BuildingBlocks - CONTAINER - Probes - check - tcpSocket": "Performs a TCP check against the Pod's IP address on a specified port. The diagnostic is considered successful if the port is open. If the remote system (the container) closes the connection immediately after it opens, this counts as healthy.",
  "BuildingBlocks - CONTAINER - Probes - outcome": "Each probe has one of three results:",
  "BuildingBlocks - CONTAINER - Probes - outcome - Success": "The container passed the diagnostic:",
  "BuildingBlocks - CONTAINER - Probes - outcome - Failure": "The container failed the diagnostic.",
  "BuildingBlocks - CONTAINER - Probes - outcome - Unknown": "The diagnostic failed (no action should be taken, and the kubelet will make further checks).",
  "BuildingBlocks - CONTAINER - Probes - Types": "The kubelet can optionally perform and react to three kinds of probes on running containers:",
  "BuildingBlocks - CONTAINER - Probes - Types - Liveness": "Indicates whether the container is running. If the liveness probe fails, the kubelet kills the container, and the container is subjected to its restart policy. If a container does not provide a liveness probe, the default state is Success.",
  "BuildingBlocks - CONTAINER - Probes - Types - Leadiness": "Indicates whether the container is ready to respond to requests. If the readiness probe fails, the endpoints controller removes the Pod's IP address from the endpoints of all Services that match the Pod. The default state of readiness before the initial delay is Failure. If a container does not provide a readiness probe, the default state is Success.",
  "BuildingBlocks - CONTAINER - Probes - Types - Startup": "Indicates whether the application within the container is started. All other probes are disabled if a startup probe is provided, until it succeeds. If the startup probe fails, the kubelet kills the container, and the container is subjected to its restart policy. If a container does not provide a startup probe, the default state is Success.",
	"BuildingBlocks - STORAGE - Volume": "At its core, a volume is a directory, possibly with some data in it, which is accessible to the containers in a pod.",
  "BuildingBlocks - STORAGE - Volume - PV": "A PersistentVolume (PV) is a physical or virtual storage resource provisioned in a Kubernetes cluster. It represents an actual storage unit that an administrator or a storage class provides.",
  "BuildingBlocks - STORAGE - Volume - VolumeSnapshot": "In Kubernetes, a VolumeSnapshot represents a snapshot of a volume on a storage system.",
  "BuildingBlocks - STORAGE - Volume - types - persistent": "",
  "BuildingBlocks - STORAGE - Volume - types - persistent - snapshots": "In Kubernetes, a VolumeSnapshot represents a snapshot of a volume on a storage system.",
  "BuildingBlocks - STORAGE - Volume - types - projected": "",
  "BuildingBlocks - STORAGE - Volume - types - ephemeral": "On-disk files in a Container are ephemeral, which presents some problems for non-trivial applications when running in Containers. First, when a Container crashes, kubelet will restart it, but the files will be lost - the Container starts with a clean state. Second, when running Containers together in a Pod it is often necessary to share files between those Containers. The Kubernetes Volume abstraction solves both of these problems.",
  "BuildingBlocks - STORAGE - Volume - Provision - Dynamic - StorageClass": "Instead of manually creating PVs, Kubernetes can dynamically provision them using a StorageClass.",
  "BuildingBlocks - STORAGE - Volume - Provision - Dynamic - PVC": "A PersistentVolumeClaim (PVC) is a request for storage by a Pod. It asks Kubernetes for a PV with specific characteristics.",
  "BuildingBlocks - STORAGE - Volume - Communication - CSI": "Container Storage Interface was developed as a standard for exposing arbitrary block and file storage storage systems to Kubernetes. Container Storage Interface (CSI) is an initiative to unify the storage interface of Container Orchestrator Systems (COs) combined with storage vendors like Ceph, Portworx, NetApp etc.",
  "BuildingBlocks - STORAGE - Volume - Communication - CSI - project": "On introduction of CSI, Kubernetes team released some external components which are not part of the core and that can interact with vendor implemented external components. They communicate to each other over gRPC on domain sockets.",
  "BuildingBlocks - STORAGE - Volume - Communication - CSI - drivers": "Using CSI, third-party storage providers can write and deploy drivers exposing new storage systems in Kubernetes.",

	"Network": "SECTION",
  "Network - toPods - extracluster - Ingress": "An API object that manages external access to the services in a cluster, acts as a reverse proxy and traffic router for HTTP/HTTPS requests.",
  "Network - toPods - extracluster - Ingress - HTTP": "Ingress exposes HTTP and HTTPS routes from outside the cluster to services within the cluster.",
  "Network - toPods - extracluster - Ingress - features": "Ingress may provide load balancing, SSL termination and name-based virtual hosting.",
  "Network - toPods - extracluster - Ingress - routing": "Traffic routing is controlled by rules defined on the Ingress resource.",
  "Network - toPods - extracluster - Ingress - GatewayAPI": "Evolution of Ingress. Make network services available by using an extensible, role-oriented, protocol-aware configuration mechanism. Gateway API is an add-on containing API kinds that provide dynamic infrastructure provisioning and advanced traffic routing.",
  "Network - toPods - intracluster - Kube-proxy": "managing traffic routing between pods. It runs on every node in a cluster and ensures that network requests reach the right pod, even when pods are spread across multiple nodes.",
  "Network - toPods - intracluster - Kube-proxy - node": "kube-proxy runs on each node.",
  "Network - toPods - intracluster - Kube-proxy - intracluster": "manages routing for Service-to-Pod traffic.",
  "Network - toPods - intracluster - Kube-proxy - ClusterIP": "connect to ClusterIP of services.",
  "Network - toPods - intracluster - NetworkPolicies.": "For security, NetworkPolicies allow you to control which pods can talk to each other.",
	"Network - toPods - Service": "A service exposes a workload to the rest of the cluster (or via ingress to the outside world). Without a Service, workloads in pods cannot be accessed at all.",
	"Network - toPods - Service - Goal": "A Service provides networking and load balancing for a group of Pods.",
	"Network - toPods - Service - Types": "The available type values and their behaviors are: ClusterIP, NodePort, LoadBalancer, ExternalName",
	"Network - toPods - Service - Types - extracluster - ExternalName": "Maps the Service to an external domain name (CNAME record).",
  "Network - toPods - Service - Types - extracluster - ExternalName - DNS": "Service network identity provides both a static IP address and a DNS name. Services listen on a static address that doesn�t change and forwards the request to the unreliable container address. It internally keeps a map that always contains the latest IP address of the Pod. So, whenever a Pod restarts, it updates that map automatically so you get a seamless connection.",
  "Network - toPods - Service - Types - extracluster - ExternalName - DNS - KubeDNS": "Services are automatically registered in KubeDNS (or CoreDNS) so other Pods can find them using a hostname.",
	"Network - toPods - Service - Types - extracluster - LoadBalancer": "Uses a cloud provider’s load balancer to expose the Service externally.",
  "Network - toPods - Service - Types - extracluster - LoadBalancer - goal": "distribute network traffic to all Pods of an exposed Deployment.",
  "Network - toPods - Service - Types - extracluster - LoadBalancer - LabelSelector": "The set of Pods targeted by a Service is (usually) determined by a Label Selector",
	"Network - toPods - Service - Types - extracluster - NodePort": "Exposes the Service outside of the cluster on a static port on each Node’s IP.",
  "Network - toPods - Service - Types - extracluster - NodePort - IP - dynamic": "Pods in Kubernetes have dynamic IP addresses.",
  "Network - toPods - Service - Types - extracluster - NodePort - IP - EndpointAPI": "Originally, Kubernetes used the Endpoints API to store all backend Pod IPs for a Service in a single object (Endpoints). However, this caused scalability issues when handling thousands of Pods",
  "Network - toPods - Service - Types - extracluster - NodePort - IP - EndpointSliceAPI": "Evolution of EndpointAPI which break large Endpoints into smaller, manageable pieces. contains references to a set of network endpoints. The control plane automatically creates EndpointSlices for any Kubernetes Service that has a selector specified. These EndpointSlices include references to all the Pods that match the Service selector. EndpointSlices group network endpoints together by unique combinations of protocol, port number, and Service name. The name of a EndpointSlice object must be a valid DNS subdomain name.",
	"Network - toPods - Service - Types - intracluster - ClusterIP": "Exposes the Service only inside the cluster. No external access.",
	"Network - toPods - Service - ServiceDiscovery": "",
	"Network - toPods - Service - ServiceDiscovery - EnvironmentVariables": "When a Pod is created, Kubernetes automatically injects environment variables for any Services in the same namespace. These environment variables include the Service name, cluster IP, and port number. However, this method is limited because it only works if the Pod is restarted after a new Service is created.",
	"Network - toPods - Service - ServiceDiscovery - DNS-Based": "Kubernetes includes a built-in DNS service (usually CoreDNS) that dynamically resolves Service names to their corresponding IP addresses. This is the standard way for applications to discover and communicate with Services.",
  "Network - toContainer - CNI": "A common interface between network plugins and container runtimes — a CNI acts like a bridge between them. ",
  "Network - toContainer - CNI - project": "CNI consists of a specification and libs for writing plugins to configure container network interfaces. The CNI focus is on network connectivity and removing resources allocated to containers when ther are deleted, so it has a wide range of support from applications and services. https://github.com/containernetworking/cni",
  "Network - toContainer - CNI - CNCF": "CNI is an initiative of the Cloud-Native Computing Foundation (CNCF), which specifies the configuration of Linux container network interfaces.",
  "Network - toContainer - CNI - mission": "The Container Network Interface (CNI) connects the containers to the cluster network and assigns IP addresses.",
  "Network - toContainer - CNI - CRI": "When the container runtime (like Kubernetes) expects to perform network operations on a container, it calls the CNI plugin with the desired command. The container runtime also provides related network configuration and container-specific data to the plugin, which performs the required operations and reports the result.",
  "Network - toContainer - CNI - Plugins": ".",
  "Network - toContainer - CNI - Plugins - Flannel": ".",
  "Network - toContainer - CNI - Plugins - Calico": ".",
  "Network - toContainer - CNI - Plugins - Cilium": ".",
  "Network - toContainer - CNI - Plugins - Weave": ".",

  "Value": "SECTION",
  "Value - WORKLOAD": "A workload is an application running on Kubernetes composed by pods.",
  "Value - WORKLOAD - Type - Stateless": ".",
  "Value - WORKLOAD - Type - Stateless - persistent": "No, Ephemeral storage",
  "Value - WORKLOAD - Type - Stateless - pods": "Random, interchangeable, any order creation",
  "Value - WORKLOAD - Type - Stateless - controllers": "ReplicationController, ReplicaSetController, DeploymentController",
  "Value - WORKLOAD - Type - Stateless - scaling": "Random scaling",
  "Value - WORKLOAD - Type - Stateless - updates": "Replaces Pods randomly",
  "Value - WORKLOAD - Type - Stateless - examples": "Web servers (NGINX, Apache), Microservices, Stateless applications",
	"Value - WORKLOAD - Type - Stateful": ".",
  "Value - WORKLOAD - Type - Stateful - persistent": "Yes, Persistent Volume per Pod",
  "Value - WORKLOAD - Type - Stateful - pods": "Unique, stable (ordinal index), sequential creation",
  "Value - WORKLOAD - Type - Stateful - controllers": "StatefulSetController",
  "Value - WORKLOAD - Type - Stateful - scaling": "Ordered",
  "Value - WORKLOAD - Type - Stateful - updates": "Ordered and controlled",
  "Value - WORKLOAD - Type - Stateful - examples": "Databases (MySQL, PostgreSQL, MongoDB), Distributed systems (Zookeeper, Kafka, Elasticsearch)",

  "K8s Market": "SECTION",
  "K8s Market - Extensions": "Extensions or plugins. Addons are pods and services that implement cluster features extending the functionality and capabilities of Kubernetes.",
  "K8s Market - Extensions - DNS": "While the other addons are not strictly required, all Kubernetes clusters should have cluster DNS, as many examples rely on it. Cluster DNS is a DNS server, in addition to the other DNS server(s) in your environment, which serves DNS records for Kubernetes services. Containers started by Kubernetes automatically include this DNS server in their DNS searches.",
  "K8s Market - Extensions - Web UI": "Dashboard is a general purpose, web-based UI for Kubernetes clusters. It allows users to manage and troubleshoot applications running in the cluster, as well as the cluster itself.",
  "K8s Market - Extensions - Container Resource Monitoring": "Container Resource Monitoring records generic time-series metrics about containers in a central database, and provides a UI for browsing that data..",
  "K8s Market - Extensions - Cluster-level Logging": "A Cluster-level logging mechanism is responsible for saving container logs to a central log store with search/browsing interface.",
  "K8s Market - Extensions - Operators": "Operators are software extensions to Kubernetes that make use of custom resources to manage applications and their components. Operators follow Kubernetes principles, notably the control loop.",
  "K8s Market - Extensions - Operators - Helm": "The Helm Operator is a Kubernetes operator, allowing one to declaratively manage Helm chart releases. Combined with Flux this can be utilized to automate releases in a GitOps manner, but the usage of Flux is not a strict requirement.",
  "K8s Market - Implementations": "https://collabnix.github.io/kubetools/",
  "K8s Market - Implementations - Minikube": "."

}