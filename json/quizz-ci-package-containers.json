{
	"Containers": "SECTION",
	"Containers 0": "https://www.linkedin.com/posts/salwan-mohamed_shipwright-is-revolutionizing-devops-workflows-activity-7337937650441510914-5Xgn/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Containers 0": "",
	"Containers 0": "",
	"Containers 0": "",

	"Process": "SECTION",
	"Process - 1. BuildApp - description": "build application",
	"Process - 2. ChooseContainerRuntime - Virtualization": "",
	"Process - 2. ChooseContainerRuntime - Virtualization - VM": "A virtual machine, also known as a VM, emulates a real computer that can execute programs and applications without having direct contact with any actual hardware. Microsoft Azure defines a VM as a “computer file, typically called an image, that behaves like an actual computer. In other words, a computer is created within a computer.”",
	"Process - 2. ChooseContainerRuntime - Virtualization - VM - How": "VMs provide hardware virtualization. VMs work by operating on top of a hypervisor, which, in turn, is stacked up on top of either a host machine or a 'bare-metal' (the hardware) host. A hypervisor, also known as a machine monitor, can either be a piece of software, firmware, or hardware that enables you to create and run VMs. Each VM runs its own unique guest operating system, thus enabling you to have a group of VMs sitting alongside each other, each one with its own unique operating system. For example, you can have Linux VM sitting next to a UNIX VM. Each VM carries their own virtualized hardware stack that comprises of network adapters, storage, applications, binaries, libraries and its own CPU.",
	"Process - 2. ChooseContainerRuntime - Containerization": "The use of Linux containers to deploy applications is called containerization. Containers are not new, but their use for easily deploying applications is.",
	"Process - 2. ChooseContainerRuntime - Containerization - Features": "Containerization is increasingly popular because containers are: Flexible: Even the most complex applications can be containerized, Lightweight: Containers leverage and share the host kernel., Interchangeable: You can deploy updates and upgrades on-the-fly., Portable: You can build locally, deploy to the cloud, and run anywhere., Scalable: You can increase and automatically distribute container replicas., Stackable: You can stack services vertically and on-the-fly..",
	"Process - 2. ChooseContainerRuntime - Containerization - Container": "Containers provide operating system-level virtualization. Each container comes packaged with its own user space to enable multiple containers to run on a single host. And since the OS is shared across all the containers, the components that need to be developed from scratch are the binaries and libraries — which can easily be added by a Docker image.",
	"Process - 2. ChooseContainerRuntime - Containerization - Container Runtme": "Container runtimes are responsible for creating, running, and managing containers. They provide a layer of abstraction between the host operating system and the container, allowing containers to be isolated from each other and from the host.",
	"Process - 2. ChooseContainerRuntime - Containerization - Tools": "Lots of applications can run containers, whereas every application would have a sightly different opinion about what a container runtime should do and support.",
	"Process - 2. ChooseContainerRuntime - Containerization - Tools - OCI": "Open Container Initiative (OCI) container runtime specification. OCI, short for the Open Container Initiative, is indeed a community project that was established in 2015 to address the need for containerization standards. It is a collaborative effort within the container ecosystem to develop open industry standards for container formats and runtime.",
	"Process - 2. ChooseContainerRuntime - Containerization - Tools - OCI - keypoints - Standardization": "Standardization: OCI defines open standards for container images and runtimes. This includes the OCI Image Format specification for container images and the OCI Runtime Specification for container runtimes.",
	"Process - 2. ChooseContainerRuntime - Containerization - Tools - OCI - keypoints - Interoperability": "Interoperability: By adhering to OCI specifications, container runtimes, and container images from various vendors can work seamlessly together. This promotes compatibility and flexibility in choosing containerization tools.",
	"Process - 2. ChooseContainerRuntime - Containerization - Tools - OCI - keypoints - Ecosystem": "Ecosystem Benefits: OCI standards have been widely adopted in the container ecosystem. This adoption has led to the development of a rich ecosystem of container tools, orchestrators, and platforms that are OCI-compliant.",
	"Process - 2. ChooseContainerRuntime - Containerization - Tools - OCI - OCI-runtime": "The OCI runtime spec defines how to interact with a container runtime to control the lifecycle of a container. While it might seem redundant (given that CRI seems to define the same thing), it adds another layer of contract definition to the architecture. As with CRI, this layer of contract gives some guarantees to the system regarding how the developer’s code will run.",
	"Process - 2. ChooseContainerRuntime - Containerization - Tools - OCI - OCI-runtime - Supporters - Docker": "",
  "Process - 2. ChooseContainerRuntime - Containerization - Tools - OCI - OCI-runtime - Supporters - runC": "The default Docker* runtime. The runc container runtime is a lightweight, portable implementation of OCI. A command-line interface tool for initiating and managing containers based on OCI standards",
	"Process - 2. ChooseContainerRuntime - Containerization - Tools - OCI - OCI-runtime - Supporters - containerd": "containerd is available as a daemon for Linux and Windows. It manages the complete container lifecycle of its host system, from image transfer and storage to container execution and supervision to low-level storage to network attachments and beyond.",
  "Process - 2. ChooseContainerRuntime - Containerization - Tools - OCI - OCI-runtime - Supporters - CRI": "Kubernetes Container Runtime Interface (CRI)",
  "Process - 2. ChooseContainerRuntime - Containerization - Tools - OCI - OCI-runtime - Supporters - CRI - CRI-O": "CRI-O is an implementation of the Kubernetes CRI (Container Runtime Interface) to enable using OCI (Open Container Initiative) compatible runtimes.",
  "Process - 2. ChooseContainerRuntime - Containerization - Tools - OCI - OCI-runtime - Supporters - Kata Containers": "Kata: Allows running containers as virtual machines (VMs), expanding the use of containers to other technologies.",
  "Process - 2. ChooseContainerRuntime - Containerization - Tools - OCI - OCI-runtime - Supporters - Nabla": "",
  "Process - 2. ChooseContainerRuntime - Containerization - Tools - OCI - OCI-runtime - Supporters - gVisor": "gVisor (via runsc): Provides an additional security layer between containers and the host operating system, enhancing security. gVisor provides a strong layer of isolation between running applications and the host operating system. It is an application kernel that implements a Linux-like interface. Unlike Linux, it is written in a memory-safe language (Go) and runs in userspace. gVisor includes an Open Container Initiative (OCI) runtime called runsc that makes it easy to work with existing container tooling. The runsc runtime integrates with Docker and Kubernetes, making it simple to run sandboxed containers.",
  "Process - 2. ChooseContainerRuntime - Containerization - Tools - LXC": "",
  "Process - 2. ChooseContainerRuntime - Containerization - Tools - systemd": "",
  "Process - 2. ChooseContainerRuntime - Containerization - Tools - Firecracker": "Firecracker is an open source virtualization technology that is purpose-built for creating and managing secure, multi-tenant container and function-based services.",
	"Process - 2. ChooseContainerRuntime - Containerization vs Virtualization": "Virtualization is an abstract version of a physical machine, while containerization is the abstract version of an application. While virtual machines virtualize a machine, a container virtualizes an entire operating system so that multiple workloads can run on a single OS instance. With VMs, the hardware is being virtualized to run multiple OS instances — which slows everything down and gradually increases the total cost of ownership. To avoid all of that, containers leverage one OS, increasing deployment speed and portability while lowering costs. A container is a Linux-based application that is used to isolate a service and its dependencies into a self-contained unit that you can run in any environment. The sole purpose of containers is to promote efficient use of the allocated server space and resources, thus enabling the isolated processes to run more efficiently and quickly, while giving developers the ability to scale up or down these individual containers very easily.",
	"Process - 3. BuildImage - definition": "A container is defined by its image as well as any configuration options you provide to it when you create or start it.",
	"Process - 3. BuildImage - Images": "A container is launched by running an image. An image is an executable package that includes everything needed to run an application--the code, a runtime, libraries, environment variables, and configuration files..",
	"Process - 3. BuildImage - OCI - OCI-image": "The container engine provides the runtime with a filesystem bundle (conforming to the OCI-image spec) to run. Within this filesystem bundle are all the files needed in the runtime and a configuration specifying what to run in the container (also known as its entrypoint).",
	"Process - 3. BuildImage - OCI - OCI-image - spec": "There are three main specifications that container images must adhere to in order to be OCI-compliant. These include: https://specs.opencontainers.org/image-spec/",
	"Process - 3. BuildImage - OCI - OCI-image - spec - Image Format Specification": "1. Image Format Specification: Defines how container images should be packaged, distributed, and stored.",
	"Process - 3. BuildImage - OCI - OCI-image - spec - Runtime Specification": "Runtime Specification: Defines how how container images should be run and managed.",
	"Process - 3. BuildImage - OCI - OCI-image - spec - Signature Specification": "Signature Specification: Defines how container images should be signed and verified.",
	"Process - 4. RunImageOnDev - Container": "A container is a runnable instance of an image. A container is a runtime instance of an image--what the image becomes in memory when executed (that is, an image with state, or a user process).",
	"Process - 4. RunImageOnDev - Container - Namespace": "Docker uses a technology called namespaces to provide the isolated workspace called the container. When you run a container, Docker creates a set of namespaces for that container. These namespaces provide a layer of isolation. Each aspect of a container runs in a separate namespace and its access is limited to that namespace.",
	"Process - 4. RunImageOnDev - Container - Namespace - pid": "The pid namespace: Process isolation (PID: Process ID).",
	"Process - 4. RunImageOnDev - Container - Namespace - net": "The net namespace: Managing network interfaces (NET: Networking).",
	"Process - 4. RunImageOnDev - Container - Namespace - ipc": "The ipc namespace: Managing access to IPC resources (IPC: InterProcess Communication).",
	"Process - 4. RunImageOnDev - Container - Namespace - mnt": "The mnt namespace: Managing filesystem mount points (MNT: Mount).",
	"Process - 4. RunImageOnDev - Container - Namespace - uts": "The uts namespace: Isolating kernel and version identifiers. (UTS: Unix Timesharing System).",
	"Process - 5. AddImageToRegistry - public": "Public registries are commonly used by individuals or small teams that want to get up and running with their registry as quickly as possible. However, as their organizations grow, this can bring more complex security issues like patching, privacy, and access control that can arise. ",
	"Process - 5. AddImageToRegistry - private": "Private registries provide a way to incorporate security and privacy into enterprise container image storage, either hosted remotely or on-premises. These private registries often come with advanced security features and technical support. ",
	"Process - 5. AddImageToRegistry - private - Google Container Registry": "",
	"Process - 5. AddImageToRegistry - private - Amazon Container Registry": "Amazon Elastic Container Registry (ECR)",
	"Process - 5. AddImageToRegistry - private - Azure Container Registry": "",
  "Process - 6. ChooseCO - description": "Each node runs a container runtime, which is responsible for downloading images and running containers.",
  "Process - 6. ChooseCO - COs Market - definition": "Container Orchestrator Systems (COs)",
  "Process - 6. ChooseCO - COs Market - Providers - Mesos": "",
  "Process - 6. ChooseCO - COs Market - Providers - Docker swarm": "",
  "Process - 6. ChooseCO - COs Market - Providers - cloud foundry": "",
  "Process - 6. ChooseCO - COs Market - Providers - Kubernetes": "",
  "Process - 6. ChooseCO - K8s Market - Implementations - Kubernetes": "Deprecated Docker https://docs.datadoghq.com/containers/guide/docker-deprecation/?tab=helm.",
  "Process - 6. ChooseCO - K8s Market - Implementations - Providers - Kubernetes Reference Implementation": "Installing Kubernetes yourself on cloud or on-premises infrastructure with a Kubernetes installation tool like kubeadm or kops",
  "Process - 6. ChooseCO - K8s Market - Implementations - Providers - Minikube": "It’s not suitable for production but can be used in a test environment. Maintained by main Kubernetes project..",
  "Process - 6. ChooseCO - K8s Market - Implementations - Providers - K3S/K3D": "Developed by Rancher, for mainly IoT and Edge devices. It uses SQLite as a default storage backend rather than etcd3.",
  "Process - 6. ChooseCO - K8s Market - Implementations - Providers - MicroK8S": "It is lightweight K8S, developed by Canonical(a.k.a. Ubuntu). It is suitable for Edge and IoT devices.",
  "Process - 6. ChooseCO - K8s Market - Implementations - Providers - KinD": "It means Kubernetes-IN-Docker. It runs k8s inside a docker container.",
  "Process - 6. ChooseCO - K8s Market - Implementations - Providers - K0S": "It is certificated(CNCF) Kubernetes distribution works on any infrastructure (Cloud, Edge, IoT…)",
  "Process - 6. ChooseCO - K8s Market - Implementations - Providers - Docker Desktop": ".",
  "Process - 6. ChooseCO - K8s Market - Implementations - Cloud": ".",
  "Process - 6. ChooseCO - K8s Market - Implementations - Cloud - GKE": "Google Kubernetes Engine. GKE 1.19 deprecated Docker and uses containerd by default, on new nodes. https://docs.datadoghq.com/containers/guide/docker-deprecation/?tab=helm",
  "Process - 6. ChooseCO - K8s Market - Implementations - Cloud - EKS": "Amazon Elastic Kubernetes Service. EKS 1.22 deprecated Docker and uses containerd by default.",
  "Process - 6. ChooseCO - K8s Market - Implementations - Cloud - AKS": "Microsoft Azure Kubernetes Service. AKS 1.19 deprecated Docker and uses containerd by default",
  "Process - 6. ChooseCO - K8s Market - Implementations - Cloud - OKE": "Oracle Kubernetes Engine (OKE). OKE 1.20 deprecated Docker and uses CRI-O by default.",
  "Process - 6. ChooseCO - K8s Market - Implementations - Cloud - OCP": "Redhat OpenShift Container Platform.",
	"Process - 7. DeployContainer": "",
	"Process - 8. ManageCO - handle": "You can create, start, stop, move, or delete a container using the Docker API or CLI. You can connect a container to one or more networks, attach storage to it, or even create a new image based on its current state.",
	"Process - 8. ManageCO - isolation": "By default, a container is relatively well isolated from other containers and its host machine. You can control how isolated a container’s network, storage, or other underlying subsystems are from other containers or from the host machine.",
	"Process - 8. ManageCO - removal": "When a container is removed, any changes to its state that are not stored in persistent storage disappear.",
	"Process - 8. ManageCO - Tools - Podman": "Podman (the POD MANager) is a tool for managing OCI containers and images, volumes mounted into those containers, and pods made from groups of containers.",

	"Buildpacks": "SECTION",
	"Buildpacks ": "Cloud Native Buildpacks are a tool that allows you to create a container image from your source code without writing a Dockerfile.",
	"Buildpacks - Goal - Layered": "Cloud Native Buildpacks use a layered approach to construct the image, adding only the dependencies and configurations needed for your application. You can customize the build process with different Buildpacks that suit your needs.",
	"Buildpacks - Goal - Operation": "They do this by detecting the language and framework of your application, installing the required dependencies, and optimizing the image for production.",
	"Buildpacks - Goal - Image": "Cloud Native Buildpacks are tools and specifications that automate the process of turning source code into a runnable image.",
	"Buildpacks - Spec - CloudNativeBuildpacks": "Cloud Native Buildpacks provides a specification for Buildpacks API and doesn’t implement any.",
	"Buildpacks - Impl - Paketo": "Paketo Buildpacks are compatible with any platform that supports the Cloud Native Buildpacks API (such as kpack, Tekton, and pack) and, in fact, is an implementation for Cloud Native Buildpacks specification.",
	"Buildpacks - Impl - Google": "."

}