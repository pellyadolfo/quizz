{
	"Security": "SECTION",
	"Security 0": "https://medium.com/@hassene/api-security-best-practices-acf0e3a0d469",
	"Security 22": "https://www.linkedin.com/posts/satya619_the-one-thing-standing-between-you-and-a-activity-7325110590228598785-Mha0?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Security 1": "https://www.linkedin.com/posts/activity-7322092207073619968-sVcP/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Security 2": "https://www.linkedin.com/posts/sandip-das-developer_%F0%9D%90%92%F0%9D%90%92%F0%9D%90%8B%F0%9D%90%93%F0%9D%90%8B%F0%9D%90%92-%F0%9D%90%9F%F0%9D%90%A5%F0%9D%90%A8%F0%9D%90%B0-%F0%9D%90%9E%F0%9D%90%B1%F0%9D%90%A9%F0%9D%90%A5%F0%9D%90%9A%F0%9D%90%A2%F0%9D%90%A7%F0%9D%90%9E%F0%9D%90%9D-activity-7318477159130353665-ux9x?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Security 3": "https://www.linkedin.com/posts/curiouslearner_what-is-oauth-20-oauth-20-open-authorization-activity-7317805769628827648-TtWI?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Security 4": "https://www.linkedin.com/posts/balasubramani-s-mba-in-information-security-a7541b16_cybersecurity-securearchitecture-securitybydesign-activity-7314729780044603392-cMuo/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Security 5": "https://www.linkedin.com/posts/sahnlam_session-jwt-sso-and-oauth-20-in-one-diagram-activity-7313414204118417410-FYtx?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Security 6": "https://www.linkedin.com/posts/rajneesh-kumar-mishra-97a40966_api-jwt-webdevelopment-activity-7322856160066170881-1D9C?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Security 7": "https://www.linkedin.com/posts/zoranmilosevic_things-every-developer-should-know-json-activity-7312709177108238336-wxuR?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Security 8": "https://www.linkedin.com/posts/activity-7322480946769780736-zgaU/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Security 9": "https://www.linkedin.com/posts/balasubramani-s-mba-in-information-security-a7541b16_microservicessecurity-securityarchitecture-activity-7318133098167033859-hgcd/?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Security 10": "https://www.linkedin.com/posts/bytebytego_systemdesign-coding-interviewtips-activity-7313058044521705473-b2Zj/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Security 11": "https://www.linkedin.com/posts/sina-riyahi_how-ssl-certificate-works-an-ssl-secure-activity-7311667232110010368-MQJ0/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Security 12": "https://www.linkedin.com/posts/sahnlam_oauth-20-flows-visualized-note-the-implicit-activity-7312686657302892545-swbe?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Security 13": "https://www.linkedin.com/posts/satya619_%F0%9D%90%8C%F0%9D%90%A8%F0%9D%90%AC%F0%9D%90%AD-%F0%9D%90%AE%F0%9D%90%AC%F0%9D%90%9E%F0%9D%90%9D-%F0%9D%90%80%F0%9D%90%AE%F0%9D%90%AD%F0%9D%90%A1%F0%9D%90%9E%F0%9D%90%A7%F0%9D%90%AD%F0%9D%90%A2%F0%9D%90%9C%F0%9D%90%9A%F0%9D%90%AD%F0%9D%90%A2%F0%9D%90%A8%F0%9D%90%A7-activity-7276801457687851008-CIwX/?utm_source=share&utm_medium=member_android",
	"Security 14": "https://www.linkedin.com/posts/parikshit-wayal-1695b52a6_improved-php-script-activity-7320982316745482240-UYIC/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Security 15": "https://www.linkedin.com/posts/shantanu-shende-17800a324_developer-backend-pythondeveloper-activity-7318113943007158272-Xs4s/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Security 16": "https://www.linkedin.com/posts/balasubramani-s-mba-in-information-security-a7541b16_oauth2-oidc-securityarchitecture-activity-7320698239295307776-nY9r?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Security 17": "https://www.linkedin.com/posts/activity-7322160102554169344-P8_F/?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Security 18": "https://www.linkedin.com/posts/ninadurann_api-security-best-tips-every-api-exposed-activity-7314889735401803776-f8oN/?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Security 19": "https://www.linkedin.com/posts/nikkisiapno_http-2-vs-http-3-whats-the-difference-activity-7307711303282802688-xgWK/?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Security 20": "https://www.linkedin.com/posts/balasubramani-s-mba-in-information-security-a7541b16_cloudstrategy-aws-azure-activity-7315238220969963520-lNtr?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Security 21": "https://www.linkedin.com/posts/balasubramani-s-mba-in-information-security-a7541b16_azurelogicapps-logicappssecurity-azuresecurity-activity-7320277726672621568-Vowg/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Security 23": "",
	"Security 24": "",
	"Security 25": "",
	"Security 26": "",
	"Security 27": "",
	"Security 28": "",
	"Security 29": "",
	"Security 30": "",

	"Client": "SECTION",
	"Client - WebAuthenticationAPI": "Web Authentication API (WebAuthn) is a W3C and FIDO specification that allows registration and authentication of users using public key cryptography instead of a password.",

	"Transport": "SECTION",
  "Transport - HTTP - CSP": "The Content-Security-Policy header allows you to restrict which resources (such as JavaScript, CSS, Images, etc.) can be loaded, and the URLs that they can be loaded from..",
  "Transport - HTTP - UseHTTPS": "with SSL, TLS or mTLS.",
  "Transport - HTTP - UseHTTPS - HSTS": "The HTTP Strict-Transport-Security response header (often abbreviated as HSTS) informs browsers that the site should only be accessed using HTTPS, and that any future attempts to access it using HTTP should automatically be upgraded to HTTPS.",
  "Transport - WS-Security": "Web Services Security (WS-Security, WSS) is an extension to SOAP to apply security to Web services.",

	"Invokation": "SECTION",
	"Invokation - DDoS - RateLimiting": "Prevent brute-force attacks. Controlling the amount of traffic a server receives within a specified time frame. It's used to prevent overuse of resources, improve server reliability, and ensure fair usage among users. Rate limiting is common in API management to prevent abuse and to manage traffic effectively.",
	"Invokation - DDoS - RateLimiting - Algorithms": "In implementing rate limiting, it's crucial to choose an algorithm that aligns with the system's needs, balancing between fairness, efficiency, and resource utilization.",
	"Invokation - DDoS - RateLimiting - Algorithms - TokenBucket": "Description: Uses tokens to control traffic flow. Tokens are added to a bucket at a regular rate and requests consume tokens. If the bucket runs out of tokens, new requests are denied. Example: A bucket can hold 10 tokens and 1 token is added every 10 seconds. A request needs 1 token to pass. If there's a sudden burst of 15 requests, only 10 can go through, and subsequent requests must wait for new tokens.",
	"Invokation - DDoS - RateLimiting - Algorithms - LeakyBucket": "Description: Requests are added to a queue (bucket) and processed at a fixed rate to smooth out burst traffic. Example: If the bucket size is 10 and the rate is 1 request per second, and a burst of 20 requests comes in, the first 10 are queued and processed at 1 per second, while the rest are either queued (if the bucket can hold them) or discarded.",
	"Invokation - DDoS - RateLimiting - Algorithms - FixedWindowCounter": "Description: Divides time into fixed windows and counts the number of requests in each window. Example: If the limit is 100 requests per hour, and a user makes 100 requests in the first half-hour, they will be blocked for the remaining half-hour, even if the server is underutilized during that time.",
	"Invokation - DDoS - RateLimiting - Algorithms - SlidingWindowCounter": "Description: A hybrid of the fixed window and the sliding log, offering a balance between efficiency and precision. It combines the fixed window's simplicity and the sliding log's accuracy. Example: If the limit is 100 requests per hour, the server counts requests in the current window and a fraction of the requests from the previous window, based on the time elapsed.",
	"Invokation - DDoS - RateLimiting - Algorithms - SlidingWindowLog": "Description: Keeps a time-stamped log of requests. It checks whether adding a new request would exceed the rate limit, considering the time frame. Example: If the limit is 100 requests per hour, each incoming request is checked against the log of requests in the past hour. Older entries are discarded.",
	"Invokation - DDoS - RateLimiting - Headers - RFC 6585": "Return Proper Rate-Limit Headers (RFC 6585). Include these headers in responses to inform clients of their rate limit status.",
	"Invokation - DDoS - RateLimiting - Headers - x-ratelimit-limit": "The maximum number of requests allowed within the time window.",
	"Invokation - DDoS - RateLimiting - Headers - x-ratelimit-remaining": "The number of requests you can still make within the current time window.",
	"Invokation - DDoS - RateLimiting - Headers - x-ratelimit-reset": "The time (in seconds) until the rate limit resets. The behavior of RateLimit-Reset is compatible with the delta-seconds notation of Retry-After.",
	"Invokation - DDoS - RateLimiting - Headers - x-ratelimit-policy": "return the quota policy. The quota policy expression can be found in paragraph 2.1 of the IETF draft. The format is, for example, for 100 requests in 60 seconds:",
	"Invokation - DDoS - RateLimiting - Applications - NetworkTraffic": "To control data flow in networks.",
	"Invokation - DDoS - RateLimiting - Applications - WebServers": "To control traffic and prevent abuse.",
	"Invokation - DDoS - RateLimiting - Applications - ApplicationServers": "To prevent overload and ensure fair usage.",
	"Invokation - DDoS - RateLimiting - Applications - APIs": "To control traffic and prevent abuse.",
	"Invokation - DDoS - RateLimiting - Tools - APIGateway": ".",
	"Invokation - DDoS - RateLimiting - Tools - express-rate-limit": ".",
	"Invokation - DDoS - Throttling": "Throttling doesn’t block requests but slows down the rate at which requests are processed.",
	"Invokation - DDoS - Throttling - Algorithms": "There are four common throttling algorithms: the fixed window algorithm, sliding window algorithm, leaky bucket algorithm, and token bucket algorithm.",
	"Invokation - DDoS - Throttling - Algorithms - FixedWindow": "The number of accesses within a specified period is added up. When it reaches the specified threshold, the throttling is triggered, and the number of accesses is cleared in the next period.",
	"Invokation - DDoS - Throttling - Algorithms - SlidingWindow": "The sliding window is an improved version of the fixed window, addressing the issue where the fixed window receives twice the threshold number of requests when the window is switched. In the sliding window algorithm, the start and end times of the window are dynamic, while the window size remains fixed. This algorithm effectively handles the window boundary problem, but its implementation is relatively complex due to the need to record the timestamp of each request.",
	"Invokation - DDoS - Throttling - Algorithms - LeakyBucketAlgorithm": "The leaky bucket throttling algorithm is a common traffic shaping and traffic policy algorithm, which helps to regulate the rate of data transmission and avoid network congestion.",
	"Invokation - DDoS - Throttling - Algorithms - TokenBucketAlgorithm": "The token bucket algorithm is an improved version of the leaky bucket algorithm. It limits the average rate of service calls while allowing certain burst calls.",
	"Invokation - CircuitBreaker": "",

	"Access": "SECTION",
  "Access - Session - SessionId": "",
	"Access - Session - Tokens - JWT": "JWT (RFC 7519) for securely transmitting information between parties as a JSON object.",
  "Access - Session - Tokens - JWT - Structure - Payload - Claim": "A compact and self-contained way to represent a set of claims securely between two parties.",
  "Access - Session - Tokens - JWT - Structure - Payload - Claim - Structure": "From the text, we can understand that JWT is not a structure but a set of claims in the shape of either JWS or JWE as its way of securing itself. In the most basic form, the difference between JWS and JWE is that everyone can see the payload of JWS while the JWE one is encrypted.",
  "Access - Session - Tokens - JWT - Usage": "JSON Web Token (JWT) is an abstract that is represented in the form of JSON Web Signature (JWS) and JSON Web Encryption (JWE).",
  "Access - Session - Tokens - JWT - Usage - Benefits - Statelessness": "server doesn't need to store session information. Reduces the need for server-side sessions.",
  "Access - Session - Tokens - JWT - Usage - Benefits - Security": "Ensures secure communication between two parties. can be signed using various algorithms",
  "Access - Session - Tokens - JWT - Usage - Benefits - Decentralization": "ideal for single sign-on (SSO).",
  "Access - Session - Tokens - JWT - Usage - BestPractices - Shortlived": "Keep tokens short-lived (set an expiration).",
  "Access - Session - Tokens - JWA": "JWA (RFC 7518), which stands for JSON Web Algorithm, is a specification defining which hashing and encryption algorithm to make a JWT.",
  "Access - Session - Tokens - JWA - Usage": "JSON Web Signature (JWS) and JSON Web Encryption (JWE) use signature and encryption algorithms defined in JSON Web Algorithm (JWA) as a way of securing themselves.",
  "Access - Session - Tokens - JWA - Usage - BestPractices - Asymmetry": "Prioritize Asymmetry: Use RS256 (RSA) or ES256 (Elliptic Curve) for stronger security.",
  "Access - Session - Tokens - JWT - Usage - BestPractices - Strong": "Use strong secret keys and algorithms. ",
  "Access - Session - Tokens - JWA - Usage - BestPractices - HS256": "Avoid HS256: HMAC-based signing (HS256) requires careful key management.",
  "Access - Session - Tokens - JWA - Usage - BestPractices - none": "Never Use 'none': This disables signing, rendering JWTs completely insecure.",
	"Access - Session - Tokens - JWK": "JWK (RFC 7517) stands for JSON Web Key. JWK is a JSON data structure that contains information about hashing function's cryptographic key. It's a way to store your hashing key in JSON format.",
  "Access - Session - Tokens - JWK - Usage": "The public key of the signature algorithm defined in the JSON Web Algorithm (JWA) can be hosted as JSON Web Key (JWK).",
  "Access - Session - Tokens - JWK - Usage - BestPractices - keys": "◾ Generate robust, cryptographically secure keys (256-bit or higher)",
  "Access - Session - Tokens - JWK - Usage - BestPractices - rotate": "◾ Regularly rotate keys.",
  "Access - Session - Tokens - JWKS": "JWKS is a set of public keys that can be used to verify the JWTs issued by a specific authorization server.",
  "Access - Session - Tokens - JWKS - Usage": "verify any JSON Web Token (JWT) issued by the Authorization Server and signed using the RS256 signing algorithm. ",
	"Access - Session - Tokens - JWS": "A signed JWT. JWS (RFC 7515), which stands for JSON Web Signature, is one of the structures used by JWT. It's the most common implementation of the JWT.",
  "Access - Session - Tokens - JWS - Security": "The signature only provides integrity, not confidentiality. The JWT is secure because only the one with the secret key can create it.",
  "Access - Session - Tokens - JWS - Algorithms": "Signing algos (HS256, etc)",
  "Access - Session - Tokens - JWS - Structure": "3 components: Three Base64-URL string generated by dots: Header.Payload.Signature",
  "Access - Session - Tokens - JWS - Structure - Header": "Contains metadata about the token.",
  "Access - Session - Tokens - JWS - Structure - Header - alg": "The signing algorithm (e.g., HS256, RS256, ES256).",
  "Access - Session - Tokens - JWS - Structure - Header - typ": "The type of token (usually 'JWT')",
  "Access - Session - Tokens - JWS - Structure - Payload": "◾ Contains the claims (statements) about an entity (typically, the user) and additional data.",
  "Access - Session - Tokens - JWS - Structure - Payload - Readable": "Well, the payload of the JWS is intended for everyone to read. What makes the JWT safe is the consumer can verify who is the one issued the JWT.",
  "Access - Session - Tokens - JWS - Structure - Payload - Claims": "",
  "Access - Session - Tokens - JWS - Structure - Payload - Claims - Registered": "Registered claims (standardized). Standard fields (optional but recommended)",
  "Access - Session - Tokens - JWS - Structure - Payload - Claims - Registered - iss": "iss (issuer)",
  "Access - Session - Tokens - JWS - Structure - Payload - Claims - Registered - sub": "sub (subject)",
  "Access - Session - Tokens - JWS - Structure - Payload - Claims - Registered - aud": "aud (audience)",
  "Access - Session - Tokens - JWS - Structure - Payload - Claims - Registered - exp": "exp (expiration time)",
  "Access - Session - Tokens - JWS - Structure - Payload - Claims - Registered - nbf": "nbf (not before time)",
  "Access - Session - Tokens - JWS - Structure - Payload - Claims - Registered - iat": "iat (issued at time)",
  "Access - Session - Tokens - JWS - Structure - Payload - Claims - Registered - jti": "jti (unique identifier)",
  "Access - Session - Tokens - JWS - Structure - Payload - Claims - Public": "Public claims (customizable by your application). Custom fields (should be defined in IANA registry or use URIs)",
  "Access - Session - Tokens - JWS - Structure - Payload - Claims - Private": "Private claims (application-specific agreements). Custom fields agreed between parties",
  "Access - Session - Tokens - JWS - Structure - Signature": "Used to verify the token's authenticity and integrity. Used to verify the message wasn't changed along the way",
  "Access - Session - Tokens - JWS - Structure - Signature - Structure": "signature = algorithm(base64UrlEncode(header) + '.' + base64UrlEncode(payload), secret_key)",
	"Access - Session - Tokens - JWS - Process - Generation": "Token Creation: The server generates a JWT when the user logs in.",
  "Access - Session - Tokens - JWS - Process - Transmission": "This token is sent to the client (e.g., browser).",
  "Access - Session - Tokens - JWS - Process - Usage": "For subsequent requests, the client sends the JWT, which the server verifies before granting access.",
	"Access - Session - Tokens - JWS - Process - Usage - BestPractices - Storage": "Store keys securely, never in source code or version control.",
  "Access - Session - Tokens - JWS - Process - Usage - BestPractices - TokenHandling - HTTPS": "Transmit JWTs exclusively over HTTPS to prevent interception.",
  "Access - Session - Tokens - JWS - Process - Usage - BestPractices - TokenHandling - HttpOnly": "Store JWTs in HttpOnly cookies to protect against cross-site scripting (XSS) attacks.",
  "Access - Session - Tokens - JWS - Process - Usage - BestPractices - TokenHandling - Expiration": "Set short expiration times and consider refresh tokens for longer sessions.",
  "Access - Session - Tokens - JWS - Process - Usage - BestPractices - TokenHandling - Revoke": "Implement mechanisms for revoking compromised tokens =>blacklists, short-lived tokens.",
  "Access - Session - Tokens - JWS - Process - Usage - BestPractices - ValidationAndVerification - verify": "ALWAYS verify the JWT signature using the appropriate algorithm and key before processing the claims.",
  "Access - Session - Tokens - JWS - Process - Usage - BestPractices - ValidationAndVerification - claims": "Check all relevant claims (exp, iss, aud) for validity and relevance to your application.",
	"Access - Session - Tokens - JWE": "An encrypted JWT. JWE (RFC 7516), unlike JWS, encrypts its content using an encryption algorithm.",
  "Access - Session - Tokens - JWE - Security": "The only one that can see what is inside the JWT is the one with the key.",
  "Access - Session - Tokens - JWE - Algorithms": "Encryption algos (AES, etc)",
  "Access - Session - Tokens - JWE - Structure": "5 components: Base64Url(Header).Base64Url(Encrypted Key).Base64Url(Initialization Vector).Base64Url(Ciphertext).Base64Url(Authentication Tag)",
  "Access - Session - Tokens - JWE - Structure - Header": "BASE64URL(UTF8(JWE Protected Header)) || ’.’ ||",
  "Access - Session - Tokens - JWE - Structure - EncryptedKey": "BASE64URL(JWE Encrypted Key) || ’.’ ||",
  "Access - Session - Tokens - JWE - Structure - InitializationVector": "BASE64URL(JWE Initialization Vector) || ’.’ ||",
  "Access - Session - Tokens - JWE - Structure - Ciphertext": "BASE64URL(JWE Ciphertext) || ’.’ ||",
  "Access - Session - Tokens - JWE - Structure - AuthenticationTag": "BASE64URL(JWE Authentication Tag",
  "Access - Session - Tokens - JWE - Process - KeyGeneration": "A random Content Encryption Key (CEK) is generated",
  "Access - Session - Tokens - JWE - Process - KeyEncryption": "The CEK is encrypted using the recipient's public key (using the alg specified)",
  "Access - Session - Tokens - JWE - Process - PayloadEncryption": "The actual data is encrypted with the CEK (using the enc algorithm)",
  "Access - Session - Tokens - JWE - Process - Serialization": "All components are base64url encoded and concatenated",
	"Access - Session - SessionPersistance": "Server generates token (session id or JWT token) and sends it to the user. User stores the token (e.g., in local storage or cookies). User sends the token in subsequent requests.",
	"Access - Session - SessionPersistance - URLRewritting": "",
	"Access - Session - SessionPersistance - Cookies": "",
	"Access - Session - SessionPersistance - Cookies - HTTP-Only": "Use HTTP-only cookies to store tokens instead of localStorage or sessionStorage.",
	"Access - Session - SessionPersistance - localStorage": "",
	"Access - Session - SessionPersistance - sessionStorage": "",
	"Access - Authorization": "access to data. Authorization determines permissions (e.g., access levels).",
	"Access - Authorization - Types - RBAC": "RBAC (Role-Based Access Control) grants access based on user roles",
	"Access - Authorization - Types - ABAC": "ABAC (Attribute-Based Access Control) considers attributes",
	"Access - Authorization - Types - PBAC": "PBAC (Policy-Based Access Control) uses policies and rules for authorization,",
	"Access - Authorization - OAuth": "OAuth (Open Authorization) is an open-standard authorization framework that allows third-party applications to access user data from a service (like Google, Facebook, or GitHub) without exposing the user's credentials. Instead, it provides secure, delegated access using access tokens.",
	"Access - Authorization - OAuth - Features - deprecated": ".",
	"Access - Authorization - OAuth - Features - Passwordless": "Allows users to grant applications access without sharing passwords..",
	"Access - Authorization - OAuth - Features - Security": "Required complex cryptographic signing.",
	"Access - Authorization - OAuth - Features - Tokens": "Instead of passwords, OAuth uses short-lived tokens for secure API access.",
	"Access - Authorization - OAuth - Features - Usage": "Less flexible for modern apps.",
	"Access - Authorization - OAuth - Flow - UserRequestsAccess": "App asks the user to authorize access via an OAuth provider (e.g., Google).",
	"Access - Authorization - OAuth - Flow - AuthorizationGrant": "User logs in and approves the requested permissions. The provider gives the app an authorization code.",
	"Access - Authorization - OAuth - Flow - TokenExchange": "The app exchanges the code for an access token (and optionally a refresh token).",
	"Access - Authorization - OAuth - Flow - APIAccess": "The app uses the access token to fetch data from the provider's API.",
	"Access - Authorization - OAuth2": "OAuth 2.0 (Open Authorization 2.0) is an industry-standard authorization framework that enables secure delegated access. Allows third-party applications to access user resources without requiring users to share credentials.",
	"Access - Authorization - OAuth2 - 2012": "Published in 2012 as RFC 6749/6750",
	"Access - Authorization - OAuth2 - Roles - ResourceOwner": "The user who owns the protected resources",
	"Access - Authorization - OAuth2 - Roles - Client": "The application requesting access to protected resources",
	"Access - Authorization - OAuth2 - Roles - ResourceServer": "The server hosting the protected resources (API)",
	"Access - Authorization - OAuth2 - Roles - AuthorizationServer": "The server authenticating users and issuing tokens",
	"Access - Authorization - OAuth2 - Flow - UserRequestsAccess": "1. Client initiates by redirecting user to the authorization server",
	"Access - Authorization - OAuth2 - Flow - AuthorizationGrant": "2. User authenticates and explicitly grants permissions",
	"Access - Authorization - OAuth2 - Flow - Token": "3. Authorization server redirects back with an authorization code",
	"Access - Authorization - OAuth2 - Flow - TokenExchange": "4. Client exchanges this code for access/refresh tokens",
	"Access - Authorization - OAuth2 - Flow - APIAccess": "5. Client uses access token to request protected resources",
	"Access - Authorization - OAuth2 - TokenTypes - AccessToken": "Short-lived credential to access protected resources. Used to call APIs on behalf of the user. Think of this as a pass granting limited rights to a third-party service.",
	"Access - Authorization - OAuth2 - TokenTypes - RefreshToken": "Long-lived credential to obtain new access tokens.",
	"Access - Authorization - OAuth2 - TokenTypes - IDToken": "Contains user identity information (in OpenID Connect).",
	"Access - Authorization - OAuth2 - GrantTypes - AuthorizationCode": "Most secure flow with separate front/back channel",
	"Access - Authorization - OAuth2 - GrantTypes - ClientCredentials": "For server-to-server authentication",
	"Access - Authorization - OAuth2 - GrantTypes - RefreshToken": "Obtaining new access tokens without user interaction",
	"Access - Authorization - OAuth2 - GrantTypes - DeviceCode": "For devices with limited input capabilities",
	"Access - Authorization - OAuth2 - Features - Security": "Simpler, uses HTTPS (not cryptographic signatures).",
	"Access - Authorization - OAuth2 - Features - Tokens": "Uses Bearer Tokens (like JWT).",
	"Access - Authorization - OAuth2 - Features - Usage": "Supports mobile & web apps better.",
	"Access - Authorization - PKCE": "PKCE (RFC 7636) is an extension to the Authorization Code flow to prevent CSRF and authorization code injection attacks.",
	"Access - Authentication": "who is the user. Authentication verifies identity (e.g., login)",
	"Access - Authentication - Mechanisms - Transport - SSHKeys": "Used for remote access to systems without needing passwords. When you use SSH keys to authenticate to the GitLab remote server, you don't need to supply your username and password each time.",
	"Access - Authentication - Mechanisms - Transport - SSLCertificates": "Ensure encrypted communication between users and servers.",
	"Access - Authentication - Mechanisms - Credentials": "The First Line of Defense. The classic method—username and password. But is it enough? Weak passwords are easily cracked; multi-factor authentication (MFA) is essential. The best practice? Use passphrases, password managers, and regular updates.",
	"Access - Authentication - Mechanisms - Credentials - Basic": "Uses non-encrypted base64 encoding. Basic Authentication should generally only be used where transport layer security is provided such as https.",
	"Access - Authentication - Mechanisms - Credentials - Digest": "Uses encrypted form by applying a hash function to: the username, the password, a server supplied nonce value, the HTTP method and the requested URI.",
	"Access - Authentication - Mechanisms - Key - APIKey": "API keys are supposed to be a secret that only the client and server know. Like Basic authentication, API key-based authentication is only considered secure if used together with other security mechanisms such as HTTPS/SSL.",
	"Access - Authentication - Mechanisms - Key - Token Based - JWT": "",
	"Access - Authentication - Mechanisms - Protocol - OpenID": "",
	"Access - Authentication - Mechanisms - Protocol - OpenID2": "",
  "Access - Authentication - Mechanisms - Protocol - OIDC": "OpenID Connect (OIDC) builds upon OpenID and uses OAuth 2.0's authorization and authentication mechanisms.",
  "Access - Authentication - Mechanisms - Protocol - OIDC - id_token": "OIDC introduces the id_token, a JSON Web Token (JWT) that contains claims about the user's identity.",
	"Access - Authentication - Mechanisms - Pattern - mTLS": "Mutual TLS (mTLS) Use Case: High-security environments (banking, internal systems).",
	"Access - Authentication - Mechanisms - Pattern - MFA": "MFA adds a second layer of protection",
	"Access - SSO": "SSO allows users to authenticate once and access multiple applications without re-entering credentials.",
	"Access - SSO - IdP": "Identity Provider. An IdP is a trusted service that stores and manages user identities, including usernames, passwords, and permissions.",
	"Access - SSO - IdP - Types": "Types of identity providers: SAML, OAuth2, OIDC",
	"Access - SSO - IdP - Types - SAML": "SAML, or Security Assertion Markup Language, is an XML-based open standard that facilitates secure exchange of authentication and authorization data between two parties: an Identity Provider (IdP) and a Service Provider (SP), enabling single sign-on (SSO).",
	"Access - SSO - IdP - Types - OAuth2": ".",
	"Access - SSO - IdP - Types - OIDC": "OpenID Connect (OIDC) is an identity layer on top of OAuth. In the domain model associated with OIDC, an identity provider is a special type of OAuth 2.0 authorization server.",
	"Access - SSO - IdP - Process": "Identity-Provider. IdP acts as a central authority for authentication, verifying user credentials and granting access to various applications.",
	"Access - SSO - IdP - Process - 1. SP - Request": "User Attempts to Access Application (Service Provider - SP) The user tries to access a resource (e.g., a web app) that requires authentication. The application detects that the user is not logged in.",
	"Access - SSO - IdP - Process - 2. SP - Redirect": "The application (SP) redirects the user to the Identity Provider (IdP) with a request for authentication. This redirection includes metadata like a SAML request, OAuth2 token request, or OIDC (OpenID Connect) request.",
	"Access - SSO - IdP - Process - 3. IdP - LogIn": "The user is presented with a login page (from the IdP). The user enters their credentials (username/password, biometric, or 2FA).",
	"Access - SSO - IdP - Process - 4. IdP - Verify": "The IdP checks the credentials against its user database (like LDAP, Active Directory, or its own DB). If valid, it creates a secure authentication token (e.g., SAML Assertion or ID Token)..",
	"Access - SSO - IdP - Process - 6. IdP - Token": "Once authenticated, the IdP creates and provides a token or assertion to the Service Provider (SP) confirming the user's identity. The user is now authenticated and can access the Service Provier (LinkedIn)..",
	"Access - SSO - IdP - Process - 7. SP - Granted": "Since the Identity Provider has established a session, when the user goes to access a different Service Provider (eg; GitHub), they won't need to re-enter their credentials. Future service providers will request authentication from the Identity Provider, recognize the existing session, and grant access to the user based on the previously authenticated session.",
	"Access - SSO - IdP - Tools - MicrosoftEntraID": "",
	"Access - SSO - IdP - Tools - Okta": "",
	"Access - SSO - IdP - Tools - Auth0": "",
	"Access - SSO - IdP - Tools - JumpCloud": "",
  "Access - SSO - IdP - Tools - CAS": "Central authentication service, or CAS, is a single sign-on (SSO) protocol that allows websites to authenticate users.",

  "Processing": "SECTION",
	"Processing - Validation": "Validating request payloads is crucial for ensuring data integrity, security, and API reliability.",
	"Processing - Validation - Threats": ".",
	"Processing - Validation - Threats - InjectionAttacks": "Protect against injection attacks (e.g., SQLi, XSS).",
	"Processing - Validation - Threats - InjectionAttacks - SQLInjection": ".",
	"Processing - Validation - Threats - InjectionAttacks - XSS": ".",
	"Processing - Validation - Threats - JSON Threat Protection": "Minimizes the risk posed by content-level attacks by enabling you to specify limits on various JSON structures, such as arrays and strings.",
	"Processing - Validation - Threats - XML Threat Protection": "Applications processing XML requests are susceptible to attacks characterized by unusual inflation of elements, attributes, and nesting levels.",
	"Processing - Validation - Threats - MessageSize": ".",
	"Processing - Validation - Threats - Malformed": "Prevent malformed/invalid data from being processed.",
	"Processing - Validation - Threats - Compliance": "Ensure compliance with expected data formats (e.g., JSON schema).",
	"Processing - Validation - Layers": ".",
	"Processing - Validation - Layers - Client": "HTML Sanitization.",
	"Processing - Validation - Layers - Protocol": "GraphQL: Built-in type validation. gRPC: Uses Protocol Buffers (protobuf) for strict payload definitions.",
	"Processing - Validation - Layers - Schema": "Validate payloads against a predefined schema (e.g., JSON Schema, OpenAPI/Swagger).",
	"Processing - Validation - Layers - Middleware": "Use libraries like express-validator (for Express.js) or similar in other frameworks.",
	"Processing - Validation - Layers - Code - TypeSafe": "Use languages/frameworks with compile-time validation (e.g., TypeScript, GraphQL).",
	"Processing - Validation - Layers - Code - Manual": "Validate manually in code",
	"Processing - Validation - Layers - Data - PrepareStatements": "Use Prepared Statements (Parameterized Queries)",
	"Processing - Validation - Layers - Data - PrepareStatements - ORM": "Use ORMs that automatically parameterize queries:",
	"Processing - Validation - Layers - Data - StoredProcedures": "Use stored procedures",
	"Processing - Validation - Layers - Data - RegEx": "Implement regular expression filters for suspicious SQL patterns",
	"Processing - Validation - GoodPractices - ValidateEarly": "Check payloads at the API gateway or middleware layer.",
	"Processing - Validation - GoodPractices - StandardizedErrors": "Use standardized error formats (e.g., RFC 7807).",
	"Processing - Validation - GoodPractices - SanitizeInputs": "Strip unsafe content (e.g., HTML tags) even after validation.",
	"Processing - Validation - GoodPractices - UseAllowlists": "Reject unexpected fields (e.g., with additionalProperties: false in JSON Schema).",
	"Processing - Validation - GoodPractices - CombineTechniques": "Use both runtime (schema) and compile-time (TypeScript) checks.",
	"Processing - Validation - GoodPractices - LeastPrivilegePrinciple": "Database users should have minimal required permissions.",
	"Processing - Validation - Tools - Express": "express-validator, joi, zod, ajv",
	"Processing - Validation - Tools - Flask": "marshmallow, pydantic",
	"Processing - Validation - Tools - Spring": "Bean Validation (@Valid), Hibernate Validator",
	"Processing - Validation - Tools - Rails": "Strong Parameters, ActiveModel Validations",
	"Processing - Validation - Tools - Go": "go-playground/validator",

	"UI": "SECTION",
	"UI - OWASP": "",
	"UI - OWASP - Top10": "",
	"UI - SensitiveInfo": "",
	"UI - SensitiveInfo - .env": "",
  "UI - XSS": "",
	"UI - XSS - Encode": "Always encode data before outputting to HTML.",
	"UI - XSS - Content-Security-Policy": ".",
	"UI - XSS - HTTPSecurityHeaders - X-XSS-Protection": ".",
	"UI - XSS - HTTPSecurityHeaders - X-Content-Type-Options": ".",
	"UI - XSS - HTTPSecurityHeaders - X-Frame-Options": ".",
	"UI - XSS - Sanitize": "Any form of user input (like search forms, comment sections, or feedback forms) must be treated as untrusted. Malicious users can exploit these to execute XSS attacks or SQL injections.",
	"UI - XSS - Sanitize - Manual": ".",
	"UI - XSS - Sanitize - Angular": ".",
	"UI - XSS - Sanitize - Tools - DOMPurify": ".",
	"UI - XSS - Escape": ".",
	"UI - XSS - PKCE": "PKCE was originally designed to protect the authorization code flow in mobile apps, but its ability to prevent authorization code injection makes it useful for every type of OAuth client, even web apps that use client authentication.",
	"UI - XSS - NoEval()": "Functions like eval(), setTimeout() with dynamic strings, and innerHTML are vulnerable to XSS attacks. They allow an attacker to inject arbitrary code into your site.",
  "UI - CORS": "https://javascript.plainenglish.io/cors-the-friendly-gatekeeper-of-the-web-and-how-to-fix-it-650e33179d24",
  "UI - CORS - CORSPolicies": "Configure your CORS policy to restrict allowed origins, HTTP methods, and headers.",
  "UI - CSRF": "Cross-site request forgery (also known as CSRF) is a web security vulnerability that allows an attacker to induce users to perform actions that they do not intend to perform. Secure form submissions",
	"UI - Standards - NIS2": "https://digital-strategy.ec.europa.eu/en/policies/nis2-directive"

}

