{
	"Functional Testing - By Location - Local Testing": "Unit tests that run locally on the Java Virtual Machine (JVM)",
	"Functional Testing - By Location - Local Testing - Runner - AndroidJunitRunner": "The AndroidJUnitRunner class defines an instrumentation-based JUnit test runner that lets you run JUnit 3- or JUnit 4-style test classes on Android devices. The test runner facilitates loading your test package and the app under test onto a device or emulator, running your tests, and reporting the results.",
	"Functional Testing - By Location - Local Testing - Runner - AndroidJunitRunner - Features": "JUnit4 Rules, Espresso, UI Automator, Android Test Orchestrator",
	"Functional Testing - By Location - Local Testing - Path": "located in src/test/java. src/test/java is for pure unit test that do not involve android framework. You can run tests here without running on a real device or on emulator.",
	"Functional Testing - By Location - Instrumentation Testing": "Unit tests that run on an Android device or emulator. These tests have access to Instrumentation information, such as the Context of the app you are testing.",
	"Functional Testing - By Location - Instrumentation Testing - Runner - InstrumentationTestRunner": "The InstrumentationTestRunner is the base test runner for Android tests. This test runner starts and loads the test methods. Via the instrumentation API it communicates with the Android system.",
	"Functional Testing - By Location - Instrumentation Testing - Path": "located in src/androidTest/java",
	"Functional Testing - By Location - Instrumentation Testing - InstrumentationRegistry": "AndroidJunitRunner provides access to the instrumentation API, via the InstrumentationRegistery.",
	"Functional Testing - By Location - Instrumentation Testing - InstrumentationRegistry.getInstrumentation()": "returns the Instrumentation currently running",
	"Functional Testing - By Location - Instrumentation Testing - InstrumentationRegistry.getContext()": "returns the Context of this Instrumentation’s package",
	"Functional Testing - By Location - Instrumentation Testing - InstrumentationRegistry.getTargetContext()": "returns the application Context of the target application",
	"Functional Testing - By Location - Instrumentation Testing - InstrumentationRegistry.getArguments()": "returns a copy of arguments Bundle that was passed to this Instrumentation. This is useful when you want to access the command line arguments passed to the instrumentation for your test.",
	"Functional Testing - By Purpose - @LargeTest": "Large tests should be focused on testing integration of all application components. These tests fully participate in the system and may make use of all resources such as databases, file systems and network. As a rule of thumb most functional UI tests are large tests.",
	"Functional Testing - By Purpose - @MediumTest": "Medium tests should be focused on a very limited subset of components or a single component. Resource access to the file system through well defined interfaces like databases, ContentProviders, or Context is permitted. Network access should be restricted, (long-running) blocking operations should be avoided and use mock objects instead.",
	"Functional Testing - By Purpose - @SmallTest": "Small tests should be run very frequently. Focused on units of code to verify specific logical conditions. These tests should runs in an isolated environment and use mock objects for external dependencies. Resource access (such as file system, network, or databases) are not permitted. Tests that interact with hardware, make binder calls, or that facilitate android instrumentation should not use this annotation.",
	"Functional Testing - By Purpose - Unit Testing": "",
	"Functional Testing - By Purpose - Unit Testing - How To": "",
	"Functional Testing - By Purpose - Integration Testing": "",
	"Functional Testing - By Purpose - Integration Testing - How To": "",
	"Functional Testing - By Purpose - Integration Testing - Products - Roboelectric": "",
	"Functional Testing - By Purpose - UI Testing": "",
	"Functional Testing - By Purpose - UI Testing - Types": "",
	"Functional Testing - By Purpose - UI Testing - Types - Single App": "UI tests that span a single app: This type of test verifies that the target app behaves as expected when a user performs a specific action or enters a specific input in its activities. It allows you to check that the target app returns the correct UI output in response to user interactions in the app’s activities. UI testing frameworks like Espresso allow you to programmatically simulate user actions and test complex intra-app user interactions.",
	"Functional Testing - By Purpose - UI Testing - Types - Multiple App": "UI tests that span multiple apps: This type of test verifies the correct behavior of interactions between different user apps or between user apps and system apps. For example, you might want to test that your camera app shares images correctly with a 3rd-party social media app, or with the default Android Photos app. UI testing frameworks that support cross-app interactions, such as UI Automator, allow you to create tests for such scenarios.",
	"Functional Testing - By Purpose - UI Testing - How To": "",
	"Functional Testing - By Purpose - UI Testing - Products": "Espresso, Robotium, Selendroid, UI Automator, Appium",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso": "An Espresso is really good and fast test automation framework, which allows you test many things inside your application in simple way.",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Target": "For Single App",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Ubication": "In terms of testing style, the Espresso description mentions “white box testing.” As Espresso is inside the application, it has access to and knows how to use the code that actually runs the application for more thorough testing of each element.",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Requirements": "Espresso tests can run on devices running Android 2.3.3 (API level 10) and higher.",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Requirements - Runner": "The Espresso testing framework is an instrumentation-based API and works with the AndroidJUnitRunner test runner.",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Requirements - Animations": "Turn off animations on your test device — leaving system animations turned on in the test device might cause unexpected results or may lead your test to fail. Turn off animations from Settings by opening Developer options and turning all the following options off: Window animation scale Transition animation scale Animator duration scale",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Rules": "",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Rules - ActivityTestRule": "This rule provides functional testing of a single Activity. When launchActivity is set to true in the constructor, the Activity under test will be launched before each test annotated with Test and before methods annotated with Before, and it will be terminated after the test is completed and methods annotated with After are finished. The Activity can be manually launched with launchActivity(Intent), and manually finished with finishActivity(). If the Activity is running at the end of the test, the test rule will finish it. During the duration of the test you will be able to manipulate your Activity directly using the reference obtained from getActivity(). If the Activity is finished and relaunched, the reference returned by getActivity() will always point to the current instance of the Activity. ActivityTestRule<CoffeeOrderDetailsActivity> mActivityRule = new ActivityTestRule<>(CoffeeOrderDetailsActivity.class, true, false),",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Rules - ServiceTestRule": "A JUnit rule that provides a simplified mechanism to start and shutdown your service before and after the duration of your test. It also guarantees that the service is successfully connected when starting (or binding to) a service. The service can be started (or bound) using one of the helper methods. It will automatically be stopped (or unbound) after the test completes and any methods annotated with After are finished. Note: This rule doesn't support IntentService because it's automatically destroyed when onHandleIntent(android.content.Intent) finishes all outstanding commands. So there is no guarantee to establish a successful connection in a timely manner.",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Rules - GrantPermissionRule": "The GrantPermissionRule Rule allows granting of runtime permissions on Android M (API 23) and above. Use this Rule when a test requires a runtime permission to do its work. When applied to a test class this Rule attempts to grant all requested runtime permissions. The requested permissions will then be granted on the device and will take immediate effect. Permissions can only be requested on Android M (API 23) or above and will be ignored on all other API levels. Once a permission is granted it will apply for all tests running in the current Instrumentation. There is no way of revoking a permission after it was granted. Attempting to do so will crash the Instrumentation process. Note, this Rule is usually used to grant runtime permissions to avoid the permission dialog from showing up and blocking the App's Ui. This is especially helpful for Ui-Testing to avoid loosing control over the app under test. The requested permissions will be granted for all test methods in the test class. Use grant(String) static factory method to request a variable number of permissions. Usage: @Rule public GrantPermissionRule mRuntimePermissionRule = GrantPermissionRule .grant(android.Manifest.permission.ACCESS_FINE_LOCATION)",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Rules - DisableOnAndroidDebug": "The DisableOnAndroidDebug Rule allows you to label certain rules to be disabled when debugging. The most illustrative use case is for tests that make use of the Timeout rule, when ran in debug mode the test may terminate on timeout abruptly during debugging. Developers may disable the timeout, or increase the timeout by making a code change on tests that need debugging and remember revert the change afterwards or rules such as Timeout that may be disabled during debugging may be wrapped in a DisableOnDebug. The important benefit of this feature is that you can disable such rules without any making any modifications to your test class to remove them during debugging. This does nothing to tackle timeouts or time sensitive code under test when debugging and may make this less useful in such circumstances.",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Espresso class": "",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Espresso class - void closeSoftKeyboard ()": "",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Espresso class - List< IdlingResource > getIdlingResources ()": "",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Espresso class - DataInteraction onData (Matcher< ? extends Object > dataMatcher)": "",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Espresso class - void onIdle ()": "",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Espresso class - T onIdle (Callable<T> action)": "",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Espresso class - ViewInteraction onView (Matcher<View> viewMatcher)": "",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Espresso class - void openActionBarOverflowOrOptionsMenu (Context context)": "",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Espresso class - void openContextualActionModeOverflowMenu ()": "",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Espresso class - void pressBack ()": "",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Espresso class - void pressBackUnconditionally ()": "",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Espresso class - boolean registerIdlingResources (IdlingResource... resources)": "",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Espresso class - void registerLooperAsIdlingResource (Looper looper)": "",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Espresso class - void registerLooperAsIdlingResource (Looper looper, boolean considerWaitIdle)": "",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Espresso class - void setFailureHandler (FailureHandler failureHandler)": "",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Espresso class - boolean unregisterIdlingResources (IdlingResource... resources)": "",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - ViewMatchers": "A collection of hamcrest matchers that match Views.",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - LayoutMatchers": "A collection of hamcrest matchers that match Layouts.",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - ViewActions": "A collection of common ViewActions.",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - ViewAction": "Responsible for performing an interaction on the given View element. This is part of the test framework public API - developers are free to write their own ViewAction implementations when necessary. When implementing a new ViewAction, follow these rules: (*) Inject motion events or key events via the UiController to simulate user interactions. (*) Do not mutate the view directly via setter methods and other state changing methods on the view parameter. (*) Do not throw AssertionErrors. Assertions belong in ViewAssertion classes. (*) View action code will executed on the UI thread, therefore you should not block, perform sleeps, or perform other expensive computations. (*) The test framework will wait for the UI thread to be idle both before and after perform() is called. This means that the action is guaranteed to be synchronized with any other view operations. (*) Downcasting the View object to an expected subtype is allowed, so long as the object expresses the subtype matches the constraints as specified in getConstraints.",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - ViewAssertions": "Collection of common ViewAssertions..",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - ViewAssertion": "Responsible for performing assertions on a View element. This is considered part of the test framework public API - developers are free to write their own assertions as long as they meet the following requirements: (*) Do not mutate the passed in view. (*) Throw junit.framework.AssertionError when the view assertion does not hold. (*) Implementation runs on the UI thread - so it should not do any blocking operations (*) Downcasting the view to a specific type is allowed, provided there is a test that view is an instance of that type before downcasting. If not, an AssertionError should be thrown. (*) It is encouraged to access non-mutating methods on the view to perform assertion. ",
	"Functional Testing - By Purpose - UI Testing - Products - Espresso - Espresso Test Recorder": "",
	"Functional Testing - By Purpose - UI Testing - Products - Robotium": "It is an excellent android testing tool and has an open source library. Robotium makes it easy to write powerful and robust automatic black-box UI tests for Android applications. It has full support for native and hybrid applications. With its support, developers can write function, system, and user acceptance test scenarios, spanning multiple Android activities.",
	"Functional Testing - By Purpose - UI Testing - Products - Selendroid": "",
	"Functional Testing - By Purpose - UI Testing - Products - UI Automator": "A UiAutomator is perfect framework for automation testing outside of application because this framework allows test many system stuff, as example notification, access to any application, etc.",
	"Functional Testing - By Purpose - UI Testing - Products - UI Automator - UIAutomatorViewer": "Android->sdk->tools folder",
	"Functional Testing - By Purpose - UI Testing - Products - Appium": "Android supports Android via uiautomator (API level 16 or higher) and Seledroid (API level lower than 16), iOS via UI Automation, and mobile web as Selenium driver for Android and iOS.",
	"Functional Testing - By Purpose - UI Testing - Products - Appium - Ubication": "Appium is designed to be a cross-platform test platform. As such, one of the trade-offs focuses on “black box testing” which only tests what has been exposed externally to the application. Using the Android UIAutomator framework, Appium can access all the UI elements that a user will see. Two of the benefits of being external to the application are the ability to validate the data going to and from the service layer behind the scenes, and the ability to execute simulations by telling the app the device has rotated, or that the home button has been pushed.",
	"Functional Testing - By Purpose - UI Testing - Products - Appium - UI Automator2": "UiAutomator2 is a custom implementation of Google UiAutomator by Appium community, that mostly fixes existing issues in original UiAutomator and stabilise/speedup interactions with UI elements: from my own measurement tests running Android 6/UiAutomator 2 are in average 20-30% faster then the same ones on Android 5.1/UiAutomator Starting with Android 6 Appium supports UiAutomator2 only, so basically there is no choice to go with old flaky UiAutomator and community do not support it, so if smth doesn't work with UiAutomator -> its up to you to solve it.",


	"Performance Testing": "User interface (UI) performance testing ensures that your app not only meets its functional requirements, but that user interactions with your app are buttery smooth, running at a consistent 60 frames per second (why 60fps?), without any dropped or delayed frames, or as we like to call it, jank.",
	"Performance Testing - dumpsys": "dumpsys is an Android tool that runs on the device and dumps interesting information about the status of system services.",

	"Android Test Orchestrator": "Android Test Orchestrator is a tool which allows you to run each of your app’s tests within its own invocation of Instrumentation. This means that each test (method annotated with @Test ) will be run on a separate instance of AndroidJUnitRunner."
}