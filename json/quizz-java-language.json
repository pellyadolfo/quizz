{
	"types": "SECTION",
	"Type Checking - Speculative Attribution (Java 8)": "In Java 8, the implementation of type-checking at compiler level was based on Speculative Attribution. In Speculative Attribution, the same tree can be type-checked against multiple targets at runtime. This is particularly used in target typing for lambda expressions, resolving diamond expressions for generics, etc.",
	"Type Checking - Tiered Attribution (Java 9)": "As we saw in the previous example, there may be instances in which the compiler will have to perform type checking for multiple target types. This is a very important capability but can result in performance issues because of redundant steps done in the process. A JDK Enhancement Proposal (JEP 215) was proposed for type checking of poly expressions. The newly proposed way is known as Tiered Attribution. It focuses on improving performance by implementing a different way of type-checking that reduces redundant steps but gives the same results as current type-checking implementation.",
	"Type Inference (Java 10)": "In Java 10, this is how we could declare a local variable: var message = 'Hello, Java 10', We don’t provide the data type of message. Instead, we mark the message as a var, and the compiler infers the type of message from the type of the initializer present on the right-hand side.",
	"Type Inference - keyword": "Another thing to note is that var is not a keyword – this ensures backward compatibility for programs using var say, as a function or variable name. var is a reserved type name, just like int.",
	"Type Inference - overhead": "there is no runtime overhead in using var nor does it make Java a dynamically typed language. The type of the variable is still inferred at compile time and cannot be changed later.",
	"Type Inference - object": "the inferred type of obj isn’t Object. var obj = new Object() {},",
	"Type Inference - wrong - initializer": "var won’t work without the initializer: var n, // error:",
	"Type Inference - wrong - null": "Nor would it work if initialized with null: var emptyList = null,",
	"Type Inference - wrong - local": "Note that this feature is available only for local variables with the initializer. It cannot be used for member variables, method parameters, return types, etc. public var = 'hello', // error:",
	"Type Inference - wrong - lambda": "Lambda expression needs explicit target type, and hence var cannot be used: var p = (String s) -> s.length() > 10, // error:",
	"Type Inference - wrong - array": "Array needs explicit target type, and hence var cannot be used: var arr = { 1, 2, 3 }, // error",

	"reflection": "SECTION",
	"Reflection": "",
	"MethodHandle (Java 7)": "A method handle is a typed, directly executable reference to an underlying method, constructor, field, or similar low-level operation, with optional transformations of arguments or return values.",
	"MethodHandle vs Reflection": "From a performance standpoint, the MethodHandles API can be much faster than the Reflection API since the access checks are made at creation time rather than at execution time.",
	"VarHandle (Java 9)": "Generally, a variable handle is just a typed reference to a variable. The variable can be an array element, instance or static field of the class. The VarHandle class provides write and read access to variables under specific conditions. VarHandles are immutable and have no visible state. What’s more, they cannot be sub-classed.",
	"VarHandle - goal": "The goal of VarHandle is to define a standard for invoking equivalents of java.util.concurrent.atomic and sun.misc.Unsafe operations on fields and array elements. Those operations are in majority atomic or ordered operations. For example, atomic field incrementation.",

	"try": "SECTION",
	"try-with-resources (Java 7)": "Java 7 introduced the try-with-resources statement, where resources will be closed automatically after the execution. It requires an additional variable for the resources to be assigned. But Java 9 manages the same with the final or effectively final variables. The effectively final variable is the variable or the parameter whose values will never be changed once it is initialized.",
	"try-with-resources - requires additional variable (Java 7)": "InputStream inputStream = new FileInputStream('test.txt'), try (InputStream stream = inputStream) {} catch (IOException e) {}",
	"try-with-resources - no requires additional variable (Java 9)": "InputStream inputStream = new FileInputStream('test.txt'), try (inputStream) {} catch (IOException e) {}",

	"generics": "SECTION",
	"Diamond Operator - Generic Instantiation (Java 7)": "Java 7 introduced the diamond operator ( <> ) in generic class instantiation contexts. List<String> list2 = new ArrayList<>(),",
	"Diamond Operator - Generic Instantiation )Java 9)": "Java 9 enhanced the type inference algorithm to tell whether the inferred type is denotable when analyzing an anonymous class that supports the diamond operator. Iterator <String> iter = new Iterator <> () { }",

	"functional interfaces": "SECTION",
	"Functional Java": "Annonymous Inner Class -> Callback Hell -> Functional Interfaces + Default Methods -> Lambda Expressions -> Method References",
	"Functional Java - Functional Interfaces": "A functional interface is an interface that contains only one abstract method.",
	"Functional Java - Functional Interfaces - annotation": "@FunctionalInterface",
	"Functional Java - Functional Interfaces - types by function": "Suppliers, Consumers, Predicates, Operators.",
	"Functional Java - Functional Interfaces - Default Methods": "So it’d be really frustrating if we had lambdas in Java 8 but couldn’t use those with the standard collections library since backwards compatibility can’t be sacrificed. Due to the problem described above a new concept was introduced",
	"Functional Java - Functional Interfaces - Default Methods ": "Virtual extension methods or defender methods.",
	"Functional Java - Functional Interfaces - Default Methods - public (Java 8)": "implicit",
	"Functional Java - Functional Interfaces - Default Methods - static (Java 8)": "allowed",
	"Functional Java - Functional Interfaces - Default Methods - private (Java 9)": "allowed",
	"Functional Java - Functional Interfaces - Default Methods - final": "forbidden",
	"Functional Java - Functional Interfaces - Default Methods - synchronize": "forbidden",
	"Functional Java - Method Reference": "A method reference to a static method. A method reference to an instance method of an object of a particular type. A method reference to an instance method of an existing object. A method reference to a constructor.",
	"Functional Java - Method Reference - static method": "s -> Integer.parseInt(s) vs Integer::parseInt",
	"Functional Java - Method Reference - instance method of an object of a particular type": "(String s) -> s.toUpperCase() vs String::toUpperCase",
	"Functional Java - Method Reference - instance method of an existing object": "() -> books.size() vs books::size",
	"Functional Java - Method Reference - constructor": "() -> new Foo() vs Foo::new",

	"logging": "SECTION",
	"Logging": ".",
	"Logging - Internal Logging (Java 9)": "The new Java 9 Platform Logging API allows applications and frameworks to route JDK internal logs to the desired logging framework (e.g. Log4j2, SLF4J etc). This is the similar to what SLF4J does via its bridges (an example here) but now it is built into JDK and is meant to redirect JDK internal logs to the desired logging destination.",
	"Logging - Internal Logging - System.LoggerFinder ": ".",
	"Logging - Internal Logging - System.Logger ": ".",

	"JShell": "SECTION",
	"JShell (Java 9)": "The Java Shell tool (JShell) is an interactive tool for learning the Java programming language and prototyping Java code. JShell is a Read-Evaluate-Print Loop (REPL), which evaluates declarations, statements, and expressions as they are entered and immediately shows the results. The tool is run from the command line.",
}