{
  "React": "SECTION",
  "React - ": ".",

  "UI": "SECTION",
  "UI - Tree": "",
  "UI - Components - Types - Functional Components": "Functional components are JavaScript functions that take in props (short for properties) as parameters and return React elements.",
  "UI - Components - Types - Class Components": "Class components are ES6 classes that extend from `React.Component`. They have a more feature-rich API, including state and lifecycle methods.- They are used when you need to manage the component’s state or lifecycle events.",
	"UI - Components - Development - Lifecycle - ": "These methods are called in the following order when an instance of a component is being created and inserted into the DOM.",
  "UI - Components - Development - Lifecycle - Mounting - constructor()": "The constructor runs before your class component mounts (gets added to the screen). Typically, a constructor is only used for two purposes in React. It lets you declare state and bind your class methods to the class instance:",
  "UI - Components - Development - Lifecycle - Mounting - getDerivedStateFromProps()": "During the mounting phase, getDerivedStateFromProps() is called after the constructor and before render(). This method is called for every render cycle and provides an opportunity to update the component's state based on changes in props before the initial render.",
	"UI - Components - Development - Lifecycle - Mounting - render()": "The render() method is responsible for generating the component's virtual DOM representation based on its current props and state. It is called every time the component needs to be re-rendered, either because its props or state have changed, or because a parent component has been re-rendered.",
  "UI - Components - Development - Lifecycle - Mounting - componentDidMount()": "The componentDidMount() method is called once the component has been mounted into the DOM. It is typically used to set up any necessary event listeners or timers, perform any necessary API calls or data fetching, and perform other initialization tasks that require access to the browser's DOM API.",
  "UI - Components - Development - Lifecycle - Mounting - componentWillMount()": "Deprecated. ",
	"UI - Components - Development - Lifecycle - Unmounting - componentWillUnmount()": "React will call it before your component is removed (unmounted) from the screen.",
	"UI - Components - Development - Lifecycle - Updating": "An update can be caused by changes to props or state. These methods are called in the following order when a component is being re-rendered.",
  "UI - Components - Development - Lifecycle - Updating - shouldComponentUpdate()": "The shouldComponentUpdate()  method is called before a component is updated. It takes two arguments: nextProps and nextState. This method returns a boolean value that determines whether the component should update or not. If this method returns true, the component will update, and if it returns false, the component will not update.",
  "UI - Components - Development - Lifecycle - Updating - static getDerivedStateFromProps()": ".",
  "UI - Components - Development - Lifecycle - Updating - render()": ".",
  "UI - Components - Development - Lifecycle - Updating - getSnapshotBeforeUpdate()": "The getSnapshotBeforeUpdate() method is called just before the component's UI is updated. It allows the component to capture some information about the current state of the UI, such as the scroll position before it changes. This method returns a value that is passed as the third parameter to the componentDidUpdate() method.",
  "UI - Components - Development - Lifecycle - Updating - componentWillUpdate()": "componentWillUpdate() is a lifecycle method in React that gets called just before a component's update cycle starts.",
  "UI - Components - Development - Lifecycle - Updating - componentDidUpdate()": "The componentDidUpdate() method is a lifecycle method in React that is called after a component has been updated and re-rendered.",
  "UI - Components - Development - Lifecycle - Error Handling": "These methods are called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component.",
  "UI - Components - Development - Lifecycle - Error Handling - static getDerivedStateFromError()": ".", 
  "UI - Components - Development - Lifecycle - Error Handling - componentDidCatch()": ".",
  "UI - Components - Development - Parameters - passing props": "Props are the information that you pass to a JSX tag.",
  "UI - Components - Development - Parameters - forwarding props": "Props are the information that you pass to a JSX tag.",
  "UI - Components - Development - Parameters - quotes": "You may use quotes to specify string literals as attributes: const element = <a href='https://www.reactjs.org'> link </a>;",
  "UI - Components - Development - Parameters - curly braces": "You may also use curly braces to embed a JavaScript expression in an attribute: const element = <img src={user.avatarUrl}></img>;.",
	"UI - Components - Development - Parameters - props drilling": ".",
  "UI - Components - Development - JSX": "Returned by Components.",
  "UI - Components - Development - JSX - elements": "React elements are immutable. Once you create an element, you can’t change its children or attributes.",
  "UI - Components - Development - JSX - transpilation": "JSX allows you to write HTML-like code in your JavaScript. It gets transpiled by a tool like Babel to JavaScript before being rendered in the browser..",
  "UI - Components - Development - JSX - transpilation - Babel": "Browsers don’t understand JSX out of the box, so most React users rely on a compiler like Babel or TypeScript to transform JSX code into regular JavaScript.",
  "UI - Components - Development - JSX - transpilation - React.createElement()": "Babel compiles JSX down to React.createElement() calls.",
  "UI - Components - Development - JSX - expressions": "You can put any valid JavaScript expression inside the curly braces in JSX.",
  "UI - Components - Development - JSX - injection attacks": "By default, React DOM escapes any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that’s not explicitly written in your application. Everything is converted to a string before being rendered. This helps prevent XSS (cross-site-scripting) attacks.",
  "UI - Components - Development - Modules": ".",
  "UI - Components - Development - Modules - Import": "Importing more components or modules than necessary can increase bundle size and negatively impact performance. Import only the specific components or functions you need from a module. Use code-splitting to load components on demand.",
  "UI - Components - Development - Modules - Export": ".",
  "UI - Components - Development - Patterns - Base UI Component": "",
  "UI - Components - Development - Patterns - Base UI Component - BaseUI": "https://baseweb.design/",
  "UI - Components - Development - Patterns - Inheritance": "No use",
  "UI - Components - Development - Patterns - Composition": "",
	"UI - Components - Built-in - <Fragment>": "<Fragment>, often used via <>...</> syntax, lets you group elements without a wrapper node.",
  "UI - Components - Built-in - <Profiler>": "<Profiler> lets you measure rendering performance of a React tree programmatically.",
  "UI - Components - Built-in - <StrictMode>": "<StrictMode> lets you find common bugs in your components early during development. <StrictMode> <App /> </StrictMode>",
  "UI - Components - Built-in - <Suspense>": "<Suspense> lets you display a fallback until its children have finished loading. <Suspense fallback={<Loading />}> <SomeComponent /> </Suspense>",
  "UI - Components - Built-in - <input>": "The built-in browser <input> component lets you render different kinds of form inputs. <input />",
  "UI - Components - Built-in - <option>": "The built-in browser <option> component lets you render an option inside a <select> box. <select>  <option value='someOption'>Some option</option> <option value='otherOption'>Other option</option> </select>",
  "UI - Components - Built-in - <progress>": "The built-in browser <progress> component lets you render a progress indicator. <progress value={0.5} />",
  "UI - Components - Built-in - <select>": "The built-in browser <select> component lets you render a select box with options. <select>  <option value='someOption'>Some option</option> <option value='otherOption'>Other option</option> </select>",
  "UI - Components - Built-in - <textarea>": "The built-in browser <textarea> component lets you render a multiline text input. <textarea />",
  "UI - Components - Built-in - Common": "All built-in browser components, such as <div>, support some common props and events. https://beta.reactjs.org/reference/react-dom/components/common",
  "UI - Components - APIs": "the react package exports a few other APIs that are useful for defining components.",
  "UI - Components - APIs - act": "act is a test helper to apply pending React updates before making assertions.",
  "UI - Components - APIs - cache": "cache is only for use with React Server Components.",
  "UI - Components - APIs - createContext": "createContext lets you create a context that components can provide or read.",
  "UI - Components - APIs - forwardRef": "forwardRef lets your component expose a DOM node to parent component with a ref.",
  "UI - Components - APIs - lazy": "lazy lets you defer loading component’s code until it is rendered for the first time.",
  "UI - Components - APIs - memo": "memo lets you skip re-rendering a component when its props are unchanged.",
  "UI - Components - APIs - startTransition": "startTransition lets you update the state without blocking the UI.",
  "UI - Components - APIs - use": "use is a React API that lets you read the value of a resource like a Promise or context.",
  "UI - Components - APIs - taintObjectReference": "lets you prevent a specific object instance from being passed to a Client Component like a user object.",
  "UI - Components - APIs - taintUniqueValue": "lets you prevent unique values from being passed to Client Components like passwords, keys, or tokens.",
  "UI - Components - Execution": "Any screen update in a React app happens in three steps: Trigger, Render, Commit",
  "UI - Components - Execution - Triggering": ".",
  "UI - Components - Execution - Rendering": "Rendering takes a snapshot in time. After rendering (calling) your components, React will modify the DOM.",
  "UI - Components - Execution - Rendering - Cascading": "Re-renders in React are cascading. Every time you change state in a React component, you trigger a re-render of that component, every component inside, components inside of those components, etc., until the end of the component tree is reached.",
  "UI - Components - Execution - Rendering - Conditional": ".",
  "UI - Components - Execution - Rendering - Rerendering": ".",
  "UI - Components - Execution - Rendering - memoization": "In web development, memoization is the process of storing data (e.g. a variable value) in the cache and then retrieving this information next time it is needed (e.g. on a page or component re-render).",
  "UI - Components - Execution - Rendering - memoization - React.memo": "",
  "UI - Components - Execution - Rendering - memoization - useMemo": "This hook allows you to cache the result of a function output and retrieve this information when it’s needed, without recomputing the value all over again.",
  "UI - Components - Execution - Rendering - memoization - useCallback": "The useCallback hook is very similar to useMemo. The main difference is that useMemo returns a memoized value while useCallback returns a memoized function.",
  "UI - Components - Execution - Rendering - memoization - React Compiler": "Now, everything I’ve just told you about useMemo and useCallback may become totally irrelevant when React Compiler is released! Although useMemo and useCallback serve their purpose in React right now, they also increase mental overhead for developers, hence the reason React Compiler is in the pipeline. React Compiler is a low-level, auto-memoizing compiler that will handle all memoization without you - the developer - having to do anything at all.React Compiler is an ‘auto-memoizing compiler’ that automates all memoizations in your application. In simpler terms, this means that it will automatically detect the need for useMemo and useCallback so you will no longer have to think about these hooks or which one you need to use for a certain situation.",
  "UI - Components - Execution - Rendering - memoization - React Compiler - plugAndPlay": "The Compiler is plug-and-play: you install it, and it Just Works; there is no need to rewrite existing code.",
  "UI - Components - Execution - Committing": ".",
	"UI - Components - Testing": ".",

  "State": "SECTION",
  "State - Variables": "Sharing status",
  "State - Variables - Update": "setting state requests a re-render from React. This means that for an interface to react to the event, you need to update the state.",
  "State - Provider": "Sharing status",
  "State - Hooks": ".",
  "State - Hooks - state": "State lets a component “remember” information like user input.",
  "State - Hooks - state - useState": "The React useState Hook allows us to track state in a function component. State generally refers to data or properties that need to be tracking in an application.",
  "State - Hooks - state - useReducer": "The useReducer Hook is similar to the useState Hook. It allows for custom state logic. If you find yourself keeping track of multiple pieces of state that rely on complex logic, useReducer may be useful. useReducer(<reducer>, <initialState>)",
  "State - Hooks - context": "Context lets a component receive information from distant parents without passing it as props.",
  "State - Hooks - context - useContext": "React Context is a way to manage state globally. It can be used together with the useState Hook to share state between deeply nested components more easily than with useState alone.",
  "State - Hooks - ref": "Refs let a component hold some information that isn’t used for rendering, like a DOM node or a timeout ID. Unlike with state, updating a ref does not re-render your component. Refs are an “escape hatch” from the React paradigm. They are useful when you need to work with non-React systems, such as the built-in browser APIs.",
  "State - Hooks - ref - useRef": "The useRef Hook allows you to persist values between renders. It can be used to store a mutable value that does not cause a re-render when updated. It can be used to access a DOM element directly. The useRef Hook returns an object with a single property called current. Initially, myRef.current will be null. When React creates a DOM node for this <div>, React will put a reference to this node into myRef.current. You can then access this DOM node from your event handlers and use the built-in browser APIs defined on it.",
  "State - Hooks - ref - useImperativeHandle": "useImperativeHandle is a React Hook that lets you customize the handle exposed as a ref. useImperativeHandle(ref, createHandle, dependencies?)",
  "State - Hooks - effect": "Effects let a component connect to and synchronize with external systems. This includes dealing with network, browser DOM, animations, widgets written using a different UI library, and other non-React code.",
  "State - Hooks - effect - useEffect": "The useEffect Hook allows you to perform side effects in your components. Some examples of side effects are: fetching data, directly updating the DOM, and timers. useEffect accepts two arguments. The second argument is optional. useEffect(<function>, <dependency>)",
  "State - Hooks - effect - useInsertionEffect": "Pitfall. useInsertionEffect is aimed at CSS-in-JS library authors. Unless you are working on a CSS-in-JS library and need a place to inject the styles, you probably want useEffect or useLayoutEffect instead. useInsertionEffect is a version of useEffect that fires before any DOM mutations. useInsertionEffect(setup, dependencies?)",
  "State - Hooks - effect - useLayoutEffect": "useLayoutEffect Pitfall. useLayoutEffect can hurt performance. Prefer useEffect when possible. useLayoutEffect is a version of useEffect that fires before the browser repaints the screen. useLayoutEffect(setup, dependencies?)",
	"State - Hooks - performance": "A common way to optimize re-rendering performance is to skip unnecessary work. For example, you can tell React to reuse a cached calculation or to skip a re-render if the data has not changed since the previous render.",
	"State - Hooks - performance - useTransition": "useTransition is a React Hook that lets you update the state without blocking the UI. const [isPending, startTransition] = useTransition()",
  "State - Hooks - performance - useCallback": "This allows us to isolate resource intensive functions so that they will not automatically run on every render. The useCallback Hook only runs when one of its dependencies update. This can improve performance.",
  "State - Hooks - performance - useMemo": "The useMemo Hook only runs when one of its dependencies update. This can improve performance. The useMemo and useCallback Hooks are similar. The main difference is that useMemo returns a memoized value and useCallback returns a memoized function.",
  "State - Hooks - performance - useDeferredValue": "useDeferredValue is a React Hook that lets you defer updating a part of the UI. const deferredValue = useDeferredValue(value)",
  "State - Hooks - other": "These Hooks are mostly useful to library authors and aren’t commonly used in the application code.",
  "State - Hooks - other - useId": "useId is a React Hook for generating unique IDs that can be passed to accessibility attributes. const id = useId()",
  "State - Hooks - other - useDebugValue": "useDebugValue is a React Hook that lets you add a label to a custom Hook in React DevTools. useDebugValue(value, format?)",
  "State - Hooks - other - useSyncExternalStore": "useSyncExternalStore is a React Hook that lets you subscribe to an external store. const snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)",
  "State - Redux": ".",
  "State - Contexts API": ".",
  "State - Mobx": ".",
  "State - Recoil": ".",
  "State - Zustand": ".",
  "State - Jotai": ".",
  "State - Valtio": ".",
  "State - Signals": ".",
  "State - Classes - deprecated": "Before React 16.8, Class components were the only way to track state and lifecycle on a React component. With the addition of Hooks, Function components are now almost equivalent to Class components. The differences are so minor that you will probably never need to use a Class component in React. Even though Function components are preferred, there are no current plans on removing Class components from React.",

  "DataFetching": "SECTION",
  "DataFetching - React Query": "useQuery",
  "DataFetching - tRPC": "",
  "DataFetching - ServerActions": "",
  "DataFetching -  SWR": "React Hooks for data fetching. Standing for “stale-while-revalidate,” SWR is a strategy and library that makes fetching, caching, and updating data in your React applications a breeze.",

  "CICD": "SECTION",
  "CICD - packaging - modularization": "",
  "CICD - packaging - modularization - Vite": "native ES modules in the browser https://vitejs.dev/",
  "CICD - build - Bit": "Bit is a next-generation building system that develops composable software. https://bit.dev/"

}