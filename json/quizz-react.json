{
  "React": "SECTION",
  "React - ": ".",

  "UI - Tree ": "SECTION",
  "UI - Tree": "React applications use components that form a hierarchical structure to build applications. Components can be functional or class-based and represent reusable UI elements.",
  "UI - Tree - Virtual DOM": "React uses a Virtual DOM, a lightweight representation of the browser DOM. The Virtual DOM allows React to efficiently manage and update the UI. React has introduced a new way of handling routing in web applications and it was the Virtual DOM.",
  "UI - Tree - Virtual DOM - routing": "Instead of using the native browser routing and navigation, we keep all of that in the JavaScript memory and use JavaScript to handle pages and routing for us, and as a result, it will become a lot faster.",
  "UI - Tree - Virtual DOM - reconciler - <16": "React 15 and previous versions of React, in those versions, we had a reconciler called stack reconciler which was a LIFO data structure responsible for picking a work and returning the results just like how the JavaScript call stack works. The main problem was that the stack reconciler was synchronous and sequential meaning there was no chance for it to handle multiple units of work at the same time in parallel or concurrently.",
  "UI - Tree - Virtual DOM - reconciler - >=16": "In React version 16 and above, the React team has introduced a new way of handling the units of work and virtual DOM tree using the new meta called Fiber Reconciler to tackle two main challenges: 1- Synchronous way of processing the units of work 2- Prioritizing and concurrency of the units of work.",
  "UI - Tree - Virtual DOM - reconciler - >=16 - Fiber": "The current React Fiber Reconciler consists of many fiber nodes which are plain JavaScript objects with a lot of properties to handle their work. Fiber = { a JavaScript object with many properties OR unit of work }. Fiber Reconciler = The current React reconciler based on Fiber objects or units of work. https://maxtsh.medium.com/how-does-the-react-fiber-reconciler-work-77c3650127da",
  "UI - Tree - shaking": "Leverage tree shaking techniques, typically provided by bundlers like webpack, to eliminate unused code from your JavaScript bundle. This helps reduce the overall bundle size and improve loading time.",

  "UI - Components": "SECTION",
	"UI - Components - Functional Components": "Functional components are JavaScript functions that take in props as parameters and return React elements. Stateless, less code, easier to test and better perfaormance. ",
  "UI - Components - Class Components": "They have a more feature-rich API, including state and lifecycle methods.- They are used when you need to manage the component’s state or lifecycle events.",
  "UI - Components - Class Components - React.Component": "Class components are ES6 classes that extend from `React.Component`.",
  "UI - Components - Class Components - React.PureComponent": "React.PureComponent is similar to React.Component . The difference between them is that React.Component doesn't implement shouldComponentUpdate(). React.PureComponent is a base component class that checks the fields of state and props to know whether the component should be updated. React.PureComponent optimizes our components by reducing the number of wasted renders.",
  "UI - Components - Class Components - this": "React will not auto-bind your functions within components. However, you may manually achieve the binding. Here are some ways to bind your components and functions: Bind in render, Allow arrow function in render, Bind in constructor, Bind arrow function in the class property [Not in official ECMAscript]",
	"UI - Components - Class Components - Lifecycle - ": "These methods are called in the following order when an instance of a component is being created and inserted into the DOM.",
  "UI - Components - Class Components - Lifecycle - Mounting": "When a React application is first loaded, React constructs the initial Virtual DOM tree based on the component hierarchy. Each component’s render method is called to generate the corresponding Virtual DOM representation.",
  "UI - Components - Class Components - Lifecycle - Mounting - constructor()": "The constructor runs before your class component mounts (gets added to the screen). Typically, a constructor is only used for two purposes in React. It lets you declare state and bind your class methods to the class instance:",
  "UI - Components - Class Components - Lifecycle - Mounting - getDerivedStateFromProps()": "During the mounting phase, getDerivedStateFromProps() is called after the constructor and before render(). This method is called for every render cycle and provides an opportunity to update the component's state based on changes in props before the initial render.",
	"UI - Components - Class Components - Lifecycle - Mounting - render()": "The render() method is responsible for generating the component's virtual DOM representation based on its current props and state. It is called every time the component needs to be re-rendered, either because its props or state have changed, or because a parent component has been re-rendered.",
  "UI - Components - Class Components - Lifecycle - Mounting - componentDidMount()": "The componentDidMount() method is called once the component has been mounted into the DOM. It is typically used to set up any necessary event listeners or timers, perform any necessary API calls or data fetching, and perform other initialization tasks that require access to the browser's DOM API.",
  "UI - Components - Class Components - Lifecycle - Mounting - componentWillMount()": "Deprecated. ",
	"UI - Components - Class Components - Lifecycle - Diffing": "React performs a diffing algorithm to compare the previous Virtual DOM with the new one, and react determines which parts of the actual DOM need to be updated by comparing the differences.",
  "UI - Components - Class Components - Lifecycle - Diffing - shouldComponentUpdate()": "The shouldComponentUpdate()  method is called before a component is updated. It takes two arguments: nextProps and nextState. This method returns a boolean value that determines whether the component should update or not. If this method returns true, the component will update, and if it returns false, the component will not update.",
	"UI - Components - Class Components - Lifecycle - Diffing - Why did you update": "If you are still not satisfied by the output of React performance tools, you can still use “why-did-you-update” library that hooks into React and detects potentially unnecessary component renders. The library once goes in an active stage will shout out into your console anytime a piece of state makes your component update which in reality shouldn’t update at all.",
	"UI - Components - Class Components - Lifecycle - Reconciliation": "After the initial render, any changes to the application state or props trigger React’s reconciliation process. React optimization applies the necessary changes to the browser DOM to reflect the updated Virtual DOM. However, instead of updating every DOM node individually, React optimizes the process by batching updates and efficiently applying them. React uses a “reconciliation” technique to minimize the number of DOM manipulations required.",
	"UI - Components - Class Components - Lifecycle - Updating": "An update can be caused by changes to props or state. These methods are called in the following order when a component is being re-rendered.",
  "UI - Components - Class Components - Lifecycle - Updating - static getDerivedStateFromProps()": ".",
  "UI - Components - Class Components - Lifecycle - Updating - render()": ".",
  "UI - Components - Class Components - Lifecycle - Updating - getSnapshotBeforeUpdate()": "The getSnapshotBeforeUpdate() method is called just before the component's UI is updated. It allows the component to capture some information about the current state of the UI, such as the scroll position before it changes. This method returns a value that is passed as the third parameter to the componentDidUpdate() method.",
  "UI - Components - Class Components - Lifecycle - Updating - componentWillUpdate()": "componentWillUpdate() is a lifecycle method in React that gets called just before a component's update cycle starts.",
  "UI - Components - Class Components - Lifecycle - Updating - componentDidUpdate()": "The componentDidUpdate() method is a lifecycle method in React that is called after a component has been updated and re-rendered.",
	"UI - Components - Class Components - Lifecycle - Unmounting - componentWillUnmount()": "React will call it before your component is removed (unmounted) from the screen.",
  "UI - Components - Class Components - Lifecycle - Error Handling": "These methods are called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component.",
  "UI - Components - Class Components - Lifecycle - Error Handling - static getDerivedStateFromError()": ".", 
  "UI - Components - Class Components - Lifecycle - Error Handling - componentDidCatch()": ".",
	"UI - Components - Logic - Events": ".",
	"UI - Components - Logic - Events - Throttling": "Throttling in React is a technique used to limit the number of times a function or an event handler is invoked by postponing the execution of a function. It ensures that the function is called at a specified interval, preventing it from being executed too frequently. Throttling allows you to control the rate at which the function is called by setting up a minimum time interval between each function invocation. If the function is called multiple times within that interval, only the first invocation is executed, and subsequent invocations are ignored until the interval elapses.",
	"UI - Components - Logic - Events - Debouncing": "Debouncing, as opposed to throttling, is a method to stop the event trigger from firing too frequently. Debouncing, on the other hand, is also used to limit the number of times a function or an event handler is invoked. It ensures that the function is called only after a certain period of inactivity. Debouncing allows you to postpone the function call until the user has finished typing or a specific time has elapsed since the last event..",
  "UI - Components - Logic - Hooks - useId": "useId is a React Hook for generating unique IDs that can be passed to accessibility attributes. const id = useId()",
  "UI - Components - Logic - Hooks - useDebugValue": "useDebugValue is a React Hook that lets you add a label to a custom Hook in React DevTools. useDebugValue(value, format?)",
	"UI - Components - Props": "React components use props to communicate with each other. The component receives the argument as a props object. Every parent component can pass some information to its child components by giving them props. ",
  "UI - Components - Props - syntax": "React Props are like function arguments in JavaScript and attributes in HTML. Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, and functions.",
  "UI - Components - Props - syntax - quotes": "You may use quotes to specify string literals as attributes: const element = <a href='https://www.reactjs.org'> link </a>;",
  "UI - Components - Props - syntax - curly braces": "You may also use curly braces to embed a JavaScript expression in an attribute: const element = <img src={user.avatarUrl}></img>;.",
  "UI - Components - Props - passing props": "Props are the information that you pass to a JSX tag.",
  "UI - Components - Props - forwarding props": "Props are the information that you pass to a JSX tag.",
	"UI - Components - Props - props drilling": ".",
	"UI - Components - Props - spreading": "<div {...props}>{props.text}</div> should avoid spreading properties into a DOM element as it adds unknown HTML attribute, which is unnecessary and a bad practice.",
	"UI - Components - Layout": ".",
	"UI - Components - Layout - Layout pattern": "The main idea behind the Layout component pattern is that components should not know where they are being displayed, and Layout components should only be concerned with displaying the component.",
	"UI - Components - JSX": "Returned by Components.",
  "UI - Components - JSX - elements": "React elements are immutable. Once you create an element, you can’t change its children or attributes.",
  "UI - Components - JSX - nesting": "When you nest content inside a JSX tag, the parent component will receive that content in a prop called children.",
  "UI - Components - JSX - transpilation": "JSX allows you to write HTML-like code in your JavaScript. It gets transpiled by a tool like Babel to JavaScript before being rendered in the browser..",
  "UI - Components - JSX - transpilation - Babel": "Browsers don’t understand JSX out of the box, so most React users rely on a compiler like Babel or TypeScript to transform JSX code into regular JavaScript.",
  "UI - Components - JSX - transpilation - React.createElement()": "Babel compiles JSX down to React.createElement() calls.",
  "UI - Components - JSX - expressions": "You can put any valid JavaScript expression inside the curly braces in JSX.",
  "UI - Components - JSX - injection attacks": "By default, React DOM escapes any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that’s not explicitly written in your application. Everything is converted to a string before being rendered. This helps prevent XSS (cross-site-scripting) attacks.",
	"UI - Components - JSX - Built-in - <Fragment>": "<Fragment>, often used via <>...</> syntax, lets you group elements without a wrapper node. This is particularly useful when you need to return multiple elements from a component's render method, but you don't want to introduce unnecessary DOM elements that could affect the layout or styles of your application.",
  "UI - Components - JSX - Built-in - <Profiler>": "<Profiler> lets you measure rendering performance of a React tree programmatically.",
  "UI - Components - JSX - Built-in - <StrictMode>": "<StrictMode> lets you find common bugs in your components early during development. <StrictMode> <App /> </StrictMode>",
  "UI - Components - JSX - Built-in - <Suspense>": "<Suspense> lets you display a fallback until its children have finished loading. <Suspense fallback={<Loading />}> <SomeComponent /> </Suspense>",
  "UI - Components - JSX - Built-in - <input>": "The built-in browser <input> component lets you render different kinds of form inputs. <input />",
  "UI - Components - JSX - Built-in - <option>": "The built-in browser <option> component lets you render an option inside a <select> box. <select>  <option value='someOption'>Some option</option> <option value='otherOption'>Other option</option> </select>",
  "UI - Components - JSX - Built-in - <progress>": "The built-in browser <progress> component lets you render a progress indicator. <progress value={0.5} />",
  "UI - Components - JSX - Built-in - <select>": "The built-in browser <select> component lets you render a select box with options. <select>  <option value='someOption'>Some option</option> <option value='otherOption'>Other option</option> </select>",
  "UI - Components - JSX - Built-in - <textarea>": "The built-in browser <textarea> component lets you render a multiline text input. <textarea />",
  "UI - Components - JSX - Built-in - Common": "All built-in browser components, such as <div>, support some common props and events. https://beta.reactjs.org/reference/react-dom/components/common",

  "UI - Apps": "SECTION",
	"UI - Apps - Modules": ".",
  "UI - Apps - Modules - Import": "Importing more components or modules than necessary can increase bundle size and negatively impact performance. Import only the specific components or functions you need from a module. Use code-splitting to load components on demand.",
  "UI - Apps - Modules - Export": ".",
  "UI - Apps - Patterns - Base UI Component": "",
  "UI - Apps - Patterns - Base UI Component - BaseUI": "https://baseweb.design/",
  "UI - Apps - Patterns - Inheritance": "No use",
  "UI - Apps - Patterns - Composition": "",
  "UI - Apps - Patterns - Compound": "The Compound Components pattern isn’t just a coding technique; it’s a design paradigm that promotes collaboration between components while maintaining loose coupling. Recognizing its value involves understanding the use of static properties, which resemble dot notation for accessing nested components within a parent component. https://medium.com/@khushi1399gupta/mastering-reacts-compound-components-a-guide-for-experienced-developers-8a35c1468acb",
  "UI - Apps - APIs": "the react package exports a few other APIs that are useful for defining components.",
  "UI - Apps - APIs - act": "act is a test helper to apply pending React updates before making assertions.",
  "UI - Apps - APIs - cache": "cache is only for use with React Server Components.",
  "UI - Apps - APIs - createContext": "createContext lets you create a context that components can provide or read.",
  "UI - Apps - APIs - forwardRef": "forwardRef lets your component expose a DOM node to parent component with a ref.",
  "UI - Apps - APIs - lazy": "lazy lets you defer loading component’s code until it is rendered for the first time.",
  "UI - Apps - APIs - memo": "memo lets you skip re-rendering a component when its props are unchanged.",
  "UI - Apps - APIs - startTransition": "startTransition lets you update the state without blocking the UI.",
  "UI - Apps - APIs - use": "use is a React API that lets you read the value of a resource like a Promise or context.",
  "UI - Apps - APIs - taintObjectReference": "lets you prevent a specific object instance from being passed to a Client Component like a user object.",
  "UI - Apps - APIs - taintUniqueValue": "lets you prevent unique values from being passed to Client Components like passwords, keys, or tokens.",

  "UI - Execution": "SECTION",
  "UI - Execution - Stages": "Any screen update in a React app happens in three steps: Trigger, Render, Commit",
  "UI - Execution - Triggering": ".",
  "UI - Execution - Rendering": "Rendering takes a snapshot in time. After rendering (calling) your components, React will modify the DOM.",
  "UI - Execution - Rendering - Cascading": "Re-renders in React are cascading. Every time you change state in a React component, you trigger a re-render of that component, every component inside, components inside of those components, etc., until the end of the component tree is reached.",
  "UI - Execution - Rendering - Conditional": ".",
  "UI - Execution - Rendering - Rerendering": ".",
  "UI - Execution - Rendering - caching": "Cache data fetched from APIs or expensive computations to prevent unnecessary re-fetching or re-computation. By storing data in memory or leveraging browser caching mechanisms, you can reduce network latency and improve app responsiveness.",
  "UI - Execution - Rendering - memoization": "Memoization in React is a technique used to optimize the performance of functional components by caching the results of expensive computations or function calls. In web development, memoization is the process of storing data (e.g. a variable value) in the cache and then retrieving this information next time it is needed (e.g. on a page or component re-render).",
  "UI - Execution - Rendering - memoization - React.memo": "By using React.memo(), the rendering result is cached based on props. If the props haven't changed since the last render, React reuses the previously rendered result instead of redoing the rendering process. This saves time and resources.",
  "UI - Execution - Rendering - memoization - useMemo": "This hook allows you to cache the result of a function output and retrieve this information when it’s needed, without recomputing the value all over again.",
  "UI - Execution - Rendering - memoization - useCallback": "The useCallback hook is very similar to useMemo. The main difference is that useMemo returns a memoized value while useCallback returns a memoized function.",
  "UI - Execution - Rendering - memoization - React Compiler": "Now, everything I’ve just told you about useMemo and useCallback may become totally irrelevant when React Compiler is released! Although useMemo and useCallback serve their purpose in React right now, they also increase mental overhead for developers, hence the reason React Compiler is in the pipeline. React Compiler is a low-level, auto-memoizing compiler that will handle all memoization without you - the developer - having to do anything at all.React Compiler is an ‘auto-memoizing compiler’ that automates all memoizations in your application. In simpler terms, this means that it will automatically detect the need for useMemo and useCallback so you will no longer have to think about these hooks or which one you need to use for a certain situation.",
  "UI - Execution - Rendering - memoization - React Compiler - plugAndPlay": "The Compiler is plug-and-play: you install it, and it Just Works; there is no need to rewrite existing code.",
	"UI - Execution - Rendering - Hooks - performance": "A common way to optimize re-rendering performance is to skip unnecessary work. For example, you can tell React to reuse a cached calculation or to skip a re-render if the data has not changed since the previous render.",
	"UI - Execution - Rendering - Hooks - performance - useTransition": "useTransition is a React Hook that lets you update the state without blocking the UI. const [isPending, startTransition] = useTransition(). The useTransition hook in React plays a pivotal role in improving the performance of applications by allowing the marking of state updates as non-blocking transitions. This capability enables React to defer rendering for these updates, preventing UI blocking and enhancing overall responsiveness.",
  "UI - Execution - Rendering - Hooks - performance - useCallback": "This allows us to isolate resource intensive functions so that they will not automatically run on every render. The useCallback Hook only runs when one of its dependencies update. This can improve performance.",
  "UI - Execution - Rendering - Hooks - performance - useMemo": "The useMemo Hook only runs when one of its dependencies update. This can improve performance. The useMemo and useCallback Hooks are similar. The main difference is that useMemo returns a memoized value and useCallback returns a memoized function.",
  "UI - Execution - Rendering - Hooks - performance - useDeferredValue": "useDeferredValue is a React Hook that lets you defer updating a part of the UI. const deferredValue = useDeferredValue(value)",
	"UI - Execution - Rendering - lazy loading": "",
	"UI - Execution - Rendering - lazy loading - React.lazy": "React.lazy is a feature that allows you to lazily load components, meaning they are loaded only when needed.",
	"UI - Execution - Rendering - lazy loading - Suspense": "Suspense is a component that can be used to define a fallback UI while the lazily loaded component is being loaded. By reducing lazy-loading components that are not immediately needed, you can lower the initial load time of your application. This technique is especially useful for large applications with complex component hierarchies.",
	"UI - Execution - Rendering - lists - keys": "Keys must be unique among siblings. However, it’s okay to use the same keys for JSX nodes in different arrays. Keys must not change or that defeats their purpose! Don’t generate them while rendering.",
	"UI - Execution - Rendering - lists - keys - index": "You might be tempted to use an item’s index in the array as its key. In fact, that’s what React will use if you don’t specify a key at all. But the order in which you render items will change over time if an item is inserted, deleted, or if the array gets reordered. Index as a key often leads to subtle and confusing bugs.",
	"UI - Execution - Rendering - lists - keys - generated": "Similarly, do not generate keys on the fly, e.g. with key={Math.random()}. This will cause keys to never match up between renders, leading to all your components and DOM being recreated every time. Not only is this slow, but it will also lose any user input inside the list items. Instead, use a stable ID based on the data.",
	"UI - Execution - Rendering - lists - filter": ".",
	"UI - Execution - Rendering - lists - map": ".",
	"UI - Execution - Rendering - lists - windowing": "List visualization, or windowing, involves rendering only the items currently visible on the screen. When dealing with a large number of items in a list, rendering all the items at once can lead to slow performance and consume a significant amount of memory. List virtualization tackles this issue by rendering only a subset of the list items currently visible within the view, which conserves resources as the users scroll through the list.",
  "UI - Execution - Rendering - lists - windowing - virtualization": "The virtualization technique dynamically replaces rendered items with new ones, keeping the visible portion of the list updated and responsive. It efficiently allows you to render large lists or tabular data by only rendering the visible portion, recycling components as needed, and optimizing scroll performance. There are different approaches to implementing list visualization in React, and one is using a popular library called React Virtualized.",
  "UI - Execution - Rendering - lists - windowing - Unique Keys": "When rendering lists, always provide unique keys to help React identify which items have changed, added, or removed. This can prevent unnecessary re-renders and improve overall performance.",
  "UI - Execution - Rendering - lists - windowing - Batch Updates": "Utilize React's batched updates mechanism to minimize the number of re-renders when updating lists. By batching multiple updates into a single render pass, you can optimize performance and ensure a smoother user experience.",
	"UI - Execution - Rendering - images - lazy loading": "Similar to the list virtualization technique, lazy loading images prevents the creation of unnecessary DOM nodes, thereby boosting performance. Lazy loading allows you to defer or delay the loading of images until they are needed or visible to the user instead of loading all the images on page load..",
	"UI - Execution - Rendering - images - lazy loading - technique": "The concept behind lazy loading is to initiate the load of a placeholder or a small low-resolution version of the image, typically a small-sized thumbnail or a blurred placeholder. As the user scrolls or interacts with the page, the actual image is loaded dynamically, replacing the placeholder when the user enters the viewport or when it becomes visible. Lazy loading in React can be achieved using various libraries and techniques. One of the popular libraries is the react-lazyload.  .",
	"UI - Execution - Rendering - images - lazy loading - compression": "Image compression reduces the file size of images without significant loss of visual quality..",
  "UI - Execution - Committing": ".",
  "UI - Execution - WebWorkers": "JS code runs on a single thread. Running a long process on the same thread will seriously affect the UI-rendering code, so the best bet is to move the process to another thread. This is done by Web workers. They are the gateway where we can create a thread and run it parallel to the main thread without hampering the UI-flow.",
  "UI - Execution - WebWorkers - Parallel Processing": "Web Workers enable parallel processing by allowing you to execute JavaScript code in separate threads. This means that computationally intensive tasks can be offloaded to Web Workers, running concurrently with the main thread and significantly reducing the impact on overall performance.",
  "UI - Execution - WebWorkers - Offloading Expensive Computations": "By moving complex calculations, data processing, or heavy algorithms to Web Workers, you prevent them from blocking the main thread. This ensures that user interactions remain responsive and smooth UI even when dealing with intensive computations.",
  "UI - Execution - WebWorkers - Asynchronous Execution": "Web Workers communicate with the main thread via messages, allowing for asynchronous execution of tasks. This means time-consuming operations can be processed in the background without blocking the main thread, and results can be sent back asynchronously when ready.",
  "UI - Execution - WebWorkers - Improved Responsiveness": "Offloading expensive computations to Web Workers prevents UI freezes or slowdowns caused by long-running operations. Users can continue interacting with the application while the Web Workers handle the computationally intensive tasks in the background, leading to a more responsive and seamless experience.",
	"UI - Testing": ".",
	"UI - Testing - JEST": ".",
	"UI - Testing - Vite": ".",
	"UI - Testing - Playwright": ".",
	"UI - Testing - Cypress": ".",

  "State": "SECTION",
  "State ": "State lets a component “remember” information like user input.",
	"State - Update": "setting state requests a re-render from React. This means that for an interface to react to the event, you need to update the state.",
  "State - Update - SetState": "We recommend using a function and not an object in the setState function. React setState method is asynchronous. This means that rather than immediately mutating this.state, setState() creates a pending state transition. If you access this.state after calling this method, it would potentially return the existing value. To prevent this, use the callback function of setState to run code after the call is completed.",
  "State - Inmmutability": "React state should be treated as immutable. We should never mutate this.state directly, as calling setState() afterward may replace the mutation you made.",
  "State - Inmmutability - libraries": "But it’s better to use an optimized library which provides a set of immutable data structures.",
  "State - Inmmutability - libraries - Immutability Helper": "This is a good library when it’s comes to mutating a data copy without changing the source.",
  "State - Inmmutability - libraries - Immutable.js": "provides a lot of persistent immutable data structures, including: List, Stack, Map, OrderedMap, Set, OrderedSet, and Record.",
  "State - Inmmutability - libraries - Seamless-immutable:": "A library for immutable JavaScript data structures that are backward-compatible with normal arrays and objects.",
  "State - Inmmutability - libraries - React-copy-write": "An immutable React state management library with a simple mutable API, memoized selectors, and structural sharing.",
	"State - Provider": "Sharing status",
  "State - Hooks - state - useState": "The React useState Hook allows us to track state in a function component. State generally refers to data or properties that need to be tracking in an application.",
  "State - Hooks - state - useReducer": "The useReducer Hook is similar to the useState Hook. It allows for custom state logic. If you find yourself keeping track of multiple pieces of state that rely on complex logic, useReducer may be useful. useReducer(<reducer>, <initialState>)",
  "State - Hooks - context": "Context lets a component receive information from distant parents without passing it as props.",
  "State - Hooks - context - useContext": "React Context is a way to manage state globally. It can be used together with the useState Hook to share state between deeply nested components more easily than with useState alone.",
  "State - Hooks - ref": "Refs let a component hold some information that isn’t used for rendering, like a DOM node or a timeout ID. Unlike with state, updating a ref does not re-render your component. Refs are an “escape hatch” from the React paradigm. They are useful when you need to work with non-React systems, such as the built-in browser APIs.",
  "State - Hooks - ref - useRef": "The useRef Hook allows you to persist values between renders. It can be used to store a mutable value that does not cause a re-render when updated. It can be used to access a DOM element directly. The useRef Hook returns an object with a single property called current. Initially, myRef.current will be null. When React creates a DOM node for this <div>, React will put a reference to this node into myRef.current. You can then access this DOM node from your event handlers and use the built-in browser APIs defined on it.",
  "State - Hooks - ref - useImperativeHandle": "useImperativeHandle is a React Hook that lets you customize the handle exposed as a ref. useImperativeHandle(ref, createHandle, dependencies?)",
  "State - Hooks - effect": "Effects let a component connect to and synchronize with external systems. This includes dealing with network, browser DOM, animations, widgets written using a different UI library, and other non-React code.",
  "State - Hooks - effect - useEffect": "The useEffect Hook allows you to perform side effects in your components. Some examples of side effects are: fetching data, directly updating the DOM, and timers. useEffect accepts two arguments. The second argument is optional. useEffect(<function>, <dependency>)",
  "State - Hooks - effect - useInsertionEffect": "Pitfall. useInsertionEffect is aimed at CSS-in-JS library authors. Unless you are working on a CSS-in-JS library and need a place to inject the styles, you probably want useEffect or useLayoutEffect instead. useInsertionEffect is a version of useEffect that fires before any DOM mutations. useInsertionEffect(setup, dependencies?)",
  "State - Hooks - effect - useLayoutEffect": "useLayoutEffect Pitfall. useLayoutEffect can hurt performance. Prefer useEffect when possible. useLayoutEffect is a version of useEffect that fires before the browser repaints the screen. useLayoutEffect(setup, dependencies?)",
  "State - Hooks - custom": "https://javascript.plainenglish.io/collection-of-custom-hooks-for-your-nextjs-react-project-1779379e6f4a",
  "State - libraries - Redux": ".",
  "State - libraries - Redux - performance": "A well-known flaw faced by Yahoo is a classic example to consider when React apps are built with Redux. Indeed the combination is deadly and enables complex situations to structurize, but when you use Redux, your React app rerenders and slows down your performance.",
  "State - libraries - Contexts API": ".",
  "State - libraries - Mobx": ".",
  "State - libraries - Recoil": ".",
  "State - libraries - Zustand": ".",
  "State - libraries - Jotai": ".",
  "State - libraries - Valtio": ".",
  "State - libraries - Signals": ".",
  "State - libraries - Classes - deprecated": "Before React 16.8, Class components were the only way to track state and lifecycle on a React component. With the addition of Hooks, Function components are now almost equivalent to Class components. The differences are so minor that you will probably never need to use a Class component in React. Even though Function components are preferred, there are no current plans on removing Class components from React.",

  "DataFetching": "SECTION",
  "DataFetching - Hooks - other - useSyncExternalStore": "useSyncExternalStore is a React Hook that lets you subscribe to an external store. const snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)",
  "DataFetching - React Query": "useQuery",
  "DataFetching - tRPC": "",
  "DataFetching - ServerActions": "",
  "DataFetching - SWR": "React Hooks for data fetching. Standing for “stale-while-revalidate,” SWR is a strategy and library that makes fetching, caching, and updating data in your React applications a breeze.",

  "CICD": "SECTION",
  "CICD - packaging": "",
  "CICD - packaging - splitting": "When you develop a new React application, all your JavaScript code is typically bundled together into a single file. This file contains all the components, libraries, and other code required for your application to function. But as your application grows, the bundle size can become quite large, resulting in slow initial load times for your users. Code splitting allows you to divide a single bundle into multiple chunks, which can be loaded selectively based on the current needs of your application. Instead of downloading the entire bundle upfront, only the necessary code is fetched and executed when a user visits a particular page or triggers a specific action.",
  "CICD - packaging - splitting - libraries - CommonsChunkPlugin": "",
  "CICD - packaging - splitting - libraries - SplitChunksPlugin": "",
  "CICD - packaging - trim": "If you wish to eliminate code redundancy, learn to trim your Javascript packages. When you cut-off duplicates and unnecessary code, the possibility of your React app performance multiplies. You must analyze and determine bundled code..",
  "CICD - packaging - react Profiler": "The React Profiler is a tool that comes with the React Developer Tools extension. It allows you to measure and analyze the rendering performance of your components. The React Profiler lets you identify components that take longer to render and detect potential performance bottlenecks.",
  "CICD - packaging - modularization": "",
  "CICD - packaging - modularization - Vite": "native ES modules in the browser https://vitejs.dev/",
  "CICD - packaging - WebPack": "",
  "CICD - packaging - Webpack Bundle Analyzer": "Webpack Bundle Analyzer helps analyze the size of webpack bundles and identify opportunities for optimization. By visualizing the composition of your bundles, you can pinpoint large dependencies or chunks that can be split or optimized.",
  "CICD - build": "",
  "CICD - build - production": "Make sure to test any performance issues you may be seeing with your React apps using the production build's minified version.",
  "CICD - build - Bit": "Bit is a next-generation building system that develops composable software. https://bit.dev/"

}