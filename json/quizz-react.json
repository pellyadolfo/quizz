{
  "Structure": "SECTION",
  "Structure - Components - CreateClass - 2013": "Deprecated. Everything started out with React's createClass Components. The createClass method provided developers with a factory method to create React class components without using a JavaScript class. It was the status quo for creating React components prior JavaScript ES6, because in JavaScript ES5 there was no class syntax available. const MyComponent = React.createClass({ render() { return <p>I am a component!</p>; } });",
  "Structure - Components - CreateClass - deprecated": "Note: React's createClass method is no longer available in the React core package. If you want to try it, you have to install an additional node package: npm install create-react-class. After all, you should only use React's createClass method, if you have no JavaScript ES6 or beyond available in your project. Otherwise you should avoid using it. ",
  "Structure - Components - CreateClass - methods - getInitialState": "the getInitialState() function is used to set an initial state for the React component",
  "Structure - Components - CreateClass - methods - render": "the mandatory render() method is there to display the output with JSX",
  "Structure - Components - CreateClass - methods - onChange": "Additional methods (e.g. onChange()) are added by passing more functions to the object.",
  "Structure - Components - CreateClass - Lifecycle - componentDidUpdate": "Lifecycle methods for side-effects are available as well. For instance, in order to write every time the value from the input field to the browser's local storage, we could make use of the componentDidUpdate() lifecycle method by passing a function to the object with an object key named after a React lifecycle method.",
	"Structure - Components - Class - ES6": "They have a more feature-rich API, including state and lifecycle methods.- They are used when you need to manage the component’s state or lifecycle events.",
	"Structure - Components - Class - deprecated": "Probably never need to use a Class component in React anymore. Even though Function components are preferred, there are no current plans on removing Class components from React",
  "Structure - Components - Class - React.Component": "Class components are ES6 classes that extend from `React.Component`.",
  "Structure - Components - Class - React.PureComponent": "React.PureComponent is similar to React.Component . The difference between them is that React.Component doesn't implement shouldComponentUpdate(). React.PureComponent is a base component class that checks the fields of state and props to know whether the component should be updated. React.PureComponent optimizes our components by reducing the number of wasted renders.",
  "Structure - Components - Class - Structure": "You want to have a clear structure in components so you can navigate through them quickly and have a pattern that is obvious to other engineers: 1- State declarations, 2 - Ref declarations, 3 - Memoized values, 4 - Memoized callbacks, 5 - Custom hooks, 6 - Effects, 7 Event handler, 8- JSX",
  "Structure - Components - Class - this": "React will not auto-bind your functions within components. However, you may manually achieve the binding. Here are some ways to bind your components and functions: Bind in render, Allow arrow function in render, Bind in constructor, Bind arrow function in the class property [Not in official ECMAscript]",
  "Structure - Components - Class - render()": "renders JSX",
	"Structure - Components - Class - Lifecycle - ": "These methods are called in the following order when an instance of a component is being created and inserted into the DOM.",
  "Structure - Components - Class - Lifecycle - Mounting": "When a React application is first loaded, React constructs the initial Virtual DOM tree based on the component hierarchy. Each component’s render method is called to generate the corresponding Virtual DOM representation.",
  "Structure - Components - Class - Lifecycle - Mounting - constructor()": "The constructor runs before your class component mounts (gets added to the screen). Typically, a constructor is only used for two purposes in React. It lets you declare state and bind your class methods to the class instance:",
  "Structure - Components - Class - Lifecycle - Mounting - getDerivedStateFromProps()": "During the mounting phase, getDerivedStateFromProps() is called after the constructor and before render(). This method is called for every render cycle and provides an opportunity to update the component's state based on changes in props before the initial render.",
	"Structure - Components - Class - Lifecycle - Mounting - render()": "The render() method is responsible for generating the component's virtual DOM representation based on its current props and state. It is called every time the component needs to be re-rendered, either because its props or state have changed, or because a parent component has been re-rendered.",
  "Structure - Components - Class - Lifecycle - Mounting - componentDidMount()": "The componentDidMount() method is called once the component has been mounted into the DOM. It is typically used to set up any necessary event listeners or timers, perform any necessary API calls or data fetching, and perform other initialization tasks that require access to the browser's DOM API.",
  "Structure - Components - Class - Lifecycle - Mounting - componentWillMount()": "Deprecated. ",
	"Structure - Components - Class - Lifecycle - Diffing": "React performs a diffing algorithm to compare the previous Virtual DOM with the new one, and react determines which parts of the actual DOM need to be updated by comparing the differences.",
  "Structure - Components - Class - Lifecycle - Diffing - shouldComponentUpdate()": "The shouldComponentUpdate()  method is called before a component is updated. It takes two arguments: nextProps and nextState. This method returns a boolean value that determines whether the component should update or not. If this method returns true, the component will update, and if it returns false, the component will not update.",
	"Structure - Components - Class - Lifecycle - Diffing - Why did you update": "If you are still not satisfied by the output of React performance tools, you can still use “why-did-you-update” library that hooks into React and detects potentially unnecessary component renders. The library once goes in an active stage will shout out into your console anytime a piece of state makes your component update which in reality shouldn’t update at all.",
	"Structure - Components - Class - Lifecycle - Reconciliation": "After the initial render, any changes to the application state or props trigger React’s reconciliation process. React optimization applies the necessary changes to the browser DOM to reflect the updated Virtual DOM. However, instead of updating every DOM node individually, React optimizes the process by batching updates and efficiently applying them. React uses a “reconciliation” technique to minimize the number of DOM manipulations required.",
	"Structure - Components - Class - Lifecycle - Updating": "An update can be caused by changes to props or state. These methods are called in the following order when a component is being re-rendered.",
  "Structure - Components - Class - Lifecycle - Updating - static getDerivedStateFromProps()": ".",
  "Structure - Components - Class - Lifecycle - Updating - render()": ".",
  "Structure - Components - Class - Lifecycle - Updating - getSnapshotBeforeUpdate()": "The getSnapshotBeforeUpdate() method is called just before the component's UI is updated. It allows the component to capture some information about the current state of the UI, such as the scroll position before it changes. This method returns a value that is passed as the third parameter to the componentDidUpdate() method.",
  "Structure - Components - Class - Lifecycle - Updating - componentWillUpdate()": "componentWillUpdate() is a lifecycle method in React that gets called just before a component's update cycle starts.",
  "Structure - Components - Class - Lifecycle - Updating - componentDidUpdate()": "The componentDidUpdate() method is a lifecycle method in React that is called after a component has been updated and re-rendered.",
	"Structure - Components - Class - Lifecycle - Unmounting - componentWillUnmount()": "React will call it before your component is removed (unmounted) from the screen.",
	"Structure - Components - Functional": "Functional components are JavaScript functions that take in props as parameters and return React elements. Stateless, less code, easier to test and better perfaormance. ",
	"Structure - Components - Function - Preferred": "In the past, it wasn't possible to use state or side-effects in Function Components -- that's why they were called Functional Stateless Components -- but that's not the case anymore with React Hooks which rebranded them to Function Components. React Hooks bring state and side-effects to React Function Components.",
	"Structure - Components - Function - Lifecycle - No Constructor": "First of all, you have no constructor in a Function Component. Usually the constructor would have been used in a React Class Component to allocate initial state. As you have seen, you don't need it in a Function Component, because you allocate initial state with the useState hook and set up functions within the Function Component for further business logic",
	"Structure - Components - Function - Lifecycle - Simulate Mount": "there is the mounting lifecycle for React components when they are rendered for the first time. If you want to execute something when a React Function Component did mount, you can use the useEffect hook: https://www.robinwieruch.de/react-function-component/#react-arrow-function-component",
	"Structure - Components - Function - Lifecycle - Update": "Every time incoming props or state of the component change, the component triggers a rerender to display the latest status quo which is often derived from the props and state. A render executes everything within the Function Component's body.",
	"Structure - Components - Function - Lifecycle - Rerender": "React memo -- which is one of React's top level APIs -- can be used for React Function Components to prevent a rerender when the incoming props of this component haven't changed:",
	"Structure - Components - Function - Lifecycle - ref": "React Function Components cannot be given refs! If you try the following, the ref will be assigned to the component instance but not to the actual DOM node.",
  "Structure - Components - Function - Lifecycle - Hooks": "Before React 16.8, Class components were the only way to track state and lifecycle on a React component. With the addition of Hooks, Function components are now almost equivalent to Class components.",
	"Structure - Components - Arrow Function": "With the introduction of JavaScript ES6, new coding concepts were introduced to JavaScript and therefore to React. For instance, a JavaScript function can be expressed as lambda (arrow function). That's why a Function Component is sometimes called Arrow Function Components (or maybe also Lambda Function Component). const App = () => { ... };",
	"Structure - Router - ReactRouter": "",
	"Structure - Router - TanStackRouter": "",

  "Data": "SECTION",
	"Data - Props": "React components use props to communicate with each other. The component receives the argument as a props object. Every parent component can pass some information to its child components by giving them props. Passing props from component to component in React doesn't make components interactive, because props are read-only and therefore immutable.",
  "Data - Props - syntax": "React Props are like function arguments in JavaScript and attributes in HTML. Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, and functions.",
  "Data - Props - syntax - quotes": "You may use quotes to specify string literals as attributes: const element = <a href='https://www.reactjs.org'> link </a>;",
  "Data - Props - syntax - curly braces": "You may also use curly braces to embed a JavaScript expression in an attribute: const element = <img src={user.avatarUrl}></img>;.",
	"Data - Props - spreading": "<div {...props}>{props.text}</div> should avoid spreading properties into a DOM element as it adds unknown HTML attribute, which is unnecessary and a bad practice.",
  "Data - Props - passing props": "Props are the information that you pass to a JSX tag.",
  "Data - Props - taintObjectReference": "lets you prevent a specific object instance from being passed to a Client Component like a user object.",
  "Data - Props - taintUniqueValue": "lets you prevent unique values from being passed to Client Components like passwords, keys, or tokens.",
	"Data - Props - forwarding props": "Props are the information that you pass to a JSX tag.",
	"Data - Props - Props Drilling": "At some point, you are passing a lot of props down your component tree. Depending on the depth of the component tree, it can happen that many props are passed from a top level component to all the leaf components. Every component in between has to pass the props even though it may not be interested in the props. The problem is called prop drilling in React. The solution is Context.",
	"Data - Inmmutability": "React state should be treated as immutable. We should never mutate this.state directly, as calling setState() afterward may replace the mutation you made.",
  "Data - Inmmutability - libraries": "But it’s better to use an optimized library which provides a set of immutable data structures.",
  "Data - Inmmutability - libraries - Immutability Helper": "This is a good library when it’s comes to mutating a data copy without changing the source.",
  "Data - Inmmutability - libraries - Immutable.js": "provides a lot of persistent immutable data structures, including: List, Stack, Map, OrderedMap, Set, OrderedSet, and Record.",
  "Data - Inmmutability - libraries - Seamless-immutable:": "A library for immutable JavaScript data structures that are backward-compatible with normal arrays and objects.",
  "Data - Inmmutability - libraries - React-copy-write": "An immutable React state management library with a simple mutable API, memoized selectors, and structural sharing.",
	"Data - State ": "State lets a component “remember” information like user input. f you want interactive React components, you have to introduce stateful values by using React State. ",
	"Data - State - BuiltIn - State": "setting state requests a re-render from React. This means that for an interface to react to the event, you need to update the state.",
  "Data - State - BuiltIn - State - useState": "The React useState Hook allows us to track state in a function component. State generally refers to data or properties that need to be tracking in an application.",
  "Data - State - BuiltIn - State - SetState": "We recommend using a function and not an object in the setState function. React setState method is asynchronous. This means that rather than immediately mutating this.state, setState() creates a pending state transition. If you access this.state after calling this method, it would potentially return the existing value. To prevent this, use the callback function of setState to run code after the call is completed.",
	"Data - State - BuiltIn - State - useTransition": "useTransition is a React Hook that lets you update the state without blocking the UI. const [isPending, startTransition] = useTransition(). The useTransition hook in React plays a pivotal role in improving the performance of applications by allowing the marking of state updates as non-blocking transitions. This capability enables React to defer rendering for these updates, preventing UI blocking and enhancing overall responsiveness.",
	"Data - State - BuiltIn - Context": "React Context is a way to manage state globally. Context is designed to share data that can be considered 'global' for a tree of React components, such as the current authenticated user, theme, or preferred language. Context is not a good solution for state management in most cases. Built into React, requiring no additional libraries. Context lets a component receive information from distant parents without passing it as props.",
	"Data - State - BuiltIn - Context - howto - 1.createContext": "createContext lets you create a context that components can provide or read. type CartContextValues = { count: number; ... } }; export const CartContext = createContext<CartContextValues | null>(null); - https://medium.com/@samhodev/zustand-how-is-it-better-than-react-context-with-an-example-24dad4c65753",
	"Data - State - BuiltIn - Context - howto - 2.Create Provider": "The CartContextProvider is a component that will wrap part of your component tree and provides the context value to all components within that tree. - export const CartContextProvider = ({children}: Props) => { return ( <CartContext.Provider value={{count, setCount, payTotal, subTotal, deliveryCost}}> {children}<CartContext.Provider>); } ",
  "Data - State - BuiltIn - Context - howto - 3.Apply Provider": "Wraps our component tree with CartContextProviderto make the context available to child components. - export const ReactContextDemo = () => { return (<> <CartContextProvider>.../CartContextProvider></>);};",
  "Data - State - BuiltIn - Context - howto - 4.useContext": "To access the context value, use the useContext hook in our child component. It can be used together with the useState Hook to share state between deeply nested components more easily than with useState alone. - const cartContext = useContext(CartContext);",
	"Data - State - BuiltIn - Context - Use": "React Context is still a valuable tool when used correctly. It’s well-suited for:",
  "Data - State - BuiltIn - Context - Use - Theming": "Theme Management: Managing UI themes across an application.",
  "Data - State - BuiltIn - Context - Use - Locale": "Locale Management: Handling localization and language settings.",
  "Data - State - BuiltIn - Context - Use - Authentication": "Authentication State: Providing user authentication status throughout your app.",
  "Data - State - BuiltIn - Context - Use - Routing": "Routing: Most routing solutions use context internally to hold the current route. This is how every link “knows” whether it’s active or not. If you build your own router, you might want to do it too.",
  "Data - State - BuiltIn - Context - Use - State": "Managing state: As your app grows, you might end up with a lot of state closer to the top of your app. Many distant components below may want to change it. It is common to use a reducer together with context to manage complex state and pass it down to distant components without too much hassle.",
  "Data - State - BuiltIn - Context - NoUse": "Large Applications with Complex State Management Needs:, High-Frequency State Updates, Cross-Cutting Concerns, Frequent Debugging Issues",
	"Data - State - BuiltIn - Context - NoUse - Renders": "There are unnecessary re-renders on the delivery component.",
	"Data - State - BuiltIn - Context - NoUse - Performance": "React Context can lead to performance bottlenecks, especially in large applications. When you update the context, every component that consumes that context will re-render, even if the part of the state they use hasn’t changed. This can significantly impact performance.",
  "Data - State - BuiltIn - Context - NoUse - Debug": "When state is scattered across various contexts, debugging becomes more complex. Understanding the flow of state and tracking down where and why certain updates occur can be challenging. Example: Imagine having multiple contexts like UserContext, ThemeContext, and SettingsContext. Debugging why a component re-rendered unexpectedly becomes a complex task as you need to check updates across all these contexts.",
  "Data - State - BuiltIn - Context - NoUse - Code": "Using React Context for state management can introduce a lot of boilerplate code. You need to set up the provider, create context objects, and ensure proper usage throughout the application. Every new context requires similar setup, which can quickly add up and clutter your codebase.",
  "Data - State - BuiltIn - Context - NoUse - Scalability": "React Context is not inherently designed to handle complex state management tasks such as actions, reducers, or middleware. This limitation becomes apparent as your application grows and your state management needs become more complex.",
  "Data - State - BuiltIn - Context - NoUse - Testing": "Testing components that rely on React Context can be cumbersome. You often need to wrap your components with context providers, adding an extra layer of complexity to your tests.",
	"Data - State - BuiltIn - Reducer": "Reducers let you consolidate a component’s state update logic. Context lets you pass information deep down to other components. You can combine reducers and context together to manage state of a complex screen.",
  "Data - State - BuiltIn - Reducer - useReducer": "The useReducer Hook is similar to the useState Hook. It allows for custom state logic. If you find yourself keeping track of multiple pieces of state that rely on complex logic, useReducer may be useful. useReducer(<reducer>, <initialState>)",
  "Data - State - BuiltIn - Signals": "In a general sense, signals operate on a publish-subscribe model. A component (the publisher) emits a signal when a particular event occurs, and other components (subscribers) can listen for and react to that signal without needing direct knowledge of each other. Signals provide a powerful mechanism for communication between components in a React application. Rather than relying solely on traditional state management, Signals in React introduces a more event-driven approach. Components can emit signals, and other components can listen for these signals, allowing for a more loosely coupled and responsive architecture.",
  "Data - State - BuiltIn - Signals - asHooks": "Replacing useState, useEffect, useContext https://medium.com/@samhodev/signals-future-of-react-state-management-f4b04b897c9e",
  "Data - State - BuiltIn - Signals - Use - UIInteractions": "User Interface Interactions: Signals are commonly used in graphical user interfaces to handle user interactions such as button clicks, mouse movements, or keyboard inputs.",
  "Data - State - BuiltIn - Signals - Use - Cross-ComponentCommunication": "Cross-Component Communication: Signals facilitate communication between different components or modules, allowing them to coordinate actions without tight coupling.",
  "Data - State - BuiltIn - Signals - Use - SystemLevelEvents": "System-Level Events: In larger software systems, signals can be employed to handle system-level events, such as data updates, network activity, or error notifications.",
  "Data - State - BuiltIn - Signals - Benefits - DecouplingComponents": "Decoupling Components: Signals facilitate communication between components without creating direct dependencies, promoting a more modular and maintainable codebase.",
  "Data - State - BuiltIn - Signals - Benefits - Event-DrivenArchitecture": "Event-Driven Architecture: By embracing an event-driven architecture, Signals enable a flexible and scalable design. Components respond to signals based on their specific concerns, leading to a more responsive and intuitive user interface.",
  "Data - State - BuiltIn - Signals - Benefits - SimplifiedStateManagement": "Simplified State Management: While React has a robust state management system, Signals offer an alternative that might be more suitable for certain scenarios. Signals can be employed to manage specific aspects of the application state without the need for a centralised state management solution. Signals are reactive primitives for managing application state. What makes Signals unique is that state changes automatically update components and UI in the most efficient way possible. Automatic state binding and dependency tracking allows Signals to provide excellent ergonomics and productivity while eliminating the most common state management footguns. Signals are effective in applications of any size, with ergonomics that speed up the development of small apps, and performance characteristics that ensure apps of any size are fast by default.",
  "Data - State - libraries - Zustand": "<b>Zustand is a single store similar to Redux</b>. A small, fast, and scalable state management library that provides a simpler API compared to Redux. https://medium.com/@samhodev/zustand-how-is-it-better-than-react-context-with-an-example-24dad4c65753",
	"Data - State - libraries - Zustand - builtOn": "Zustand uses React's custom hook-based approach to handle Component state distribution.",
  "Data - State - libraries - Zustand - howto - 1. Create Store.": "A 'store' in Zustand holds your application’s state. We create a store using the create function provided by Zustand, and define the cart state and actions. - interface CountState { ... }; export const useCartStore = create<CountState>((set) => ({ ... }));",
  "Data - State - libraries - Zustand - howto - 2. Use Store.": "We can use the Zustand store in our components by calling the custom hook we exported from CartStore.tsx. We can also prevent unnecessary re-render using useShallow hook provided by Zustand. The component re-renders only when state.deliveryCost change  const { deliveryCost } = useCartStore( useShallow((state) => ({ deliveryCost: state.deliveryCost })) );",
	"Data - State - libraries - Zustand - Use - State": "Use Zustand if you need simple, high-performance state management with minimal setup and are dealing with mostly global state",
  "Data - State - libraries - Zustand - Use - Performance": "While React Context provide a simple native solution of passing states to child components, Zustand can offer better performance in some scenarios, such as the above scenario where components only re-renders to the specific pieces of state they use.",
  "Data - State - libraries - Zustand - Use - Hooks": "works well with React’s hooks.",
  "Data - State - libraries - Zustand - Use - SSR": "smooth SSR integration.",
  "Data - State - libraries - Valtio": "Valtio is yet another library for global state. Unlike Zustand and Jotai, it's based on the mutating update model. It's primarily for module states like Zustand. It utilizes proxies to get an immutable snapshot, which is required to integrate with React.",
	"Data - State - libraries - Flux": "Flux uses a unidirectional data flow pattern to solve state management complexity. Remember it is not a framework – rather it's more of a pattern that targets to solve the state management issue.",
  "Data - State - libraries - Redux": ".",
  "Data - State - libraries - Redux - performance": "A well-known flaw faced by Yahoo is a classic example to consider when React apps are built with Redux. Indeed the combination is deadly and enables complex situations to structurize, but when you use Redux, your React app rerenders and slows down your performance.",
  "Data - State - libraries - atoms - Recoil": "A state management library from Facebook that offers fine-grained state management with a simpler API.",
  "Data - State - libraries - atoms - Recoil - atoms": "Atoms contain the source of truth for our application state.",
  "Data - State - libraries - atoms - Recoil - builtOn": "Using React's internal Context API, Recoil internally uses this API to propagate state updates to the subscribed Components.",
	"Data - State - libraries - atoms - Jotai": "Jotai is a minimalistic state management library for React that focuses on atomic state",
	"Data - State - libraries - atoms - Jotai - atoms": "<b>Jotai consists of primitive atoms that can be composed together</b>. It allows you to manage state in small, isolated pieces called atoms. When your application benefits from fine-grained control over state and you prefer managing state in small, isolated pieces. Use Jotai if you prefer atomic state management, need fine-grained control over state, or are dealing with scoped or dynamic state requirements.",
  "Data - State - libraries - atoms - Mobx": "A library that makes state management simple and scalable through reactive state management.",
  "Data - State - libraries - atoms - Mobx - observable": "Mobx applies concepts from Functional Reactive Programming and Object-Oriented design to automatically track changes to state and propagate updates. Mobx lets you create individual 'store' classes and mark specific fields as 'observable', then mark React components and other logic as 'observers'. You can directly modify those observables fields in your code, and Mox will transparently update any observer code that depends on those fields.",
  "Data - State - libraries - atoms - Mobx - atoms": " Achieving this is pretty simple by using atoms, which is the class that MobX uses internally for all observable data types. Atoms can be used to signal to MobX that some observable data source has been observed or changed, and MobX will let the atom know when it's being used and when it's not.",

  "Logic": "SECTION",
  "Logic - client - SideEffects - Mixins - 2014": "A React Mixin got introduced as React's first advanced pattern for reusable component logic. With a Mixin, it's possible to extract logic from a React component as standalone object. When using a Mixin in a component, all features from the Mixin are introduced to the component:",
  "Logic - client - SideEffects - Mixins - drawbacks": "However, Mixins are not used anymore in modern React applications, because they come with several drawbacks.",
  "Logic - client - SideEffects - Mixins - drawbacks - dependencies": "Often, mixins come to depend on other mixins, and removing one of them breaks the other. In these situations it is very tricky to tell how the data flows in and out of mixins, and what their dependency graph looks like. Unlike components, mixins don’t form a hierarchy: they are flattened and operate in the same namespace. If you have a name conflict with a mixin from a third party package, you can’t just rename a method on it. Instead, you have to use awkward method names on your component to avoid clashes.",
  "Logic - client - SideEffects - Mixins - drawbacks - clashes": "There is no guarantee that two particular mixins can be used together. For example, if FluxListenerMixin defines handleChange() and WindowSizeMixin defines handleChange(), you can’t use them together. You also can’t define a method with this name on your own component.",
  "Logic - client - SideEffects - Mixins - drawbacks - complexity": "Even when mixins start out simple, they tend to become complex over time.",
	"Logic - client - SideEffects - HOCs": "React Higher-Order Components (HOCs), a popular advanced React pattern, are an alternative for React Mixins to deploy reusable logic across React components. The shortest explanation for a Higher-Order Component is that it is a component which takes a component as input and returns the component as output but with extended functionalities. Let's revisit the example with the local storage and how the functionality can be extracted into a reusable Higher-Order Component:",
	"Logic - client - SideEffects - Render Props": "Another popular advanced React pattern are React Render Prop Components, which are often used as alternative to React Higher-Order Components. This kind of abstraction isn't shown here though, but I highly recommend you to check out the linked tutorial which teaches more about them.",
	"Logic - client - SideEffects - Hooks - effect": "Effects let a component connect to and synchronize with external systems. This includes dealing with network, browser DOM, animations, widgets written using a different UI library, and other non-React code.",
  "Logic - client - SideEffects - Hooks - effect - useEffect": "React Hooks were also introduced to bring side-effects to Function Components. In general, the built-in React useEffect Hook is used to execute a function every time props or state of the component are changed. The useEffect Hook allows you to perform side effects in your components. Some examples of side effects are: fetching data, directly updating the DOM, and timers. useEffect accepts two arguments. The second argument is optional. useEffect(<function>, <dependency>). https://medium.com/@sassenthusiast/i-thought-i-knew-useeffect-but-i-was-wrong-useeffect-misconceptions-dcc2781010a9",
  "Logic - client - SideEffects - Hooks - effect - useInsertionEffect": "Pitfall. useInsertionEffect is aimed at CSS-in-JS library authors. Unless you are working on a CSS-in-JS library and need a place to inject the styles, you probably want useEffect or useLayoutEffect instead. useInsertionEffect is a version of useEffect that fires before any DOM mutations. useInsertionEffect(setup, dependencies?)",
  "Logic - client - SideEffects - Hooks - effect - useLayoutEffect": "useLayoutEffect Pitfall. useLayoutEffect can hurt performance. Prefer useEffect when possible. useLayoutEffect is a version of useEffect that fires before the browser repaints the screen. useLayoutEffect(setup, dependencies?)",
	"Logic - client - SideEffects - Hooks - useId": "useId is a React Hook for generating unique IDs that can be passed to accessibility attributes. const id = useId()",
  "Logic - client - SideEffects - Hooks - useDebugValue": "useDebugValue is a React Hook that lets you add a label to a custom Hook in React DevTools. useDebugValue(value, format?)",
  "Logic - client - SideEffects - Hooks - custom": "https://javascript.plainenglish.io/collection-of-custom-hooks-for-your-nextjs-react-project-1779379e6f4a",
	"Logic - client - Async": "",
	"Logic - client - Async - Actions": "React 19. Actions streamline the process of handling form submissions and other async tasks, making your code cleaner and more maintainable.",
	"Logic - client - Async - useAsyncScript": "React 19. You can now render async scripts within any component, with React handling deduplication. This ensures that scripts are loaded efficiently without redundancy.",
	"Logic - client - Events": ".",
	"Logic - client - Events - SyntheticEvent": "React synthetic events encapsulate native browser events, providing a unified API interface so that developers can handle events in the same way regardless of the browser environment. The main purpose of this approach is to ensure cross-browser consistency and integrate with React’s declarative programming model and lifecycle. React synthetic events handle all browser compatibility issues, providing developers with a clean, consistent interface for event handling.",
	"Logic - client - Events - SyntheticEvent - pool": "React synthetic events use an event pool to improve performance, i.e., reusing event objects. This means that after the event callback function is executed, all properties of the event object are cleared and recycled for reuse, reducing the pressure on garbage collection and memory usage.",
	"Logic - client - Events - Throttling": "Throttling in React is a technique used to limit the number of times a function or an event handler is invoked by postponing the execution of a function. It ensures that the function is called at a specified interval, preventing it from being executed too frequently. Throttling allows you to control the rate at which the function is called by setting up a minimum time interval between each function invocation. If the function is called multiple times within that interval, only the first invocation is executed, and subsequent invocations are ignored until the interval elapses.",
	"Logic - client - Events - Debouncing": "Debouncing, as opposed to throttling, is a method to stop the event trigger from firing too frequently. Debouncing, on the other hand, is also used to limit the number of times a function or an event handler is invoked. It ensures that the function is called only after a certain period of inactivity. Debouncing allows you to postpone the function call until the user has finished typing or a specific time has elapsed since the last event..",
  "Logic - client - Error Handling": "These methods are called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component.",
  "Logic - client - Error Handling - static getDerivedStateFromError()": ".", 
  "Logic - client - Error Handling - componentDidCatch()": ".",
	"Logic - client - Error Handling - onCaughtError": "React 19. ",
	"Logic - client - Error Handling - onUncaughtError": "React 19. ",
	"Logic - client - Error Handling - <ErrorBoundary>": "React gives us what is known as 'Error Boundaries': a special API that turns a regular component into a try/catch statement in a way, only for React declarative code. ",
  "Logic - Server - DataFetching - Hooks - other - useSyncExternalStore": "useSyncExternalStore is a React Hook that lets you subscribe to an external store. const snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)",
  "Logic - Server - DataFetching - React Query": "useQuery. We can cache it, invalidate it, and fetch it anew.",
  "Logic - Server - DataFetching - tRPC": "",
  "Logic - Server - DataFetching - SWR": "React Hooks for data fetching. Standing for “stale-while-revalidate,” SWR is a strategy and library that makes fetching, caching, and updating data in your React applications a breeze.",
	"Logic - Server - DataFetching - caching": "Cache data fetched from APIs or expensive computations to prevent unnecessary re-fetching or re-computation. By storing data in memory or leveraging browser caching mechanisms, you can reduce network latency and improve app responsiveness.",
  "Logic - Server - DataFetching - server": "whenever possible, it is recommended to fetch data within Server Components to ensure direct access to backend data sources and to prevent sensitive environment variables from being exposed to the client.",
	"Logic - Server - ServerComponents": "React 19. React Server Components (RSC) are a game-changer. These components render at build time or for each request, reducing the workload on the client side and enhancing performance.",
	"Logic - Server - ServerComponents - no server": "Server components can run at build time to read from the filesystem or fetch static content, so a web server is not required. For example, you may want to read static data from a content management system.",
	"Logic - Server - ServerComponents - server": "Server Components can also run on a web server during a request for a page, letting you access your data layer without having to build an API. They are rendered before your application is bundled, and can pass data and JSX as props to Client Components.",
	"Logic - Server - ServerComponents - use client": "Server Components are not sent to the browser, so they cannot use interactive APIs like useState. To add interactivity to Server Components, you can compose them with Client Component using the 'use client' directive. A common misunderstanding is that Server Components are denoted by 'use server', but there is no directive for Server Components. The 'use server' directive is used for Server Actions.",
	"Logic - Server - ServerComponents - async": "Server Components introduce a new way to write Components using async/await. When you await in an async component, React will suspend and wait for the promise to resolve before resuming rendering. This works across server/client boundaries with streaming support for Suspense.",
  "Logic - Server - ServerComponents - cache": "cache is only for use with React Server Components.",
  "Logic - Server - ServerActions": "Server Actions allow Client Components to call async functions executed on the server.",
  "Logic - Server - ServerActions - attaching - as props": "Server Actions can be created in Server Components and passed as props to Client Components. Server Components can define Server Actions with the 'use server' directive",
  "Logic - Server - ServerActions - attaching - importing": "Server Actions can be imported and used in Client Components. Client Components can import Server Actions from files that use the 'use server' directive:",
  "Logic - Server - ServerActions - composing": "Server Actions can be composed with Actions on the client",
  "Logic - Server - ServerActions - forms": "Server Actions work with the new Form features in React 19. You can pass a Server Action to a Form to automatically submit the form to the server:",
  "Logic - Server - ServerActions - useActionState": "You can compose Server Actions with useActionState for the common case where you just need access to the action pending state and last returned respons.",

	"View": "SECTION",
	"View - JSX": "Returned by Components.",
  "View - JSX - elements": "React elements are immutable. Once you create an element, you can’t change its children or attributes.",
	"View - JSX - nesting": "When you nest content inside a JSX tag, the parent component will receive that content in a prop called children.",
  "View - JSX - expressions": "You can put any valid JavaScript expression inside the curly braces in JSX.",
  "View - JSX - injection attacks": "By default, React DOM escapes any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that’s not explicitly written in your application. Everything is converted to a string before being rendered. This helps prevent XSS (cross-site-scripting) attacks.",
  "View - JSX - Built-in - Common": "All built-in browser components, such as <div>, support some common props and events. https://beta.reactjs.org/reference/react-dom/components/common",
	"View - JSX - Built-in - <Fragment>": "<Fragment>, often used via <>...</> syntax, lets you group elements without a wrapper node. This is particularly useful when you need to return multiple elements from a component's render method, but you don't want to introduce unnecessary DOM elements that could affect the layout or styles of your application.",
  "View - JSX - Built-in - <Profiler>": "<Profiler> lets you measure rendering performance of a React tree programmatically.",
  "View - JSX - Built-in - <StrictMode>": "<StrictMode> lets you find common bugs in your components early during development. <StrictMode> <App /> </StrictMode>",
  "View - JSX - Built-in - <Suspense>": "<Suspense> lets you display a fallback until its children have finished loading. <Suspense fallback={<Loading />}> <SomeComponent /> </Suspense>",
  "View - JSX - Built-in - <input>": "The built-in browser <input> component lets you render different kinds of form inputs. <input />",
  "View - JSX - Built-in - <option>": "The built-in browser <option> component lets you render an option inside a <select> box. <select>  <option value='someOption'>Some option</option> <option value='otherOption'>Other option</option> </select>",
  "View - JSX - Built-in - <progress>": "The built-in browser <progress> component lets you render a progress indicator. <progress value={0.5} />",
  "View - JSX - Built-in - <select>": "The built-in browser <select> component lets you render a select box with options. <select>  <option value='someOption'>Some option</option> <option value='otherOption'>Other option</option> </select>",
  "View - JSX - Built-in - <textarea>": "The built-in browser <textarea> component lets you render a multiline text input. <textarea />",
  "View - JSX - Built-in - <form>": "The built-in browser <form> component lets you create interactive controls for submitting information.",
	"View - JSX - Built-in - <form> - FormData": "https://mostlyfocusedmike.medium.com/stop-controlling-every-form-in-react-use-formdata-instead-c26d89409afe",
	"View - JSX - Built-in - <form> - Hooks - useActionState": "React 19. Declare form state and degrade gracefully if JS hasn’t executed yet.",
	"View - JSX - Built-in - <form> - Hooks - useFormStatus": "React 19. Get a form’s status easily.",
	"View - JSX - Built-in - <form> - Hooks - useOptimistic": "React 19. Show the final state optimistically while an async request is underway.",
  "View - Styling": "",
  "View - Styling - library - CSS": "",
  "View - Styling - library - CSS - TailwindCSS": "",
  "View - Styling - library - CSS - TailwindCSS - Signals": "Tailwind Signals is a new experimental feature in Tailwind CSS that enables custom state consumption by any descendant in the DOM for cleaner coding and efficient styling. Signals build on the concept of pseudo-classes and allow for bidirectional communication between parent and child components, enabling child components to react to state changes in their parents and vice versa.",
  "View - Styling - library - UI - StyledComponents": "Styled Components is a library for React and React Native that allows you to use component-level styles in your application. It leverages tagged template literals to style your components, providing a seamless integration of styles within your JavaScript.",
  "View - Styling - library - UI - TailwindUI": "",
  "View - Styling - library - UI - MaterialUI": "",
  "View - Styling - library - UI - ShadcnUI": "https://levelup.gitconnected.com/using-5-new-shadcn-ui-components-in-next-js-14-8f4bc33d2911",
	"View - resources - Preload": "React v19 allows developers to preload resources using various strategies like prefetchDNS, preconnect, preload, and preinit. This ensures that critical resources are loaded quickly, improving performance.",
	"View - resources - Preload - prefetchDNS": "React 19. ",
	"View - resources - Preload - preconnect": "React 19. ",
	"View - resources - Preload - preload": "React 19. ",
	"View - resources - Preload - preinit": "React 19. ",
	"View - resources - lazy loading - React.lazy": "React.lazy is a feature that allows you to lazily load components, meaning they are loaded only when needed.",
	"View - resources - lazy loading - Suspense": "Suspense is a component that can be used to define a fallback UI while the lazily loaded component is being loaded. By reducing lazy-loading components that are not immediately needed, you can lower the initial load time of your application. This technique is especially useful for large applications with complex component hierarchies.",
	"View - build content - Conditional": ".",
	"View - build content - Conditional - if - short-circuit": "<div>{count && <h1>Messages: {count}</h1>}</div>.",
	"View - build content - Conditional - if - ternary": "<div>{count ? <h1>Messages: {count}</h1> : null}</div>. Preferred",
  "View - build content - memoization": "Memoization in React is a technique used to optimize the performance of functional components by caching the results of expensive computations or function calls. In web development, memoization is the process of storing data (e.g. a variable value) in the cache and then retrieving this information next time it is needed (e.g. on a page or component re-render).",
  "View - build content - memoization - React.memo": "By using React.memo(), the rendering result is cached based on props. If the props haven't changed since the last render, React reuses the previously rendered result instead of redoing the rendering process. This saves time and resources.",
  "View - build content - memoization - useMemo": "The useMemo Hook only runs when one of its dependencies update. This can improve performance. The useMemo and useCallback Hooks are similar. The main difference is that useMemo returns a memoized value and useCallback returns a memoized function. This hook allows you to cache the result of a function output and retrieve this information when it’s needed, without recomputing the value all over again.",
  "View - build content - memoization - useCallback": "This allows us to isolate resource intensive functions so that they will not automatically run on every render. The useCallback Hook only runs when one of its dependencies update. This can improve performance. The useCallback hook is very similar to useMemo. The main difference is that useMemo returns a memoized value while useCallback returns a memoized function.",
  "View - build content - memoization - React Compiler": "Now, everything I’ve just told you about useMemo and useCallback may become totally irrelevant when React Compiler is released! Although useMemo and useCallback serve their purpose in React right now, they also increase mental overhead for developers, hence the reason React Compiler is in the pipeline. React Compiler is a low-level, auto-memoizing compiler that will handle all memoization without you - the developer - having to do anything at all.React Compiler is an ‘auto-memoizing compiler’ that automates all memoizations in your application. In simpler terms, this means that it will automatically detect the need for useMemo and useCallback so you will no longer have to think about these hooks or which one you need to use for a certain situation.",
  "View - build content - memoization - React Compiler - plugAndPlay": "The Compiler is plug-and-play: you install it, and it Just Works; there is no need to rewrite existing code.",
  "View - build content - memoization - React Compiler - ReactCompilerConfig": "https://jherr2020.medium.com/react-compiler-with-react-18-1e39f60ae71a",
	"View - Stages": "Any screen update in a React app happens in three steps: Trigger, Render, Commit",
  "View - Stages - Triggering": ".",
  "View - Stages - Rendering": "Rendering takes a snapshot in time. After rendering (calling) your components, React will modify the DOM.",
	"View - Stages - Rendering - prevent - useTransition": "useTransition is a React Hook that lets you update the state without blocking the UI. const [isPending, startTransition] = useTransition(). The useTransition hook in React plays a pivotal role in improving the performance of applications by allowing the marking of state updates as non-blocking transitions. This capability enables React to defer rendering for these updates, preventing UI blocking and enhancing overall responsiveness.",  "View - Stages - Rendering - delay - useDeferredValue": "useDeferredValue is a React Hook that lets you defer updating a part of the UI. const deferredValue = useDeferredValue(value)",
	"View - Stages - Rendering - lists - keys": "Keys must be unique among siblings. However, it’s okay to use the same keys for JSX nodes in different arrays. Keys must not change or that defeats their purpose! Don’t generate them while rendering.",
	"View - Stages - Rendering - lists - keys - index": "You might be tempted to use an item’s index in the array as its key. In fact, that’s what React will use if you don’t specify a key at all. But the order in which you render items will change over time if an item is inserted, deleted, or if the array gets reordered. Index as a key often leads to subtle and confusing bugs.",
	"View - Stages - Rendering - lists - keys - generated": "Similarly, do not generate keys on the fly, e.g. with key={Math.random()}. This will cause keys to never match up between renders, leading to all your components and DOM being recreated every time. Not only is this slow, but it will also lose any user input inside the list items. Instead, use a stable ID based on the data.",
	"View - Stages - Rendering - lists - filter": ".",
	"View - Stages - Rendering - lists - map": ".",
	"View - Stages - Rendering - lists - windowing": "List visualization, or windowing, involves rendering only the items currently visible on the screen. When dealing with a large number of items in a list, rendering all the items at once can lead to slow performance and consume a significant amount of memory. List virtualization tackles this issue by rendering only a subset of the list items currently visible within the view, which conserves resources as the users scroll through the list.",
  "View - Stages - Rendering - lists - windowing - virtualization": "The virtualization technique dynamically replaces rendered items with new ones, keeping the visible portion of the list updated and responsive. It efficiently allows you to render large lists or tabular data by only rendering the visible portion, recycling components as needed, and optimizing scroll performance. There are different approaches to implementing list visualization in React, and one is using a popular library called React Virtualized.",
  "View - Stages - Rendering - lists - windowing - Unique Keys": "When rendering lists, always provide unique keys to help React identify which items have changed, added, or removed. This can prevent unnecessary re-renders and improve overall performance.",
  "View - Stages - Rendering - lists - windowing - Batch Updates": "Utilize React's batched updates mechanism to minimize the number of re-renders when updating lists. By batching multiple updates into a single render pass, you can optimize performance and ensure a smoother user experience.",
	"View - Stages - Committing": ".",
	"View - Stages - Rerendering": ".",
  "View - Stages - Rerendering - Cascading": "Re-renders in React are cascading. Every time you change state in a React component, you trigger a re-render of that component, every component inside, components inside of those components, etc., until the end of the component tree is reached.",
	"View - NoVirtualDOM - Preact": "Preact X is what we always wanted Preact to be: A tiny, fast and feature-packed library. And speaking of size, you'll be happy to hear that all the new features and improved rendering fit into the same size footprint as 8.x!",
	"View - NoVirtualDOM - Preact vs React": "The main difference between Preact and React is that Preact does not implement a synthetic event system for size and performance reasons. Preact uses the browser's standard addEventListener to register event handlers, which means event naming and behavior works the same in Preact as it does in plain JavaScript / DOM.",
	"View - VirtualDOM": "React applications use components that form a hierarchical structure to build applications. Components can be functional or class-based and represent reusable UI elements.",
  "View - VirtualDOM - Tree": "React uses a Virtual DOM, a lightweight representation of the browser DOM. The Virtual DOM allows React to efficiently manage and update the UI. React has introduced a new way of handling routing in web applications and it was the Virtual DOM.",
  "View - VirtualDOM - routing": "Instead of using the native browser routing and navigation, we keep all of that in the JavaScript memory and use JavaScript to handle pages and routing for us, and as a result, it will become a lot faster.",
  "View - VirtualDOM - reconciler - <16": "React 15 and previous versions of React, in those versions, we had a reconciler called stack reconciler which was a LIFO data structure responsible for picking a work and returning the results just like how the JavaScript call stack works. The main problem was that the stack reconciler was synchronous and sequential meaning there was no chance for it to handle multiple units of work at the same time in parallel or concurrently.",
  "View - VirtualDOM - reconciler - >=16": "In React version 16 and above, the React team has introduced a new way of handling the units of work and virtual DOM tree using the new meta called Fiber Reconciler to tackle two main challenges: 1- Synchronous way of processing the units of work 2- Prioritizing and concurrency of the units of work.",
  "View - VirtualDOM - reconciler - >=16 - Fiber": "The current React Fiber Reconciler consists of many fiber nodes which are plain JavaScript objects with a lot of properties to handle their work. Fiber = { a JavaScript object with many properties OR unit of work }. Fiber Reconciler = The current React reconciler based on Fiber objects or units of work. https://maxtsh.medium.com/how-does-the-react-fiber-reconciler-work-77c3650127da",
  "View - VirtualDOM - shaking": "Leverage tree shaking techniques, typically provided by bundlers like webpack, to eliminate unused code from your JavaScript bundle. This helps reduce the overall bundle size and improve loading time.",
  "View - VirtualDOM - ref": "Refs let a component hold some information that isn’t used for rendering, like a DOM node or a timeout ID. Unlike with state, updating a ref does not re-render your component. Refs are an “escape hatch” from the React paradigm. They are useful when you need to work with non-React systems, such as the built-in browser APIs. A React Ref should only be used in rare cases such as accessing/manipulating the DOM manually (e.g. focus element), animations, and integrating third-party DOM libraries.",
  "View - VirtualDOM - ref - useRef": "The useRef Hook allows you to persist values between renders. It can be used to store a mutable value that does not cause a re-render when updated. It can be used to access a DOM element directly. The useRef Hook returns an object with a single property called current. Initially, myRef.current will be null. When React creates a DOM node for this <div>, React will put a reference to this node into myRef.current. You can then access this DOM node from your event handlers and use the built-in browser APIs defined on it.",
  "View - VirtualDOM - ref - useImperativeHandle": "useImperativeHandle is a React Hook that lets you customize the handle exposed as a ref. useImperativeHandle(ref, createHandle, dependencies?)",
  "View - VirtualDOM - ref - forwardRef": "forwardRef lets your component expose a DOM node to parent component with a ref. It's not recommended to pass a ref from a Parent Component to a Child Component and that's why the assumption has always been: React Function Components cannot have refs. However, if you need to pass a ref to a Function Component -- because you have to measure the size of a function component's DOM node, for example, or like in this case to focus an input field from the outside -- you can forward the ref:",

  "CICD": "SECTION",
	"CICD - Bundling - Arch - Patterns - Base UI Component": "",
  "CICD - Bundling - Arch - Patterns - Base UI Component - BaseUI": "https://baseweb.design/",
  "CICD - Bundling - Arch - Patterns - Inheritance": "No use",
  "CICD - Bundling - Arch - Patterns - Composition": "",
  "CICD - Bundling - Arch - Patterns - Compound": "The Compound Components pattern isn’t just a coding technique; it’s a design paradigm that promotes collaboration between components while maintaining loose coupling. Recognizing its value involves understanding the use of static properties, which resemble dot notation for accessing nested components within a parent component. https://medium.com/@khushi1399gupta/mastering-reacts-compound-components-a-guide-for-experienced-developers-8a35c1468acb",
	"CICD - Bundling - Arch - Patterns - Layout": ".",
	"CICD - Bundling - Arch - Patterns - Layout - Layout pattern": "The main idea behind the Layout component pattern is that components should not know where they are being displayed, and Layout components should only be concerned with displaying the component.",
  "CICD - Bundling - Arch - Patterns - Adapter": "The Adapter Pattern allows incompatible interfaces to work together. It converts the interface of a class into another interface clients expect. This pattern is often used to make existing classes work with others without modifying their source code.",
  "CICD - Bundling - Arch - Patterns - Repository": "The Repository Pattern abstracts the data layer, providing a collection-like interface for accessing domain objects. It mediates between the domain and data mapping layers, acting like an in-memory domain object collection.",
	"CICD - Building": "",
  "CICD - Building - Bit": "Bit is a next-generation building system that develops composable software. https://bit.dev/",
  "CICD - Building - JSX - transpilation": "JSX allows you to write HTML-like code in your JavaScript. It gets transpiled by a tool like Babel to JavaScript before being rendered in the browser..",
  "CICD - Building - JSX - transpilation - Babel": "Browsers don’t understand JSX out of the box, so most React users rely on a compiler like Babel or TypeScript to transform JSX code into regular JavaScript.",
  "CICD - Building - JSX - transpilation - React.createElement()": "Babel compiles JSX down to React.createElement() calls.",
  "CICD - Building - production": "Make sure to test any performance issues you may be seeing with your React apps using the production build's minified version.",
	"CICD - Execution - Scopes - Block": "Block scope: The context inside of a pair of curly braces (only applies to variables created with const and let).",
	"CICD - Execution - Scopes - Function": "Function scope: The context within a JS-function.",
	"CICD - Execution - Scopes - Component": "Component scope: The context inside a functional or class component.",
	"CICD - Execution - Scopes - Module": "Module scope: The context for code running inside a JavaScript (JS), JSX, TypeScript (TS), or TSX file.",
	"CICD - Audit - Testing - React Testing": ".",
  "CICD - Audit - Profiling - react Profiler": "The React Profiler is a tool that comes with the React Developer Tools extension. It allows you to measure and analyze the rendering performance of your components. The React Profiler lets you identify components that take longer to render and detect potential performance bottlenecks."

}