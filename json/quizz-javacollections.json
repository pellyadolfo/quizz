{
	"framework": "SECTION",
	"Collections Framework": "A collections framework is a unified architecture for representing and manipulating collections. All collections frameworks contain the following: interfaces, implementations. algorithms",
	"Collections Framework - interfaces": "These are abstract data types that represent collections. Interfaces allow collections to be manipulated independently of the details of their representation. In object-oriented languages, interfaces generally form a hierarchy.",
	"Collections Framework - implementations": "These are the concrete implementations of the collection interfaces. In essence, they are reusable data structures.",
	"Collections Framework - algorithms": "These are the methods that perform useful computations, such as searching and sorting, on objects that implement collection interfaces. The algorithms are said to be polymorphic: that is, the same method can be used on many different implementations of the appropriate collection interface. In essence, algorithms are reusable functionality.",

	"interfaces": "SECTION",
	"Collection": "the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn't provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List.",
	"Collection - Generic": "Note that all the core collection interfaces are generic. When you declare a Collection instance you can and should specify the type of object contained in the collection. Specifying the type allows the compiler to verify (at compile-time) that the type of object you put into the collection is correct, thus reducing errors at runtime.",
	"Collection - Traversing": "There are three ways to traverse collections: (1) using aggregate operations (streams()) (2) with the for-each construct and (3) by using Iterators..",
	"Collection - UnsupportedOperationException": "If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform's general-purpose implementations support all of the optional operations.",

	"sets": "SECTION",
	"Set": "a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student's schedule, or the processes running on a machine.",
	"Set - Unmodifiable Set (Java10)": "The Set.of and Set.copyOf static factory methods provide a convenient way to create unmodifiable sets. The Set instances created by these methods have the following characteristics: (1) They are unmodifiable. Elements cannot be added or removed. Calling any mutator method on the Set will always cause UnsupportedOperationException to be thrown. However, if the contained elements are themselves mutable, this may cause the Set to behave inconsistently or its contents to appear to change. (2) They disallow null elements. Attempts to create them with null elements result in NullPointerException. (3) They are serializable if all elements are serializable. (4) They reject duplicate elements at creation time. Duplicate elements passed to a static factory method result in IllegalArgumentException. (5) The iteration order of set elements is unspecified and is subject to change. (6) They are value-based. Callers should make no assumptions about the identity of the returned instances. Factories are free to create new instances or reuse existing ones. Therefore, identity-sensitive operations on these instances (reference equality (==), identity hash code, and synchronization) are unreliable and should be avoided. (7) They are serialized as specified on the Serialized Form page.",
	"Set - SortedSet": "a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls..",
	"Set - HashSet": "implements Set, backed by a hash table (actually a HashMap instance), makes no guarantees as to the iteration order of the set, permits the null element, not synchronized.",
	"Set - TreeSet": "implements Set, .",
	"Set - LinkedHashSet": "implements Set, .",
	"Set - NavigableSet": ".",
	"Set - EnumSet": ".",
	"Set - ConcurrentSkipListSet": ".",
	"Set - CopyOnWriteArraySet": ".",

	"lists": "SECTION",
	"List": "an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you've used Vector, you're familiar with the general flavor of List.",
	"List - Unmodifiable List (Java10)": "The List.of and List.copyOf static factory methods provide a convenient way to create unmodifiable lists. The List instances created by these methods have the following characteristics: (1) They are unmodifiable. Elements cannot be added, removed, or replaced. Calling any mutator method on the List will always cause UnsupportedOperationException to be thrown. However, if the contained elements are themselves mutable, this may cause the List's contents to appear to change. (2) They disallow null elements. Attempts to create them with null elements result in NullPointerException. (3) They are serializable if all elements are serializable. (4) The order of elements in the list is the same as the order of the provided arguments, or of the elements in the provided array. (5) They are value-based. Callers should make no assumptions about the identity of the returned instances. Factories are free to create new instances or reuse existing ones. Therefore, identity-sensitive operations on these instances (reference equality (==), identity hash code, and synchronization) are unreliable and should be avoided. (6) They are serialized as specified on the Serialized Form page.",
	"List - ArrayList,": "implements List, .",
	"List - LinkedList": "implements List, FIFO semantics, .",
	"List - Vector": "",
	"List - Stack": "",

	"queue": "SECTION",
	"Queue": " a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties.",
	"Queue - BlockingQueue": ".",
	"Queue - PriorityQueue": ".",
	"Queue - ArrayBlockingQueue": ".",
	"Queue - ConcurrentLinkedQueue": ".",
	"Queue - DelayQueue": ".",
	"Queue - LinkedBlockingQueue": ".",
	"Queue - LinkedBlockingDeque": ".",
	"Queue - LinkedTransferQueue": ".",
	"Queue - PriorityBlockingQueue": ".",
	"Queue - SynchronousQueue": ".",

	"deque": "SECTION",
	"Deque": "a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Deque provides additional insertion, extraction, and inspection operations. Deques can be used both as FIFO (first-in, first-out) and LIFO (last-in, first-out). In a deque all new elements can be inserted, retrieved and removed at both end.",
	"Deque - ArrayDeque": ".",

	"map": "SECTION",
	"Map": "an object that maps keys to values. A Map cannot contain duplicate keys, each key can map to at most one value. If you've used Hashtable, you're already familiar with the basics of Map. Also see The Map Interface section.",
	"Map - Unmodifiable Map (Java10)": "The Map.of, Map.ofEntries, and Map.copyOf static factory methods provide a convenient way to create unmodifiable maps. The Map instances created by these methods have the following characteristics: (1) They are unmodifiable. Keys and values cannot be added, removed, or updated. Calling any mutator method on the Map will always cause UnsupportedOperationException to be thrown. However, if the contained keys or values are themselves mutable, this may cause the Map to behave inconsistently or its contents to appear to change. (2) They disallow null keys and values. Attempts to create them with null keys or values result in NullPointerException. (3) They are serializable if all keys and values are serializable. (4) They reject duplicate keys at creation time. Duplicate keys passed to a static factory method result in IllegalArgumentException. (5) The iteration order of mappings is unspecified and is subject to change. (6) They are value-based. Callers should make no assumptions about the identity of the returned instances. Factories are free to create new instances or reuse existing ones. Therefore, identity-sensitive operations on these instances (reference equality (==), identity hash code, and synchronization) are unreliable and should be avoided. (7) They are serialized as specified on the Serialized Form page.",
	"Map - SortedMap": "a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories.",
	"Map - HashMap": ".",
	"Map - HashMap - features - structure": "Internally HashMap contains an array of Node and a node is represented as a class which contains 4 fields: int hash, K key, V value, Node next. It can be seen that node is containing a reference of its own object. So it’s a linked list.",
	"Map - HashMap - features - performance": "Performance of HashMap depends on 2 parameters: Initial Capacity and Load Factor. As already said, Capacity is simply the number of buckets whereas the Initial Capacity is the capacity of HashMap instance when it is created. The Load Factor is a measure that when rehashing should be done. Rehashing is a process of increasing the capacity. In HashMap capacity is multiplied by 2. Load Factor is also a measure that what fraction of the HashMap is allowed to fill before rehashing. When the number of entries in HashMap increases the product of current capacity and load factor the capacity is increased that is rehashing is done. If the initial capacity is kept higher then rehashing will never be done. But by keeping it higher it increases the time complexity of iteration. So it should be choosed very cleverly to increase the performance. The expected number of values should be taken into account to set initial capacity. Most generally preffered load factor value is 0.75 which provides a good deal between time and space costs. Load factor’s value varies between 0 and 1..",
	"Map - HashMap - features - synchronization": "As it is told that HashMap is unsynchronized i.e. multiple threads can access it simultaneously. If multiple threads access this class simultaneously and at least one thread manipulates it structurally then it is necessary to make it synchronized externally. It is done by synchronizing some object which enzapsulates the map. If No such object exists then it can be wrapped around Collections.synchronizedMap() to make HashMap synchronized and avoid accidental unsynchronized access. As in following example: Map m = Collections.synchronizedMap(new HashMap(...)), ",
	"Map - HashMap - features - operation": "If we need to retrieve value object following steps will be followed: (1) Call hashCode() method of key to find bucket location. (2) Traverse thought linked list, comparing keys in each entries using keys.equals() until it return true.",
	"Map - HashMap - features - index": "Hash code of key may be large enough to create an array. hash code generated may be in the range of integer and if we create arrays for such a range, then it will easily cause outOfMemoryException. So we generate index to minimize the size of array. Basically following operation is performed to calculate index. index = hashCode(key) & (n-1). where n is number of buckets or the size of array.",
	"Map - HashMap - features - collision": "In case of collision, i.e. index (=hashcode()) of two or more nodes are same, nodes are joined by link list i.e. second node is referenced by first node and third by second and so on..",
	"Map - HashMap - features - bucket (linkedlist)": "A bucket is one element of HashMap array. It is used to store nodes. Two or more nodes can have the same bucket. In that case link list structure is used to connect the nodes. Buckets are different in capacity. A relation between bucket and capacity is as follows: capacity = number of buckets * load factor A single bucket can have more than one nodes, it depends on hashCode() method. The better your hashCode() method is, the better your buckets will be utilized.",
	"Map - HashMap - features - bucket (balanced tree, Java 8)": "As we know now that in case of hash collision entry objects are stored as a node in a linked-list and equals() method is used to compare keys. That comparison to find the correct key with in a linked-list is a linear operation so in a worst case scenario the complexity becomes O(n).To address this issue, Java 8 hash elements use balanced trees instead of linked lists after a certain threshold is reached. Which means HashMap starts with storing Entry objects in linked list but after the number of items in a hash becomes larger than a certain threshold, the hash will change from using a linked list to a balanced tree, which will improve the worst case performance from O(n) to O(log n).",
	"Map - TreeMap": ".",
	"Map - LinkedHashMap": ".",
	"Map - ConcurrentMap": ".",
	"Map - ConcurrentHashMap": ".",
	"Map - ConcurrentSkipListMap": ".",
	"Map - NavigableMap": ".",
	"Map - WeahHashMap": ".",
	"Map - EnumMap": ".",
	"Map - Hashtable": ".",
	"Map - IdentityHashMap": ".",

	"algorithms": "SECTION",
	"algorithms - sort": ".",
	"algorithms - shuffle": ".",
	"algorithms - reverse": ".",
	"algorithms - rotate": ".",
	"algorithms - swap": ".",
	"algorithms - replaceAll": ".",
	"algorithms - fill": ".",
	"algorithms - copy": ".",
	"algorithms - binarySearch": ".",
	"algorithms - indexOfSubList": ".",
	"algorithms - lastIndexOfSubList": ".",
}