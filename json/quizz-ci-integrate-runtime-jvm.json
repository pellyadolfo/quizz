{

	"CI - Building": "SECTION",
	"CI - Building - SourceToBytecode - Compilation - Compile - older - Java11": "Java 11's javac can compile for older versions: javac --release 8 MyClass.java",
	"CI - Building - SourceToBytecode - Compilation - Compile - older - >Java7": "Cannot compile for versions older than Java 7",
	"CI - Building - Bytecode": "",
	"CI - Building - Bytecode - BinaryCompatibility": "Binary compatibility in Java refers to the ability of a newer version of a class or library to work seamlessly with existing compiled code (bytecode) without requiring recompilation.",
	"CI - Building - Bytecode - BinaryCompatibility - compatible": "In other words, if a change in a Java class or interface does not break existing client code that was compiled against an older version, it is considered binary compatible.",
	"CI - Building - Bytecode - BinaryCompatibility - dependencies": "Binary compatibility ensures that compiled Java programs continue to work when dependencies are updated, as long as the changes follow Java's compatibility rules.",
	"CI - Building - Bytecode - BinaryCompatibility - updates": "Ensures smooth updates in libraries/frameworks without forcing users to recompile.",
	"CI - Building - Bytecode - BinaryCompatibility - Tools - japi-compliance-checker": "japi-compliance-checker (for comparing JAR versions)",
	"CI - Building - Bytecode - BinaryCompatibility - Tools - jdeps": "jdeps (Java Dependency Analysis Tool)",
	"CI - Building - Bytecode - BinaryCompatibility - Tools - IntelliJAPICheck": "",
	"CI - Building - Bytecode - execution": "To execute a class’ bytecode, the JVM needs to perform a couple of preparatory steps. Given a class name, it looks the class up in a JAR, loads it, verifies the bytecode, and pulls it into an internal data structure. That takes some time of course, which is most noticeable when the JVM launches and needs to load at least a few hundred, more likely a couple of thousand classes. The thing is, as long as the application’s JARs do not change, this class-data is always the same. The JVM executes the same steps and comes to the same result every time it runs the app.",
	"CI - Building - Bytecode - AppCDS - Java 10": "Application Class-Data Sharing. Enter application class-data sharing! The idea behind it is to create this data once, dump it into an archive, and then reuse that in future launches and even share it across simultaneously running JVM instances: (1) create a list of classes to include in the archive (possibly with -XX:DumpLoadedClassList) (2) create an archive with the option -Xshare:dump (3) use the archive with the option -Xshare:on. When launching with -Xshare:on, the JVM maps the archive file into its own memory and thus has most classes it needs readily available and does not have to muck around with JARs. The memory region can even be shared between concurrently running JVM instances, which frees up memory that would otherwise be wasted on replicating the same information in each instance.",
	"CI - Building - Bytecode - AppCDS - advantages": "AppCDS significantly reduces the time the JVM has to spend on class loading, which is most noticeable during launch. It also prevents long response times in the case where a user is the first to access a feature that requires a lot of classes that weren’t loaded yet.",
	"CI - Building - Bytecode - XX:DumpLoadedClassList": "List of classes to include in the archive",
	"CI - Building - Bytecode - Link - JLink - Java9": "Create a tool that can assemble and optimize a set of modules and their dependencies into a custom run-time image as defined in JEP 220.",
	"CI - Building - Bytecode - Link - JLink - Jigsaw": "jlink is a command-line tool introduced in Java 9 as part of Project Jigsaw (Java Platform Module System - JPMS). It allows you to create custom, minimized Java runtime images containing only the modules your application needs.",
	"CI - Building - Bytecode - Link - JLink": "Create a minimal runtime (optional). it’s a customized, minimized Java Runtime Environment (JRE) containing only the modules your application needs.",
	"CI - Building - Bytecode - Class - Metadata - ACC_RECORD": "Records are marked with the ACC_RECORD flag in the class file",
	"CI - Building - Bytecode - Manipulation": ".",
	"CI - Building - Bytecode - Manipulation - Libs - ASM": ".",
	"CI - Building - Bytecode - Manipulation - Libs - Javassist": ".",
	"CI - Building - Bytecode - Manipulation - Libs - BCEL": ".",
	"CI - Building - Bytecode - Manipulation - Libs - ClassFileAPI": "It provides programmatic access to parsing, generating, and transforming Java class files.",
	"CI - Building - Bytecode - Manipulation - Libs - ClassFileAPI - Java22": "The Class-File API is a new standard API introduced in Java 22 (JEP 457) as a preview feature. It provides programmatic access to parsing, generating, and transforming Java class files.",
	"CI - Building - Bytecode - Manipulation - Libs - ClassFileAPI - ClassFileParser": "Reads class files into a structured representation.",
	"CI - Building - Bytecode - Manipulation - Libs - ClassFileAPI - ClassFileBuilder": "Generates new class files.",
	"CI - Building - Bytecode - Manipulation - Libs - ClassFileAPI - ClassFileTransformer": "Modifies existing class files.",
	"CI - Building - BytecodeToNative": "Bytecode → Native Machine Code",
	"CI - Building - BytecodeToNative - VectorAPI - Java16": "The Vector API was first introduced as an incubator feature in Java 16 (JEP 338) and has undergone several iterations in subsequent releases. This API provides a way to express vector computations that reliably compile at runtime to optimal vector instructions on supported CPU architectures.",
	"CI - Building - BytecodeToNative - VectorAPI - Concepts - VectorOperations": "Perform single instruction multiple data (SIMD) operations.",
	"CI - Building - BytecodeToNative - VectorAPI - Concepts - Species": "Defines the shape (size and type) of vectors (e.g., 256-bit float vector).",
	"CI - Building - BytecodeToNative - VectorAPI - Concepts - LaneWiseOperations": "Operations applied to each element (lane) of the vector.",
	"CI - Building - BytecodeToNative - VectorAPI - Usage": "The Vector API is particularly useful for: Scientific computing, Machine learning, Image processing, Cryptography, Any numerically intensive workloads",
	"CI - Building - BytecodeToNative - WarningsForValueBasedClasses - Java16": "Starting with Java 16 (as part of JEP 390), the compiler generates warnings when programs synchronize on instances of value-based classes. This is part of Java's gradual migration toward value objects (a preview feature in later versions) and primitive classes.",
	"CI - Building - BytecodeToNative - WarningsForValueBasedClasses - SynchronizationWarnings": "",
	"CI - Building - BytecodeToNative - WarningsForValueBasedClasses - IdentityHashCodeWarnings:": "",
	"CI - Building - BytecodeToNative - JIT": "code is compiled to native machine code during execution",
	"CI - Building - BytecodeToNative - JIT - Compilation": "JIT compilation is a form of dynamic compilation which combines the use of Ahead-Of-Time (AOT) compilation and interpretation, and thus has advantages and disadvantages from both technologies. JIT compilation combines the start-up speed of AOT compiled code with the flexibility of interpretation to create a faster solution. The main difference between JIT and AOT is that instead of interpreting bytecode every time a method is invoked, a JIT compiler will compile the bytecode into the machine code instructions of the running machine, and then invoke this object code instead. Another difference is that AOT also turns the bytecode of a virtual machine into native machine code so the interpreted code can be executed.",
	"CI - Building - BytecodeToNative - JIT - Compilation - JVMCI - Java9": "Java 9 specifies a new interface for JIT compilers that’s written in Java (JVMCI). This means that anybody can ship a JIT compiler that can be easily attached to a VM. The compiler can be the exclusive JIT compiler in a system, or it can work hand-in-hand with a built-in JIT compiler in tiered mode. In the first case, the compiler (which is just Java code, just like any application), interprets and eventually compiles itself. In the latter case however, the compiled code can be used for any compilation tier. Hotspot, like many other VMs, already defaults to a tiered compilation mode. In this mode, a method starts out by being interpreted, but after reaching a specific number of executions, it is compiled by the client compiler (which generates code quickly, but only with rather simple optimizations). Finally once enough executions have occurred, the code is compiled by the server compiler (which is comparably slow, but applies aggressive optimizations) for maximum performance. The custom JIT can be inserted at any level. This means it can be used both as a middle tier or as the final tier. a Java based JVM compiler interface (JVMCI) enabling a compiler written in Java to be used by the JVM as a dynamic compiler.",
	"CI - Building - BytecodeToNative - JIT - Compilation - EscapeAnalysis": "Escape Analysis is an optimization technique used by the Java Virtual Machine (JVM) to analyze the scope of objects in Java programs and determine whether objects can be allocated on the stack instead of the heap.",
	"CI - Building - BytecodeToNative - JIT - Compilation - scapeAnalysis - Analysis - NoEscape": "The object doesn't escape the method or thread it was created in",
	"CI - Building - BytecodeToNative - JIT - Compilation - EscapeAnalysis - Analysis - MethodEscape": "The object escapes the method but not the thread (passed to another method but not stored where another thread can access it)",
	"CI - Building - BytecodeToNative - JIT - Compilation - EscapeAnalysis - Analysis - ThreadEscape": "The object escapes the thread (stored in a static field or instance field of another object that might be accessed by another thread)",
	"CI - Building - BytecodeToNative - JIT - Compilation - EscapeAnalysis - Optimizations - StackAllocation": "Objects that don't escape the method can be allocated on the stack rather than the heap, reducing garbage collection overhead.",
	"CI - Building - BytecodeToNative - JIT - Compilation - EscapeAnalysis - Optimizations - ScalarReplacement": "The object may be broken down into its constituent primitive fields (scalars) which can then be stored in registers or on the stack.",
	"CI - Building - BytecodeToNative - JIT - Compilation - EscapeAnalysis - Optimizations - LockElision": "Synchronization on objects that don't escape the thread can be removed since no other thread can access them.",
	"CI - Building - BytecodeToNative - JIT - Compilers - EclipseOpenJ9 ": "",
	"CI - Building - BytecodeToNative - JIT - Compilers - AzulZulu ": "",
	"CI - Building - BytecodeToNative - JIT - Compilers - DalvikVM ": "",
	"CI - Building - BytecodeToNative - JIT - Compilers - C1 ": "",
	"CI - Building - BytecodeToNative - JIT - Compilers - C2 ": "",
	"CI - Building - BytecodeToNative - JIT - Compilers - GraalJIT ": "",
	"CI - Building - BytecodeToNative - JIT - Compilers - KeyJIT ": "",
	"CI - Building - BytecodeToNative - JIT - Compilers - AmazonCorretto ": "",
	"CI - Building - BytecodeToNative - JIT - Compilers - JRockitVM ": "",
	"CI - Building - BytecodeToNative - JIT - Compilers - JRockitVM": "",
	"CI - Building - BytecodeToNative - JIT - Compilers - JRockitVM - DiagnosticCommands": "You can use diagnostic commands to communicate with a running Oracle JRockit JVM process. These commands tell the JRockit JVM to perform tasks such as printing a heap report or a garbage collection activity report, or enabling a specific verbose module. You can send diagnostic commands to a running JVM process in several ways: (1) By using jrcmd, a command-line tool that sends the commands to a given JRockit JVM process. (2) By pressing Ctrl-Break, the JVM will search for the ctrlhandler.act file and execute the commands in it. (3) By using the JRockit Management Console in Oracle JRockit Mission Control to send diagnostic commands to a running JRockit JVM process. You can enable or disable diagnostic command by using the system property -Djrockit.ctrlbreak.enable<name>=<true|false>, where name is the name of the diagnostic command. The run_class handler is not enabled by default. To enable it, enter the following: -Djrockit.ctrlbreak.enablerun_class=true",
	"CI - Building - BytecodeToNative - JIT - Compilers - JRockitVM - DiagnosticCommands - jrcmd": "Enter jrcmd at the command line with the appropriate parameters. jrcmd <jrockit pid> [<command> [<arguments>]] [-l] [-f file] [-p] -h]",
	"CI - Building - BytecodeToNative - JIT - Compilers - HotSpotVM": "The Java HotSpot Virtual Machine is a core component of the Java SE platform. It implements the Java Virtual Machine Specification, and is delivered as a shared library in the Java Runtime Environment. As the Java bytecode execution engine, it provides Java runtime facilities, such as thread and object synchronization, on a variety of operating systems and architectures. It includes dynamic compilers that adaptively compile Java bytecodes into optimized machine instructions and efficiently manages the Java heap using garbage collectors, optimized for both low pause time and throughput. It provides data and information to profiling, monitoring and debugging tools and applications.",
	"CI - Building - BytecodeToNative - JIT - Compilers - HotSpotVM - bytecode": "running Java applications through the Java Virtual Machine, commonly known as Hotspot VM, which interprets bytecode",
	"CI - Building - BytecodeToNative - JIT - Compilers - HotSpotVM - CommandLine": "The HotSpot JVM provides several command-line arguments related to Just In Time (JIT) compilation. In this post, I look at the steps needed to start applying the command-line flag -XX:CompileCommand to see the just-in-time compilation being performed on individual methods.",
	"CI - Building - BytecodeToNative - JIT - Compilers - HotSpotVM - CompilerControl (Java 9)": "Compiler Control provides a way to control Java Virtual Machine (JVM) compilation through compiler directive options. The level of control is runtime-manageable and method specific. Compiler Control supersedes and is backward compatible with CompileCommand.",
	"CI - Building - BytecodeToNative - JIT - Compilers - HotSpotVM - CompilerControl - directives": "A compiler directive is an instruction that tells the JVM how compilation should occur. A directive provides method-context precision in controlling the compilation process. Directives are a powerful tool for writing small, contained, JVM compiler tests because tests can be run without restarting the entire JVM. Compiler Control is also very useful for creating workarounds for bugs in the JVM compilers. You can specify a file that contains compiler directives while starting a program through the command line. You can also add or remove directives from an already running program through diagnostic commands.",
	"CI - Building - BytecodeToNative - JIT - Compilers - HotSpotVM - enable": "It is very easy to enable the experimental JIT compiler though as it is already included as part of the JDK. You just have to set the following options when running Java from the command line: -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler",
	"CI - Building - BytecodeToNative - JIT - Compilers - HotSpotVM - codecache": "The Java Virtual Machine (JVM) generates native code and stores it in a memory area called the codecache.",
	"CI - Building - BytecodeToNative - JIT - Compilers - HotSpotVM - codecache - segments (Java 9)": "Divide the code cache into distinct segments, each of which contains compiled code of a particular type, in order to improve performance and enable future extensions.",
	"CI - Building - BytecodeToNative - JIT - Compilers - HotSpotVM - javac": "",
	"CI - Building - BytecodeToNative - JIT - Compilers - HotSpotVM - sjavac (Java 9)": "The sjavac tool is an (allegedly smart) wrapper around javac, developed at Oracle and intended to provide the following features: incremental compiles - recompile only what's necessar, parallel compilation - utilize more than one core during compilation, keep compiler in a hot VM - reuse a JIT'ed javac instance for consecutive invocations",
	"CI - Building - BytecodeToNative - AoT": "code is compiled to native machine code before execution.",
	"CI - Building - BytecodeToNative - AoT - Java 9": "An AOT compiler was added to the OpenJDK as part of the Java 9 release. The main goal was to improve the start-up time of Java applications with minimum impact to the application’s peak performance. Whilst not as fast as a warmed up JIT compilation AOT avoids incurring performance penalties from having to repeat interpreted invocations.",
	"CI - Building - BytecodeToNative - AoT - SubstrateVM ": "Graal’s Substrate VM is a framework that allows compilation of Java programs into self-contained executables. Substrate VM is an internal project name for the technology behind GraalVM Native Image.",
	"CI - Building - BytecodeToNative - AoT - GraalVM": "GraalVM is an advanced JDK with ahead-of-time Native Image compilation.",
	"CI - Building - BytecodeToNative - AoT - GraalVM - Distributions": "There are three distributions: Oracle GraalVM Community Edition (CE), Oracle GraalVM Enterprise Edition (EE) and Mandrel.",
	"CI - Building - BytecodeToNative - AoT - GraalVM - Distributions - OracleGraalVMCommunityEdition": ".",
	"CI - Building - BytecodeToNative - AoT - GraalVM - Distributions - OracleGraalVMEnterpriseEdition": ".",
	"CI - Building - BytecodeToNative - AoT - GraalVM - Distributions - Mandrel": "Mandrel is a downstream distribution of the Oracle GraalVM CE. Mandrel’s main goal is to provide a way to build native executables specifically designed to support Quarkus.",
	"CI - Building - BytecodeToNative - AoT - GraalVM - AoT": "It supports ahead-of-time (AOT) compilation, reducing runtime overhead dramatically. ",
	"CI - Building - BytecodeToNative - AoT - ExcelsiorJET": "",
	"CI - Building - BytecodeToNative - AoT - AzulZulu": "",
	"CI - Building - BytecodeToNative - AoT - AndroidRuntime": "",
	"CI - Building - SourceToNative - Autocompilation - Java11": "we don’t need to compile the Java source files with javac explicitly anymore: we can directly run the file using the java command: $ java HelloWorld.java",
	"CI - Building - SourceToNative - Autocompilation - IndifyStringConcatenation - Java11": "Indify String Concatenation refers to a major optimization introduced in Java 9 (via JEP 280) that changed how the Java compiler handles string concatenation (+ operations) to improve performance.",
	"CI - Building - SourceToNative - Autocompilation - IndifyStringConcatenation - StringBuilder": "Before Java 9: String concatenation (\"a\" + \"b\") compiled to StringBuilder operations: new StringBuilder().append('Hello, ').append(name).append('!').toString(); -> inefficient",
	"CI - Building - SourceToNative - Autocompilation - IndifyStringConcatenation - invokedynamic": "Since Java 9: Uses invokedynamic (a JVM feature) for runtime optimization",

	"CI - Integration": "SECTION",
	"CI - Integration - Execution - JVMConstantsAPI - Java12": "Java 12 introduced a new JVM Constants API as an incubator feature (later finalized in Java 15) to provide programmatic access to low-level classfile and runtime artifacts that were previously only accessible through native code or reflection hacks.",
	"CI - Integration - Execution - JVMConstantsAPI - Constants - CONSTANT_Class": "",
	"CI - Integration - Execution - JVMConstantsAPI - Constants - CONSTANT_MethodHandle": "",
	"CI - Integration - Execution - Lifecycle - Loading": "Loading refers to the process of finding the binary form of a class or interface with a particular name",
	"CI - Integration - Execution - Lifecycle - Loading - class": "The binary representation of a class or interface is normally the class file format",
	"CI - Integration - Execution - Lifecycle - Loading - ClassLoaders": "",
	"CI - Integration - Execution - Lifecycle - Loading - ClassLoaders - ClassLoader": "",
	"CI - Integration - Execution - Lifecycle - Loading - ClassLoaders - ClassLoader - loadClass": "",
	"CI - Integration - Execution - Lifecycle - Loading - ClassLoaders - ClassLoader - defineClass": "",
	"CI - Integration - Execution - Lifecycle - Loading - ClassLoaders - ClassLoader - findClass": "",
	"CI - Integration - Execution - Lifecycle - Loading - ClassLoaders - ClassLoader - getParent": "",
	"CI - Integration - Execution - Lifecycle - Loading - ClassLoaders - ClassLoader - getResource": "",
	"CI - Integration - Execution - Lifecycle - Loading - ClassLoaders - Types - BootstrapClassLoader": "Bootstrap class loader – The virtual machine’s built-in class loader, is represented as null. A bootstrap or primordial class loader is the parent of all the others; however, it doesn’t have a parent.",
	"CI - Integration - Execution - Lifecycle - Loading - ClassLoaders - Types - PlatformClassLoader": "Platform class loader – Loads the platform classes, which include the Java SE platform APIs, their implementation classes, and JDK-specific run-time classes. The platform class loader is the parent of the system class loader. The platform class loader is a child of the bootstrap class loader",
	"CI - Integration - Execution - Lifecycle - Loading - ClassLoaders - Types - SystemClassLoader": "System class loader – Also known as application class loader, loads classes on the application class path, module path, and JDK-specific tools. It’s also a child of the platform class loader.",
	"CI - Integration - Execution - Lifecycle - Loading - ClassLoaders - Types - ContextClassLoader": "The java.lang.Thread class has a method, getContextClassLoader(), that returns the ContextClassLoader for the particular thread. The ContextClassLoader is provided by the creator of the thread when loading resources and classes. As of Java SE 9, threads in the fork/join common pool always return the system class loader as their thread context class loader.",
	"CI - Integration - Execution - Lifecycle - Loading - ClassLoaders - DelegationMode": "Class loaders follow the delegation model, where on being requested to find a class or resource, a ClassLoader instance will delegate the search of the class or resource to the parent class loader.",
	"CI - Integration - Execution - Lifecycle - Loading - ClassLoaders - DelegationMode - UniqueClasses": "As a consequence of the delegation model, it’s easy to ensure unique classes, as we always try to delegate upwards. If the parent class loader isn’t able to find the class, only then will the current instance attempt to do so itself.",
	"CI - Integration - Execution - Lifecycle - Loading - ClassLoaders - Visibility": "In addition, child class loaders are visible to classes loaded by their parent class loaders. For instance, classes loaded by the system class loader have visibility into classes loaded by the platform and bootstrap class loaders, but not vice-versa.",
	"CI - Integration - Execution - Lifecycle - Loading - ClassLoaders - Custom": "The built-in class loader is sufficient for most cases where the files are already in the file system. However, in scenarios where we need to load classes out of the local hard drive or a network, we may need to make use of custom class loaders.",
	"CI - Integration - Execution - Lifecycle - Loading - AoT - Java24": "This feature is part of Project Leyden, which aims to optimize Java’s startup and warmup performance by shifting certain computations from runtime to build time.",
	"CI - Integration - Execution - Lifecycle - Linking": "Linking is the process of taking a binary form of a class or interface and combining it into the run-time state of the Java Virtual Machine, so that it can be executed.",
	"CI - Integration - Execution - Lifecycle - Linking - Steps": "Linking involves verification, preparation, and (optionally) resolution.",
	"CI - Integration - Execution - Lifecycle - Linking - Steps - Verification": "Verification checks that the loaded representation of Test is well-formed, with a proper symbol table. Verification also checks that the code that implements Test obeys the semantic requirements of the Java programming language and the Java Virtual Machine",
	"CI - Integration - Execution - Lifecycle - Linking - Steps - Preparation": "Preparation involves allocation of static storage and any data structures that are used internally by the implementation of the Java Virtual Machine, such as method tables",
	"CI - Integration - Execution - Lifecycle - Linking - Steps - Resolution": "Resolution is the process of checking symbolic references from Test to other classes and interfaces, by loading the other classes and interfaces that are mentioned and checking that the references are correct.",
	"CI - Integration - Execution - Lifecycle - Linking - AoT - Java24": "This feature is part of Project Leyden, which aims to optimize Java’s startup and warmup performance by shifting certain computations from runtime to build time.",
	"CI - Integration - Execution - Lifecycle - Initialization": "Initialization consists of execution of any class variable initializers and static initializers of the class Test, in textual order. But before Test can be initialized, its direct superclass must be initialized, as well as the direct superclass of its direct superclass, and so on, recursively.",
	"CI - Integration - Execution - Lifecycle - Initialization - Sync": "Because the Java programming language is multithreaded, initialization of a class or interface requires careful synchronization, since some other thread may be trying to initialize the same class or interface at the same time.",
	"CI - Integration - Execution - Lifecycle - Initialization - < clinit >": "In Java, clinit is a special method generated by the Java compiler for initializing static variables and executing static initialization blocks in a class. It is internally used by the Java Virtual Machine (JVM) and is not directly visible in the source code.",
	"CI - Integration - Execution - Lifecycle - Initialization - < clinit > - static": "If a class has static variables or static blocks, the Java compiler generates the <clinit> method. If there are no static initializations, <clinit> is not generated.",
	"CI - Integration - Execution - Lifecycle - Initialization - < clinit > - onLoading": "Runs only once when the class is first loaded by the JVM.",
	"CI - Integration - Execution - Lifecycle - Initialization - < clinit > - order": "Static variables and blocks are executed in the order they appear in the source code.",
	"CI - Integration - Execution - Lifecycle - Initialization - < clinit > - safety": "The JVM ensures that <clinit> is executed in a thread-safe manner (only one thread can initialize the class).",
	"CI - Integration - Execution - Lifecycle - Initialization - < init >": "Initializes instance members (constructor). ",
	"CI - Integration - Execution - Lifecycle - Initialization - < init > - members": "Initializes instance members (constructor). ",
	"CI - Integration - Execution - Lifecycle - Initialization - < init > - onCreation": "Initializes instance members (constructor). ",
	"CI - Integration - Execution - Lifecycle - Initialization - < init > - safety": "No automatic thread safety.",
	"CI - Integration - Execution - Lifecycle - Instantiation": ".",
	"CI - Integration - Execution - Lifecycle - Instantiation - Cases - ClassInstance": "A new class instance is explicitly created when evaluation of a class instance creation expression causes a class to be instantiated.",
	"CI - Integration - Execution - Lifecycle - Instantiation - Cases - TextBlock": "Loading of a class or interface that contains a string literal or a text block may create a new String object to denote the string represented by the string literal or text block",
	"CI - Integration - Execution - Lifecycle - Instantiation - Cases - Boxing": "Execution of an operation that causes boxing conversion",
	"CI - Integration - Execution - Lifecycle - Instantiation - Cases - StringConcatenation": "Execution of a string concatenation operator +",
	"CI - Integration - Execution - Lifecycle - Instantiation - Cases - MethodReference": "Evaluation of a method reference expression (§15.13.3) or a lambda expression",
	"CI - Integration - Execution - Lifecycle - Instantiation - Cases - LambdaExpression": "Evaluation of a method reference expression (§15.13.3) or a lambda expression",
	"CI - Integration - Execution - Lifecycle - Instantiation - Constructor": "Each of these situations identifies a particular constructor to be called with specified arguments (possibly none) as part of the class instance creation process.",
	"CI - Integration - Execution - Lifecycle - Instantiation - Memory - Allocation": "Whenever a new class instance is created, memory space is allocated for it with room for all the instance variables declared in the class and all the instance variables declared in each superclass of the class, including all the instance variables that may be hidden",
	"CI - Integration - Execution - Lifecycle - Invokation": ", after completion of the initialization for class Test (during which other consequential loading, linking, and initializing may have occurred), the method main of Test is invoked.",
	"CI - Integration - Execution - Lifecycle - Invokation - main": "The method main must be declared public, static, and void.",
	"CI - Integration - Execution - Lifecycle - Finalization": "",
	"CI - Integration - Execution - Lifecycle - Finalization - finalize": "The class Object has a protected method called finalize; this method can be overridden by other classes. The particular definition of finalize that can be invoked for an object is called the finalizer of that object.",
	"CI - Integration - Execution - Lifecycle - Finalization - GC": "Before the storage for an object is reclaimed by the garbage collector, the Java Virtual Machine will invoke the finalizer of that object.",
	"CI - Integration - Execution - Lifecycle - Finalization - Resources": "Finalizers provide a chance to free up resources that cannot be freed automatically by an automatic storage manager.",
	"CI - Integration - Execution - Lifecycle - Unloading": "An implementation of the Java programming language may unload classes. Classes and interfaces loaded by the bootstrap loader may not be unloaded.",
	"CI - Integration - Execution - Lifecycle - ProgramExit": "",
	"CI - Integration - Execution - Mechanisms - FromSource - Java11": "java MyProgram.java",
	"CI - Integration - Execution - Mechanisms - FromSource - -source - Java21": "java --source 21 --enable-preview Main.java",
	"CI - Integration - Execution - Mechanisms - FromSource - Complex - Java21": "java --source-path src -m com.example/com.example.Main",
	"CI - Integration - Execution - Mechanisms - JShell": "",
	"CI - Integration - Execution - Mechanisms - JShell - Java9": "The Java Shell tool (JShell) is an interactive tool for learning the Java programming language and prototyping Java code. JShell is a Read-Evaluate-Print Loop (REPL), which evaluates declarations, statements, and expressions as they are entered and immediately shows the results. The tool is run from the command line.",
	"CI - Integration - Memory": "",
	"CI - Integration - Memory - Optimizations - Records": "Records generally have a smaller memory footprint than equivalent POJOs (Plain Old Java Objects) due to several JVM optimizations, but the exact savings depend on context.",
	"CI - Integration - Memory - Stack": "Stores method calls and local variables.",
	"CI - Integration - Memory - Stack - Features - size": "The size of the stack will vary as methods and functions create and delete local variables as needed. Stack has size limits, which can vary according to the operating system you use.",
	"CI - Integration - Memory - Stack - Features - Lifecycle": "Memory is allocated and then subsequently freed without you needing to manage the memory allocation. Variables that are stored on the stack exist for as long as the function that created them are running.",
	"CI - Integration - Memory - Stack - Features - LIFO": "Follows LIFO (Last In, First Out) – The last method added is removed first.",
	"CI - Integration - Memory - Stack - Features - FastAccess": "Fast Access – Stack memory is very fast compared to heap memory.",
	"CI - Integration - Memory - Stack - Features - ThreadSpecific": "Thread-Specific – Each thread gets its own stack.",
	"CI - Integration - Memory - Stack - Stores": ".",
	"CI - Integration - Memory - Stack - Stores - MethodExecution": "Method execution (stores method calls).",
	"CI - Integration - Memory - Stack - Stores - LocalVariables": "Local variables (primitives & references to objects).",
	"CI - Integration - Memory - Stack - Stores - FunctionCallManagement": "Function call management (each method has its own stack frame).",
	"CI - Integration - Memory - Stack - Reserved Areas - Java9": "Reserve extra space on thread stacks for use by critical sections, so that they can complete even when stack overflows occur..",
	"CI - Integration - Memory - Stack - StackTrace": "Java 1.4 also introduced the StackTraceElement[] getStackTrace() method to the java.lang.Thread and java.lang.Throwable classes. This method respectively returns an array of stack trace elements representing the invoking thread's stack dump and provides programmatic access to the stack trace information printed by printStackTrace().",
	"CI - Integration - Memory - Stack - StackTrace - StackWalker": "StackWalker provides four static getInstance() methods that return StackWalkers. The methods differ in whether or not the walkers also access hidden frames or refective frames (a subset of hidden frames) and retain Class references:",
	"CI - Integration - Memory - Stack - StackTrace - StackWalker - Walking": "Once you have a StackWalker instance, you can access stack frames by invoking the forEach() and walk() methods.",
	"CI - Integration - Memory - PermGen - <Java7": "Permanent Generation or Perm Gen contains the application metadata required by the JVM to describe the classes and methods used in the application. Note that Perm Gen is not part of Java Heap memory. Perm Gen is populated by JVM at runtime based on the classes used by the application. Perm Gen also contains Java SE library classes and methods. Perm Gen objects are garbage collected in a full garbage collection.",
	"CI - Integration - Memory - PermGen - MethodArea": "Method Area is part of space in the Perm Gen and used to store class structure (runtime constants and static variables) and code for methods and constructors.",
	"CI - Integration - Memory - PermGen - MemoryPool - <Java7": "Memory Pools are created by JVM memory managers to create a pool of immutable objects, if implementation supports it. String Pool is a good example of this kind of memory pool. Memory Pool can belong to Heap or Perm Gen, depending on the JVM memory manager implementation.",
	"CI - Integration - Memory - PermGen - Runtime Constant Pool": "Runtime constant pool is per-class runtime representation of constant pool in a class. It contains class runtime constants and static methods. Runtime constant pool is the part of method area.",
	"CI - Integration - Memory - PermGen - Java Stack Memory": "Java Stack memory is used for execution of a thread. They contain method specific values that are short-lived and references to other objects in the heap that are getting referred from the method.",
	"CI - Integration - Memory - PermGen - Size - -XX:PermGen": "For setting the initial heap size when JVM starts",
	"CI - Integration - Memory - PermGen - Size - -XX:MaxPermGen": "For setting the maximum size of Perm Gen",
	"CI - Integration - Memory - PermGen - Size - -XX:SurvivorRatio": "For providing ratio of Eden space and Survivor Space, for example if Young Generation size is 10m and VM switch is -XX:SurvivorRatio=2 then 5m will be reserved for Eden Space and 2.5m each for both the Survivor spaces. The default value is 8",
	"CI - Integration - Memory - PermGen - Size - -XX:NewRatio": "For providing ratio of old/new generation sizes. The default value is 2.",
	"CI - Integration - Memory - MetaSpace - Stores": "It is used to store metadata such as class definitions, method data, and field data.",
	"CI - Integration - Memory - MetaSpace - Java8": "The PermGen has been removed completely and replaced by MetaSpace. Metaspace is no more part of the heap memory, but of the native memory allocated to the process.",
	"CI - Integration - Memory - MetaSpace - Capacity": "By default class metadata allocation is limited by the amount of available native memory (capacity will of course depend if you use a 32-bit JVM vs. 64-bit along with OS virtual memory availability).",
	"CI - Integration - Memory - MetaSpace - MaxMetaspaceSize": "A new flag is available (MaxMetaspaceSize), allowing you to limit the amount of native memory used for class metadata. If you don’t specify this flag, the Metaspace will dynamically re-size depending of the application demand at runtime.",
	"CI - Integration - Memory - MetaSpace - GC": "Garbage collection of the dead classes and classloaders is triggered once the class metadata usage reaches the “MaxMetaspaceSize.",
	"CI - Integration - Memory - Heap": "Stores objects and instance variables.",
	"CI - Integration - Memory - Heap - Features": ".",
	"CI - Integration - Memory - Heap - Features - shared": "Shared by all threads – Unlike the stack, the heap is common for all threads.",
	"CI - Integration - Memory - Heap - Features - slower": "Slower than stack – Since it requires garbage collection.",
	"CI - Integration - Memory - Heap - Features - GC": "Garbage Collection (GC) – Objects that are no longer referenced are removed.",
	"CI - Integration - Memory - Heap - Features - dynamic": "Used for Dynamic Memory Allocation – Objects remain in memory as long as needed.",
	"CI - Integration - Memory - Heap - Stores - Objects": "All Java objects (instance variables, arrays, collections).",
	"CI - Integration - Memory - Heap - Stores - new": "Objects created with new keyword.",
	"CI - Integration - Memory - Heap - Stores - long": "Long-lived data (remains until garbage collection).",
	"CI - Integration - Memory - Heap - Parts": "JVM Heap memory is physically divided into two parts – Young Generation and Old Generation.",
	"CI - Integration - Memory - Heap - Parts - OldGeneration.": "Objects that are survived after many cycles of GC, are moved to the Old generation memory space. Usually it’s done by setting a threshold for the age of the young generation objects before they become eligible to promote to Old generation.",
	"CI - Integration - Memory - Heap - Parts - OldGeneration": "Old Generation memory contains the objects that are long lived and survived after many rounds of Minor GC. Usually garbage collection is performed in Old Generation memory when it’s full. Old Generation Garbage Collection is called Major GC and usually takes longer time.",
	"CI - Integration - Memory - Heap - Parts - YoungGeneration": "Young generation is the place where all the new objects are created. When young generation is filled, garbage collection is performed. This garbage collection is called Minor GC.",
	"CI - Integration - Memory - Heap - Parts - YoungGeneration - Parts": "Young Generation is divided into three parts – Eden Memory and two Survivor Memory spaces S0 and S1.",
	"CI - Integration - Memory - Heap - Parts - YoungGeneration - Parts - Eden": "Most of the newly created objects are located in the Eden memory space.",
	"CI - Integration - Memory - Heap - Parts - YoungGeneration - Parts - S0": "When Eden space is filled with objects, Minor GC is performed and all the survivor objects are moved to one of the survivor spaces.",
	"CI - Integration - Memory - Heap - Parts - YoungGeneration - Parts - S1": "Minor GC also checks the survivor objects and move them to the other survivor space. So at a time, one of the survivor space is always empty.",
	"CI - Integration - Memory - Heap - Parts - StringPool": "Since Java 7, the String Pool was moved to the main heap memory to avoid OutOfMemoryError issues related to PermGen.",
	"CI - Integration - Memory - Heap - Parts - StringPool - Location": "Initially, interned strings go into the Young Generation (Eden space). If they survive GC, they move to the Old Generation. Frequently used strings (e.g., 'java', 'main') live in the Old Generation. ",
	"CI - Integration - Memory - Heap - Parts - StringPool - Storage - Inmutability": "String is immutable in Java. An immutable class is simply a class whose instances cannot be modified. All information in an instance is initialized when the instance is created and the information can not be modified. ",
	"CI - Integration - Memory - Heap - Parts - StringPool - Storage - Inmutability - ThreadSafe": "Immutable objects are naturally thread-safe Because immutable objects can not be changed, they can be shared among multiple threads freely. This eliminates the requirements of doing synchronization.",
	"CI - Integration - Memory - Heap - Parts - StringPool - Storage - StringPool": "String pool (String intern pool) is a special storage area in MethodArea. When a string is created and if the string already exists in the pool, the reference of the existing string will be returned, instead of creating a new object. If a string is mutable, changing the string with one reference will lead to the wrong value for the other references.",
	"CI - Integration - Memory - Heap - Parts - StringPool - Storage - StringPool - Interning": "The JVM maintains a global String pool (in the heap’s 'interned strings' table).",
	"CI - Integration - Memory - Heap - Parts - StringPool - Storage - StringPool - Interning - intern()": "Manually invoke String.intern(): If the String exists in the pool, returns the pooled reference. If not, adds the String to the pool and returns it.",
	"CI - Integration - Memory - Heap - Parts - StringPool - Storage - StringPool - Interning - cost": "Interning is faster for lookups but can pollute the permanent pool.",
	"CI - Integration - Memory - Heap - Parts - StringPool - Deduplication": "Runs as part of Garbage Collection (GC). The JVM identifies duplicate String objects in the heap. If duplicates are found, the JVM replaces multiple char[] arrays with a single shared copy. Automatic & transparent.",
	"CI - Integration - Memory - Heap - Parts - StringPool - Deduplication - enable": "-XX:+UseG1GC -XX:+UseStringDeduplication",
	"CI - Integration - Memory - Heap - Parts - StringPool - Deduplication - cost": "Deduplication is cheaper (runs during GC) but doesn’t eliminate String overhead. Java 17’s default G1 GC + deduplication often provides the best balance for most applications. For specialized cases (e.g., parsers), manual interning may still help.",
	"CI - Integration - Memory - Heap - Parts - StringPool - CompactString - Java9": "Until now, the String was stored as a char[]: From now on, it’ll be a byte[]: This means that whenever we create a String if all the characters of the String can be represented using a byte — LATIN-1 representation, a byte array will be used internally, such that one byte is given for one character. In other cases, if any character requires more than 8-bits to represent it, all the characters are stored using two bytes for each — UTF-16 representation. So basically, whenever possible, it’ll just use a single byte for each character.",
	"CI - Integration - Memory - Heap - Parts - StringPool - CompactString - Solution": "The String class was rewritten to use a byte[] instead of char[]",
	"CI - Integration - Memory - Heap - Parts - StringPool - CompactString - Solution - char[] - <Java9": "Prior to Java 9, Strings in Java were stored internally as: A char[] (character array). Each char using 2 bytes (UTF-16 encoding). This was inefficient for strings containing mostly Latin-1 characters (ISO-8859-1), which only need 1 byte per character",
	"CI - Integration - Memory - Heap - Parts - StringPool - CompactString - Solution - byte[] - Java9+": "Strings containing only Latin-1 characters (0x00-0xFF) are stored as byte[] (1 byte per character). Strings with any other characters use byte[] with UTF-16 encoding (2 bytes per character)",
	"CI - Integration - Memory - Heap - Parts - StringPool - CompactString - Features - Automatic": "Automatic Handling: The JVM automatically chooses the appropriate representation",
	"CI - Integration - Memory - Heap - Parts - StringPool - CompactString - Features - BackwardCompatibility": "All String methods behave exactly as before. No changes needed in existing code",
	"CI - Integration - Memory - Heap - Size - -Xms": "For setting the initial heap size when JVM starts",
	"CI - Integration - Memory - Heap - Size - -Xmx": "For setting the maximum heap size.",
	"CI - Integration - Memory - Heap - Size - -Xmn": "For setting the size of the Young Generation, rest of the space goes for Old Generation.",
	"CI - Integration - Memory - Heap - Size - XX:AllocateHeapAt=<path> (Java 10)": "Some operating systems already expose non-DRAM memory through the file system. Examples are NTFS DAX mode and ext4 DAX. Memory-mapped files in these file systems bypass the page cache and provide a direct mapping of virtual memory to the physical memory on the device. To allocate the heap in such memory we can add a new option, -XX:AllocateHeapAt=<path>. This option would take a path to the file system and use memory mapping to achieve the desired result of allocating the object heap on the memory device. The JEP does not intend to share a non-volatile region between multiple running JVMs or re-use the same region for further invocations of the JVM.",
	"CI - Integration - Memory - Heap - GC": "Garbage Collector is the program running in the background that looks into all the objects in the memory and find out objects that are not referenced by any part of the program. All these unreferenced objects are deleted and space is reclaimed for allocation to other objects.",
	"CI - Integration - Memory - Heap - GC - Operation - Stop the World": "All the Garbage Collections are “Stop the World” events because all application threads are stopped until the operation completes.",
	"CI - Integration - Memory - Heap - GC - Operation - Duration": "The duration taken by garbage collector depends on the strategy used for garbage collection. That’s why it’s necessary to monitor and tune the garbage collector to avoid timeouts in the highly responsive applications.",
	"CI - Integration - Memory - Heap - GC - Operation - Minor Gc": "Since Young generation keeps short-lived objects, Minor GC is very fast and the application doesn’t get affected by this.",
	"CI - Integration - Memory - Heap - GC - Operation - Major Gc": "However Major GC takes longer time because it checks all the live objects. Major GC should be minimized because it will make your application unresponsive for the garbage collection duration. So if you have a responsive application and there are a lot of Major Garbage Collection happening, you will notice timeout errors.",
	"CI - Integration - Memory - Heap - GC - Operation - References": "",
	"CI - Integration - Memory - Heap - GC - Operation - References - StrongReference": "The strong reference is the most common kind of reference. We use this kind of reference every day.",
	"CI - Integration - Memory - Heap - GC - Operation - References - WeakReference": "WeakReference is the type of references that will be removed by the garbage collector on the next pass, if there are no other type references to the object. You can get an object value from the WeakReference until the GC decides to collect the object. As soon as the GC decides to do it — not after the GC finalize the object and clear an allocated memory—, you will get the NULL from the WeakReference. This happens when the GC is just marking the object for a further processing. It is important to understand that all finalization actions are executed only after this. When we look at the PhantomReference, we’ll return to this point. WeakReference<String> reference = new WeakReference<>(instance)",
	"CI - Integration - Memory - Heap - GC - Operation - References - WeakReference - WeakHashMap": "Java provides us with the WeakHashMap data structure. It’s something like a HashMap, which uses the WeakReference as a key of the Map. If a key of the WeakHashMap becomes garbage, its entry is removed automatically. WeakHashMap<String, Boolean> map = new WeakHashMap<>(),",
	"CI - Integration - Memory - Heap - GC - Operation - References - SoftReference": "The behavior of SoftReference is similar to WeakReference, but the GC collect this kind of reference only when our application does not have enough of memory. The GC collects our SoftReference before we get the OutOfMemoryError. This behavior is a good reason to use SoftReferences as a cache for a data that is difficult to build in memory. SoftReference<String> softReference = new SoftReference<>(instance)",
	"CI - Integration - Memory - Heap - GC - Operation - References - PhantomReference": "The PhantomReferences are enqueued only when the object is physically removed from memory. The get() method of the PhantomReference always returns NULL, especially to prevent you from being able to resurrect an almost removed object. The PhantomReference provides you with the ability to determine exactly when an object was removed from memory. In order for implementation, we need to work with a ReferenceQueue. When the referent object of a PhantomReference is removed from a memory, then the GC enqueues the  phantomReference in the  referenceQueue, and we can poll this reference from this queue.    ReferenceQueue<Foo> referenceQueue = new ReferenceQueue<>(),    PhantomReference<Foo> phantomReference = new PhantomReference<>(foo, referenceQueue),",
	"CI - Integration - Memory - Heap - GC - Types - SerialGC - Java1": "-XX:+UseSerialGC  Serial GC uses the simple mark-sweep-compact approach for young and old generations garbage collection i.e Minor and Major GC. Serial GC is useful in client-machines such as our simple stand alone applications and machines with smaller CPU. It is good for small applications with low memory footprint.",
	"CI - Integration - Memory - Heap - GC - Types - ParallelGC (-XX:+UseParallelGC) - Java1.2": "Parallel GC is same as Serial GC except that is spawns N threads for young generation garbage collection where N is the number of CPU cores in the system. We can control the number of threads using -XX:ParallelGCThreads=n JVM option. Parallel Garbage Collector is also called throughput collector because it uses multiple CPUs to speed up the GC performance. Parallel GC uses single thread for Old Generation garbage collection.",
	"CI - Integration - Memory - Heap - GC - Types - ParallelOldGC (-XX:+UseParallelOldGC)": "This is same as Parallel GC except that it uses multiple threads for both Young Generation and Old Generation garbage collection.",
	"CI - Integration - Memory - Heap - GC - Types - ConcurrentMarkSweep  - Java1.4.2": "Removed in Java14",
	"CI - Integration - Memory - Heap - GC - Types - ConcurrentMarkSweep - deprecated - Java9": "Deprecate the Concurrent Mark Sweep (CMS) garbage collector, with the intent to stop supporting it in a future major release.",
	"CI - Integration - Memory - Heap - GC - Types - ConcurrentMarkSweep (-XX:+UseConcMarkSweepGC)": "CMS Collector is also referred as concurrent low pause collector. It does the garbage collection for Old generation. CMS collector tries to minimize the pauses due to garbage collection by doing most of the garbage collection work concurrently with the application threads. CMS collector on young generation uses the same algorithm as that of the parallel collector. This garbage collector is suitable for responsive applications where we can’t afford longer pause times. We can limit the number of threads in CMS collector using -XX:ParallelCMSThreads=n JVM option.",
	"CI - Integration - Memory - Heap - GC - Types - G1 - Java9": "",
	"CI - Integration - Memory - Heap - GC - Types - G1 Garbage Collector (-XX:+UseG1GC)": "The Garbage First or G1 garbage collector is available from Java 7 and it’s long term goal is to replace the CMS collector. The G1 collector is a parallel, concurrent, and incrementally compacting low-pause garbage collector. Garbage First Collector doesn’t work like other collectors and there is no concept of Young and Old generation space. It divides the heap space into multiple equal-sized heap regions. When a garbage collection is invoked, it first collects the region with lesser live data, hence “Garbage First”. ",
	"CI - Integration - Memory - Heap - GC - Types - GC1 - default (Java 9)": "Make G1 the default garbage collector on 32- and 64-bit server configurations.",
	"CI - Integration - Memory - Heap - GC - Types - GC Interface (Java 10)": "Before Java10, the garbage collector code was fragmented in places scattered all over the HotSpot sources. As the JEP states: Adding a new garbage collector should be a matter of implementing a well documented set of interfaces, rather than figuring out all the places in HotSpot that needs changing. The aim is to refactor the HotSpot code so that GC implementations are mostly contained within source files in their respective directories, with as little code as possible outside of them. This code should also be used minimally outside of these directories (any code shared between GC’s should be placed in a helper class), and there should be very few GC specific if-else branches. Finally, as is usually the case, performance should not regress because of any changes made. This should also greatly improve the overall code quality.",
	"CI - Integration - Memory - Heap - GC - Types - GC1 - Parallel G1 (Java 10)": "The aim of this JEP is pretty much what it says on the tin – to parallelise G1’s full GC algorithm to improve performance. Due to the fact that G1 divides the memory up into regions, this change will most likely result in a little more wasted space (compared to a single-threaded algorithm), but in return you get a little boost to throughput and potentially your application’s performance as it’ll be spending less time performing full collections.",
	"CI - Integration - Memory - Heap - GC - Types - GC1 - XX:ParallelGCThreads (Java 10)": "You can also customise how many threads are used with the option -XX:ParallelGCThreads, though keep in mind that this will also affect the number of threads used for the Young and Mixed / minor collections too.",
	"CI - Integration - Memory - Heap - GC - Types - ZGC": ".",
	"CI - Integration - Memory - Heap - GC - Types - ZGC - Java11": "ZGC (-XX:+UseZGC) shines in ultra-low-latency scenarios.",
	"CI - Integration - Memory - Heap - GC - Types - ZGC - Generational": "The Generational ZGC enhances application performance by efficiently collecting short-lived objects more frequently, reducing pause times, and improving throughput.",
	"CI - Integration - Memory - Heap - GC - Types - ZGC - Generational - Java15": "With the release of JDK 23, Generational ZGC became the default garbage collector mode.",
	"CI - Integration - Memory - Heap - GC - Types - ZGC - NonGenerational - deprecated": "While the Non-Generational Mode remained available, it was deprecated and slated for removal in future Java versions.",
	"CI - Integration - Memory - Heap - GC - Types - Shenandoah - Java12": "Shenandoah is an ultra-low-pause-time garbage collector introduced in Java as an experimental feature (JEP 189 in Java 12) and later stabilized (JEP 379 in Java 15). It is designed to reduce GC pause times dramatically, even with large heaps, making it ideal for latency-sensitive applications.",

	"CI - Monitor": "SECTION",
	"CI - Monitor - Logging": ".",
	"CI - Monitor - Logging - InternalLogging - Java 9": "The new Java 9 Platform Logging API allows applications and frameworks to route JDK internal logs to the desired logging framework (e.g. Log4j2, SLF4J etc). This is the similar to what SLF4J does via its bridges (an example here) but now it is built into JDK and is meant to redirect JDK internal logs to the desired logging destination.",
	"CI - Monitor - Logging - InternalLogging - System.LoggerFinder ": ".",
	"CI - Monitor - Logging - InternalLogging - System.Logger ": ".",
	"CI - Monitor - Logging - UnifiedLogging - Java 9": "The JVM-internal, unified logging infrastructure is very similar to known logging frameworks like Log4j or Logback that you might have used for your application. It generates textual messages, attaches some meta information like tags (describing the originating subsystem), a log level (describing the importance of the message), and time stamps before printing them somewhere. The logging output can be configured according to your needs.",
	"CI - Monitor - Logging - UnifiedLogging - -Xlog": "Logging can be activated with the java option -Xlog. This is the only flag regarding this mechanism – any further configuration is immediately appended to that option. Configurable aspects of logging are: which messages to log (by tag and/or by log level), which information to include (for example time stamps and process IDs), which output to use (for example a file)",
	"CI - Monitor - Memory - Heap - HeapDumps": "jcmd <pid> GC.heap_dump /tmp/heap.hprof",
	"CI - Monitor - Memory - GC - PrintGCDetails": "-XX:+PrintGCDetails",
	"CI - Monitor - Memory - GC - PrintGCTimeStamps": "-XX:+PrintGCTimeStamps",
	"CI - Monitor - Memory - GC - Xloggc": "-Xloggc:gc.log",
	"CI - Monitor - Tools - jstat": "We can use jstat command line tool to monitor the JVM memory and garbage collection activities. It ships with standard JDK, so you don’t need to do anything else to get it. For executing jstat you need to know the process id of the application, you can get it easily using ps -eaf | grep java command.",
	"CI - Monitor - Tools - jvisualvm + Visual GC": "If you want to see memory and GC operations in GUI, then you can use jvisualvm tool. Java VisualVM is also part of JDK, so you don’t need to download it separately. Just run jvisualvm command in the terminal to launch the Java VisualVM application. Once launched, you need to install Visual GC plugin from Tools -< Plugins option, as shown in below image.",
	"CI - Monitor - JFREventStreaming": "JFR (JDK Flight Recorder) Event Streaming is a powerful feature introduced in Java 14 that allows continuous, low-overhead monitoring of JVM and application events without requiring dump files. It enables real-time access to JFR data programmatically.",
	"CI - Monitor - JFREventStreaming - Process - Start": "Start a recording in streaming mode.",
	"CI - Monitor - JFREventStreaming - Process - Subscribe": "Subscribe to events (e.g., CPU usage, GC pauses, exceptions).",
	"CI - Monitor - JFREventStreaming - Process - Process": "Process events in real-time (e.g., log, analyze, trigger actions)."

}