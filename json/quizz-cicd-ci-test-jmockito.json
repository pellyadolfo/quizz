{
	"Mockito": "SECTION",
	"Mockito - Thread Safe": "For healthy scenarios Mockito plays nicely with threads. For instance, you can run tests in parallel to speed up the build. Also, you can let multiple threads call methods on a shared mock to test in concurrent conditions. Check out a timeout() feature for testing concurrency. However Mockito is only thread-safe in healthy tests, that is tests without multiple threads stubbing/verifying a shared mock. Stubbing or verification of a shared mock from different threads is NOT the proper way of testing because it will always lead to intermittent behavior. In general, mutable state + assertions in multi-threaded environment lead to random results. If you do stub/verify a shared mock across threads you will face occasional exceptions like: WrongTypeOfReturnValue, etc.",
	"Mockito - Mocks Initialization": "MockitoAnnotations.initMocks(testClass), Initializes fields annotated with Mockito annotations. Allows shorthand creation of objects required for testing. Minimizes repetitive mock creation code. Makes the test class more readable. Makes the verification error easier to read because field name is used to identify the mock.",
	"Mockito - MockitoSession - mockitoSession()": "MockitoSession is an optional, highly recommended feature that helps driving cleaner tests by eliminating boilerplate code and adding extra validation. There is no need to use MockitoSession if you already use MockitoJUnitRunner or MockitoRule.",
	"Mockito - MockitoSession - finishMocking()": "Must be invoked when the user is done with mocking for given session (test method). It detects unused stubbings and may throw UnnecessaryStubbingException or emit warnings (MockitoHint) depending on the Strictness level. The method also detects incorrect Mockito usage via Mockito.validateMockitoUsage(). In order to implement Strictness Mockito session keeps track of mocking using MockitoListener. This method cleans up the listeners and ensures there is no leftover state after the session finishes. It is necessary to invoke this method to conclude mocking session. For more information about session lifecycle see MockitoSessionBuilder.startMocking(). This method is intended to be used in your test framework's 'tear down' method. In the case of JUnit it is the '@After' method.",
	"Mockito - MockitoSession - finishMocking(Throwable failure)": "Must be invoked when the user is done with mocking for given session (test method). When a failure is specified, certain checks are disabled to avoid confusion that may arise because there are multiple competing failures. Other than that, this method behaves exactly like finishMocking(). This method is intended to be used by framework integrations. When using MockitoSession directly, most users should rather use finishMocking(). MockitoRule uses this method behind the hood.",
	"Mockito - MockitoSession - setStrictness(Strictness strictness)": "Changes the strictness of this MockitoSession. The new strictness will be applied to operations on mocks and checks performed by finishMocking(). This method is used behind the hood by MockitoRule.strictness(Strictness) method. In most healthy tests, this method is not needed. We keep it for edge cases and when you really need to change strictness in given test method.",
	"Mockito - MockitoJUnitRunner - @RunWith(MockitoJUnitRunner.class)": "Runs with MockitoJUnitRunner.",
	"Mockito - MockitoJUnitRunner - Strict": "Class MockitoJUnitRunner.Silent - This Mockito JUnit Runner implementation ignores unused stubs (e.g. it remains 'silent' even if unused stubs are present). This was the behavior of Mockito JUnit runner in versions 1.x. Using this implementation of the runner is not recommended. Engineers should care for removing unused stubbings because they are dead code, they add unnecessary details, potentially making the test code harder to comprehend.",
	"Mockito - MockitoJUnitRunner - Silent": "Class MockitoJUnitRunner.Strict - Detects unused stubs and reports them as failures. Default behavior in Mockito 2.x. See UnnecessaryStubbingException. Also prints stubbing argument mismatch warnings when test fails",
	"Mockito - MockitoJUnitRunner - StrictStubs": "class MockitoJUnitRunner.StrictStubs - Improves debugging tests, helps keeping the tests clean. Planned default behavior of Mockito v3. Test fails early on stubbing argument mismatch to streamline debugging tests. Unused stubbings trigger test failures to keep tests clean.",
	"Mockito - MockitoJUnitRunner - MockitoHint": "Stubbing argument mismatch warnings. Starting with 2.1.0 of Mockito stubbing hints / warnings are printed to standard output. Hints contain clickable links that take you right to the line of code that contains a possible problem. Those are hints - they not necessarily indicate real problems 100% of the time. This way the developer can: produce cleaner tests - by detecting and removing unused stubs understand why test fails - by detecting stubs that were ineffective due to argument mismatch. How to take advantage of the hints? Use one of the JUnit integrations: MockitoJUnit.rule() MockitoJUnitRunner",
	"Mockito - MockitoJUnitRunner - MockitoHint - UnnecessaryStubbingException": "This exception indicates presence of unused stubbings. It is highly recommended to remove unused stubbings to keep the codebase clean. You can opt-out from detecting unused stubbings using MockitoJUnitRunner.Silent or MockitoRule.silent(). Unnecessary stubbings are stubbed method calls that were never realized during test execution.",
	"Mockito - MockitoRule - @Rule": "Mockito JUnit Rule helps keeping tests clean. It initializes mocks, validates usage and detects incorrect stubbing. Make sure to configure your rule with strictness(Strictness) which automatically detects stubbing argument mismatches and is planned to be the default in Mockito v3. Since Mockito 2.1.0, JUnit rule emits stubbing warnings and hints to System output (see MockitoHint). The JUnit rule can be used instead of MockitoJUnitRunner. It requires JUnit at least 4.7. The rule adds following behavior: Since 2.1.0, stubbing warnings and hints are printed to System output. Hints contain clickable links that take you right to the line of code that contains a possible problem. Please give us feedback about the stubbing warnings of JUnit rules in the issue tracker (issue 384). It's a new feature of Mockito 2.1.0. It aims to help debugging tests. If you wish the previous behavior, see silent(). However, we would really like to know why do you wish to silence the warnings! See also MockitoHint Initializes mocks annotated with Mock, so that explicit usage of MockitoAnnotations.initMocks(Object) is not necessary. Mocks are initialized before each test method Validates framework usage after each test method. See javadoc for Mockito.validateMockitoUsage() It is highly recommended to use the rule with strictness(Strictness) configured to Strictness.STRICT_STUBS. It drives cleaner tests and improves debugging experience. The only reason this feature is not turned on by default is because it would have been an incompatible change and Mockito strictly follows semantic versioning. @Rule public MockitoRule rule = MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS),",
	"Mockito - MockitoRule - silent()": "Rule will not report stubbing warnings during test execution. By default, stubbing warnings are printed to Standard output to help debugging. Equivalent of configuring strictness(Strictness) with Strictness.LENIENT.",
	"Mockito - MockitoRule - strictness(Strictness strictness)": "3 strictness: Strictness.STRICT_STUBS, Strictness.LENIENT, Strictness.WARN. It is possible to tweak the strictness per test method",
	"Mockito - MockitoRule - strictness(Strictness strictness) - Strictness.STRICT_STUBS": "helps debugging and keeping tests clean. It's a new feature introduced in Mockito 2.3.",
	"Mockito - MockitoRule - strictness(Strictness strictness) - Strictness.LENIENT": "equivalent of silent() - no added behavior. The default of Mockito 1.x. already present in Mockito 2.1.0",
	"Mockito - MockitoRule - strictness(Strictness strictness) - Strictness.WARN": "helps keeping tests clean and with debuggability. Reports console warnings about unused stubs and stubbing argument mismatches (see MockitoHint). The default of Mockito 2.x",
	"Mocking - MockitoFramework Mockito.framework()": "For advanced users or framework integrators. .",
	"Mocking - MockitoFramework Mockito.validateMockitoUsage()": "validateMockitoUsage() explicitly validates the framework state to detect invalid use of Mockito. However, this feature is optional because Mockito validates the usage all the time... but there is a gotcha so read on. Mockito throws exceptions if you misuse it so that you know if your tests are written correctly. The gotcha is that Mockito does the validation next time you use the framework (e.g. next time you verify, stub, call mock etc.). But even though the exception might be thrown in the next test, the exception message contains a navigable stack trace element with location of the defect. Hence you can click and find the place where Mockito was misused. Sometimes though, you might want to validate the framework usage explicitly. For example, one of the users wanted to put validateMockitoUsage() in his @After method so that he knows immediately when he misused Mockito. Without it, he would have known about it not sooner than next time he used the framework. One more benefit of having validateMockitoUsage() in @After is that jUnit runner and rule will always fail in the test method with defect whereas ordinary 'next-time' validation might fail the next test method. But even though JUnit might report next test as red, don't worry about it and just click at navigable stack trace element in the exception message to instantly locate the place where you misused mockito. Both built-in runner: MockitoJUnitRunner and rule: MockitoRule do validateMockitoUsage() after each test method. Bear in mind that usually you don't have to validateMockitoUsage() and framework validation triggered on next-time basis should be just enough, mainly because of enhanced exception message with clickable location of defect. However, I would recommend validateMockitoUsage() if you already have sufficient test infrastructure (like your own runner or base class for all tests) because adding a special action to @After has zero cost.",
	"Mocking - MockitoFramework.getPlugins()": "Returns an object that has access to Mockito plugins.",
	"Mocking - MockitoFramework.getInvocationFactory()": "Returns a factory that can create instances of Invocation. It is useful for framework integrations, because Invocation is NotExtensible.",
	"Mocking - MockitoFramework.addListener(MockitoListener listener) throws RedundantListenerException": "Adds listener to Mockito. For a list of supported listeners, see the interfaces that extend MockitoListener. Listeners can be useful for engs that extend Mockito framework. They are used in the implementation of unused stubbings warnings (MockitoHint). Make sure you remove the listener when the job is complete, see removeListener(MockitoListener). Currently the listeners list is thread local so you need to remove listener from the same thread otherwise remove is ineffectual. In typical scenarios, it is not a problem, because adding & removing listeners typically happens in the same thread. If you are trying to add the listener but a listener of the same type was already added (and not removed) this method will throw RedundantListenerException. This is a safeguard to ensure users actually remove the listeners via removeListener(MockitoListener). We do not anticipate the use case where adding the same listener type multiple times is useful. ",
	"Mocking - MockitoFramework.removeListener(MockitoListener listener)": "When you add listener using addListener(MockitoListener) make sure to remove it. Currently the listeners list is thread local so you need to remove listener from the same thread otherwise remove is ineffectual. In typical scenarios, it is not a problem, because adding & removing listeners typically happens in the same thread.",
	"Mocking - MockitoFramework MockCreationListener.onMockCreated(Object mock, MockCreationSettings settings)": "Notified when mock object is created.",
	"Mockito - Mockito Plugins": "Enables framework integrators to get access to default Mockito plugins. Useful when one needs to implement custom plugin such as MockMaker and delegate some behavior to the default Mockito implementation.",
	"Mockito - Mockito Plugins. Switch on or off plugins (Since 1.10.15)": "An incubating feature made it's way in mockito that will allow to toggle a mockito-plugin. More information here PluginSwitch.",

	"Test Doubles": "SECTION",
	"Test Doubles. Dummy": "Dummy objects are passed around but never actually used. Usually they are just used to fill parameter lists.",
	"Test Doubles. Fake": "Fake objects actually have working implementations, but usually take some shortcut which makes them not suitable for production (an InMemoryTestDatabase is a good example).",
	"Test Doubles. Stubs": "A stub exists just to supply enough data to keep things going. For example, a stub of a logging service could discard everything. A stub of a user lookup service could always return a single static user or no user at all.",
	"Test Doubles. Stubs Test Lifecycle": "(1) Setup - Prepare object that is being tested and its stubs collaborators. (2) Exercise - Test the functionality. (3) Verify state - Use asserts to check object's state. (4) Teardown - Clean up resources.",
	"Test Doubles. Mocks": "A mock allows you test how your services are called. For example, you may want to test that when you supply bad data, the logging service gets called. If you create a user, you want to assert that the user service got called to store it. Mock is smarter stub.",
	"Test Doubles. Mocks Test Lifecycle": "(1) Setup - Prepare object that is being tested., <b>(2) Setup expectations - Prepare expectations in mock that is being used by primary object.,</b> (3) Exercise - Test the functionality., <b>(4) Verify expectations - Verify that correct methods has been invoked in mock.</b> (5) Verify state - Use asserts to check object's state. (6) Teardown - Clean up resources.",
	"Test Doubles. Spies": "Spies are stubs that also record some information based on how they were called. One form of this might be an email service that records how many messages it was sent.",
	"Test Doubles. Partial Mocks": "Partial mocking is where you take a class and ask it to behave as normal, except you want to override certain functionality, i.e. mock some methods without mocking others",

	"Mocking": "SECTION",
	"Mockito - Mocks Creation - @Mocks": "Create a Mock minimizing repetitive mock creation code. Makes the test class more readable. Makes the verification error easier to read because the field name is used to identify the mock. @Mock private ArticleCalculator calculator,",
	"Mocking - Mocks Injection - @InjectMocks": "Injects a @Mock or @Spy fields into tested object automatically. Mockito will inject mocks/spy into the partial mock.",
	"Mocking - Mocking Target - an interface": "mock(List.class)",
	"Mocking - Mocking Target - a class": "mock(LinkedList.class)",
	"Mocking - Mocking Target - an abstract class (Since 1.10.12, further enhanced in 2.7.13 and 2.7.14)": "New API makes it possible to use constructor when creating an instance of the mock. This is particularly useful for mocking abstract classes because the user is no longer required to provide an instance of the abstract class. At the moment, only parameter-less constructor is supported, let us know if it is not enough.",
	"Mocking - Mocking Target - methods": "not private, not static and no constructors",
	"Mocking - Mocking Target - final types, enums and final methods (Since 2.1.0)": "Incubating, optional support for mocking final classes and methods. It can be activated explicitly by the mockito extension mechanism, just create in the classpath a file /mockito-extensions/org.mockito.plugins.MockMaker containing the value mock-maker-inline. As a convenience, the Mockito team provides an artifact where this mock maker is preconfigured. Instead of using the mockito-core artifact, include the mockito-inline artifact in your project. Some noteworthy notes about this mock maker: Mocking final types and enums is incompatible with mock settings like : explicitly serialization support withSettings().serializable() extra-interfaces withSettings().extraInterfaces() Some methods cannot be mocked Package-visible methods of java.* native methods",
	"Mocking - MockMaker (Since 1.9.5)": "Driven by requirements and patches from Google Android guys Mockito now offers an extension point that allows replacing the proxy generation engine. By default, Mockito uses Byte Buddy to create dynamic proxies. The extension point is for advanced users that want to extend Mockito. For example, it is now possible to use Mockito for Android testing with a help of dexmaker.",
	"Mocking - MockMaker interface": "The facility to create mocks. By default, an internal byte-buddy/asm/objenesis based implementation is used.MockMaker is an extension point that makes it possible to use custom dynamic proxies and avoid using the default byte-buddy/asm/objenesis implementation. For example, the android users can use a MockMaker that can work with Dalvik virtual machine and hence bring Mockito to android apps developers.",
	"Mocking - MockMaker.createMock(MockCreationSettings<T> settings, MockHandler handler)": "If you want to provide your own implementation of MockMaker this method should: Create a proxy object that implements settings.typeToMock and potentially also settings.extraInterfaces. You may use the information from settings to create/configure your proxy object. Your proxy object should carry the handler with it. For example, if you generate byte code to create the proxy you could generate an extra field to keep the handler with the generated object. Your implementation of MockMaker is required to provide this instance of handler when getHandler(Object) is called.",
	"Mocking - MockMaker.getHandler(Object mock)": "Returns the handler for the mock. Do not provide your own implementations at this time because the work on the MockHandler api is not completed. Use the instance provided to you by Mockito at createMock(org.mockito.mock.MockCreationSettings<T>, org.mockito.invocation.MockHandler) or resetMock(java.lang.Object, org.mockito.invocation.MockHandler, org.mockito.mock.MockCreationSettings).",
	"Mocking - MockMaker.resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings)": "Replaces the existing handler on mock with newHandler. The invocation handler actually store invocations to achieve stubbing and verification. In order to reset the mock, we pass a new instance of the invocation handler. Your implementation should make sure the newHandler is correctly associated to passed mock",
	"Mocking - Mockito.reset() (Since 1.8.0)": "Smart Mockito users hardly use this feature because they know it could be a sign of poor tests. Normally, you don't need to reset your mocks, just create new mocks for each test method. Instead of reset() please consider writing simple, small and focused test methods over lengthy, over-specified tests. First potential code smell is reset() in the middle of the test method. This probably means you're testing too much. Follow the whisper of your test methods: 'Please keep us small & focused on single behavior'. There are several threads about it on mockito mailing list. The only reason we added reset() method is to make it possible to work with container-injected mocks. For more information see FAQ (here). Don't harm yourself. reset() in the middle of the test method is a code smell (you're probably testing too much).",
	"Mocking - Meta data and generic type retention (Since 2.1.0)": "Mockito now preserves annotations on mocked methods and types as well as generic meta data. Previously, a mock type did not preserve annotations on types unless they were explicitly inherited and never retained annotations on methods. As a consequence, the following conditions now hold true:",
	"Mocking - Mockito.mockingDetails(Object toInspect)": "Returns a MockingDetails instance that enables inspecting a particular object for Mockito related information. Can be used to find out if given object is a Mockito mock or to find out if a given mock is a spy or mock.",
	"Mocking - Mocking details (Improved in 2.2.x)": "Mockito offers API to inspect the details of a mock object. This API is useful for advanced users and mocking framework integrators.",
	"Mocking - MockingDetails. isMock()": "Informs if the object is a mock. isMock() for null input returns false.",
	"Mocking - MockingDetails. isSpy()": "Informs if the object is a spy. isSpy() for null input returns false.",
	"Mocking - MockingDetails. getInvocations()": "All method invocations on this mock. Can be empty - it means there were no interactions with the mock. This method is useful for framework integrators and for certain edge cases. Manipulating the collection (e.g. by removing, adding elements) is safe and has no effect on the mock. Throws meaningful exception when object wrapped by MockingDetails is not a mock.",
	"Mocking - MockingDetails. getMockCreationSettings()": "Returns various mock settings provided when the mock was created, for example: mocked class, mock name (if any), any extra interfaces (if any), etc. See also MockCreationSettings. This method is useful for framework integrators and for certain edge cases. If null or non-mock was passed to Mockito.mockingDetails(Object) then this method will throw with an appropriate exception. After all, non-mock objects do not have any mock creation settings.",
	"Mocking - MockingDetails. getStubbings()": "Returns stubbings declared on this mock object. Mockito.mockingDetails(mock).getStubbings() What is 'stubbing'? Stubbing is your when(x).then(y) declaration, e.g. configuring the mock to behave in a specific way, when specific method with specific arguments is invoked on a mock. Typically stubbing is configuring mock to return X when method Y is invoked Why do you need to access stubbings of a mock? In a normal workflow of creation clean tests, there is no need for this API. However, it is useful for advanced users, edge cases or framework integrators. For example, Mockito internally uses this API to report and detect unused stubbings that should be removed from test. Unused stubbings are dead code that needs to be removed (see MockitoHint). Manipulating the collection (e.g. by removing, adding elements) is safe and has no effect on the mock. This method throws meaningful exception when object wrapped by MockingDetails is not a mock.",
	"Mocking - MockingDetails. printInvocations()": "Returns printing-friendly list of the invocations that occurred with the mock object. Additionally, this method prints stubbing information, including unused stubbings. For more information about unused stubbing detection see MockitoHint. You can use this method for debugging, print the output of this method to the console to find out about all interactions with the mock. Content that is printed is subject to change as we discover better ways of presenting important mock information. Don't write code that depends on the output of this method. If you need to know about interactions and stubbings, use getStubbings() and getInvocations(). This method was moved from the deprecated and semi-hidden type MockitoDebugger. This method throws meaningful exception when object wrapped by MockingDetails is not a mock.",
	"Mocking - MockingDetails. getMockHandler()": "Returns the MockHandler associated with this mock object. The handler is the core of mock object method handling. This method is useful for framework integrators. For example, other frameworks may use mock handler to simulate method calls on the Mock object.",
	"Mocking - MockingDetails. getMock()": "Returns the mock object which is associated with this this instance of MockingDetails. Basically, it's the object that you have passed to Mockito.mockingDetails(Object) method.",
	"Mocking - MockingDetails. mockingDetails(Object toInspect)": "Returns a MockingDetails instance that enables inspecting a particular object for Mockito related information. Can be used to find out if given object is a Mockito mock or to find out if a given mock is a spy or mock. In future Mockito versions MockingDetails may grow and provide other useful information about the mock, e.g. invocations, stubbing info, etc.",
	"Mocking - MockSettings - Mockito.withSettings()": "Allows mock creation with additional mock settings. MockSettings has been introduced for two reasons. Firstly, to make it easy to add another mock settings when the demand comes. Secondly, to enable combining different mock settings without introducing zillions of overloaded mock() methods.",
	"Mocking - MockSettings - Mockito.withSettings() - Usage": "Allows mock creation with additional mock settings. Don't use it too often. Consider writing simple tests that use simple mocks.",
	"Mocking - MockSettings - build(Class)": "Creates immutable view of mock settings used later by Mockito. Useful for creating invocations with InvocationFactory or when implementing custom MockHandler.",
	"Mocking - MockSettings - extraInterfaces(Class< ? >... interfaces)": "Specifies extra interfaces the mock should implement. Foo foo = mock(Foo.class, withSettings().extraInterfaces(Bar.class, Baz.class)), Now, the mock casting is possible: Bar bar = (Bar) foo, Baz baz = (Baz) foo,",
	"Mocking - MockSettings - name(String name)": "Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors. Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators. If you have too many mocks then refactor the code so that it's easy to test/debug without necessity of naming mocks. If you use @Mock annotation then you've got naming mocks for free! @Mock uses field name as mock name.  Foo foo = mock(Foo.class, withSettings().name('foo')),",
	"Mocking - MockSettings - spiedInstance(Object instance)": "Specifies the instance to spy on. Makes sense only for spies/partial mocks. Sets the instance that will be spied. Actually copies the internal fields of the passed instance to the mock. Foo foo = mock(Foo.class, withSettings().spiedInstance(fooInstance)),",
	"Mocking - MockSettings - defaultAnswer(Answer defaultAnswer)": "Specifies default answers to interactions. It's quite advanced feature and typically you don't need it to write decent tests. However it can be helpful when working with legacy systems. It is the default answer so it will be used only when you don't stub the method call. Foo mockTwo = mock(Foo.class, withSettings().defaultAnswer(new YourOwnAnswer())),",
	"Mocking - MockSettings - serializable() (Since 1.8.1)": "Configures the mock to be serializable. With this feature you can use a mock in a place that requires dependencies to be serializable. List serializableMock = mock(List.class, withSettings().serializable()),",
	"Mocking - MockSettings - serializable() Usage": "This should be rarely used in unit testing. The behaviour was implemented for a specific use case of a BDD spec that had an unreliable external dependency. This was in a web environment and the objects from the external dependency were being serialized to pass between layers. To create serializable mock use MockSettings.serializable(): The mock can be serialized assuming all the normal serialization requirements are met by the class. Making a real object spy serializable is a bit more effort as the spy(...) method does not have an overloaded version which accepts MockSettings. No worries, you will hardly ever use it.",
	"Mocking - MockSettings - serializable(SerializableMode mode)": "Configures the mock to be serializable. With this feature you can use a mock in a place that requires dependencies to be serializable.List serializableMock = mock(List.class, withSettings().serializable(SerializableMode.ACROSS_CLASSLOADERS)),",
	"Mocking - MockSettings - serializable(SerializableMode mode) - SerializableMode BASIC": "Basic serializable mode for mock objects.",
	"Mocking - MockSettings - serializable(SerializableMode mode) - SerializableMode NONE": "No serialization.",
	"Mocking - MockSettings - serializable(SerializableMode mode) - SerializableMode ACROSS_CLASSLOADERS (Since 1.10.0)": "Mockito introduces serialization across classloader. Like with any other form of serialization, all types in the mock hierarchy have to serializable, inclusing answers. As this serialization mode require considerably more work, this is an opt-in setting. Useful if the mock is deserialized in a different classloader / vm.",
	"Mocking - MockSettings - verboseLogging()": "Enables real-time logging of method invocations on this mock. Can be used during test debugging in order to find wrong interactions with this mock. Invocations are logged as they happen to the standard output stream. Calling this method multiple times makes no difference. List mockWithLogger = mock(List.class, withSettings().verboseLogging()),",
	"Mocking - MockSettings - invocationListeners(InvocationListener... listeners)": "Registers a listener for method invocations on this mock. The listener is notified every time a method on this mock is called. Multiple listeners may be added and they will be notified in the order they were supplied. Example: List mockWithListener = mock(List.class, withSettings().invocationListeners(new YourInvocationListener())), ",
	"Mocking - MockSettings - verificationStartedListeners": "MockSettings verificationStartedListeners(VerificationStartedListener... listeners) Registers a listener(s) that will be notified when user starts verification. See VerificationStartedListener on how such listener can be useful. When multiple listeners are added, they are notified in order they were supplied. There is no reason to supply multiple listeners but we wanted to keep the API simple and consistent with invocationListeners(InvocationListener...). Throws exception when any of the passed listeners is null or when the entire vararg array is null.",
	"Mocking - MockSettings - VerificationStartedListener.onVerificationStarted(VerificationStartedEvent event)": "This listener gets notified when the user starts verification. It allows to replace the mock object for verification. This API is not needed for regular Mockito users who want to write beautiful and clean tests. It is only needed for advanced framework integrations where there are multiple layers of proxying. An example framework that leverages this API is Spring Boot. For details about the use case see issue 1191. For sample code see VerificationStartedListenerTest class. Mockito is Open Source so feel free to dive into the code! How can you add listeners? The listener is attached to the mock object during creation:List mock = Mockito.mock(List.class, withSettings().verificationStartedListeners(myListener)),",			
	"Mocking - MockSettings - stubOnly()": "A stub-only mock does not record method invocations, thus saving memory but disallowing verification of invocations. List stubOnly = mock(List.class, withSettings().stubOnly()),",
	"Mocking - MockSettings - useConstructor()": "Mockito attempts to use constructor when creating instance of the mock. This is particularly useful for spying on abstract classes. OtherAbstract spy = mock(OtherAbstract.class, withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS)),",
	"Mocking - MockSettings - outerInstance(Object outerClassInstance)": "Makes it possible to mock non-static inner classes in conjunction with useConstructor(Object...). InnerClass mock = mock(InnerClass.class, withSettings().useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS)),",
	"Mocking - MockSettings - withoutAnnotations()": "@Incubating MockSettings withoutAnnotations() By default, Mockito makes an attempt to preserve all annotation meta data on the mocked type and its methods to mirror the mocked type as closely as possible. If this is not desired, this option can be used to disable this behavior.",
	"Mocking - MockSettings - build(Class<T> typeToMock)": "build @Incubating <T> MockCreationSettings<T> build(Class<T> typeToMock) Creates immutable view of mock settings used later by Mockito. Framework integrators can use this method to create instances of creation settings and use them in advanced use cases, for example to create invocations with InvocationFactory, or to implement custom MockHandler. Since MockCreationSettings is NotExtensible, Mockito public API needs a creation method for this type.",
	"Mocking - MockSettings - lenient()": "Lenient mocks bypass 'strict stubbing' validation (see Strictness.STRICT_STUBS). When mock is declared as lenient none of its stubbings will be checked for potential stubbing problems such as 'unnecessary stubbing' (UnnecessaryStubbingException) or for 'stubbing argument mismatch' PotentialStubbingProblem. Foo mock = mock(Foo.class, withSettings.lenient()),",
	"Mocking - Answer<T> interface": "Generic interface to be used for configuring mock's answer. Answer specifies an action that is executed and a return value that is returned when you interact with the mock.",
	"Mocking - Answer<T> interface - Java 8 Support (Since 2.1.0)": "As the Answer interface has just one method it is already possible to implement it in Java 8 using a lambda expression for very simple situations. The more you need to use the parameters of the method call, the more you need to typecast the arguments from InvocationOnMock. For convenience it is possible to write custom answers/actions, which use the parameters to the method call, as Java 8 lambdas. Even in Java 7 and lower these custom answers based on a typed interface can reduce boilerplate. In particular, this approach will make it easier to test functions which use callbacks. The methods answer and answerVoid can be used to create the answer. They rely on the related answer interfaces in org.mockito.stubbing that support answers up to 5 parameters.",
	"Mocking - Answer<Object> RETURNS_DEFAULTS": "The default Answer of every mock if the mock was not stubbed. Typically it just returns some empty value. Answer can be used to define the return values of unstubbed invocations. This implementation first tries the global configuration and if there is no global configuration then it will use a default answer that returns zeros, empty collections, nulls, etc.",
	"Mocking - Answer<Object> RETURNS_SMART_NULLS": "Optional Answer to be used with mock(Class, Answer). Answer can be used to define the return values of unstubbed invocations. This implementation can be helpful when working with legacy code. Unstubbed methods often return null. If your code uses the object returned by an unstubbed call you get a NullPointerException. This implementation of Answer returns SmartNull instead of null. SmartNull gives nicer exception message than NPE because it points out the line where unstubbed method was called. You just click on the stack trace. ReturnsSmartNulls first tries to return ordinary values (zeros, empty collections, empty string, etc.) then it tries to return SmartNull. If the return type is final then plain null is returned. ReturnsSmartNulls will be probably the default return values strategy in Mockito 3.0.0",
	"Mocking - Answer<Object> RETURNS_MOCKS": "Optional Answer to be used with mock(Class, Answer) Answer can be used to define the return values of unstubbed invocations. This implementation can be helpful when working with legacy code. ReturnsMocks first tries to return ordinary values (zeros, empty collections, empty string, etc.) then it tries to return mocks. If the return type cannot be mocked (e.g. is final) then plain null is returned.",
	"Mocking - Answer<Object> RETURNS_DEEP_STUBS": "Optional Answer to be used with mock(Class, Answer). WARNING: This feature should rarely be required for regular clean code! Leave it for legacy code. Mocking a mock to return a mock, to return a mock, (...), to return something meaningful hints at violation of Law of Demeter or mocking a value object (a well known anti-pattern). Good quote I've seen one day on the web: every time a mock returns a mock a fairy dies. Please note that this answer will return existing mocks that matches the stub. This behavior is ok with deep stubs and allows verification to work on the last mock of the chain.",
	"Mocking - Answer<Object> CALLS_REAL_METHODS": "Optional Answer to be used with mock(Class, Answer) Answer can be used to define the return values of unstubbed invocations. This implementation can be helpful when working with legacy code. When this implementation is used, unstubbed methods will delegate to the real implementation. This is a way to create a partial mock object that calls real methods by default.  Example:Foo mock = mock(Foo.class, CALLS_REAL_METHODS),",
	"Mocking - Answer<Object> RETURNS_SELF": "Optional Answer to be used with mock(Class, Answer). Allows Builder mocks to return itself whenever a method is invoked that returns a Type equal to the class or a superclass. Keep in mind this answer uses the return type of a method. If this type is assignable to the class of the mock, it will return the mock. Therefore if you have a method returning a superclass (for example Object) it will match and return the mock. Consider a HttpBuilder used in a HttpRequesterWithHeaders.",

	"Spying": "SECTION",
	"Spying - @Spy": "Allows shorthand wrapping of field instances in an spy object.",
	"Spying - Spy. How it works": "Mockito *does not* delegate calls to the passed real instance, instead it actually creates a copy of it. So if you keep the real instance and interact with it, don't expect the spied to be aware of those interaction and their effect on real instance state. The corollary is that when an *unstubbed* method is called *on the spy* but *not on the real instance*, you won't see any effects on the real instance. Watch out for final methods. Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble. Also you won't be able to verify those method as well.",
	"Spying - Spy. Code Smell Hint": "Overusing spies hints at code design smells.",
	"Spying - Spying instances of object": "spy(T object) Creates a spy of the real object. The spy calls real methods unless they are stubbed.",
	"Spying - Spying classes": "spy(Class<T> classToSpy) Creates a spy based on class. The spy calls real methods unless they are stubbed.",
	"Spying - Spying abstract classes (Since 1.10.12, further enhanced in 2.7.13 and 2.7.14)": "New API makes it possible to use constructor when creating an instance of the mock.  This is particularly useful for mocking abstract classes. At the moment, only parameter-less constructor is supported.",
	"Spying - Spying on Real Objects": "You can create spies of real objects. When you use the spy then the real methods are called (unless a method was stubbed). Real spies should be used carefully and occasionally, for example when dealing with legacy code.",

	"Partial Mocks": "SECTION",
	"Partial Mocks - Warning": "Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects. How does partial mock fit into this paradigm? Well, it just doesn't... Partial mock usually means that the complexity has been moved to a different method on the same object. In most cases, this is not the way you want to design your application. However, there are rare cases when partial mocks come handy: dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.) However, I wouldn't use partial mocks for new, test-driven & well-designed code.",
	"Partial Mocks - Usage (Since 1.8.0)": "Partial mock support was added to Mockito. Previously we considered partial mocks as code smells. However, we found a legitimate use case for partial mocks: dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.). I wouldn't use partial mocks for new, test-driven & well-designed code.",
	"Partial Mocks - Delegate calls to real instance (Since 1.9.5)": "Useful for spies or partial mocks of objects that are difficult to mock or spy using the usual spy API. Since Mockito 1.10.11, the delegate may or may not be of the same type as the mock. If the type is different, a matching method needs to be found on delegate type otherwise an exception is thrown. Possible use cases for this feature: Final classes but with an interfac Already custom proxied objec Special objects with a finalize method, i.e. to avoid executing it 2 timesThe difference with the regular spy: The regular spy (spy(Object)) contains all state from the spied instance and the methods are invoked on the spy. The spied instance is only used at mock creation to copy the state from. If you call a method on a regular spy and it internally calls other methods on this spy, those calls are remembered for verifications, and they can be effectively stubbed. The mock that delegates simply delegates all methods to the delegate. The delegate is used all the time as methods are delegated onto it. If you call a method on a mock that delegates and it internally calls other methods on this mock, those calls are not remembered for verifications, stubbing does not have effect on them, too. Mock that delegates is less powerful than the regular spy but it is useful when the regular spy cannot be created.",
	"Partial Mocks - Implementation - with Mock": "Use thenCallRealMethod() -> when(calculationService.getComputedValue()).thenCallRealMethod(), or Foo mock = mock(Foo.class, CALLS_REAL_METHODS),",
	"Partial Mocks - Implementation - with Spy": "Use normal spy(new CalculationService())",
	"Partial Mocks - Implementation - Preference": "Mockito.spy() is a recommended way of creating partial mocks. The reason is it guarantees real methods are called against correctly constructed object because you're responsible for constructing the object passed to spy() method.",

	"ArgumentMatchers ": "SECTION",
	"ArgumentMatchers": "Argument matchers allow flexible verification or stubbing. Mockito verifies argument values in natural java style: by using an equals() method. Sometimes, when extra flexibility is required then you might use argument matchers. If you are using argument matchers, all arguments have to be provided by matchers.",
	"ArgumentMatchers - Java 8 Lambda Matcher Support (Since 2.1.0)": "You can use Java 8 lambda expressions with ArgumentMatcher to reduce the dependency on ArgumentCaptor. If you need to verify that the input to a function call on a mock was correct, then you would normally use the ArgumentCaptor to find the operands used and then do subsequent assertions on them. While for complex examples this can be useful, it's also long-winded. Writing a lambda to express the match is quite easy. The argument to your function, when used in conjunction with argThat, will be passed to the ArgumentMatcher as a strongly typed object, so it is possible to do anything with it.",
	"ArgumentMatchers - any": "any(), any(Class<T> type), anyBoolean(), anyByte(), anyChar(), anyCollection(), anyCollectionOf(Class<T> clazz), anyDouble(), anyFloat(), anyInt(), anyIterable(), anyIterableOf(Class<T> clazz), anyList(), anyListOf(Class<T> clazz), anyLong(), anyMap(), anyMapOf(Class<K> keyClazz, Class<V> valueClazz), anyObject(), anySet(), anySetOf(Class<T> clazz), anyShort(), anyString(), anyVararg()",
	"ArgumentMatchers - that": "argThat(ArgumentMatcher<T> matcher), booleanThat(ArgumentMatcher<Boolean> matcher), byteThat(ArgumentMatcher<Byte> matcher), charThat(ArgumentMatcher<Character> matcher), doubleThat(ArgumentMatcher<Double> matcher), floatThat(ArgumentMatcher<Float> matcher), intThat(ArgumentMatcher<Integer> matcher), longThat(ArgumentMatcher<Long> matcher), shortThat(ArgumentMatcher<Short> matcher)",
	"ArgumentMatchers - contains": "contains(String substring)",
	"ArgumentMatchers - eq": "eq(boolean value), eq(byte value), eq(char value), eq(double value), eq(float value), eq(int value), eq(long value), eq(short value), eq(T value), refEq(T value, String... excludeFields)",
	"ArgumentMatchers - is": "isA(Class<T> type), isNotNull(), isNotNull(Class<T> clazz), isNull(), isNull(Class<T> clazz)",
	"ArgumentMatchers - null": "isNull(), isNull(Class<T> clazz), notNull(), notNull(Class<T> clazz), nullable(Class<T> clazz)",
	"ArgumentMatchers - same": "same(T value)",
	"ArgumentMatchers - startsWith": "startsWith(String prefix)",
	"AdditionalMatchers - and": "and(boolean first, boolean second), and(byte first, byte second), and(char first, char second), and(double first, double second), and(float first, float second), and(int first, int second), and(long first, long second), and(short first, short second), and(T first, T second)",
	"AdditionalMatchers - aryEq": "aryEq(boolean[] value), aryEq(byte[] value), aryEq(char[] value), aryEq(double[] value), aryEq(float[] value), aryEq(int[] value), aryEq(long[] value), aryEq(short[] value), aryEq(T[] value)",
	"AdditionalMatchers - cmEq": "cmpEq(T value)",
	"AdditionalMatchers - eq": "eq(double value, double delta)",
	"AdditionalMatchers - eq ": "eq(float value, float delta)",
	"AdditionalMatchers - find": "find(String regex)",
	"AdditionalMatchers - geq": "geq(byte value), geq(double value), geq(float value), geq(int value), geq(long value), geq(short value), geq(T value)",
	"AdditionalMatchers - gt": "gt(byte value), gt(double value), gt(float value),   gt(int value), gt(long value), gt(short value), gt(T value)",
	"AdditionalMatchers - leq": "leq(byte value), leq(double value), leq(float value), leq(int value), leq(long value), leq(short value), leq(T value)",
	"AdditionalMatchers - lt": "lt(byte value), lt(double value), lt(float value), lt(int value), lt(long value), lt(short value), lt(T value)",
	"AdditionalMatchers - not": "not(boolean first), not(byte first), not(char first), not(double first), not(float first), not(int first), not(long first), not(short first), not(T first)",
	"AdditionalMatchers - or": "or(boolean first, boolean second), or(byte first, byte second), or(char first, char second), or(double first, double second), or(float first, float second), or(int first, int second), or(long first, long second), or(short first, short second), or(T first, T second)",

	"Stubbing": "SECTION",
	"Stubbing - Lifecycle": "Stubbing can be overridden: for example common stubbing can go to fixture setup but the test methods can override it. Please note that overridding stubbing is a potential code smell that points out too much stubbing Once stubbed, the method will always return a stubbed value, regardless of how many times it is called..",
	"Stubbing - Target": "By default, for all methods that return a value, a mock will return either null, a primitive/primitive wrapper value, or an empty collection, as appropriate. For example 0 for an int/Integer and false for a boolean/Boolean.",
	"Stubbing - Priority": "Last stubbing is more important - when you stubbed the same method with the same arguments many times. Other words: the order of stubbing matters but it is only meaningful rarely, e.g. when stubbing exactly the same method calls or sometimes when argument matchers are used, etc.",
	"Stubbing - OngoingStubbing<T> Interface": "Simply put: 'When the x method is called then return y'. Methods: getMock(), then(), thenAnswer(), thenCallRealMethod(), thenReturn(), thenThrow()",
	"Stubbing - OngoingStubbing.when()": "when(T methodCall) Enables stubbing methods. Use it when you want the mock to return particular value when particular method is called Simply put: 'When the x method is called then return y'.",
	"Stubbing - OngoingStubbing.then(Answer< ? > answer)": "Sets a generic Answer for the method. This method is an alias of thenAnswer(Answer).",
	"Stubbing - OngoingStubbing.thenReturn(T value)": "Sets a return value to be returned when the method is called.",
	"Stubbing - OngoingStubbing.thenReturn(T value, T... values)": "Sets consecutive return values to be returned when the method is called.",
	"Stubbing - OngoingStubbing.thenThrow(Throwable... throwables)": "Sets Throwable objects to be thrown when the method is called. E.g: when(mock.someMethod()).thenThrow(new RuntimeException()), If throwables contain a checked exception then it has to match one of the checked exceptions of method signature. You can specify throwables to be thrown for consecutive calls. In that case the last throwable determines the behavior of further consecutive calls. If throwable is null then exception will be thrown.",
	"Stubbing - OngoingStubbing.thenThrow(Class< ? extends Throwable > throwableType)": "Sets a Throwable type to be thrown when the method is called. E.g: when(mock.someMethod()).thenThrow(RuntimeException.class), If the throwable class is a checked exception then it has to match one of the checked exceptions of the stubbed method signature. If throwable is null then exception will be thrown. See examples in javadoc for Mockito.when(T) Note depending on the JVM, stack trace information may not be available in the generated throwable instance. If you require stack trace information, use thenThrow(Throwable...) instead.",
	"Stubbing - OngoingStubbing.thenThrow(Class< ? extends Throwable > toBeThrown, Class< ? extends Throwable >... nextToBeThrown)": "Sets Throwable classes to be thrown when the method is called. E.g: when(mock.someMethod()).thenThrow(RuntimeException.class), Each throwable class will be instantiated for each method invocation. If throwableTypes contain a checked exception then it has to match one of the checked exceptions of method signature. You can specify throwableTypes to be thrown for consecutive calls. In that case the last throwable determines the behavior of further consecutive calls. If throwable is null then exception will be thrown. ",
	"Stubbing - OngoingStubbing.thenCallRealMethod()": "Sets the real implementation to be called when the method is called on a mock object.",
	"Stubbing - OngoingStubbing.thenAnswer(Answer< ? > answer)": "Sets a generic Answer for the method",
	"Stubbing - OngoingStubbing.getMock()": "Returns the mock that was used for this stub. It allows to create a stub in one line of code. This can be helpful to keep test code clean. For example, some boring stub can be created & stubbed at field initialization in a test:",
	"Stubbing - BaseStubber interface": "Base interface for stubbing consecutive method calls with Mockito.doReturn(Object) syntax. This interface is needed so that we can reuse the same hierarchy in subinterfaces.",
	"Stubbing - BaseStubber.doReturn(Object toBeReturned)": "Use doReturn() in those rare occasions when you cannot use when(Object). Beware that when(Object) is always recommended for stubbing because it is argument type-safe and more readable (especially when stubbing consecutive calls). Here are those rare occasions when doReturn() comes handy: When spying real objects and calling real methods on a spy brings side effects. Overriding a previous exception-stubbing:",
	"Stubbing - BaseStubber.doReturn(Object toBeReturned, Object... toBeReturnedNext)": "Same as doReturn(Object) but sets consecutive values to be returned. Remember to use doReturn() in those rare occasions when you cannot use when(Object). Beware that when(Object) is always recommended for stubbing because it is argument type-safe and more readable (especially when stubbing consecutive calls). Here are those rare occasions when doReturn() comes handy:: When spying real objects and calling real methods on a spy brings side effects. Overriding a previous exception-stubbing:",
	"Stubbing - BaseStubber.doAnswer(Answer answer)": "Use doAnswer() when you want to stub a void method with generic Answer. Stubbing voids requires different approach from when(Object) because the compiler does not like void methods inside brackets...",
	"Stubbing - BaseStubber.doCallRealMethod()": "Use doCallRealMethod() when you want to call the real implementation of a method.",
	"Stubbing - BaseStubber.doNothing()": "Use doNothing() for setting void methods to do nothing. Beware that void methods on mocks do nothing by default! However, there are rare situations when doNothing() comes handy: Stubbing consecutive calls on a void method, When you spy real objects and you want the void method to do nothing",
	"Stubbing - BaseStubber.doThrow(Throwable... toBeThrown)": "Use doThrow() when you want to stub the void method with an exception. Stubbing voids requires different approach from when(Object) because the compiler does not like void methods inside brackets... Example: doThrow(new RuntimeException()).when(mock).someVoidMethod(),",
	"Stubbing - BaseStubber.doThrow(Class< ? extends Throwable > toBeThrown)": "Use doThrow() when you want to stub the void method with an exception. A new exception instance will be created for each method invocation. Stubbing voids requires different approach from when(Object) because the compiler does not like void methods inside brackets... Example: doThrow(RuntimeException.class).when(mock).someVoidMethod(),",
	"Stubbing - BaseStubber.doThrow(Class< ? extends Throwable > toBeThrown, Class< ? extends Throwable >... toBeThrownNext)": "Same as doThrow(Class) but sets consecutive exception classes to be thrown. Remember to use doThrow() when you want to stub the void method to throw several exception of specified class. A new exception instance will be created for each method invocation. Stubbing voids requires different approach from when(Object) because the compiler does not like void methods inside brackets... Example:doThrow(RuntimeException.class, BigFailure.class).when(mock).someVoidMethod(),",
	"Stubbing - BDDMockito - BDD style verification (Since 1.10.0)": "Enables Behavior Driven Development (BDD) style verification by starting verification with the BDD then keyword. given(dog.bark()).willReturn(2),",
	"Stubbing - BDDMockito extends Mockito": "Behavior Driven Development style of writing tests uses //given //when //then comments as fundamental parts of your test methods. This is exactly how we write our tests and we warmly encourage you to do so! The problem is that current stubbing api with canonical role of when word does not integrate nicely with //given //when //then comments. It's because stubbing belongs to given component of the test and not to the when component of the test. Hence BDDMockito class introduces an alias so that you stub method calls with given(Object) method. Now it really nicely integrates with the given component of a BDD style test!",
	"Stubbing - BDDMockito.BDDMyOngoingStubbing<T> given(T methodCall)": "Mockito.when(Object)",
	"Stubbing - Aliases for behavior driven development (Since 1.8.0)": "Behavior Driven Development style of writing tests uses //given //when //then comments as fundamental parts of your test methods. This is exactly how we write our tests and we warmly encourage you to do so! The problem is that current stubbing api with canonical role of when word does not integrate nicely with //given //when //then comments. It's because stubbing belongs to given component of the test and not to the when component of the test. Hence BDDMockito class introduces an alias so that you stub method calls with BDDMockito.given(Object) method. Now it really nicely integrates with the given component of a BDD style test! Here is how the test might look like:",
	"Stubbing.- BDDMockito.BDDStubber will(Answer< ? > answer)": "Mockito.doAnswer(Answer)",
	"Stubbing - BDDMockito.BDDStubber willAnswer(Answer< ? > answer)": "Mockito.doAnswer(Answer)",
	"Stubbing - BDDMockito.BDDStubber willReturn(Object toBeReturned)": "Mockito.doReturn(Object)",
	"Stubbing - BDDMockito.BDDStubber willReturn(Object toBeReturned, Object... toBeReturnedNext)": "Mockito.doReturn(Object, Object...)",
	"Stubbing - BDDMockito.BDDStubber willDoNothing()": "Mockito.doNothing()",
	"Stubbing - BDDMockito.BDDStubber willCallRealMethod()": "Mockito.doCallRealMethod()",
	"Stubbing - BDDMockito.BDDStubber willThrow(Throwable... toBeThrown)": "Mockito.doThrow(Throwable[])",
	"Stubbing - BDDMockito.BDDStubber willThrow(Class< ? extends Throwable > toBeThrown)": " Mockito.doThrow(Class)",
	"Stubbing - BDDMockito.BDDStubber willThrow(Class< ? extends Throwable > toBeThrown, Class< ? extends Throwable >... throwableTypes)": "Mockito.doThrow(Class)",
	"Stubbing - BDDMockito.Then<T> then(T mock)": "Bdd style verification of mock behavior.",
	"Stubbing - One-liner stubs (Since 1.9.0)": "Mockito will now allow you to create mocks when stubbing. Basically, it allows to create a stub in one line of code.: Car boringStubbedCar = when(mock(Car.class).shiftGear()).thenThrow(EngineNotStarted.class).getMock(),",
	"Stubbing - stubbing void methods": "Stubbing void methods requires a different approach from when(Object) because the compiler does not like void methods inside brackets...",
	"Stubbing - Stubbing void methods with exceptions": "doThrow(new RuntimeException()).when(mockedList).clear(),",
	"Stubbing - Stubbing consecutive calls (iterator-style stubbing)": "Sometimes we need to stub with different return value/exception for the same method call. Typical use case could be mocking iterators. Original version of Mockito did not have this feature to promote simple mocking. For example, instead of iterators one could use Iterable or simply collections. Those offer natural ways of stubbing (e.g. using real collections). In rare scenarios stubbing consecutive calls could be useful, though:",
	"Stubbing - Stubbing with callbacks": "Allows stubbing with generic Answer interface. Yet another controversial feature which was not included in Mockito originally. We recommend simply stubbing with thenReturn() or thenThrow(), which should be enough to test/test-drive any clean & simple code. However, if you do have a need to stub with the generic Answer interface,",
	"Stubbing - Changing default return values of unstubbed invocations (Since 1.7)": "You can create a mock with specified strategy for its return values. It's quite an advanced feature and typically you don't need it to write decent tests. However, it can be helpful for working with legacy systems. It is the default answer so it will be used only when you don't stub the method call.",
	"Stubbing - Deep stubs (Since 1.10.0)": "Deep stubbing has been improved to find generic information if available in the class. That means that classes like this can be used without having to mock the behavior.",

	"Verifying": "SECTION",
	"Verification - Mockito.verify(T mock)": "Verifies certain behavior happened once.",
	"Verification - Mockito.verify(T mock, VerificationMode mode)": "Verifies certain behavior happened at least once / exact number of times / never.",
	"Verification - Mockito.verifyNoMoreInteractions(Object. . . mocks)": "Checks if any of given mocks has any unverified interaction. You can use this method after you verified your mocks - to make sure that nothing else was invoked on your mocks.",
	"Verification - Verification ignoring stubs (Since 1.9.0)": "Mockito will now allow to ignore stubbing for the sake of verification. Sometimes useful when coupled with verifyNoMoreInteractions() or verification inOrder(). Helps avoiding redundant verification of stubbed calls - typically we're not interested in verifying stubs. Warning, ignoreStubs() might lead to overuse of verifyNoMoreInteractions(ignoreStubs(...)), Bear in mind that Mockito does not recommend bombarding every test with verifyNoMoreInteractions() for the reasons outlined in javadoc for verifyNoMoreInteractions(Object...)",
	"Verification - Finding redundant invocations": "A word of warning: Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. verifyNoMoreInteractions() is not recommended to use in every test method. verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant. Abusing it leads to overspecified, less maintainable tests",
	"Verification - Mockito.verifyZeroInteractions(Object. . . mocks)": "Verifies that no interactions happened on given mocks beyond the previously verified interactions. This method has the same behavior as verifyNoMoreInteractions(Object...).",
	"Verification - Mockito.times(int wantedNumberOfInvocations)": "Allows verifying exact number of invocations. E.g: verify(mock, times(2)).someMethod('some arg'),",
	"Verification - Mockito.never()": "Alias to times(0), see times(int) Verifies that interaction did not happen. E.g: verify(mock, never()).someMethod(),",
	"Verification - Mockito.atLeastOnce()": "Allows at-least-once verification. E.g: verify(mock, atLeastOnce()).someMethod('some arg'),",
	"Verification - Mockito.atLeast()": "Allows at-least-x verification. E.g: verify(mock, atLeast(3)).someMethod('some arg'),",
	"Verification - Mockito.atMost()": "Allows at-most-x verification. E.g: verify(mock, atMost(3)).someMethod('some arg'),",
	"Verification - Mockito.only()": "Verifies that there the given method is invoked and is the only method invoked.",
	"Verification - Mockito.calls(int wantedNumberOfInvocations)": "Allows non-greedy verification in order. For example inOrder.verify( mock, calls( 2 )).someMethod( 'some arg' ), will not fail if the method is called 3 times, unlike times( 2 ) will not mark the third invocation as verified, unlike atLeast( 2 ) This verification mode can only be used with in order verification.",
	"Verification - Mockito.after(long millis)": "Verification will be triggered after given amount of millis, allowing testing of async code. Useful when interactions with the mock object did not happened yet. Extensive use of after() method can be a code smell - there are better ways of testing concurrent code. Not yet implemented to work with InOrder verification.verify(mock, after(100)).someMethod(),",
	"Verification - Mockito.timeout(long millis) (Since 1.8.5)": "Verification will be triggered after given amount of millis, allowing testing of async code. Useful when interactions with the mock object did not happened yet. verify(mock, timeout(100)).someMethod(),",
	"Verification - Mockito.timeout(long millis) - Usage": " It causes a verify to wait for a specified period of time for a desired interaction rather than fails immediately if had not already happened. May be useful for testing in concurrent conditions. This feature should be used rarely - figure out a better way of testing your multi-threaded system. Not yet implemented to work with InOrder verification.,",
	"Verification - Mockito.timeout(long millis) vs Mockito.after(long millis)": "Extensive use of after() method can be a code smell - there are better ways of testing concurrent code. Extensive use of timeout() method can be a code smell - there are better ways of testing concurrent code.",
	"Verification - Mockito.description(String description)": "Adds a description to be printed if verification fails. verify(mock, description('This will print on failure')).someMethod('some arg'),",
	"Verification - Mockito.ignoreStubs(Object... mocks)": "Ignores stubbed methods of given mocks for the sake of verification. Sometimes useful when coupled with verifyNoMoreInteractions() or verification inOrder(). Helps avoiding redundant verification of stubbed calls - typically we're not interested in verifying stubs. Warning, ignoreStubs() might lead to overuse of verifyNoMoreInteractions(ignoreStubs(...)), Bear in mind that Mockito does not recommend bombarding every test with verifyNoMoreInteractions() for the reasons outlined in javadoc for verifyNoMoreInteractions(Object...) Other words: all *stubbed* methods of given mocks are marked *verified* so that they don't get in a way during verifyNoMoreInteractions(). This method changes the input mocks! This method returns input mocks just for convenience. Ignored stubs will also be ignored for verification inOrder, including InOrder.verifyNoMoreInteractions(). verifyNoMoreInteractions(ignoreStubs(mock1, mock2)),",
	"Verification - Mockito.inOrder": "Creates InOrder object that allows verifying mocks in order. InOrder inOrder = inOrder(firstMock, secondMock), inOrder.verify(firstMock).add('was called first'), inOrder.verify(secondMock).add('was called second'), Verification in order is flexible - you don't have to verify all interactions one-by-one but only those that you are interested in testing in order. Also, you can create InOrder object passing only mocks that are relevant for in-order verification. InOrder verification is 'greedy', but you will hardly ever notice it.",
	"Verification - Verification in order": "Verification in order is flexible - you don't have to verify all interactions one-by-one but only those that you are interested in testing in order. Also, you can create an InOrder object passing only the mocks that are relevant for in-order verification. inOrder.verify(firstMock).add('was called first'),",
	"Verification - ArgumentCaptor (Since 1.8.0)": "Use it to capture argument values for further assertions. Mockito verifies argument values in natural java style: by using an equals() method. This is also the recommended way of matching arguments because it makes tests clean & simple. In some situations though, it is helpful to assert on certain arguments after the actual verification.",
	"Verification - ArgumentCaptor - Purpose": "In a way ArgumentCaptor is related to custom argument matchers (see javadoc for ArgumentMatcher class). Both techniques can be used for making sure certain arguments where passed to mocks. However, ArgumentCaptor may be a better fit if: custom argument matcher is not likely to be reused you just need it to assert on argument values to complete verification Custom argument matchers via ArgumentMatcher are usually better for stubbing. This utility class *don't do any type checks*, the generic signatures are only there to avoid casting in your code.",
	"Verification - ArgumentCaptor - Usage": "It is recommended to use ArgumentCaptor with verification but not with stubbing. Using ArgumentCaptor with stubbing may decrease test readability because captor is created outside of assert (aka verify or 'then') block. Also it may reduce defect localization because if stubbed method was not called then no argument is captured.",
	"Verification - ArgumentCaptor - vs ArgumentMatchers": "In a way ArgumentCaptor is related to custom argument matchers. Both techniques can be used for making sure certain arguments where passed to mocks. However, ArgumentCaptor may be a better fit if: custom argument matcher is not likely to be reused you just need it to assert on argument values to complete verification Custom argument matchers via ArgumentMatcher are usually better for stubbing.",
	"Verification - ArgumentCaptor - @Captor": "Allows shorthand ArgumentCaptor creation on fields. simplifies creation of ArgumentCaptor - useful when the argument to capture is a nasty generic class and you want to avoid compiler warnings",
	"Verification - ArgumentCaptor - capture()": "Use it to capture the argument. This method must be used inside of verification. Internally, this method registers a special implementation of an ArgumentMatcher. This argument matcher stores the argument value so that you can use it later to perform assertions.",
	"Verification - ArgumentCaptor - getValue()": "Returns the captured value of the argument. When capturing varargs use getAllValues(). If verified method was called multiple times then this method it returns the latest captured value.",
	"Verification - ArgumentCaptor - getAllValues()": "Returns all captured values. Use it when capturing varargs or when the verified method was called multiple times. When varargs method was called multiple times, this method returns merged list of all values from all invocations.",
	"Verification - ArgumentCaptor - forClass(Class<S> clazz)": "Build a new ArgumentCaptor. Note that an ArgumentCaptor *don't do any type checks*, it is only there to avoid casting in your code. This might however change (type checks could be added) in a future major release.",
	"Verification - Custom verification failure message (Since 2.1.0)": "Allows specifying a custom message to be printed if verification fails.",
	"Verification - can i verify toString()": "No. You can stub it, though. Verification of toString() is not implemented mainly because: When debugging, IDE calls toString() on objects to print local variables and their content, etc. After debugging, the verification of toString() will most likely fail toString() is used for logging or during string concatenation. Those invocations are usually irrelevant but they will change the outcome of verification."
}