{

	"Features": "SECTION",
	"Features - Java1": "",
	"Features - Java2": "",
	"Features - Java3": "",
	"Features - Java4": "",
	"Features - Java5": "",
	"Features - Java6": "",
	"Features - Java7": "",
	"Features - Java8": "",
	"Features - Java9": "",
	"Features - Java9 - Modular": "Modular System – Jigsaw Project Let’s start with the big one – bringing modularity into the Java platform. A modular system provides capabilities similar to OSGi framework’s system. Modules have a concept of dependencies, can export a public API and keep implementation details hidden/private.",
	"Features - Java9 - HTTPClient": "A long-awaited replacement of the old HttpURLConnection. The new API is located under the java.net.http package. It should support both HTTP/2 protocol and WebSocket handshake, with performance that should be comparable with the Apache HttpClient, Netty and Jetty.",
	"Features - Java9 - ProcessAPI": "The process API has been improved for controlling and managing operating-system processes.",
	"Features - Java9 - Try-With-Resources": "In Java 7, the try-with-resources syntax requires a fresh variable to be declared for each resource being managed by the statement. In Java 9 there is an additional refinement: if the resource is referenced by a final or effectively final variable, a try-with-resources statement can manage a resource without a new variable being declared:",
	"Features - Java9 - DiamondOperator": "Now we can use diamond operator in conjunction with anonymous inner classes",
	"Features - Java9 - Private": "Interface Private Method Interfaces in the upcoming JVM version can have private methods, which can be used to split lengthy default methods:",
	"Features - Java9 - JShell": "JShell Command Line Tool JShell is read–eval–print loop – REPL for short.",
	"Features - Java9 - JCMD": "new subcommands in jcmd command line utility.",
	"Features - Java9 - ImageAPI": "The interface java.awt.image.MultiResolutionImage encapsulates a set of images with different resolutions into a single object. We can retrieve a resolution-specific image variant based on a given DPI metric and set of image transformations or retrieve all of the variants in the image.",
	"Features - Java9 - VariableHandles": "The API resides under java.lang.invoke and consists of VarHandle and MethodHandles. It provides equivalents of java.util.concurrent.atomic and sun.misc.Unsafe operations upon object fields and array elements with similar performance. With Java 9 Modular system access to sun.misc.Unsafe will not be possible from application code.",
	"Features - Java9 - Publish-Subscribe": "The class java.util.concurrent.Flow provides interfaces that support the Reactive Streams publish-subscribe framework. These interfaces support interoperability across a number of asynchronous systems running on JVMs. We can use utility class SubmissionPublisher to create custom components.",
	"Features - Java9 - JVMLogging": "This feature introduces a common logging system for all components of the JVM.",
	"Features - Java9 - ImmutableSet": "java.util.Set.of() – creates an immutable set of a given elements. In Java 8 creating a Set of several elements would require several lines of code. Now we can do it as simple as: Set<String> strKeySet = Set.of('key', 'key2', 'key3');",
	"Features - Java9 - OptionalToStream": "java.util.Optional.stream() gives us an easy way to you use the power of Streams on Optional elements:",
	"Features - Java10": "",
	"Features - Java10 - var": "We don’t provide the data type of message. Instead, we mark the message as a var, and the compiler infers the type of message from the type of the initializer present on the right-hand side.",
	"Features - Java10 - copyOf(Collection)": "java.util.List, java.util.Map and java.util.Set each got a new static method copyOf(Collection). It returns the unmodifiable copy of the given Collection.",
	"Features - Java10 - toUnmodifiable": "java.util.stream.Collectors get additional methods to collect a Stream into unmodifiable List, Map or Set:",
	"Features - Java10 - Optional.orElseThrow": "java.util.Optional, java.util.OptionalDouble, java.util.OptionalIntand java.util.OptionalLongeach got a new method orElseThrow()which doesn’t take any argument and throws NoSuchElementExceptionif no value is present:",
	"Features - Java10 - ContainerAwareness": "JVMs are now aware of being run in a Docker container and will extract container-specific configuration instead of querying the operating system itself – it applies to data like the number of CPUs and total memory that have been allocated to the container. However, this support is only available for Linux-based platforms. This new support is enabled by default and can be disabled in the command line with the JVM option: -XX:-UseContainerSupport",
	"Features - Java10 - RootCertificates": "The cacerts keystore, which was initially empty so far, is intended to contain a set of root certificates that can be used to establish trust in the certificate chains used by various security protocols. As a result, critical security components such as TLS didn’t work by default under OpenJDK builds. With Java 10, Oracle has open-sourced the root certificates in Oracle’s Java SE Root CA program in order to make OpenJDK builds more attractive to developers and to reduce the differences between those builds and Oracle JDK builds.",
	"Features - Java10 - javah": "Tool javah has been removed from Java 10 which generated C headers and source files which were required to implement native methods – now, javac -h can be used instead.",
	"Features - Java10 - policytool": "policytool was the UI based tool for policy file creation and management. This has now been removed. The user can use simple text editor for performing this operation.",
	"Features - Java10 - java -Xprofoption": "Removed java -Xprofoption. The option was used to profile the running program and send profiling data to standard output. The user should now use jmap tool instead.",
	"Features - Java10 - java.security.acl": "Deprecated java.security.acl package has been marked forRemoval=true and is subject to removal in a future version of Java SE. It’s been replaced by java.security.Policy and related classes. Similarly, java.security.{Certificate,Identity,IdentityScope,Signer} APIs are marked forRemoval=true.",
	"Features - Java10 - ReleaseVersioning": "Starting with Java 10, Oracle has moved to the time-based release of Java.",
	"Features - Java11": "",
	"Features - Java11 - LocalVariableLambda": "Local Variable Syntax for Lambda Parameters. One of the key features introduced in Java 10 was local variable type inference. It allowed the use of var as the type of the local variable instead of the actual type. The compiler inferred the type based on the value assigned to the variable. Java 11 addresses this by supporting the above syntax. This makes the usage of var uniform in both local variables and lambda parameters. (var s1, var s2) -> s1 + s2",
	"Features - Java11 - Predicate.not()": "The Predicate.not() static method has been added to Java 11 in order to negate an existing Predicate.",
	"Features - Java11 - OpenJDK": "Java 10 was the last free Oracle JDK release that we could use commercially without a license. Starting with Java 11, there’s no free long-term support (LTS) from Oracle. Thankfully, Oracle continues to provide Open JDK releases, which we can download and use without charge.",
	"Features - Java11 - String.isBlank()": "",
	"Features - Java11 - String.lines()": "",
	"Features - Java11 - String.strip()": "",
	"Features - Java11 - String.stripLeading()": "",
	"Features - Java11 - String.stripTrailing()": "",
	"Features - Java11 - String.repeat()": "",
	"Features - Java11 - Files.readString": "",
	"Features - Java11 - Files.writeString": "",
	"Features - Java11 - Collection.toArray": "",
	"Features - Java11 - HTTPClient": "The new HTTP client from the java.net.http package was introduced in Java 9. It has now become a standard feature in Java 11. The new HTTP API improves overall performance and provides support for both HTTP/1.1 and HTTP/2:",
	"Features - Java11 - class.isNestmateOf": "JVM access rules allow access to private members between nestmates; however, in previous Java versions, the reflection API denied the same access. Java 11 fixes this issue and provides means to query the new class file attributes using the reflection API",
	"Features - Java11 - autocompilation": "we don’t need to compile the Java source files with javac explicitly anymore: we can directly run the file using the java command: $ java HelloWorld.java",
	"Features - Java11 - CONSTANT_Dynamic": "Dynamic Class-File Constants Java class-file format is extended to support a new constant-pool form named CONSTANT_Dynamic. Loading the new constant-pool will delegate creation to a bootstrap method, just as linking an invokedynamic call site delegates linkage to a bootstrap method. This feature enhances performance and targets language designers and compiler implementors.",
	"Features - Java11 - Aarch64": "Improved Aarch64 Intrinsics Java 11 optimizes the existing string and array intrinsics on ARM64 or AArch64 processors. Additionally, new intrinsics are implemented for sin, cos, and log methods of java.lang.Math. We use an intrinsic function like any other; however, the intrinsic function gets handled in a special way by the compiler. It leverages CPU architecture-specific assembly code to boost performance.",
	"Features - Java11 - Epsilon": "A new garbage collector called Epsilon is available for use in Java 11 as an experimental feature. It’s called a No-Op (no operations) because it allocates memory but does not actually collect any garbage. Thus, Epsilon is applicable for simulating out of memory errors.",
	"Features - Java11 - FlightRecorder": "Java Flight Recorder (JFR) is now open-source in Open JDK, whereas it used to be a commercial product in Oracle JDK. JFR is a profiling tool that we can use to gather diagnostics and profiling data from a running Java application.",
	"Features - Java11 - ZGC": "Introduced a low latency garbage collector, ZGC, as an experimental feature with low pause times",
	"Features - Java11 - CORBA": "deprecated",
	"Features - Java11 - JMC": "deprecated",
	"Features - Java11 - JavaFX": "deprecated",
	"Features - Java11 - Nashorn": "deprecated",
	"Features - Java11 - Pack200": "deprecated",
	"Features - Java12": "",
	"Features - Java12 - String": "String Class New Methods Java 12 comes with two new methods in the String class. The first one – indent adjusts the indentation of each line based on the integer parameter. If the parameter is greater than zero, new spaces will be inserted at the beginning of each line. On the other hand, if the parameter is less than zero, it removes spaces from the begging of each line. If a given line does not contain sufficient white space, then all leading white space characters are removed.",
	"Features - Java12 - File::mismatch": "File::mismatch Method Java 12 introduced a new mismatch method in the nio.file.Files utility class",
	"Features - Java12 - TeeingCollector": "Teeing Collector A new teeing collector was introduced in Java 12 as an addition to the Collectors class",
	"Features - Java12 - CompactNumberFormatting": "Compact Number Formatting Java 12 comes with a new number formatter – the CompactNumberFormat. It’s designed to represent a number in a shorter form, based on the patterns provided by a given locale.",
	"Features - Java12 - Switch": "Switch Expressions (Preview) The most popular feature introduced in Java 12 is the Switch Expressions. As a demonstration, let’s compare the old and new switch statements. We’ll use them to distinguish working days from weekend days based on the DayOfWeek enum from the LocalDate instance.",
	"Features - Java12 - instanceof": "Pattern Matching for instanceof (Preview) Another preview feature introduced in Java 12 is pattern matching for instanceof. In previous Java versions, when using, for example, if statements together with instanceof, we would have to explicitly typecast the object to access its features:",
	"Features - Java12 - Shenandoah": "Shenandoah: A Low-Pause-Time Garbage Collector Shenandoah is an experimental garbage collection (GC) algorithm, for now not included in the default Java 12 builds. It reduces the GC pause times by doing evacuation work simultaneously with the running Java threads. This means that with Shenandoah, pause times are not dependent on the heap’s size and should be consistent. Garbage collecting a 200 GB heap or a 2 GB heap should have a similar low pause behavior. Shenandoah will become part of mainline JDK builds since version 15.",
	"Features - Java12 - Microbenchmark": "Microbenchmark Suite Java 12 introduces a suite of around 100 microbenchmark tests to the JDK source code. These tests will allow for continuous performance testing on a JVM and will become useful for every developer wishing to work on the JVM itself or create a new microbenchmark.",
	"Features - Java12 - CDS": "Default CDS Archives The Class Data Sharing (CDS) feature helps reduce the startup time and memory footprint between multiple Java Virtual Machines. It uses a built-time generated default class list that contains the selected core library classes.",
	"Features - Java13": "",
	"Features - Java13 - Switch": "We initially saw switch expressions in JDK 12. Java 13’s switch expressions build on the previous version by adding a new yield statement. Using yield, we can now effectively return values from a switch expression:",
	"Features - Java13 - TextBlocks": "Text Blocks (JEP 355) The second preview feature is text blocks for multi-line Strings such as embedded JSON, XML, HTML, etc. Earlier, to embed JSON in our code, we would declare it as a String literal:",
	"Features - Java13 - CDS": "Dynamic CDS Archives (JEP 350) Class data sharing (CDS) has been a prominent feature of Java HotSpot VM for a while now. It allows class metadata to be shared across different JVMs to reduce startup time and memory footprint. JDK 10 extended this ability by adding application CDS (AppCDS) – to give developers the power to include application classes in the shared archive. JDK 12 further enhanced this feature to include CDS archives by default.",
	"Features - Java13 - ZGC": "ZGC: Uncommit Unused Memory (JEP 351) The Z Garbage Collector was introduced in Java 11 as a low-latency garbage collection mechanism, such that GC pause times never exceeded 10 ms. However, unlike other HotSpot VM GCs such as G1 and Shenandoah, it was not equipped to return unused heap memory to the operating system. Java 13 added this capability to the ZGC. We now get a reduced memory footprint along with performance improvement.",
	"Features - Java13 - LegacySocketAPI": "Reimplement the Legacy Socket API (JEP 353) We have seen Socket (java.net.Socket and java.net.ServerSocket) APIs as an integral part of Java since its onset. However, they were never modernized in the last twenty years. Written in legacy Java and C, they were cumbersome and difficult to maintain.",
	"Features - Java14": "",
	"Features - Java14 - Switch": "Switch Expressions (JEP 361) These were first introduced as a preview feature in JDK 12, and even in Java 13, they continued as preview features only. But now, switch expressions have been standardized so that they are part and parcel of the development kit.",
	"Features - Java14 - TextBlocks": "Text Blocks (JEP 368) Text blocks continue their journey to getting a mainstream upgrade and are still available as preview features. In addition to the capabilities from JDK 13 to make multiline strings easier to use, in their second preview, text blocks now have two new escape sequences:",
	"Features - Java14 - instanceof": "Pattern Matching for instanceof (JEP 305)  JDK 14 has introduced pattern matching for instanceof with the aim of eliminating boilerplate code and make the developer’s life a little bit easy.",
	"Features - Java14 - Records": "Records (JEP 359) Records were introduced to reduce repetitive boilerplate code in data model POJOs. They simplify day to day development, improve efficiency and greatly minimize the risk of human error.",
	"Features - Java14 - NullPointerExceptions": "Helpful NullPointerExceptions (JEP 358) Previously, the stack trace for a NullPointerException didn’t have much of a story to tell except that some value was null at a given line in a given file. Though useful, this information only suggested a line to debug instead of painting the whole picture for a developer to understand, just by looking at the log. Now Java has made this easier by adding the capability to point out what exactly was null in a given line of code.",
	"Features - Java14 - ForeignMemoryAccessAPI": "Foreign Memory Access API (JEP 370) This is a new API to allow Java programs to access foreign memory, such as native memory, outside the heap in a safe and efficient manner. Many Java libraries such as mapDB and memcached do access foreign memory and it was high time the Java API itself offered a cleaner solution. With this intention, the team came up with this JEP as an alternative to its already existing ways to access non-heap memory – ByteBuffer API and sun.misc.Unsafe API. Built upon three main abstractions of MemorySegment, MemoryAddress and MemoryLayout, this API is a safe way to access both heap and non-heap memory.",
	"Features - Java14 - PackagingTool": "Packaging Tool (JEP 343) Traditionally, to deliver Java code, an application developer would simply send out a JAR file that the user was supposed to run inside their own JVM. However, users rather expected an installer that they’d double click to install the package on their native platforms, such as Windows or macOS. This JEP aims to do precisely that. Developers can use jlink to condense the JDK down to the minimum required modules, and then use this packaging tool to create a lightweight image that can be installed as an exe on Windows or a dmg on a macOS.",
	"Features - Java14 - ZGC": "ZGC on Windows (JEP 365) and macOS (JEP 364) – Experimental The Z Garbage Collector, a scalable, low-latency garbage collector, was first introduced in Java 11 as an experimental feature. But initially, the only supported platform was Linux/x64. After receiving positive feedback on ZGC for Linux, Java 14 has ported its support to Windows and macOS as well. Though still an experimental feature, it’s all set to become production-ready in the next JDK release.",
	"Features - Java14 - G1": "NUMA-Aware Memory Allocation for G1 (JEP 345) Non-uniform memory access (NUMA) was not implemented so far for the G1 garbage collector, unlike the Parallel collector. Looking at the performance improvement that it offers to run a single JVM across multiple sockets, this JEP was introduced to make the G1 collector NUMA-aware as well. At this point, there’s no plan to replicate the same to other HotSpot collectors.",
	"Features - Java14 - EventStreaming": "JFR Event Streaming (JEP 349) With this enhancement, JDK’s flight recorder data is now exposed so that it can be continuously monitored. This involves modifications to the package jdk.jfr.consumer so that users can now read or stream the recording data directly.",
	"Features - Java14 - CMS": "Concurrent Mark Sweep (CMS) Garbage Collector (JEP 363) – deprecated by Java 9, this GC has been succeeded by G1 as the default GC. Also, there are other more performant alternatives to use now, such as ZGC and Shenandoah, hence the removal",
	"Features - Java15": "",
	"Features - Java15 - Records": "Records (JEP 384) The record is a new type of class in Java that makes it easy to create immutable data objects. Originally introduced in Java 14 as an early preview, Java 15 aims to refine a few aspects before becoming an official product feature.",
	"Features - Java15 - SealedClasses": "Sealed Classes (JEP 360 Currently, Java provides no fine-grained control over the inheritance. Access modifiers such as public, protected, private, as well as the default package-private, provide very coarse-grained control. To that end, the goal of sealed classes is to allow individual classes to declare which types may be used as sub-types. This also applies to interfaces and determining which types can implement them. Sealed classes involve two new keywords — sealed and permits:",
	"Features - Java15 - HiddenClasses": "Hidden Classes (JEP 371) A new feature being introduced in Java 15 is known as hidden classes. While most developers won’t find a direct benefit from them, anyone who works with dynamic bytecode or JVM languages will likely find them useful. The goal of hidden classes is to allow the runtime creation of classes that are not discoverable. This means they cannot be linked by other classes, nor can they be discovered via reflection. Classes such as these typically have a short lifecycle, and thus, hidden classes are designed to be efficient with both loading and unloading. Note that current versions of Java do allow for the creation of anonymous classes similar to hidden classes. However, they rely on the Unsafe API. Hidden classes have no such dependency.",
	"Features - Java15 - PatternMatching": "Pattern Matching Type Checks (JEP 375) The pattern matching feature was previewed in Java 14, and Java 15 aims to continue its preview status with no new enhancements. As a review, the goal of this feature is to remove a lot of boilerplate code that typically comes with the instanceof operator",
	"Features - Java15 - ForeignMemoryAPI": "Foreign memory access is already an incubating feature of Java 14. In Java 15, the goal is to continue its incubation status while adding several new features. Foreign memory generally refers to memory that lives outside the managed JVM heap. Because of this, it’s not subject to garbage collection and can typically handle incredibly large memory segments.",
	"Features - Java15 - GC": "In Java 15, both ZGC (JEP 377) and Shenandoah (JEP 379) will be no longer be experimental. Both will be supported configurations that teams can opt to use, while the G1 collector will remain the default.",
	"Features - Java16": "",
	"Features - Java16 - Proxy": "Invoke Default Methods From Proxy Instances (JDK-8159746) As an enhancement to the default method in Interfaces, with the release of Java 16, support has been added to java.lang.reflect.InvocationHandler invoke default methods of an interface via a dynamic proxy using reflection.",
	"Features - Java16 - DayPeriod": "Day Period Support (JDK-8247781) A new addition to the DateTimeFormatter is the period-of-day symbol “B“, which provides an alternative to the am/pm format:",
	"Features - Java16 - Stream.toList": "Add Stream.toList Method (JDK-8180352) The aim is to reduce the boilerplate with some commonly used Stream collectors, such as Collectors.toList and Collectors.toSet:",
	"Features - Java16 - VectorAPI": "Vector API Incubator (JEP-338) The Vector API is in its initial incubation phase for Java 16. The idea of this API is to provide a means of vector computations that will ultimately be able to perform more optimally (on supporting CPU architectures) than the traditional scalar method of computations.",
	"Features - Java16 - Records": "Records (JEP-395) Records were introduced in Java 14. Java 16 brings some incremental changes. Records are similar to enums in the fact that they are a restricted form of class. Defining a record is a concise way of defining an immutable data holding object.",
	"Features - Java16 - instanceof": "Pattern Matching for instanceof (JEP-394) Pattern matching for the instanceof keyword has been added as of Java 16.",
	"Features - Java16 - SealedClasses": "Sealed Classes (JEP-397) Sealed classes, first introduced in Java 15, provide a mechanism to determine which sub-classes are allowed to extend or implement a parent class or interface.",
	"Features - Java17": "",
	"Features - Java17 - Switch": "Pattern Matching for Switch (Preview) (JEP 406) This is another step toward pattern matching by enhancing pattern matching for switch expressions and statements. It reduces the boilerplate necessary to define those expressions and improves the expressiveness of the language.",
	"Features - Java17 - SealedClasses": "Sealed Classes (JEP 409) Sealed classes are part of Project Amber, and this JEP officially introduces a new feature to the language, although it was available in preview mode in the JDK versions 15 and 16. The feature restricts which other classes or interfaces may extend or implement a sealed component. Showing another improvement related to pattern matching combined with the JEP 406 will allow a more sophisticated and cleaner inspection of the type, cast and act code pattern.",
	"Features - Java17 - AOTJITCompiler": "Remove the Experimental AOT and JIT Compiler (JEP 410) Introduced into JDK 9 and JDK 10, respectively, as experimental features, the Ahead-Of-Time (AOT) compilation (JEP 295) and Just-In-Time (JIT) compiler from GraalVM (JEP-317) were features with a high cost of maintenance. On the other hand, they had no significant adoption. Because of that, this JEP removed them from the platform, but developers can still leverage them using GraalVM.",
	"Features - Java17 - StrictFP": "Restore Always-Strict Floating-Point Semantics (JEP 306) This JEP is mainly for scientific applications, and it makes floating-point operations consistently strict. The default floating-point operations are strict or strictfp, both of which guarantee the same results from the floating-point calculations on every platform. Before Java 1.2, strictfp behavior was the default one as well. However, because of hardware issues, the architects changed, and the keyword strictfp was necessary to re-enable such behavior. So, there is no need to use this keyword anymore. ",
	"Features - Java17 - Random": "Enhanced Pseudo-Random Number Generators (JEP 356) Also related to more special use cases, JEP 356 provides new interfaces and implementations for Pseudo-Random Number Generators (PRNG). So, it’s easier to use different algorithms interchangeably, and it also offers better support for stream-based programming:",
	"Features - Java17 - macOSRendering": "New macOS Rendering Pipeline (JEP 382) This JEP implements a Java 2D internal rendering pipeline for macOS since Apple deprecated the OpenGL API (in macOS 10.14), used internally in Swing GUI. The new implementation uses the Apple Metal API, and apart from the internal engine, there were no changes to the existing APIs.",
	"Features - Java17 - macOSAArch64Port": "macOS/AArch64 Port (JEP 391) Apple announced a long-term plan to transition its computer line from X64 to AArch64. This JEP ports the JDK to run on AArch64 in macOS platforms.",
	"Features - Java17 - AppletAPI": "Deprecate the Applet API for Removal (JEP 398) Although this may be sad for many Java developers who started their development career using Applet APIs, many web browsers have already removed their support for Java plugins. As the API became irrelevant, this version marked it for removal even though it has been marked as deprecated since version 9.",
	"Features - Java17 - illegal": "Strongly Encapsulate JDK Internals (JEP 403) JEP 403 represents one more step toward strongly encapsulating JDK internals since it removes the flag –illegal-access. The platform will ignore the flag, and if the flag is present, the console will issue a message informing the discontinuation of the flag. This feature will prevent JDK users from accessing internal APIs, except for critical ones like sun.misc.Unsafe.",
	"Features - Java17 - RMIActivation": "Remove RMI Activation (JEP 407) Marked for removal in version 15, this JEP removed the RMI activation API from the platform in version 17.",
	"Features - Java17 - SecurityManager": "Deprecate the Security Manager for Removal (JEP 411) The security manager aimed to secure client-side Java code is yet another feature marked for removal due to not being relevant anymore.",
	"Features - Java17 - ForeignFunctionMemoryAPI": "The Foreign Function and Memory API allow Java developers to access code from outside the JVM and manage memory out of the heap. The goal is to replace the JNI API and improve the security and performance compared to the old one. This API is another feature developed by Project Panama, and it has been evolved and predeceased by JEPs 393, 389, 383 and 370.",
	"Features - Java17 - VectorAPI": "Vector API (Second Incubator) (JEP 414) The Vector API deals with the SIMD (Single Instruction, Multiple Data) type of operation, meaning various sets of instructions executed in parallel. It leverages specialized CPU hardware that supports vector instructions and allows the execution of such instructions as pipelines. As a result, the new API will enable developers to implement more efficient code, leveraging the potential of the underlying hardware. Everyday use cases for this operation are scientific algebra linear applications, image processing, character processing, and any heavy arithmetic application or any application that needs to apply an operation for multiple independent operands.",
	"Features - Java17 - DeserializationFilters": "Context-Specific Deserialization Filters (JEP 415) JEP 290, first introduced in JDK 9, enabled us to validate incoming serialized data from untrusted sources, a common source of many security issues. That validation happens at the JVM level, giving more security and robustness. With JEP 415, applications can configure context-specific and dynamically selected deserialization filters defined at the JVM level. Each deserialization operation will invoke such filters.",
	"Features - Java18": "",
	"Features - Java19": "",
	"Features - Java20": "",
	"Features - Java21": "",
	"Features - Java21 - RecordPatterns": "Record Patterns (JEP 440) Record patterns were included in Java 19 and Java 20 as preview features. Now, with Java 21, they are out of the preview and include some refinements. This JEP extends the existing pattern-matching feature to destructure the record class instances, which enables writing sophisticated data queries. Moreover, this JEP adds support for nested patterns for more composable data queries.",
	"Features - Java21 - Switch": "Initially introduced in JDK 17, Pattern matching for the switch was refined in JDK 18, 19, and 20 and improved further in JDK 21. The main goal of this feature is to allow patterns in switch case labels and improve the expressiveness of switch statements and expressions. Besides, there is also an enhancement to handle NullPointerException by allowing a null case label.",
	"Features - Java21 - StringLiteral": "String Literal (JEP 430) Java offers several mechanisms for composing strings with string literals and expressions. Some of these are String concatenation, StringBuilder class, String class format() method, and the MessageFormat class. Java 21 introduces string templates. These complement Java’s existing string literals and text blocks by coupling literal text with template expressions and template processors to produce the desired results.",
	"Features - Java21 - VirtualThreads": "Virtual Threads (JEP 444) Virtual threads were initially introduced to the Java language as a preview feature in Java 19 and further refined in Java 20. Java 21 introduced some new changes.",
	"Features - Java21 - SequencedCollections": "Sequenced Collections (JEP 431) Java 21 introduced three new interfaces to represent sequenced collections, sequenced sets, and sequenced maps.",
	"Features - Java21 - Encapsulation": "Key Encapsulation Mechanism API (JEP 452) Key encapsulation is a technique to secure symmetric keys using asymmetric keys or public key cryptography. The traditional approach uses a public key to secure a randomly generated symmetric key. However, this approach requires padding, which is difficult to prove secure. A key encapsulation mechanism (KEM) uses the public key to derive the symmetric key that doesn’t require any padding. Java 21 has introduced a new KEM API to enable applications to use KEM algorithms.",

	"types": "SECTION",
	"Type Checking - Speculative Attribution (Java 8)": "In Java 8, the implementation of type-checking at compiler level was based on Speculative Attribution. In Speculative Attribution, the same tree can be type-checked against multiple targets at runtime. This is particularly used in target typing for lambda expressions, resolving diamond expressions for generics, etc.",
	"Type Checking - Tiered Attribution (Java 9)": "As we saw in the previous example, there may be instances in which the compiler will have to perform type checking for multiple target types. This is a very important capability but can result in performance issues because of redundant steps done in the process. A JDK Enhancement Proposal (JEP 215) was proposed for type checking of poly expressions. The newly proposed way is known as Tiered Attribution. It focuses on improving performance by implementing a different way of type-checking that reduces redundant steps but gives the same results as current type-checking implementation.",
	"Type Inference (Java 10)": "In Java 10, this is how we could declare a local variable: var message = 'Hello, Java 10', We don’t provide the data type of message. Instead, we mark the message as a var, and the compiler infers the type of message from the type of the initializer present on the right-hand side.",
	"Type Inference - keyword": "Another thing to note is that var is not a keyword – this ensures backward compatibility for programs using var say, as a function or variable name. var is a reserved type name, just like int.",
	"Type Inference - overhead": "there is no runtime overhead in using var nor does it make Java a dynamically typed language. The type of the variable is still inferred at compile time and cannot be changed later.",
	"Type Inference - object": "the inferred type of obj isn’t Object. var obj = new Object() {},",
	"Type Inference - wrong - initializer": "var won’t work without the initializer: var n, // error:",
	"Type Inference - wrong - null": "Nor would it work if initialized with null: var emptyList = null,",
	"Type Inference - wrong - local": "Note that this feature is available only for local variables with the initializer. It cannot be used for member variables, method parameters, return types, etc. public var = 'hello', // error:",
	"Type Inference - wrong - lambda": "Lambda expression needs explicit target type, and hence var cannot be used: var p = (String s) -> s.length() > 10, // error:",
	"Type Inference - wrong - array": "Array needs explicit target type, and hence var cannot be used: var arr = { 1, 2, 3 }, // error",

	"reflection": "SECTION",
	"Reflection": "",
	"MethodHandle (Java 7)": "A method handle is a typed, directly executable reference to an underlying method, constructor, field, or similar low-level operation, with optional transformations of arguments or return values.",
	"MethodHandle vs Reflection": "From a performance standpoint, the MethodHandles API can be much faster than the Reflection API since the access checks are made at creation time rather than at execution time.",
	"VarHandle (Java 9)": "Generally, a variable handle is just a typed reference to a variable. The variable can be an array element, instance or static field of the class. The VarHandle class provides write and read access to variables under specific conditions. VarHandles are immutable and have no visible state. What’s more, they cannot be sub-classed.",
	"VarHandle - goal": "The goal of VarHandle is to define a standard for invoking equivalents of java.util.concurrent.atomic and sun.misc.Unsafe operations on fields and array elements. Those operations are in majority atomic or ordered operations. For example, atomic field incrementation.",

	"try": "SECTION",
	"try-with-resources (Java 7)": "Java 7 introduced the try-with-resources statement, where resources will be closed automatically after the execution. It requires an additional variable for the resources to be assigned. But Java 9 manages the same with the final or effectively final variables. The effectively final variable is the variable or the parameter whose values will never be changed once it is initialized.",
	"try-with-resources - requires additional variable (Java 7)": "InputStream inputStream = new FileInputStream('test.txt'), try (InputStream stream = inputStream) {} catch (IOException e) {}",
	"try-with-resources - no requires additional variable (Java 9)": "InputStream inputStream = new FileInputStream('test.txt'), try (inputStream) {} catch (IOException e) {}",

	"generics": "SECTION",
	"Diamond Operator - Generic Instantiation (Java 7)": "Java 7 introduced the diamond operator ( <> ) in generic class instantiation contexts. List<String> list2 = new ArrayList<>(),",
	"Diamond Operator - Generic Instantiation )Java 9)": "Java 9 enhanced the type inference algorithm to tell whether the inferred type is denotable when analyzing an anonymous class that supports the diamond operator. Iterator <String> iter = new Iterator <> () { }",

	"functional interfaces": "SECTION",
	"Functional Java": "Annonymous Inner Class -> Callback Hell -> Functional Interfaces + Default Methods -> Lambda Expressions -> Method References",
	"Functional Java - Functional Interfaces": "A functional interface is an interface that contains only one abstract method.",
	"Functional Java - Functional Interfaces - annotation": "@FunctionalInterface",
	"Functional Java - Functional Interfaces - types by function": "Suppliers, Consumers, Predicates, Operators.",
	"Functional Java - Functional Interfaces - Default Methods": "So it’d be really frustrating if we had lambdas in Java 8 but couldn’t use those with the standard collections library since backwards compatibility can’t be sacrificed. Due to the problem described above a new concept was introduced",
	"Functional Java - Functional Interfaces - Default Methods ": "Virtual extension methods or defender methods.",
	"Functional Java - Functional Interfaces - Default Methods - public (Java 8)": "implicit",
	"Functional Java - Functional Interfaces - Default Methods - static (Java 8)": "allowed",
	"Functional Java - Functional Interfaces - Default Methods - private (Java 9)": "allowed",
	"Functional Java - Functional Interfaces - Default Methods - final": "forbidden",
	"Functional Java - Functional Interfaces - Default Methods - synchronize": "forbidden",
	"Functional Java - Method Reference": "A method reference to a static method. A method reference to an instance method of an object of a particular type. A method reference to an instance method of an existing object. A method reference to a constructor.",
	"Functional Java - Method Reference - static method": "s -> Integer.parseInt(s) vs Integer::parseInt",
	"Functional Java - Method Reference - instance method of an object of a particular type": "(String s) -> s.toUpperCase() vs String::toUpperCase",
	"Functional Java - Method Reference - instance method of an existing object": "() -> books.size() vs books::size",
	"Functional Java - Method Reference - constructor": "() -> new Foo() vs Foo::new",

	"logging": "SECTION",
	"Logging": ".",
	"Logging - Internal Logging (Java 9)": "The new Java 9 Platform Logging API allows applications and frameworks to route JDK internal logs to the desired logging framework (e.g. Log4j2, SLF4J etc). This is the similar to what SLF4J does via its bridges (an example here) but now it is built into JDK and is meant to redirect JDK internal logs to the desired logging destination.",
	"Logging - Internal Logging - System.LoggerFinder ": ".",
	"Logging - Internal Logging - System.Logger ": ".",

	"JShell": "SECTION",
	"JShell (Java 9)": "The Java Shell tool (JShell) is an interactive tool for learning the Java programming language and prototyping Java code. JShell is a Read-Evaluate-Print Loop (REPL), which evaluates declarations, statements, and expressions as they are entered and immediately shows the results. The tool is run from the command line."
}