{
	"Angular": "SECTION",
	"Angular ": "https://github.com/sudheerj/angular-interview-questions",
	"Angular  ": "https://www.turing.com/interview-questions/angular",
	"Angular    ": "https://angular-university.io/my-courses?utm=blmc",
	"Angular - SPA": "",
	"Angular - Angular1": "Angular was introduced to create SPA applications",
	"Angular - Angular2": "",
	"Angular - Angular3": "",
	"Angular - Angular4": "",
	"Angular - Angular5": "In Angular 5, they introduced httpClient.",
	"Angular - Angular6": "",
	"Angular - Angular7": "",
	"Angular - Angular8": "Angular 8 they introduce Ivy engine to make bundle size small.",
	"Angular - Angular9": "",
	"Angular - Angular10": "",
	"Angular - Angular11": "",
	"Angular - Angular12": "",
	"Angular - Angular13": "",
	"Angular - Angular14": "",
	"Angular - Angular15": "Angular 15, they introduce standalone component.",
	"Angular - Angular16": "",
	"Angular - Angular17": "Angular 17, they have introduced Built-in control flow, Deferrable views, Angular Signals.",
	"Angular - Angular18": "",
	"Angular - Angular19": "",
	"Angular - vs React": "https://blog.stackademic.com/the-future-of-angular-will-it-disappear-one-day-61603a9d542d",	

	"BuildingBlocks": "SECTION",
	"BuildingBlocks - NgModules": "basic building blocks of an Angular application",
	"BuildingBlocks - NgModules - Features - Responsibilities": "An NgModule has two main responsibilities: Declaring components, directives, and pipes that belong to the NgModule. Add providers to the injector for components, directives, and pipes that import the NgModule",
	"BuildingBlocks - NgModules - Features - Multiplicity": "app always has at least a root module that enables bootstrapping, and typically has many more feature modules",
	"BuildingBlocks - NgModules - Structure - @NgModule": "NgModules are classes decorated with @NgModule.",
	"BuildingBlocks - NgModules - Structure - @NgModule - Properties - declarations": "Declares the components, directives, and pipes that belong to this NgModule.",
	"BuildingBlocks - NgModules - Structure - @NgModule - Properties - exports": "The subset of declarations that should be visible and usable in the component templates of other NgModules.",
	"BuildingBlocks - NgModules - Structure - @NgModule - Properties - imports": "Other modules whose exported classes are needed by component templates declared in this NgModule.",
	"BuildingBlocks - NgModules - Structure - @NgModule - Properties - providers": "Creators of services that this NgModule contributes to the global collection of services, they become accessible in all parts of the app. (You can also specify providers at the component level, which is often preferred.).",
	"BuildingBlocks - NgModules - Structure - @NgModule - Properties - providers - forRoot": "Some NgModules define a static forRoot method that accepts some configuration and returns an array of providers. The name 'forRoot' is a convention that indicates that these providers are intended to be added exclusively to the root of your application during bootstrap. providers: [ CustomMenuModule.forRoot(/* some config */), ],",
	"BuildingBlocks - NgModules - Structure - @NgModule - Properties - providers - forChild": "Some NgModules may define a static forChild that indicates the providers are intended to be added to components within your application hierarchy. providers: [ CustomMenuModule.forChild(/* some config */), ],",
	"BuildingBlocks - NgModules - Structure - @NgModule -'Properties - entryComponents": "components that are not found in html and created dynamically with ComponentFactoryResolver. Deprecated Angular 9+",
	"BuildingBlocks - NgModules - Structure - @NgModule - Properties - bootstrap": "It is the main application view, also called the root component, which hosts all other app views. Only the root NgModule should set this bootstrap property. Angular creates and inserts into the index.html host web page",
	"BuildingBlocks - NgModules - Built-in - FormsModule": "Exports the required providers and directives for template-driven forms, making them available for import by NgModules that import this module.",
	"BuildingBlocks - NgModules - Built-in - ReactiveFormsModule": "Exports the required infrastructure and directives for reactive forms, making them available for import by NgModules that import this module.",
	"BuildingBlocks - NgModules - Built-in - HttpClientModule": ".",
	"BuildingBlocks - NgModules - FeatureModules": "Feature modules are NgModules for the purpose of organizing code.",
	"BuildingBlocks - NgModules - FeatureModules - Domain": ".",
	"BuildingBlocks - NgModules - FeatureModules - Routed": ".",
	"BuildingBlocks - NgModules - FeatureModules - Routing": ".",
	"BuildingBlocks - NgModules - FeatureModules - Service": ".",
	"BuildingBlocks - NgModules - FeatureModules - Widget": ".",
	"BuildingBlocks - Components": "A component(@component) is a directive-with-a-template.",
	"BuildingBlocks - Components - Types - Root": "",
	"BuildingBlocks - Components - Types - Feature": "",
	"BuildingBlocks - Components - Structure - @Component": "",
	"BuildingBlocks - Components - Structure - @Component - Multiplicity": "A component can only be declared in one module. if we want to use our component in multiple modules Just wrap your component into a module. Why not create a components module?",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector": "Every component defines a CSS selector that determines how the component is used",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector - HostElement": "Angular creates an instance of a component for every HTML element that matches the component's selector. The DOM element that matches a component's selector is that component's host element. The contents of a component's template are rendered inside its host element.",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector - Types - ElementSelector": "Matches elements based on their HTML tag name, or node name. e.g. profile-photo",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector - Types - ElementSelector - example": "selector: 'app-header' -> < app-header >< /app-header >.",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector - Types - ElementSelector - Preferred": "The vast majority of components should use a custom element name as their selector. All custom element names should include a hyphen as described by the HTML specification. By default, Angular reports an error if it encounters a custom tag name that does not match any available components, preventing bugs due to mistyped component names.",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector - Types - AttributeSelector": "Matches elements based on the presence of an HTML attribute and, optionally, an exact value for that attribute. e.g. [dropzone]",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector - Types - AttributeSelector - example": "selector: '[appHighlight]' -> < div appHighlight >< /div >.",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector - Types - AttributeSelector - use": "You should consider an attribute selector when you want to create a component on a standard native element. For example, if you want to create a custom button component, you can take advantage of the standard < button > element by using an attribute selector: selector: 'button[yt-upload]',",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector - Types - ClassSelector": "Matches elements based on the presence of a CSS class. e.g. .menu-item",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector - Types - ClassSelector - example": "selector: '.app-alert' -> < div class='app-alert' >< /div >.",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector - Types - ClassSelector - :not": "Angular supports the :not pseudo-class. You can append this pseudo-class to any other selector to narrow which elements a component's selector matches. For example, you could define a [dropzone] attribute selector and prevent matching textarea elements: selector: '[dropzone]:not(textarea)',",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector - Types - WildcardSelector": "Can use * to match multiple elements dynamically.",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector - Types - Combined": "You can combine multiple selectors by concatenating them. For example, you can match <button> elements that specify type='reset'. e.g. selector: 'button[type='reset']', ",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector - Types - Combined - Comma": "You can also define multiple selectors with a comma-separated list: selector: 'drop-zone, [dropzone]',",
	"BuildingBlocks - Components - Structure - @Component - Properties - templateUrl": "The module-relative address of this component's HTML template. Alternatively, you can provide the HTML template inline, as the value of the template property. This template defines the component's host view.",
	"BuildingBlocks - Components - Structure - @Component - Properties - styleUrl": "Components can optionally include CSS styles that apply to that component's DOM.",
	"BuildingBlocks - Components - Structure - @Component - Properties - styleUrl - embedded": "styles: ` img { border-radius: 50%; } `,",
	"BuildingBlocks - Components - Structure - @Component - Properties - styleUrl - separated": "styleUrl: 'profile-photo.css',",
	"BuildingBlocks - Components - Structure - @Component - Properties - styleUrl - Scope": "Every component has a view encapsulation setting that determines how the framework scopes a component's styles. There are three view encapsulation modes: Emulated, ShadowDom, and None. You can specify the mode in the @Component decorator:",
	"BuildingBlocks - Components - Structure - @Component - Properties - imports": "To use a component, directive, or pipe, you must add it to the imports array in the @Component decorator:",
	"BuildingBlocks - Components - Structure - @Component - Properties - standalone": "By default, Angular components are standalone, meaning that you can directly add them to the imports array of other components.",
	"BuildingBlocks - Components - Structure - @Component - Properties - standalone - benefit": "The main benefit of standalone components is that they make it super easy to develop a fully lazy-loaded application, or migrate an existing monolithic application and make it fully lazy-loaded. Your application developed with NgModules is probably relatively monolithic,",
	"BuildingBlocks - Components - Structure - @Component - Properties - standalone - Angular14": "Standalone Components allowed us to write components that didn’t need to rely on the old-school NgModules. Since then, standalone has matured, stabilized, and become the recommended way to write Angular apps.",
	"BuildingBlocks - Components - Structure - @Component - Properties - standalone - Angular19": "And now, in v19, Angular’s flipping the switch: standalone is the default for components, directives, and pipes. No more typing standalone: true—it’s baked in. Now, when you generate a new component, you won’t need to wrap it in a module or even explicitly mark it as standalone.",
	"BuildingBlocks - Components - Structure - @Component - Properties - providers": "An array of dependency injection providers for services that the component requires",
	"BuildingBlocks - Components - Structure - @Component - Properties - Host - hosts": "A component can bind properties, attributes, and events to its host element. This behaves identically to bindings on elements inside the component's template, but instead defined with the host property in the @Component decorator:",
	"BuildingBlocks - Components - Structure - Inheritance - Class": "Angular components are TypeScript classes and participate in standard JavaScript inheritance semantics. A component can extend any base class.",
	"BuildingBlocks - Components - Structure - Inheritance - Component": "When a component extends another component or a directive, it inherits all the metadata defined in the base class's decorator and the base class's decorated members. This includes the selector, template, styles, host bindings, inputs, outputs, lifecycle methods, and any other settings.",
	"BuildingBlocks - Components - Structure - Dynamic": "Dynamic components are the components in which the component's location in the application is not defined at build time i.e. they are not used in any angular template. Instead, the component is instantiated and placed in the application at runtime.",
	"BuildingBlocks - Components - Lifecycle": "There are 8 life cycle hooks in Angular: constructor -> ngOnInit() -> ngOnChanges() -> ngDoCheck() -> ngAfterContentInit() -> ngAfterContentChecked() -> ngAfterViewInit() -> ngAfterViewChecked() -> ngOnDestroy()",
	"BuildingBlocks - Components - Lifecycle - Initilization - constructor": "The Constructor is a default method of the class that is executed when the class is instantiated and ensures proper initialisation of fields in the class and its subclasses. Angular, or better Dependency Injector (DI), analyses the constructor parameters and when it creates a new instance by calling new MyClass() it tries to find providers that match the types of the constructor parameters, resolves them and passes them to the constructor.",
	"BuildingBlocks - Components - Lifecycle - Initilization - ngOnInit": "Runs once after Angular has initialized all the component's inputs.",
	"BuildingBlocks - Components - Lifecycle - Initilization - ngAfterContentInit": "Runs once after the component's content has been initialized. Within this hook, we have access for the first time to the ElementRef of the ContentChild after the component’s creation;",
	"BuildingBlocks - Components - Lifecycle - Initilization - ngAfterViewInit": "Runs once after the component's view has been initialized. Within this hook, we have access for the first time to the ElementRef of the ViewChildren after the component’s creation;",
	"BuildingBlocks - Components - Lifecycle - Initilization - ngOnDestroy": "Runs once before the component is destroyed.",
	"BuildingBlocks - Components - Lifecycle - Rendering - afterRender": "Runs every time all components have been rendered to the DOM. Not on SSR.",
	"BuildingBlocks - Components - Lifecycle - Rendering - afterNextRender": "Runs once the next time that all components have been rendered to the DOM. Not on SSR.",
	"BuildingBlocks - Components - Lifecycle - ChangeDetection - ngDoCheck": "Runs every time this component is checked for changes.",
	"BuildingBlocks - Components - Lifecycle - ChangeDetection - ngAfterContentChecked": "Runs every time this component content has been checked for changes.",
	"BuildingBlocks - Components - Lifecycle - ChangeDetection - ngAfterViewChecked": "Runs every time the component's view has been checked for changes.",
	"BuildingBlocks - Components - Lifecycle - ChangeDetection - ngOnChanges": "Runs every time the component's inputs have changed.",
	"BuildingBlocks - AngularElements": "Angular elements are Angular components packaged as custom elements (also called Web Components).",
	"BuildingBlocks - AngularElements - create - createCustomElement": "The createCustomElement() function converts a component into a class that can be registered with the browser as a custom element.",
	"BuildingBlocks - AngularElements - create - createCustomElement - NgElementConstructor": "The conversion process implements the NgElementConstructor interface, and creates a constructor class that is configured to produce a self-bootstrapping instance of your component.",
	"BuildingBlocks - AngularElements - create - createCustomElement - @angular/elements": "exports a createCustomElement() API",
	"BuildingBlocks - AngularElements - use": "After you register your configured class with the browser's custom-element registry, use the new element just like a built-in HTML element in content that you add directly into the DOM: < my-popup message='Use Angular!'>< /my-popup >",
	"BuildingBlocks - AngularElements - bootstrap": "Custom elements bootstrap themselves - they start when they are added to the DOM, and are destroyed when removed from the DOM. Once a custom element is added to the DOM for any page, it looks and behaves like any other HTML element, and does not require any special knowledge of Angular terms or usage conventions.",
	"BuildingBlocks - AngularElements - CustomElementRegistry": "The browser maintains a CustomElementRegistry of defined custom elements, which maps an instantiable JavaScript class to an HTML tag.",
	"BuildingBlocks - AngularElements - CustomElementRegistry - register": "Use the browser's native customElements.define() function to register the configured constructor and its associated custom-element tag with the browser's CustomElementRegistry",
	"BuildingBlocks - Router - RouterModule": "a service that lets you define a navigation path among the different application states and view hierarchies in your app. Presents a component for anu URL. It is not part of the Angular core. It is in its own library package, @angular/router",
	"BuildingBlocks - Router - RouterModule - Config - Singleton": "configures the router as singleton via the RouterModule.forRoot method, and adds the result to the AppModule's imports array",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray": "export const routes: Routes = [ { path: 'first-component', component: FirstComponent }, ... ];",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - path": ".",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - children": "When some routes may only be accessible and viewed within other routes it may be appropriate to create them as child routes.",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - Guards": "Guards in Angular provide a robust way to control navigation in your application. { path: 'first-component', component: FirstComponent, canActivate: [yourGuardFunction] }",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - Guards - registering": "To use the guard, you must provide it in your Angular module. @NgModule({ providers: [AuthGuard], })",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - Guards - Types - CanActivate": "The CanActivate guard checks whether a route can be activated. This is useful for protecting routes that should not be accessible unless certain conditions are met, like user authentication.",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - Guards - Types - CanActivateChild": "Similar to CanActivate, but it works on child routes. Useful for feature modules with multiple child routes.",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - Guards - Types - CanDeactivate": "This guard works when you're navigating away from a component. It is often used to warn the user about unsaved changes.",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - Guards - Types - CanLoad": "CanLoad checks if a module should be lazy-loaded or not. This is important if you want to prevent unauthorized users from downloading parts of your application.",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - Guards - Types - Resolvers": "A Resolve guard pre-fetches data before navigation completes. The data can be used to populate route parameters.",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - Guards - Types - Resolvers - 1 -AddService": "Create a resolver service implementing Resolve interface and resolve() funtion. ",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - Guards - Types - Resolvers - 2 -Attach": "Attache to route { path='' component='' resolve='ResolveService' }",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - Guards - Types - Resolvers - 3 -ImportRoute": "In Component: constructor(private route: ActivatedRoute) {}",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - Guards - Types - Resolvers - 3 -Consume": "In Component: ngOnInit() { this.beerRouterList = this.route.snapshot.data['beers']; }",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - Guards - Types - Resolvers - Resolve": "A Resolver is a class that implements the Resolve interface of Angular Router.",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - Guards - Types - Resolvers - provided": "Resolver is a service that has to be [provided] in the root module.",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - redirect": "{ path: '',   redirectTo: '/first-component', pathMatch: 'full' }",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - redirectTo": ".",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - pathMatch": ".",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - component": ".",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - component - Wildcard": "{ path: '**', component: <component-name> }",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - component - 404": "{ path: '**', component: PageNotFoundComponent }",
	"BuildingBlocks - Router - RouterModule - Config - 2-<base href>": "<base href=''>",
	"BuildingBlocks - Router - RouterModule - Config - 3-Links": "RouterLink is an anchor tag directive that gives the router authority over those elements. Because the navigation routes are set. < li >< a routerLink='/first-component' routerLinkActive='active' ariaCurrentWhenActive='page' >First Component< /a >< /li >",
	"BuildingBlocks - Router - RouterModule - Config - 3-Links - params - routerLink": "The RouterLink is a directive on the anchor tags give the router control over those elements. < a routerLink='/todosList' >List of todos< /a >",
	"BuildingBlocks - Router - RouterModule - Config - 3-Links - params - routerLinkActive": "RouterLinkActive is a directive that toggles css classes for active RouterLink bindings based on the current RouterState. i.e, The Router will add CSS classes when this link is active and remove when the link is inactive. <a routerLink='/todosList' routerLinkActive='active'>List of todos</a>",
	"BuildingBlocks - Router - RouterModule - Config - 4-Events": "During each navigation, the Router emits navigation events through the Router.events property. NavigationStart, RouteConfigLoadStart, RouteConfigLoadEnd, RoutesRecognized, GuardsCheckStart, ChildActivationStart, ActivationStart, GuardsCheckEnd, ResolveStart, ResolveEnd, ActivationEnd, ChildActivationEnd, NavigationEnd, NavigationCancel, NavigationError, Scroll",
	"BuildingBlocks - Router - RouterModule - Config - 5-Audit - RouterState": "RouterState is a route tree. This tree's nodes are aware of the 'consumed' URL segments, retrieved arguments, and processed data.",
	"BuildingBlocks - Router - RouterModule - Config - 5-Audit - RouterState - access": "You can access the current RouterState from anywhere in the application using the Router service and the routerState property.",
	"BuildingBlocks - Router - RouterModule - Config - 5-Audit - RouterState - ActivatedRoute": "ActivatedRoute contains the information about a route associated with a component loaded in an outlet. It can also be used to traverse the router state tree. The ActivatedRoute will be injected as a router service to access the information.",
	"BuildingBlocks - Router - RouterModule - Config - 6-Rendering - router-outlet": "The routed views render in the < router-outlet >< /router-outlet >",

	"Data": "SECTION",
	"Data - Components - Interaction": "component communication scenarios in which two or more components share information.",
	"Data - Components - Interaction - ChildPullFromParent - @Input": "Pass data from parent to child with input binding. When you use a component, you commonly want to pass some data to it. A component specifies the data that it accepts by declaring inputs. input properties are similar to props.",
	"Data - Components - Interaction - ChildPullFromParent - @Input - resolution": "Angular records inputs statically at compile-time. Inputs cannot be added or removed at run-time.  <custom-slider [value]='50' /> @Input() value = 0;",
	"Data - Components - Interaction - ChildPullFromParent - @Input - Configured": "The @Input decorator accepts a config object that lets you change the way that input works.",
	"Data - Components - Interaction - ChildPullFromParent - @Input - Configured - required": "You can specify the required option to enforce that a given input must always have a value.",
	"Data - Components - Interaction - ChildPullFromParent - @Input - Configured - transform": "You can specify a transform function to change the value of an input when it's set by Angular. This transform function works identically to transform functions for signal-based inputs described above.",
	"Data - Components - Interaction - ChildPullFromParent - @Input - Configured - Alias": "You can specify the alias option to change the name of an input in templates. @Input({alias: 'sliderValue'}) value = 0;",
	"Data - Components - Interaction - ChildPullFromParent - @Input - Configured - Setter": "When using decorator-based inputs, a property implemented with a getter and setter can be an input: ",
	"Data - Components - Interaction - ChildPullFromParent - @Input - Configured - Getter": "",
	"Data - Components - Interaction - ChildPullFromParent - @Input - Component": "In addition to the @Input decorator, you can also specify a component's inputs with the inputs property in the @Component decorator. This can be useful when a component inherits a property from a base class: inputs: ['disabled'],",
	"Data - Components - Interaction - ChildPullFromParent - @Input - Component - Alias": "You can additionally specify an input alias in the inputs list by putting the alias after a colon in the string: inputs: ['disabled: sliderDisabled'],",
	"Data - Components - Interaction - ChildPullFromParent - @Input - steps - 1.AddField": "(1) In Parent: add childTitle:string = 'This text is passed to child'",
	"Data - Components - Interaction - ChildPullFromParent - @Input - steps - 2.AddInput": "(2) In Child: add @Input() title:string",
	"Data - Components - Interaction - ChildPullFromParent - @Input - steps - 3.Bind": "(3) In the template: do the binding: < child-selector [title]='childTitle' >< /child-selector >",
	"Data - Components - Interaction - ChildPullFromParent - @Input + Setter": "Intercept input property changes with a setter (1)",
	"Data - Components - Interaction - ChildPullFromParent - @Input + Setter - steps - 1.AddField": "(1) In Parent: add name attribute to parent",
	"Data - Components - Interaction - ChildPullFromParent - @Input + Setter - steps - 2.AddInput": "(2) In Child: add @Input() set name(name: string) { ... } to child",
	"Data - Components - Interaction - ChildPullFromParent - @Input + Setter - steps - 3.Bind": "(3) In the template: do the binding: < app-name-child [name]='name' >< /app-name-child >",
	"Data - Components - Interaction - ChildPullFromParent - @Input + ngOnChanges()": "Intercept input property changes with ngOnChanges(). Deprecated for InputSignals",
	"Data - Components - Interaction - ChildPullFromParent - @Input + ngOnChanges() - steps - 1.AddField": "(1) In Parent: Add major: number = 1",
	"Data - Components - Interaction - ChildPullFromParent - @Input + ngOnChanges() - steps - 2.AddInput": "(2) In Child: Add @Input() major: number",
	"Data - Components - Interaction - ChildPullFromParent - @Input + ngOnChanges() - steps - 3.Bind": "(3) In Child: do the binding: in ngOnChanges()",
	"Data - Components - Interaction - ChildPushtoParent - @Output": "Parent listens for child event with EventEmitted as @Output()",
	"Data - Components - Interaction - ChildPushtoParent - @Output - CustomEvents": "Angular components can define custom events by assigning a property to the output function. <expandable-panel (panelClosed)='savePanelState()' /> - panelClosed = output<void>();",
	"Data - Components - Interaction - ChildPushtoParent - @Output - CustomEvents - OutputEmitterRef": "The output function returns an OutputEmitterRef.",
	"Data - Components - Interaction - ChildPushtoParent - @Output - CustomEvents - propagation": "Angular custom events do not bubble up the DOM. When extending a component class, outputs are inherited by the child class.",
	"Data - Components - Interaction - ChildPushtoParent - @Output - CustomEvents - names": "Output names are case-sensitive. Always use camelCase output names. Avoid prefixing output names with 'on'.",
	"Data - Components - Interaction - ChildPushtoParent - @Output - CustomEvents - names - alias": "<custom-slider (valueChanged)='saveVolume()'/>  changed = output({alias: 'valueChanged'});",
	"Data - Components - Interaction - ChildPushtoParent - @Output - CustomEvents - emit": "You can emit an event by calling the emit method on the OutputEmitterRef: this.panelClosed.emit();",
	"Data - Components - Interaction - ChildPushtoParent - @Output - CustomEvents - emit - data": "You can pass event data when calling emit: this.valueChanged.emit(7);",
	"Data - Components - Interaction - ChildPushtoParent - @Output - CustomEvents - subscribe": "When creating a component dynamically, you can programmatically subscribe to output events from the component instance. The OutputRef type includes a subscribe method:",
	"Data - Components - Interaction - ChildPushtoParent - @Output - CustomEvents - subscribe - OutputRefSubscription": "The subscribe function returns an OutputRefSubscription with an unsubscribe method:",
	"Data - Components - Interaction - ChildPushtoParent - @Output - CustomEvents - unsubscribe": "eventSubscription.unsubscribe();",
	"Data - Components - Interaction - ChildPushtoParent - @Output - @Output": "While the Angular team recommends using the output function for new projects, the original decorator-based @Output API remains fully supported.",
	"Data - Components - Interaction - ChildPushtoParent - @Output - @Output - use": "You can alternatively define custom events by assigning a property to a new EventEmitter and adding the @Output decorator: @Output() panelClosed = new EventEmitter<void>();",
	"Data - Components - Interaction - ChildPushtoParent - @Output - @Output - name - Alias": "The @Output decorator accepts a parameter that lets you specify a different name for the event in a template: @Output('valueChanged') changed = new EventEmitter<number>(); - <custom-slider (valueChanged)='saveVolume()' />",
	"Data - Components - Interaction - ChildPushtoParent - @Output - @Output - EventEmitters": "They allow child components to communicate with parent components by emitting custom events.",
	"Data - Components - Interaction - ChildPushtoParent - @Output - Component": "In addition to the @Output decorator, you can also specify a component's outputs with the outputs property in the @Component decorator. This can be useful when a component inherits a property from a base class: outputs: ['valueChanged'],",
	"Data - Components - Interaction - ChildPushtoParent - @Output - Component - outputs": "outputs: ['valueChanged'],",
	"Data - Components - Interaction - ChildPushtoParent - @Output - Component - outputs - Alias": "You can additionally specify an output alias in the outputs list by putting the alias after a colon in the string: outputs: ['valueChanged: volumeChanged'],",
	"Data - Components - Interaction - ChildPushtoParent - @Output - steps - 1.AddOutput": "(1) In Child: add EventEmitted as @Output() voted = new EventEmitter< boolean >()",
	"Data - Components - Interaction - ChildPushtoParent - @Output - steps - 2.FireEvent": "(2) In Child: this.onChangeEvent.emit(true);",
	"Data - Components - Interaction - ChildPushtoParent - @Output - steps - 3.Bind": "(3) In Parent: binds an event handler on child tag <selectors-panel (onChangeEvent)='onChange($event)'></selectors-panel>.",
	"Data - Components - Interaction - ChildPushtoParent - @Output - steps - 4.ProcessEvent": "(4) In Parent: onChange(change: boolean) { ... }",
	"Data - Components - Interaction - ParentPullsFromChild - TemplateReferenceVariables": "Parent template interacts with child via template reference variable. It is limited because the parent-child wiring must be done entirely within the parent template.",
	"Data - Components - Interaction - ParentPullsFromChild - TemplateReferenceVariables - 1.Bind": "(1) In Parent template: Place a template reference variable in children tag: < countdown-timer #timer >< /countdown-timer >",
	"Data - Components - Interaction - ParentPullsFromChild - TemplateReferenceVariables - 2.UseVariable": "(2) In Parent: Use the reference to acces children's variables, e.g. timer.start()",
	"Data - Components - Interaction - ParentPullsFromChild - ViewChild - targets": "reference a child component or DOM element inside your component’s template.",
	"Data - Components - Interaction - ParentPullsFromChild - ViewChild - targets - ChildComponents": "ViewChild makes it possible to access a child component and call methods or access instance variables that are available to the child.",
	"Data - Components - Interaction - ParentPullsFromChild - ViewChild - targets - ChildComponents - from": "@ViewChild(PupComponent) pup!: PupComponent;",
	"Data - Components - Interaction - ParentPullsFromChild - ViewChild - targets - ChildComponents - to": "export class PupComponent implements OnInit { ... }",
	"Data - Components - Interaction - ParentPullsFromChild - ViewChild - targets - Directive": "",
	"Data - Components - Interaction - ParentPullsFromChild - ViewChild - targets - DOMElements": "ViewChild makes it possible to access native DOM elements that have a template reference variable.",
	"Data - Components - Interaction - ParentPullsFromChild - ViewChild - targets - DOMElements - from": "@ViewChild('someInput') someInput!: ElementRef;",
	"Data - Components - Interaction - ParentPullsFromChild - ViewChild - targets - DOMElements - to": "< input #someInput placeholder='Your favorite sea creature' >",
	"Data - Components - Interaction - ParentPullsFromChild - ViewChild - how": "returns the first element that matches a given directive, component, or template reference selector.",
	"Data - Components - Interaction - ParentPullsFromChild - ViewChild - how - ngAfterViewInit": "Is available in ngAfterViewInit lifecycle hook.",
	"Data - Components - Interaction - ParentPullsFromChild - ViewChild - how - Inject": "Parent calls a @ViewChild() (1) Inject child component into parent with @ViewChild(CountdownTimerComponent) private timerComponent: CountdownTimerComponent,",
	"Data - Components - Interaction - ParentPullsFromChild - ViewChild - how - required": "If some cases, especially with viewChild, you know with certainty that a specific child is always available. In other cases, you may want to strictly enforce that a specific child is present. For these cases, you can use a required query. header = viewChild.required(CustomCardHeader);",
	"Data - Components - Interaction - ParentPullsFromChild - ViewChild - use": "call methods or access instance variables that are available to the child.",
	"Data - Components - Interaction - ParentPullsFromChild - ViewChild - use - Querying": "View queries retrieve results from the elements in the component's view — the elements defined in the component's own template. You can query for a single result with the viewChild function..",
	"Data - Components - Interaction - ParentPullsFromChild - ViewChildren - targets": "Property decorator that configures a view query. Use to get the QueryList of elements or directives from the view DOM. ",
	"Data - Components - Interaction - ParentPullsFromChild - ViewChildren - how - ngAfterViewInit": "View queries are set before the ngAfterViewInit callback is called.",
	"Data - Components - Interaction - ParentPullsFromChild - ViewChildren - use": "Use to get the QueryList of elements or directives from the view DOM. Any time a child element is added, removed, or moved, the query list will be updated, and the changes observable of the query list will emit a new value.",
	"Data - Components - Interaction - ParentPullsFromChild - ContentChild - targets": "access content projected from a parent component using ng-content",
	"Data - Components - Interaction - ParentPullsFromChild - ContentChild - how": "Similarly like @ViewChild , @ContentChild is used to get the first instance of a child component or directive that matches the specified selector within the projected content.",
	"Data - Components - Interaction - ParentPullsFromChild - ContentChild - how - ngAfterContentInit": "Is available in ngAfterContentInit lifecycle hook.",
	"Data - Components - Interaction - ParentPullsFromChild - ContentChild - use - Querying": "Content queries retrieve results from the elements in the component's content— the elements nested inside the component in the template where it's used. You can query for a single result with the contentChild function.",
	"Data - Components - Interaction - ParentPullsFromChild - ContentChildren - targets": "access content projected from a parent component using ng-content.",
	"Data - Components - Interaction - ParentPullsFromChild - ContentChildren - how - ngAfterContentInit": "Is available in ngAfterContentInit lifecycle hook.",
	"Data - Components - Interaction - ParentPullsFromChild - ContentChildren - use": "Used to get a QueryList containing all instances of child components or directives that match the specified selector within the projected content.",
	"Data - Components - Interaction - AnyComponents - Services": "Parent and children communicate via a servicee",
	"Data - Components - Interaction - AnyComponents - Services - Subject": "",
	"Data - Components - Interaction - AnyComponents - Services - Subject - steps - 1.Declare": "(1) In Service: Declare service with Subject- private messageSubject = new Subject<string>();",
	"Data - Components - Interaction - AnyComponents - Services - Subject - steps - 2.Observable": "(2) In Service: Get Observable from Subject - messageObservable$ = this.messageSubject.asObservable(); best practice to expose only the Observable (using asObservable()) to prevent components from being able to emit values directly.",
	"Data - Components - Interaction - AnyComponents - Services - Subject - steps - 3.Method": "(3) In Service: Create method writes to the Observable - sendMessage(message: string) { this.messageSubject.next(message); }",
	"Data - Components - Interaction - AnyComponents - Services - Subject - steps - 4.Write": "(5) In Sender Component: use the method to write in the Observable - sendMessage(message: string) { this.dataService.sendMessage(message); }",
	"Data - Components - Interaction - AnyComponents - Services - Subject - steps - 5.Subscriber": "(4) In Receiver Component: Subscriber to Observable - this.subscription = this.dataService.messageObservable$ .subscribe(message => { ... }); ",
	"Data - Components - Interaction - AnyComponents - Services - Subject - type": "Consider using interfaces to type your Subjects",
	"Data - Components - Interaction - AnyComponents - Services - Subject - cleanup": "Implement proper cleanup using ngOnDestroy",
	"Data - Components - Interaction - AnyComponents - Services - Subject - errors": "Create a separate error Subject or use a state object that includes error information: interface State<T> { data: T | null; error: Error | null; }",
	"Data - Components - Interaction - AnyComponents - Services - Signals": "",
	"Data - Components - Interaction - AnyComponents - Services - Signals - InputSignal": "The input() function returns an InputSignal. You can read the value by calling the signal: value = input(0); ",
	"Data - Components - Interaction - AnyComponents - Services - Signals - InputSignal - Angular16": "A signal is a wrapper around a value that notifies interested consumers when that value changes. Signals can contain any value, from primitives to complex data structures.",
	"Data - Components - Interaction - AnyComponents - Services - Signals - InputSignal - Angular17": "Bye @Input( ) decorator; Welcome input( ) function. The introduction of Signals marks a significant change in how reactivity works in Angular. Signals allow primitive types to react to changes, making interactions easier and, most importantly, reducing the amount of code written.",	
	"Data - Components - Interaction - AnyComponents - Services - Signals - InputSignal - recommended": "While the Angular team recommends using the signal-based input function for new projects, the original decorator-based @Input API remains fully supported.",
	"Data - Components - Interaction - AnyComponents - Services - Signals - InputSignal - Standard - typed": "You can explicitly declare a type for the input by specifying a generic parameter to the function: value = input<number>();",
	"Data - Components - Interaction - AnyComponents - Services - Signals - InputSignal - Standard - compute": "Create a computed expression that reads the value input: label = computed(() => `The slider's value is ${this.value()}`); ",
	"Data - Components - Interaction - AnyComponents - Services - Signals - InputSignal - Standard - required": "You can declare that an input is required by calling input.required instead of input: value = input.required<number>();",
	"Data - Components - Interaction - AnyComponents - Services - Signals - InputSignal - Alias": "You can specify the alias option to change the name of an input in templates. value = input(0, {alias: 'sliderValue'}); <custom-slider [sliderValue]='50' />",
	"Data - Components - Interaction - AnyComponents - Services - Signals - InputSignal - Transform": "The input function accepts a config object as a second parameter that lets you change the way that input works.",
	"Data - Components - Interaction - AnyComponents - Services - Signals - InputSignal - Transform - Transform": "You can specify a transform function to change the value of an input when it's set by Angular. label = input('', {transform: trimString});",
	"Data - Components - Interaction - AnyComponents - Services - Signals - InputSignal - Transform - transform - pure": "Input transform functions should always be pure functions. Relying on state outside the transform function can lead to unpredictable behavior.",
	"Data - Components - Interaction - AnyComponents - Services - Signals - InputSignal - Transform - transform - type": "When you specify an input transform, the type of the transform function's parameter determines the types of values that can be set to the input in a template.",
	"Data - Components - Interaction - AnyComponents - Services - Signals - InputSignal - Transform - transform - type - booleanAttribute": "booleanAttribute imitates the behavior of standard HTML boolean attributes, where the presence of the attribute indicates a 'true' value. However, Angular's booleanAttribute treats the literal string 'false' as the boolean false.",
	"Data - Components - Interaction - AnyComponents - Services - Signals - InputSignal - Transform - transform - type - numberAttribute": "numberAttribute attempts to parse the given value to a number, producing NaN if parsing fails.",
	"Data - Components - Interaction - AnyComponents - Services - Signals - InputSignal - Model": "Model inputs are a special type of input that enable a component to propagate new values back to its parent component.",
	"Data - Components - Interaction - AnyComponents - Services - Signals - InputSignal - Model - 2WayBinding": "CustomSlider can write values into its value model input, which then propagates those values back to the volume property: template: '<custom-slider [(value)]='volume' />',",
	"Data - Components - Interaction - AnyComponents - Services - Signals - InputSignal - Model - Events": "When you declare a model input in a component or directive, Angular automatically creates a corresponding output for that model. The output's name is the model input's name suffixed with 'Change'.",
	"Data - Components - Interaction - AnyComponents - Services - Signals - InputSignal - Model - required": "You can mark a model input as required or provide an alias in the same way as a standard input.",
	"Data - Components - Interaction - AnyComponents - Services - Signals - InputSignal - Model - Alias": "You can mark a model input as required or provide an alias in the same way as a standard input.",
	"Data - Components - Interaction - AnyComponents - Services - Signals - InputSignal - Model - Configured": "Model inputs do not support input transforms.",
	"Data - Components - Interaction - AnyComponents - Services - Signals - steps - 1.Create": "const count = signal(0);",
	"Data - Components - Interaction - AnyComponents - Services - Signals - steps - 2.Read": "console.log('The count is: ' + count());",
	"Data - Components - Interaction - AnyComponents - Services - Signals - steps - 3.Write - set": "count.set(3);",
	"Data - Components - Interaction - AnyComponents - Services - Signals - steps - 4.Write - update": "count.update(value => value + 1);",
	"Data - Components - Interaction - AnyComponents - Services - Signals - Type - viewChild": "The viewChild signal query does the same thing as the @ViewChild decorator.",
	"Data - Components - Interaction - AnyComponents - Services - Signals - Type - viewChildren": "viewChildren() is a signal-based query used to retrieve multiple elements from the component's template, instead of just a single one like it's the case withviewChild().",
	"Data - Components - Interaction - AnyComponents - Services - Signals - Type - contentChild": "You can use contentChild() to query components, plain HTML elements, or directives in all the content projected via ng-content.",
	"Data - Components - Interaction - AnyComponents - Services - Signals - Type - contentChildren": "contentChildren() is the content projection equivalent of viewChildren(). It allows us to query multiple elements projected into the component via ng-content, instead of just one like it's the case of viewChildren().",
	"Data - State": ".",
	"Data - State - Management - Components": "Component state is the simplest form of state management in Angular. It involves storing data within individual components. Each component has its own state, and data is passed down through the component hierarchy using input and output bindings.",
	"Data - State - Management - Components - use": "This approach is suitable for small to moderately complex applications where data doesn't need to be shared extensively.",
	"Data - State - Management - Services": "Services act as centralized stores for application data.",
	"Data - State - Management - Services - use": "Ideal for medium to large-scale applications with asynchronous data and moderate complexity.",
	"Data - State - Management - Services - RxJS": ".",
	"Data - State - Management - Services - RxJS - Observables": "The most basic approach to state management in Angular uses services with observables.",
	"Data - State - Management - Services - RxJS - Observables - syncasync": "an Observable, can be both synchronous and asynchronous.",
	"Data - State - Management - Services - RxJS - Observables - vs Promise": "The first difference is that an Observable is lazy whereas a Promise is eager.",
	"Data - State - Management - Services - RxJS - Subject": ".",
	"Data - State - Management - Services - RxJS - BehaviouralSubject": ".",
	"Data - State - Management - Services - Signals - Angular16": "A signal is a wrapper around a value that notifies interested consumers when that value changes. Signals can contain any value, from primitives to complex data structures.",
	"Data - State - Management - Services - ComputedSignals": "Computed signal are read-only signals that derive their value from other signals. You define computed signals using the computed function and specifying a derivation:",
	"Data - State - Management - Services - ComputedSignals - eval": "",
	"Data - State - Management - Services - ComputedSignals - memo": "",
	"Data - State - Management - Services - ComputedSignals - write": "You cannot directly assign values to a computed signal. That is, doubleCount.set(3); produces a compilation error, ",
	"Data - State - Management - Libraries - NgRx": "NgRx provides a robust state management solution based on Redux principles. It introduces a unidirectional data flow and a centralized store for managing the application state.",
	"Data - State - Management - Libraries - NgRx - use": "NgRx Store is most suitable for large and complex applications where state management becomes critical.",
	"Data - State - Management - Libraries - Akita": "based on the Redux pattern.",
	"Data - State - Management - Libraries - NGXS": "state management library inspired by Redux and CQRS.",
	"Data - State - Management - Libraries - RxAngularState": "A library for managing state using RxJS.",
	"Data - Inputs - NgForms": ".",
	"Data - Inputs - NgForms - Interface - DefaultValueAccessor": "The default ControlValueAccessor for writing a value and listening to changes on input elements. The accessor is used by the FormControlDirective, FormControlName, and NgModel directives.",
	"Data - Inputs - NgForms - Interface - ControlValueAccessor": "Defines an interface that acts as a bridge between the Angular forms API and a native element in the DOM.",
	"Data - Inputs - NgForms - Directives - NgModel": "Use the NgModel directive to display a data property and update that property when the user makes changes.",
	"Data - Inputs - NgForms - Directives - NgModel - use": "Add an [(ngModel)] binding on an HTML < form > element and set it equal to the property < input [(ngModel)]='currentItem.name' id='example-ngModel' >",
	"Data - Inputs - NgForms - Directives - NgModel - ControlValueAccessor": "The NgModel directive works for an element supported by a ControlValueAccessor. Angular provides value accessors for all of the basic HTML form elements.",
	"Data - Inputs - NgForms - Directives - NgModel - DefaultValueAccessor": "To apply [(ngModel)] to a non-form built-in element or a third-party custom component, you have to write a value accessor. For more information, see the API documentation on DefaultValueAccessor.",
	"Data - Inputs - NgForms - Types - TemplateDriven": "simpler, uses directives like ngModel",
	"Data - Inputs - NgForms - Types - TemplateDriven - Features - size": "simpler",
	"Data - Inputs - NgForms - Types - TemplateDriven - Features - async": ".",
	"Data - Inputs - NgForms - Types - TemplateDriven - how - View - Create": "<form #userForm='ngForm' (ngSubmit)='onSubmit(userForm)'>",
	"Data - Inputs - NgForms - Types - TemplateDriven - how - View - Create - ngForm": "Angular automatically creates and attaches an NgForm directive to the < form > tag. The ngForm directive supplements the form element with additional features. ngForm Directive: It gives access to the methods and properties of an Angular form instance by creating one.",
	"Data - Inputs - NgForms - Types - TemplateDriven - how - View - Create - ngForm - trackBy": "When you add track by you basically tell angular to generate a single DOM element per data object in the given collection.",
	"Data - Inputs - NgForms - Types - TemplateDriven - how - View - Create - ngModel": "<input type='text' name='username' [(ngModel)]='user.username' required>",
	"Data - Inputs - NgForms - Types - TemplateDriven - how - View - Create - ngModel - binding": "Using ngModel to create declarative syntax makes form attributes having two-way data binding. < input name='first' ngModel required #first='ngModel' >",
	"Data - Inputs - NgForms - Types - TemplateDriven - how - View - Create - submit - ngSubmit": "",
	"Data - Inputs - NgForms - Types - TemplateDriven - how - Class": "export class TemplateFormComponent { user = { username: '', email: '' }; ... }",
	"Data - Inputs - NgForms - Types - TemplateDriven - how - Class - FormsModule": "To use template driven form, import FormsModule",
	"Data - Inputs - NgForms - Types - TemplateDriven - how - Class - Validation": "Template-driven forms rely on directives in the template to create and manipulate the underlying object model.",
	"Data - Inputs - NgForms - Types - TemplateDriven - how - Class - Validation - types - Sync": "immediately return either a set of validation errors or null",
	"Data - Inputs - NgForms - Types - TemplateDriven - how - Class - Validation - types - Async": "make a call and return a Promise or Observable that later emits a set of validation errors or null",
	"Data - Inputs - NgForms - Types - TemplateDriven - how - Class - Validation - Built-in": "min, max, required, requiredTrue, email, minLength, maxLength, pattern, nullVaidator, compose, composeAsync",
	"Data - Inputs - NgForms - Types - TemplateDriven - how - Class - Validation - Custom": "functions that take a control instance and immediately return either a set of validation errors or null",
	"Data - Inputs - NgForms - Types - TemplateDriven - how - Class - Validation - custom": "Create a function receiving AbstractControl as argument. Adding to template-driven forms or to Reactive Forms",
	"Data - Inputs - NgForms - Types - Reactive": "more powerful, uses FormControl and FormGroup.",
	"Data - Inputs - NgForms - Types - Reactive - Features - module": "ReactiveFormsModule",
	"Data - Inputs - NgForms - Types - Reactive - Features - size": "more powerful forms",
	"Data - Inputs - NgForms - Types - Reactive - Features - sync": ".",
	"Data - Inputs - NgForms - Types - Reactive - Features - state": "Each change to the form state returns a new state, which maintains the integrity of the model between changes.",
	"Data - Inputs - NgForms - Types - Reactive - Features - observable": "Reactive forms are built around observable streams.",
	"Data - Inputs - NgForms - Types - Reactive - how - View - Create - form": "< form [formGroup]='userForm' (ngSubmit)='onSubmit() >",
	"Data - Inputs - NgForms - Types - Reactive - how - View - Create - formControlName": "< input type='text' formControlName='username' >",
	"Data - Inputs - NgForms - Types - Reactive - how - View - Create - submit": "< button type='submit' [disabled]='userForm.invalid' >Submit< /button >",
	"Data - Inputs - NgForms - Types - Reactive - how - Class": "userForm = new FormGroup({ username: new FormControl('', [Validators.required]), email: new FormControl('', [Validators.required, Validators.email]) });",
	"Data - Inputs - NgForms - Types - Reactive - how - Class - ReactiveFormsModule": "To use reactive form controls, import ReactiveFormsModule from the @angular/forms package and add it to your NgModule's imports array.",
	"Data - Inputs - NgForms - Types - Reactive - how - Class - FormBuilder": "Creating multiple form control instances manually can become very repetitive when dealing with multiple forms. The FormBuilder service provides convenience methods to handle generating controls. Underneath, the FormBuilder is creating and returning the instances in the same manner, but with much less work.",
	"Data - Inputs - NgForms - Types - Reactive - how - Class - FormBuilder - AbstractControl": "AbstractControl is the parent class of FormArray, FormGroup, and FormControl.",
	"Data - Inputs - NgForms - Types - Reactive - how - Class - FormBuilder - FormControl": "It communicates with an HTML Form element like input or select tag, this API handles the individual form value and validation state.",
	"Data - Inputs - NgForms - Types - Reactive - how - Class - FormBuilder - FormGroup": "FormGroup is a top-level API that maintains the values, properties and validation state of a group of AbstractControl instances in Angular.",
	"Data - Inputs - NgForms - Types - Reactive - how - Class - FormBuilder - FormGroup - formGroup": "Associate the FormGroup model and view <form [formGroup]='profileForm'> ... </>",
	"Data - Inputs - NgForms - Types - Reactive - how - Class - FormBuilder - FormArray": "A FormArray is an alternative to a FormGroup for managing any number of unnamed controls. As with FormGroup instances, you can dynamically insert and remove controls from a FormArray, and the FormArray instance's value and validation status is calculated from its child controls. However, you don't need to define a key for each control by name.",
	"Data - Inputs - NgForms - Types - Reactive - how - Class - Validation": "Add validator functions directly to the form control model (FormControl) in the component class. Angular then calls these functions whenever the value of the control changes.",
	"Data - Inputs - NgForms - Types - Reactive - how - Class - Validation - AbstractControl - markAsPristine": "The control's value has not changed.",
	"Data - Inputs - NgForms - Types - Reactive - how - Class - Validation - AbstractControl - markAsDirty": "The control's value has changed.",
	"Data - Inputs - NgForms - Types - Reactive - how - Class - Validation - AbstractControl - markAsUntouched": "The control has not been visited.",
	"Data - Inputs - NgForms - Types - Reactive - how - Class - Validation - AbstractControl - markAsTouched": "The control has been visited.",
	"Data - Inputs - NgForms - Types - Reactive - how - Class - Validation - AbstractControl - markAllAsTouched - Angular8": "Marks the control and all its descendant controls as touched.",
	"Data - Inputs - NgForms - Types - Reactive - how - Class - Validation - AbstractControl - markAsPending": "A control is pending while the control performs async validation.",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient": "The HttpClientAPI rests on the XMLHttpRequest interface exposed by the browsers.",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient - declare - @angular/http": "@angular/http (deprecated Angular 8.0)",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient - declare - @angular/common/http": "offers a simplified client HTTP API (HttpClient) for Angular applications that rests on 2 options exposed by browsers: HttpXhrBackend that uses XmlHttpRequest API and JsonpClientBackend that uses JSONP technique.",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient - inject": " providers: [ provideHttpClient(), ]",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient - inject - withFetch": "",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient - inject - withInterceptors": "",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient - inject - withRequestsMadeViaParent": "",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient - inject - withJsonpSupport": "",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient - inject - withXsrfConfiguration": "",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient - inject - withNoXsrfProtection": "",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient - requests": "HttpClient has methods corresponding to the different HTTP verbs used to make requests, both to load data and to apply mutations on the server.",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient - requests - fetch": "Each method returns an RxJS Observable which, when subscribed, sends the request and then emits the results when the server responds.",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient - requests - fetch - GET": "return this.http.get< Hero >(this.heroesUrl, hero, httpOptions)",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient - requests - fetch - URLParams": "const httpOptions = { params: new HttpParams().set('name', term) },",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient - requests - fetch - Observable": "Observables created by HttpClient may be subscribed any number of times and will make a new backend request for each subscription.",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient - requests - fetch - format": ".",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient - requests - fetch - format - json": "JSON data of the given generic type",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient - requests - fetch - format - text": "string data.",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient - requests - fetch - format - arraybuffer": "ArrayBuffer containing the raw response bytes",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient - requests - fetch - format - blob": "Blob instance.",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient - requests - update - POST": "return this.http.post< Hero >(this.heroesUrl, hero, httpOptions)",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient - requests - headers - Headers": "httpOptions.headers = httpOptions.headers.set('Authorization', 'my-new-auth-token'),",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient - Interceptor": "With interception, you declare interceptors that inspect and transform HTTP requests from your application to the server.",
	"Data - Inputs - DataFetching - HttpClientModule - HttpClient - Security - XSRFProtection": "By default, an interceptor sends this cookie on all mutating requests (POST, etc.) to relative URLs but not on GET/HEAD requests or on requests with an absolute URL.",
	"Data - Inputs - DataFetching - JSON": "Read JSON Data from a Local File.",
	"Data - Inputs - DataFetching - JSON - import": "import * as jsonData from '../assets/data.json';",
	"Data - Inputs - DataFetching - JSON - fetch": "fetch('./assets/data.json').then(res => res.json());",
	"Data - Inputs - DataFetching - JSON - HttpClient": "this.httpClient.get(this.URL).subscribe(console.log);",

	"View": "SECTION",
	"View - Templates": "The template is simply an HTML view where binding controls can display data to the properties of the Angular component as side effects. Defines the DOM. < button (click)='deleteHero()' >Delete hero< /button >",
	"View - Templates - Location - *.component.ts": "Templates are usually found within either the template property of a *.component.ts file",
	"View - Templates - Location - *.component.html": "Templates can also be found on a *.component.html file.",
	"View - Templates - Render - Layouts - ng-content": "directive used for content projection which allows you to insert content from a parent component into a child component at a designated spot.",
	"View - Templates - Render - Layouts - ng-content - Features - BuildTime": "Angular's compiler processes all < ng-content > elements at build-time.",
	"View - Templates - Render - Layouts - ng-content - Features - Update": " You cannot insert, remove, or modify < ng-content > at run time. You cannot add directives, styles, or arbitrary attributes to < ng-content >.",
	"View - Templates - Render - Layouts - ng-content - Specify - 1.Default": "If no select attribute is specified, < ng-content > projects all content that doesn't match other slots.",
	"View - Templates - Render - Layouts - ng-content - Specify - 2.select": "Angular supports projecting multiple different elements into different < ng-content > placeholders based on CSS selector. <ng-content select='card-title'></ng-content>",
	"View - Templates - Render - Layouts - ng-content - Specify - 3.ngProjectAs": "Angular supports a special attribute, ngProjectAs, that allows you to specify a CSS selector on any element. Whenever an element with ngProjectAs is checked against an < ng-content > placeholder, Angular compares against the ngProjectAs value instead of the element's identity:",
	"View - Templates - Render - Layouts - ng-content - Specify - 4.Fallback": "Angular can show fallback content for a component's < ng-content > placeholder if that component doesn't have any matching child content. You can specify fallback content by adding child content to the <ng-content> element itself.",
	"View - Templates - Render - Layouts - ng-template": "directive that defines a template fragment.",
	"View - Templates - Render - Layouts - ng-template - Features - Placeholder": "never displayed directly.",
	"View - Templates - Render - Layouts - ng-template - Features - TemplateRef": "<ng-template> elements are represented as instances of the TemplateRef class.",
	"View - Templates - Render - Layouts - ng-template - Usages - *ngIf": "Combine with *ngIf .. e.g. < div *ngIf='isLoggedIn; else guestTemplate' > ... < /div > and <ng-template #guestTemplate > < p >hi.< /p > < /ng-template >",
	"View - Templates - Render - Layouts - ng-template - Usages - *ngFor": "Combine with *ngFor .. e.g. < ng-template ngFor let-item [ngForOf]='items' > < div >{{ item }}< /div > < /ng-template >",
	"View - Templates - Render - Layouts - ng-template - Usages - reusable": "with TemplateReferenceVariables < ng-template #modalContent > < h2 >Modal Title< /h2 > < p >This is the modal body.< /p > < /ng-template >",
	"View - Templates - Render - Layouts - ng-template - Usages - dynamic": "Dynamic Content: Useful for creating dynamic views in components.",
	"View - Templates - Render - Layouts - ng-container": "directive to group multiple elements together or marks a location in a template without rendering a real element in the DOM.",
	"View - Templates - Render - Layouts - ng-container - ngTemplateOutlet": "take the template itself and instantiate it anywhere on the page, using the ngTemplateOutlet directive",
	"View - Styles - SASS": "Once SASS is included in your Angular project, you can write your styles using SASS syntax, which provides additional features like variables, mixins, and nested selectors.",
	"View - Styles - ViewEncapsulation": "In Angular, a component's styles can be encapsulated within the component's host element so that they don't affect the rest of the application.",
	"View - Styles - ViewEncapsulation - encapsulation": "The Component decorator provides the encapsulation option which can be used to control how the encapsulation is applied on a per component basis.",
	"View - Styles - ViewEncapsulation - encapsulation - ViewEncapsulation.ShadowDom": "scopes styles within a component by using the web standard Shadow DOM API",
	"View - Styles - ViewEncapsulation - encapsulation - ViewEncapsulation.Emulated": "component's styles only apply to elements defined in that component's template.",
	"View - ChangeDetection": "Change Detection in Angular is a mechanism that synchronizes the DOM with your application's data. It's responsible for detecting and propagating changes from your application's data model to the user interface.",
	"View - ChangeDetection - Process - Bindings": "Every Component Instance contains the list of its bindings: greeting, author.firstName, author.lastName, timestamp.",
	"View - ChangeDetection - Process - Triggers": "Angular runs its change detection mechanism periodically so that changes to the data model are reflected in an application’s view.",
	"View - ChangeDetection - Process - Triggers - zone.js": "zone.js detects async operations and triggers change detection processes. When a change occurs, Angular performs a change detection process, which involves checking each component's properties for changes and updating the DOM if necessary.",
	"View - ChangeDetection - Process - Triggers - zone.js - asyncevent": "for example, a user interaction or an XMLHttpRequest completion",
	"View - ChangeDetection - Process - Triggers - zone.js - Impl": "Angular at startup time will patch several low-level browser APIs, such as for example addEventListener, which is the browser function used to register all browser events, including click handlers. Angular will replace addEventListener with a new version. This low-level patching of browser APIs is done by a library shipped with Angular called Zone.js.",
	"View - ChangeDetection - Process - Triggers - zone.js - Impl - events": "The following frequently used browser mechanisms are patched to support change detection: all browser events (click, mouseover, keyup, etc.) setTimeout() and setInterval() Ajax HTTP requests",
	"View - ChangeDetection - Process - Triggers - Modes - changeDetection": "in the component's decorator specify the changeDetection property.",
	"View - ChangeDetection - Process - Triggers - Modes - changeDetection - Default": "Every change detection cycle. Configure: changeDetection: ChangeDetectionStrategy.Default",
	"View - ChangeDetection - Process - Triggers - Modes - changeDetection - OnPush": "When inputs or properties change. Configure: changeDetection: ChangeDetectionStrategy.OnPush",
	"View - ChangeDetection - Process - Checks": "On every change detection cycle, Angular synchronously:",
	"View - ChangeDetection - Process - Checks - Scope - Root": "Change Detection Mechanism-moves only ahead and never backward, beginning with the root component and ending with the last component.",
	"View - ChangeDetection - Process - Checks - Scope - Item": "Each Angular component has an associated change detector, which is created at application startup time.",
	"View - ChangeDetection - Process - Checks - Scope - Tree": "Angular uses a tree of change detectors to track changes in component properties and update the DOM accordingly.",
	"View - ChangeDetection - Process - Checks - Expressions": "Evaluates all template expressions in all components, unless specified otherwise, based on that each component's detection strategy",
	"View - ChangeDetection - Process - Checks - Values": "But how does Angular know that the value is indeed changed? This is done by just the JavaScript “equals” operator `===` with minor adjustments.",
	"View - ChangeDetection - Process - Checks - Hooks": "Executes the ngDoCheck, ngAfterContentChecked, ngAfterViewChecked, and ngOnChanges lifecycle hooks.",
	"View - ChangeDetection - Process - Tuning": "To configure in a component: constructor(private ref: ChangeDetectorRef) { ref.detach(); ... } which effectively turns off change detection.",
	"View - ChangeDetection - Process - Tuning - ChangeDetectorRef": "Base class that provides change detection functionality.",
	"View - ChangeDetection - Process - Tuning - ChangeDetectorRef - markForCheck": "marks the view as changed so that it can be checked again.",
	"View - ChangeDetection - Process - Tuning - ChangeDetectorRef - detach": "Detaches this view from the change-detection tree.",
	"View - ChangeDetection - Process - Tuning - ChangeDetectorRef - reattach": "Re-attaches the previously detached view to the change detection tree. Views are attached to the tree by default.",
	"View - ChangeDetection - Process - Tuning - ChangeDetectorRef - detectChanges": "Checks this view and its children.",
	"View - ChangeDetection - Process - Tuning - ChangeDetectorRef - checkNoChanges": "Checks the change detector and its children, and throws if any changes are detected.",
	"View - ChangeDetection - Process - Tuning - NgZone": "NgZone is Angular’s wrapper around Zone.js that allows fine-grained control over how and when change detection runs by preventing unnecessary change detection.",
	"View - ChangeDetection - Process - Tuning - NgZone - Optional": "Angular’s change detection mechanism does not depend on NgZone and can nicely work without it being used at all.",
	"View - ChangeDetection - Process - Tuning - NgZone - default": "By default, Angular runs in a zone called the 'Angular zone.'",
	"View - ChangeDetection - Process - Tuning - NgZone - Zone": "A Zone is an execution context that persists across async tasks. You can think of it as thread-local storage for JavaScript VMs. In Angular, `NgZone` is a service provided by the Angular framework that helps manage and control the execution of asynchronous tasks and change detection.",
	"View - ChangeDetection - Process - Tuning - NgZone - Responsible": "It is responsible for triggering change detection and updating the view when changes occur.",
	"View - ChangeDetection - Process - Tuning - NgZone - NoopZone": "NoopZone helps Angular figure out and know when to trigger the change detection. However, if Angular needs to be used without a zone, the NoopZone too needs to be configured.",
	"View - ChangeDetection - Process - Tuning - NgZone - run": "The `run()` method executes the provided function inside the Angular zone. This ensures that any changes triggered by the function will be detected and updated in the view.",
	"View - ChangeDetection - Process - Tuning - NgZone - runOutsideAngular": "you can instruct Angular to avoid calling change detection for tasks scheduled by a given piece of code using NgZone. this.ngZone.runOutsideAngular(() => setInterval(pollForUpdates), 500);",
	"View - ChangeDetection - Process - Rerendering": "If any of the bindings’ value does not match its previous value (change detected)— the view is re-rendered and all the bindings are re-calculated.",
	"View - ChangeDetection - Process - Rerendering - Programmatically - Components": "In addition to using a component directly in a template, you can also dynamically render components. There are two main ways to dynamically render a component:.",
	"View - ChangeDetection - Process - Rerendering - Programmatically - Components - NgComponentOutlet": "NgComponentOutlet is a structural directive that dynamically renders a given component in a template.",
	"View - ChangeDetection - Process - Rerendering - Programmatically - Components - ViewContainerRef": "A view container is a node in Angular's component tree that can contain content. Any component or directive can inject ViewContainerRef to get a reference to a view container corresponding to that component or directive's location in the DOM.",
	"View - ChangeDetection - Process - Rerendering - Programmatically - Components - ViewContainerRef - createComponentmethod": "You can use the createComponentmethod on ViewContainerRef to dynamically create and render a component. When you create a new component with a ViewContainerRef, Angular appends it into the DOM as the next sibling of the component or directive that injected the ViewContainerRef.",
	"View - ChangeDetection - Process - Performance": "A single slow computation within a template or a lifecycle hook can slow down the entire change detection process because Angular runs the computations sequentially.",
	"View - Internationalization": "For APP. Internationalization is the process of designing and preparing your APP to be usable in different languages.",
	"View - Internationalization - Localization": "For TEXT. Localization is the process of translating the TEXT of your internationalized app into specific languages for particular locales.",
	"View - Internationalization - Localization - translate": "(1) mark the text with a custom attribute, named i18n=\"<meaning>|<description>@@customId\" <br/><br/> (2) Add script to packages.json 'scripts': { 'i18n:extract': 'ng xi18n --output-path src/locales' } <br/><br/> (3) run npm run i18n:extract  <br/><br/> (4) open up scr/locales/messages.xlf. For each html element marked with the i18n directive, a trans-unit will be created.  <br/><br/> (5) create a new xlf file src/locales/messages.<locale>.xlf for each locale <br/><br/> (6) Add a script that builds the application for each locale we want to support on angular.json <br/><br/> (7) npm run start npm run start:fr -- --port 4201 <br/>  npm run start:gr -- --port 4202",

	"Logic": "SECTION",
	"Logic - Templates - Expression": "Angular executes the expression and assigns it to a property of a binding target; the target might be an HTML element, a component, or a directive., The Angular expressions are evaluated against a local scope object.",
	"Logic - Templates - Expression - property": "In the property binding, a template expression appears in quotes to the right of the = symbol as in [property]='expression'.",
	"Logic - Templates - Expression - interpolation": "In interpolation syntax, the template expression is surrounded by double curly braces. For example, in the below interpolation, the template expression is {{username}}.",
	"Logic - Templates - Statements": "A template statement responds to an event raised by a binding target such as an element, component, or directive. The template statements appear in quotes to the right of the = symbol like (event)='statement'.",
	"Logic - Templates - Variables": "Angular has two types of variable declarations in templates: local template variables and template reference variables.",
	"Logic - Templates - Variables - Local": "Angular's @let syntax allows you to define a local variable and re-use it across a template, similar to the JavaScript let syntax.",
	"Logic - Templates - Variables - Local - reassigned": "A key difference between @let and JavaScript's let is that @let cannot be reassigned after declaration.",
	"Logic - Templates - Variables - Local - scope": "@let declarations are scoped to the current view and its descendants. Angular creates a new view at component boundaries and wherever a template might contain dynamic content, such as control flow blocks, @defer blocks, or structural directives.",
	"Logic - Templates - Variables - References": "< input #phone placeholder='phone number' > A template reference variable is often a reference to a DOM element within a template. It can also be a reference to an Angular component or directive or a web component. You can use template reference variables to read information from one part of the template in another part of the same template.",
	"Logic - Templates - Variables - References - toDOM": "a DOM element within a template (including custom elements)",
	"Logic - Templates - Variables - References - toComponent": "< input #taskInput placeholder='Enter task name' >",
	"Logic - Templates - Variables - References - toDirective": "< section dropZone #firstZone='dropZone' > ... < /section >",
	"Logic - Templates - Variables - References - toTemplateRef": ".",
	"Logic - Templates - Binding": "Angular supports 6 binding types between Component and DOM: Event binding (click), Property binding [hero], Attribute Binding [attr.colspan], interpolations {{hero.name}} and 2 way [(ngModel)]",
	"Logic - Templates - Binding - Output - 1-PropertyBinding": "Sets a property. ng-bind-src (canonical form) vs [src]",
	"Logic - Templates - Binding - Output - 2-AttributeBinding": "< tr >< td [attr.colspan]='1 + 1' >One-Two< /td >< /tr >",
	"Logic - Templates - Binding - Output - 2-AttributeBinding - Class": "< div [class.special]='isSpecial' >Special< /div >",
	"Logic - Templates - Binding - Output - 2-AttributeBinding - Style": "< button [style.color]=\"isSpecial ? 'red' : 'green'\" >",
	"Logic - Templates - Binding - Output - 3-Interpolation": "Interpolation refers to embedding expressions into marked up text.",
	"Logic - Templates - Binding - Output - 3-Interpolation - {{ ... }}": "By default, interpolation uses the double curly braces {{ and }} as delimiters. <h3>Current customer: {{ currentCustomer }}</h3>",
	"Logic - Templates - Binding - Output - 3-Interpolation - ?.": "safe navigation operator ( ?. ). The current hero's name is {{currentHero?.name}}",
	"Logic - Templates - Binding - Output - 3-Interpolation - !": "non-null assertion operator. The hero's name is {{hero!.name}}",
	"Logic - Templates - Binding - Output - 3-Interpolation - $any": "you can use the $any cast function to cast the expression to the any type: {{$any(hero).marker}}",
	"Logic - Templates - Binding - Output - 4-ReferenceBinding": "ref-text (canonical form) vs #text",
	"Logic - Templates - Binding - Input - 5-EventBinding": "on-click (canonical form) vs (click)",
	"Logic - Templates - Binding - Input - 5-EventBinding - Event handler": "$event",
	"Logic - Templates - Binding - Both - 6-2WayBinding": "ng-model-src (canonical form) instead [(src)]",
	"Logic - Templates - Binding - Both - 6-2WayBinding - [(ngModel)]=": "< input [value]=\"currentHero.name\" input)=\"currentHero.name=$event.target.value\" >  === < input [ngModel]=\"currentHero.name\" (ngModelChange)=\"currentHero.name=$event\" >",
	"Logic - Templates - Pipes": "Pipes are simple functions to use in template expressions to accept an input value and return a transformed value.",
	"Logic - Templates - Pipes - AngularJS": "Pipe was formerly known as filters in AngularJS 1.x.",
	"Logic - Templates - Pipes - Types": "When writing a custom pipe in Angular you can specify whether you define a pure or an impure pipe: pure: false/true",
	"Logic - Templates - Pipes - Types - Pure": "Pure function as a function that doesn’t have an internal state. A pure change is either a change to a primitive input value (String, Number, Boolean, Symbol) or a changed object reference (Date, Array, Function, Object).",
	"Logic - Templates - Pipes - Types - Impure": "Impure function as a function that has an internal state. An impure pipe is called often, as often as every keystroke or mouse-move.",
	"Logic - Templates - Pipes - Types - Impure - asyncPipe": "The AsyncPipe subscribes to an Observable or Promise and returns the latest value it has emitted. {{ observableOrPromise | async }}",
	"Logic - Templates - Pipes - Types - Standalone": "Just like components, we can also create standalone pipes. standalone: true,",
	"Logic - Templates - Pipes - Lifecycle - Creating - Built-in": "Angular comes with a stock of pipes such as DatePipe, UpperCasePipe, LowerCasePipe, CurrencyPipe, and PercentPipe. They are all available for use in any template.",
	"Logic - Templates - Pipes - Lifecycle - Creating - Custom": "create a class with @Pipe decorator and implement the method transform() of the PipeTransform class.",
	"Logic - Templates - Pipes - Lifecycle - Creating - Custom - PipeTransform": "As the name suggests, the interface receives an input value and transforms it into the desired format with a transform() method. It is typically used to implement custom pipes.",
	"Logic - Templates - Pipes - Lifecycle - Creating - Chaining - Chain": "< p >Average is {{ average | uppercase | number}}< /p > ",
	"Logic - Templates - Pipes - Lifecycle - Creating - Parameterized": "A pipe can accept any number of optional parameters to fine-tune its output. The parameterized pipe can be created by declaring the pipe name with a colon ( : ) and then the parameter value. If the pipe accepts multiple parameters, separate the values with colons.",
	"Logic - Templates - Pipes - Lifecycle - Invoking - Arguments": "< p >Price is {{ price | currency : “USD$” : 0.00 }}< /p > ",
	"Logic - Templates - Pipes - Pipes - BuiltIn - JsonPipe": "JsonPipe comes directly from Angular and it converts a value into its JSON-format representation. The value has to be in a property and not in a JSON file in assets.",
	"Logic - Templates - Pipes - Pipes - Custom": "Custom pipes are defined as classes in Angular and decorated with the @Pipe decorator.",
	"Logic - Templates - Pipes - Pipes - Custom - PipeTransform": "export class Pipeclass implements PipeTransform { transform(parameters): returntype { }",
	"Logic - Templates - Pipes - Pipes - Custom - transform": "",
	"Logic - Templates - Directives": "In Angular, directives are markers on a DOM element (such as an attribute, element name, comment, or CSS class) that tells Angular’s HTML compiler ($compile) to attach a specified behavior to that DOM element or transform the DOM element and its children.  transfor the DOM: components, structural, attribute, predefined and custom directives",
	"Logic - Templates - Directives - Component": "Components are directives with templates. They encapsulate a part of the user interface and often have associated logic. They are used to create reusable UI components.",
	"Logic - Templates - Directives - Standalone": "Just like components, we can also create standalone directives. standalone: true,",
	"Logic - Templates - Directives - Structural": "They typically change the DOM layout by adding or removing DOM elements. *ngFor=\"let hero of heroes\". *ngIf=\"selectedHero\"",
	"Logic - Templates - Directives - Structural - Custom - 1.Create": "Create a Directive with ViewContainerRef: constructor(private vcr: ViewContainerRef, ...) and selector: '[appConditional]'",
	"Logic - Templates - Directives - Structural - Custom - 2.Apply": "<p *appConditional='isVisible'>This content is conditionally added!</p>",
	"Logic - Templates - Directives - Structural - Built-in - *": "They usually have an asterisk (*) prefix.",
	"Logic - Templates - Directives - Structural - Built-in - Conditional - *ngIf": "Conditionally creates or disposes of subviews from the template.",
	"Logic - Templates - Directives - Structural - Built-in - Conditional - @if () { }": "",
	"Logic - Templates - Directives - Structural - Built-in - Conditional - @else if () { }": "",
	"Logic - Templates - Directives - Structural - Built-in - Conditional - @else { }": "",
	"Logic - Templates - Directives - Structural - Built-in - Conditional - *ngSwitch": "A set of directives that switch among alternative views.",
	"Logic - Templates - Directives - Structural - Built-in - Conditional - NgSwitchCase": "Structural directive that adds its element to the DOM when its bound value equals the switch value and removes its bound value when it doesn't equal the switch value.",
	"Logic - Templates - Directives - Structural - Built-in - Conditional - NgSwitchDefault": "Structural directive that adds its element to the DOM when there is no selected NgSwitchCase.",
	"Logic - Templates - Directives - Structural - Built-in - Conditional - @switch { }": "While the @if block is great for most scenarios, the @switch block provides an alternate syntax to conditionally render data. Its syntax closely resembles JavaScript's switch statement.",
	"Logic - Templates - Directives - Structural - Built-in - Loop - *ngFor": "Repeat a node for each item in a list.",
	"Logic - Templates - Directives - Structural - Built-in - Loop - *ngFor - with index": "< div *ngFor='let hero of heroes, let i=index' >{{i + 1}} - {{hero.name}}< /div >",
	"Logic - Templates - Directives - Structural - Built-in - Loop - *ngFor - with trackBy": "To customize the default tracking algorithm, NgForOf supports trackBy option. trackBy takes a function which has two arguments: index and item. If trackBy is given, Angular tracks changes by the return value of the function. < div *ngFor='let hero of heroes, trackBy: trackByHeroes' > <br/> trackByHeroes(index: number, heroes: any): string {   return heroes.name;  }  ",
	"Logic - Templates - Directives - Structural - Built-in - Loop - @for () { }": "The @for block loops through a collection and repeatedly renders the content of a block.",
	"Logic - Templates - Directives - Structural - Built-in - Loop - @for () { } - $count": "Number of items in a collection iterated over",
	"Logic - Templates - Directives - Structural - Built-in - Loop - @for () { } - $index": "Index of the current row",
	"Logic - Templates - Directives - Structural - Built-in - Loop - @for () { } - $first": "Whether the current row is the first row",
	"Logic - Templates - Directives - Structural - Built-in - Loop - @for () { } - $last": "Whether the current row is the last row",
	"Logic - Templates - Directives - Structural - Built-in - Loop - @for () { } - $even": "Whether the current row index is even",
	"Logic - Templates - Directives - Structural - Built-in - Loop - @for () { } - $odd": "Whether the current row index is odd",
	"Logic - Templates - Directives - Attribute": "They typically change the appearance or behavior of an element, component, or another directive. They typically don’t change the DOM layout. [(ngModel)]=\"hero.name\"",
	"Logic - Templates - Directives - Attribute - Built-in - class - class": "static, multiple -> class='class1 class2'",
	"Logic - Templates - Directives - Attribute - Built-in - class - [class]": "dynamic, single, conditional - > [class.className] makes it more readable for a simple btn-disabled toggle.",
	"Logic - Templates - Directives - Attribute - Built-in - class - [class.className]": "[class.activeCSS]='isActive' [class.disabledCSS]='isDisabled' where isActive = true; isDisabled = false;",
	"Logic - Templates - Directives - Attribute - Built-in - class - [ngClass]": "dynamic, multiple, conditional - > ngClass makes it easy to switch between btn-success and btn-danger dynamically.",
	"Logic - Templates - Directives - Attribute - Built-in - class - [NgClass] - expresion - string": "<div [ngClass]=\"isSpecial ? 'special' : ''\">This div is special</div>",
	"Logic - Templates - Directives - Attribute - Built-in - class - [NgClass] - expresion - Array": "[ngClass]=\"{'btn-success': isActive, 'btn-danger': !isActive}\" where isActive = true; ",
	"Logic - Templates - Directives - Attribute - Built-in - class - [NgClass] - method": "To use NgClass with a method: 1. add the method to the component class. 2. In the template, add the ngClass property binding>",
	"Logic - Templates - Directives - Attribute - Built-in - class - combine": "Using both keeps code clean and optimized!",
	"Logic - Templates - Directives - Attribute - Built-in - class - combine - [ngClass]": "[ngClass] makes it easy to switch between btn-success and btn-danger dynamically.",
	"Logic - Templates - Directives - Attribute - Built-in - class - combine - [class.className]": "[class.className] makes it more readable for a simple btn-disabled toggle.",
	"Logic - Templates - Directives - Attribute - Built-in - style - NgStyle": "",
	"Logic - Templates - Directives - Attribute - Built-in - style - NgStyle - method": "To use NgStyle: 1. add a method to the component class. 2. add an ngStyle property binding",
	"Logic - Templates - Directives - Attribute - Built-in - model - NgModel": "Use the NgModel directive to display a data property and update that property when the user makes changes.",
	"Logic - Templates - Directives - Attribute - Custom - 1.Create": "Create a Directive constructor(private el: ElementRef, private renderer: Renderer2) {} and selector: '[appDynamicColor]'",
	"Logic - Templates - Directives - Attribute - Custom - 2.Apply": "<h2 [appDynamicColor]='selectedColor'>This text changes color dynamically!</h2>",
	"Logic - Templates - Directives - Attribute - Custom - 2.Apply - DirectiveCompositionAPI": "apply structural directives to a component's host element from within the component TypeScript class.",
	"Logic - Templates - Directives - Attribute - Custom - 2.Apply - DirectiveCompositionAPI - <Angular17": "Before Angular 17, you had to manually apply directives in templates like this: < button appHighlight appTooltip='Click me!' >Hover Me< /button s>",
	"Logic - Templates - Directives - Attribute - Custom - 2.Apply - DirectiveCompositionAPI - Angular17": "With the DirectiveCompositionAPI, you can embed directives directly into a component, so they are applied automatically when the component is used.",
	"Logic - Templates - Directives - Attribute - Custom - 2.Apply - DirectiveCompositionAPI - hostDirectives": "hostDirectives: [NgIf, NgForOf],",
	"Logic - Templates - Directives - Attribute - Custom - 2.Apply - DirectiveCompositionAPI - hostDirectives - DI": "A component or directive that specifies hostDirectives can inject the instances of those host directives and vice versa.",
	"Logic - Templates - Directives - Attribute - Custom - 2.Apply - DirectiveCompositionAPI - hostDirectives - component": "You apply directives to a component by adding a hostDirectives property to a component's decorator. We call such directives host directives. hostDirectives: [MenuBehavior],",
	"Logic - Templates - Directives - Attribute - Custom - 2.Apply - DirectiveCompositionAPI - hostDirectives - component - compile": "Angular applies host directives statically at compile time. You cannot dynamically add directives at runtime.",
	"Logic - Templates - Directives - Attribute - Custom - 2.Apply - DirectiveCompositionAPI - hostDirectives - component - render": "When the framework renders a component, Angular also creates an instance of each host directive.",
	"Logic - Templates - Directives - Attribute - Custom - 2.Apply - DirectiveCompositionAPI - hostDirectives - component - inputs": "By explicitly specifying the inputs and outputs, consumers of the component with hostDirective can bind them in a template: <admin-menu menuId='top-menu' (menuClosed)='logMenuClosed()'>",
	"Logic - Templates - Directives - Attribute - Custom - 2.Apply - DirectiveCompositionAPI - hostDirectives - component - outputs": "",
	"Logic - Templates - Directives - Attribute - Custom - 2.Apply - DirectiveCompositionAPI - hostDirectives - component - alias": "Furthermore, you can alias inputs and outputs from hostDirective to customize the API of your component:",
	"Logic - Templates - Directives - Attribute - Custom - 2.Apply - DirectiveCompositionAPI - hostDirectives - directive": "You can also add hostDirectives to other directives, in addition to components. This enables the transitive aggregation of multiple behaviors.",
	"Logic - Templates - Directives - Attribute - Custom - 2.Apply - DirectiveCompositionAPI - hostDirectives - directive - order": "Host directives go through the same lifecycle as components and directives used directly in a template. However, host directives always execute their constructor, lifecycle hooks, and bindings before the component or directive on which they are applied.",
	"Logic - Templates - Directives - Custom": "You can also write your own Attribute directives.",
	"Logic - Templates - Directives - Custom - @Directive": "",
	"Logic - Templates - Directives - Custom - @Directive - selector": "",
	"Logic - Templates - Directives - Custom - ng generate directive": "ng generate directive highlight creates src/app/highlight.directive.ts, and a corresponding test file src/app/highlight.directive.spec.ts.",
	"Logic - Templates - Directives - Custom - EventEmitter": "Directives typically raise custom events with an Angular EventEmitter. The directive creates an EventEmitter and exposes it as a property. The directive calls EventEmitter.emit(payload) to fire an event, passing in a message payload, which can be anything. Parent directives listen for the event by binding to this property and accessing the payload through the $event object.",
	"Logic - Components - Decorators": ".",
	"Logic - Components - Decorators - Class": "The Decorator must come before the class definition. We can also make our own decorators.",
	"Logic - Components - Decorators - Class - @NgModule": ".",
	"Logic - Components - Decorators - Class - @Component": ".",
	"Logic - Components - Decorators - Class - @Service": ".",
	"Logic - Components - Decorators - Class - @Directive": ".",
	"Logic - Components - Decorators - Method": "Method decorators Used for methods inside classes.",
	"Logic - Components - Decorators - Method - @HostListener": "The @HostListener decorator is used before the onHostClick () method in the above example code.",
	"Logic - Components - Decorators - Property": "Property decorators Used for properties inside classes,",
	"Logic - Components - Decorators - Property - @Input": ".",
	"Logic - Components - Decorators - Property - @Output": ".",
	"Logic - Components - Decorators - Property - @ReadOnly": ".",
	"Logic - Components - Decorators - Property - @Override": ".",
	"Logic - Components - Decorators - Parameter": "Parameter decorators Used for parameters inside class constructors",
	"Logic - Components - Decorators - Parameter - @Inject": ".",
	"Logic - Components - Decorators - Parameter - @Optional": ".",
	"Logic - Components - Binding": "You can alternatively bind to the host element by applying the @HostBinding and @HostListener decorator to class members.",
	"Logic - Components - Binding - HostBinding": "@HostBinding lets you bind host properties and attributes to properties and methods: @HostBinding('style.backgroundColor') backgroundColor: string = 'yellow';",
	"Logic - Components - Binding - HostListener": "@HostListener lets you bind event listeners to the host element. The decorator accepts an event name and an optional array of arguments: @HostListener('keydown', ['$event'])",
	"Logic - Components - DOMInteraction": "Angular handles most DOM creation, updates, and removals for you. However, you might rarely need to directly interact with a component's DOM. ",
	"Logic - Components - DOMInteraction - Direct": "",
	"Logic - Components - DOMInteraction - Direct - document": "document.getElementById()",
	"Logic - Components - DOMInteraction - Direct - elementRef": "Components can inject ElementRef to get a reference to the component's host element: constructor(elementRef: ElementRef) { ... }",
	"Logic - Components - DOMInteraction - Direct - nativeElement": "The nativeElement property references the host Element instance. console.log(elementRef.nativeElement);",
	"Logic - Components - DOMInteraction - Direct - Problems": "not recommended in Angular because: It bypasses Angular's change detection. It doesn't work with server-side rendering (SSR) or Web Workers. It can lead to security vulnerabilities (e.g., XSS attacks).",
	"Logic - Components - DOMInteraction - Renderer2": "The Renderer2 service in Angular provides a safe and platform-independent way to manipulate the DOM.",
	"Logic - Components - DOMInteraction - Renderer2 - preferred": "It helps you modify elements without directly accessing document or ElementRef.nativeElement, ensuring better security, cross-platform compatibility, and testability.",
	"Logic - Components - DOMInteraction - Renderer2 - use": "Create directives that get Renderer2 in constructor",
	"Logic - Services": "Services helps us to share common business logic, data and functions with different components of an Angular application.",
	"Logic - Services - Structure": "The service itself is a class that CLI generated",
	"Logic - Services - Lifecycle - Creation - CLI": "ng generate service User.",
	"Logic - Services - Language": "The Angular Language Service is a way to get completions, errors, hints, and navigation inside your Angular templates whether they are external in an HTML file or embedded in annotations/decorators in a string. The Angular Language Service autodetects that you are opening an Angular file, reads your tsconfig.json file, finds all the templates you have in your application, and then provides language services for any templates that you open. npm install --save-dev @angular/language-service",
	"Logic - Services - DI": "inject services. Service are implemented through dependency injection.",
	"Logic - Services - DI - Providers": "Providers tell the injector how to create the service. They are used to define how a dependency should be instantiated.",
	"Logic - Services - DI - Providers - Types": "A provider can be any object or value, but most of the time, it is a class that provides a service or functionality.",
	"Logic - Services - DI - Providers - Types - Services - Injectable": "service is decorated with @Injectable() to make it a Provider",
	"Logic - Services - DI - Providers - Types - Services - Injectable - providedIn": "By default, this decorator has a providedIn property, which creates a provider for the service. ",
	"Logic - Services - DI - Injectors": "An Angular injector is responsible for creating service instances (relies on providers) and injecting them (into components, directives, pipes, and other services).",
	"Logic - Services - DI - Injectors - Hierarchical": "Angular has a Hierarchical Dependency Injection system.",
	"Logic - Services - DI - Injectors - Hierarchical - Tree": "An Angular application is a tree of components. Each component instance has its own injector. The tree of components parallels the tree of injectors.",
	"Logic - Services - DI - Injectors - Hierarchical - FineTuning": "allows you to fine-tune which dependency to use in your consuming code.",
	"Logic - Services - DI - Injectors - Hierarchical - Resolution": "When a component requests a dependency, Angular tries to satisfy that dependency with a provider registered in that component's own injector. If the component's injector lacks the provider, it passes the request up to its parent component's injector. If that injector can't satisfy the request, it passes it along to its parent injector. The requests keep bubbling up until Angular finds an injector that can handle the request or runs out of ancestor injectors. If it runs out of ancestors, Angular throws an error.",
	"Logic - Services - DI - Injectors - Hierarchical - Sandboxing": "Sometimes you want multiple instances of a service at the same level of the component hierarchy. A good example is a service that holds state for its companion component instance. You need a separate instance of the service for each component. Each service has its own work-state, isolated from the service-and-state of a different component. This is called sandboxing because each service and component instance has its own sandbox to play in..",
	"Logic - Services - DI - Injectors - Creation - Auto": "You don't have to create injectors. Under the hood Angular creates an application-wide root injector for you during the bootstrap process. It creates additional child injectors as needed.",
	"Logic - Services - DI - Injectors - Creation - Custom": "Creating a custom injector in Angular is straightforward. You can use the Injector.create() method to create an injector with specific providers. const customInjector = Injector.create({ providers: [ { provide: MyService, useClass: MyService }, ], });",
	"Logic - Services - DI - Registration": "You must register a service provider with an injector, or it won't know how to create the service.",
	"Logic - Services - DI - Registration - Scope - Platform": "A special singleton platform injector shared by all applications on the page.",
	"Logic - Services - DI - Registration - Scope - Platform - Injectable - providedIn": "providedIn: 'platform'.",
	"Logic - Services - DI - Registration - Scope - Root": "When you add a service provider to the root application injector, it’s available throughout the app. Another way to limit provider scope is by adding the service you want to limit to the component’s providers array. Providing a service in the component limits the service only to that component",
	"Logic - Services - DI - Registration - Scope - Root - Bootstrap": "Angular creates an application-wide injector for you during the bootstrap process.",
	"Logic - Services - DI - Registration - Scope - Root - CLI": "ng generate service - registers a provider with the root injector for your service by including provider metadata in the @Injectable decorator",
	"Logic - Services - DI - Registration - Scope - Root - Injectable - providedIn": "providedIn: 'root' specifies that Angular should provide the service in the root injector.",
	"Logic - Services - DI - Registration - Scope - Root - forRoot": "configure services and providers that are intended to be singletons and eager",
	"Logic - Services - DI - Registration - Scope - Root - forChild() ": "provider that is visible only to the children modules of our module, in case they are lazy loaded. As each lazy module is loaded on demand, it has its own injector..",
	"Logic - Services - DI - Registration - Scope - Root - Singleton": "Declare tha the service should be provided in the application root. Include the service in the AppModule or in a module that is only imported by the AppModule.",
	"Logic - Services - DI - Registration - Scope - Root - preferred": "If you can get away with providing to the Root Injector so that you only have one instance of dependency for your application, then you should.",
	"Logic - Services - DI - Registration - Scope - ModuleInjector": "with a specific NgModule, the same instance of a service is available to all components in that NgModule.  at the component level, you get a new instance of the service with each new instance of that component",
	"Logic - Services - DI - Registration - Scope - ModuleInjector - Injectable - providedIn": "deprecated. @Injectable({ providedIn: UserModule, }). Specify that a service should be provided in a particular @NgModule. if you use providedIn, the injectable is registered as a provider of the Module without adding it to the providers of the module.",
	"Logic - Services - DI - Registration - Scope - ModuleInjector - providers": "You can configure the providers array to add fine-grained control to your providers [{ provide: MyService, howToProvide: OtherDependency }]",
	"Logic - Services - DI - Registration - Scope - ModuleInjector - providers - provide": "The provide property holds the token that serves as the key for both locating a dependency value and registering the provider",
	"Logic - Services - DI - Registration - Scope - ModuleInjector - providers - definition": "The second property is always a provider definition object, which you can think of as a recipe for creating the dependency value. There are many ways to create dependency values just as there are many ways to write a recipe: useClass (create new instance), useValue (provide a ready made object), useFactory (he provider is a factory function), useExisting (use existing instance)",
	"Logic - Services - DI - Registration - Scope - ModuleInjector - providers - howToProvide": "",
	"Logic - Services - DI - Registration - Scope - ModuleInjector - providers - howToProvide - useClass": "useClass - Replace the current dependency with a new instance of something else",
	"Logic - Services - DI - Registration - Scope - ModuleInjector - providers - howToProvide - useExisting": "useExisting - Replace the current dependency with an existing dependency",
	"Logic - Services - DI - Registration - Scope - ModuleInjector - providers - howToProvide - useValue": "useValue - Replace the current dependency with a new value",
	"Logic - Services - DI - Registration - Scope - ModuleInjector - providers - howToProvide - useFactory": "useFactory - Use a factory method to determine which dependency to use based on a dynamic value",
	"Logic - Services - DI - Registration - Scope - Component - Constructor": "we can use our dependency in the application by injecting it into the consuming code as a constructor parameter: constructor(private myService: MyService) { }.",
	"Logic - Services - DI - Registration - Scope - Component - @Inject - Angular14": "In Angular v14, you have a new option to use the inject() function instead of injecting the service into the consumer as a constructor parameter.",
	"Logic - Services - DI - Registration - Scope - Component - @Inject - InjectionToken": "@Inject(INJECTION_TOKEN) where const export INJECTION_TOKEN = new InjectionToken<UserConfig>('userconfig', { providedIn: 'root', factory: () => defaultUserConfig }); ",
	"Logic - Services - DI - Registration - Scope - Component - providers": "",
	"Logic - Services - DI - Registration - Scope - ElementInjector": "Angular creates ElementInjector hierarchies implicitly for each DOM element. ElementInjector injector is being created for any tag that matches the angular component, or any tag on which directive is applied, and you can configure it in component and directive annotations inside the provider's property, thus, it creates its own hierarchy likewise the upper one.",
	"Logic - Services - DI - Registration - Scope - NullInjector": "Equivalent to undefined. The injectable is not provided in any scope automatically and must be",
	"Logic - Services - DI - Registration - Scope - NullInjector - Injectable - providedIn": "providedIn: 'null'.",
	"Logic - Services - DI - Registration - Scope - Any": "Provides a unique instance in each lazy loaded module while all eagerly loaded modules share one instance.",
	"Logic - Services - DI - Registration - Scope - Any - Injectable - providedIn": "providedIn: 'any'. This option is DEPRECATED.",
	"Logic - Services - ErrorHandling - HTTP": ".",
	"Logic - Services - ErrorHandling - HTTP - HttpErrorResponse": "When there's a HTTP error, Angular wraps it in a class called HttpErrorResponse: this happens both when the error is server-side (eg. a 500 error) and when the client makes a wrong request.",
	"Logic - Services - ErrorHandling - HTTP - retry": "Since the HttpClient service returns an Observable for each call, we can easily use RxJS operators.",
	"Logic - Services - ErrorHandling - HTTP - timeout": "it triggers an error, if the Observable doesn't emit in N milliseconds.",
	"Logic - Services - ErrorHandling - HTTP - catchError": "it triggers an error, if the Observable doesn't emit in N milliseconds.",
	"Logic - Services - ErrorHandling - HTTP - Subscribe": "inside the subscribe. error: e => this.error = e,",
	"Logic - Services - ErrorHandling - HTTP - Interceptors": "You can also handle HTTP errors globally with an Interceptor. Interceptors let you do stuff before and after each HTTP request in your app.",
	"Logic - Services - ErrorHandling - ErrorHandler": "Finally, if you don't want to remedy but just detect the errors, ErrorHandler Provides a hook for centralized exception handling.",
	"Logic - Services - ErrorHandling - ErrorHandler - handleError": "@Injectable() export class GlobalErrorHandler implements ErrorHandler { ... handleError(error: any) { ... } .. }",
	"Logic - Services - ErrorHandling - ErrorHandler - all": "This class intercepts all the unhandled errors in your app (not just HTTP errors but any error), it's the final place to consider for when you can't do anything to it.",

  "CI - Packaging": "SECTION",
	"CI - Packaging - Arch - Components - Types - Dumb": "All Dumb Components do is present themselves to the DOM. Hence they are also referred to as “Presentational Components” or something called “Isolated Components”.",
	"CI - Packaging - Arch - Components - Types - Smart": "Smart Components are those components who know how to handle data, How to fetch data from services, How to interact with services and keep track of the state and care about how the app works as a whole. They are called containers as they send data to Dumb Components via property bindings.",
	"CI - Packaging - Optimization - CodeReduction - Resources - OptimizeImages - NgOptimizedImage": "The NgOptimizedImage directive makes it easy to adopt performance best practices for loading images.",
	"CI - Packaging - Optimization - CodeReduction - TreeShakable - Providers": "Tree shaking is the ability to remove code that is not referenced in an application from the final bundle.",
	"CI - Packaging - Optimization - CodeReduction - TreeShakable - Providers - Angular6": "Tree-shakable providers give Angular the ability to remove services that are not used in your application from the final output. This significantly reduces the size of your bundles.",
	"CI - Packaging - Optimization - CodeReduction - TreeShakable - Providers - Default": "Ideally, if an application is not injecting a service, it should not be included in the final output. However, it turns out that the Angular compiler cannot identify at build time if the service will be required or not. Because it's always possible to inject a service directly using injector.get(Service), Angular cannot identify all of the places in your code where this injection could happen, so it has no choice but to include the service in the injector regardless. Thus, services provided in modules are not tree-shakable.",
	"CI - Packaging - Optimization - CodeReduction - TreeShakable - Providers - Configure": "To create providers that are tree-shakable, the information that used to be specified in the module should be specified in the @Injectable decorator on the service itself. @Injectable({ providedIn: 'root', useFactory: () => new Service('dependency'), })",
  "CI - Packaging - Optimization - CodeReduction - Budgets": "A performance budget is a group of limits to certain values that affect site performance, that may not be exceeded in the design and development of any web project.",
  "CI - Packaging - Optimization - CodeReduction - Budgets - angular.json": "",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - Routes - loadChildren": "With standalone components, Angular’s routing system can now lazily load components at the route level much more easily.",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - Routes - loadChildren - eg": "{ path: '/student', loadChildren: './student/student.module#StudentModule' } <br/>Now, looks as: <br/>{ path: '/student', loadChildren: () => import('./student/student.module').then(s => s.StudentModule) }.",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - Routes - loadComponent - standalone": "loadComponent property, which uses a dynamic import statement like an NgModule would, but for a standalone component:",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - Routes - loadComponent - eg": " loadComponent: () => import('./menu-list/menu-list.component').then((x) => x.MenuListComponent)",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - Routes - loadComponent - Rendering": "You can use both of the approaches described above, NgComponentOutlet and ViewContainerRef, to render components that are lazy-loaded with a standard JavaScript dynamic import.",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - Routes - loadComponent - Rendering - ViewContainerRef": "Defines the placeholder where the component will be inserted.",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - Routes - loadComponent - Rendering - NgComponentOutlet": "",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - DeferrableViews - Angular17": "Deferrable Views: This one’s a game-changer for performance optimization. Standalone components can be lazy-loaded right in the template, making it easier than ever to defer loading parts of your app until they’re actually needed.",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - DeferrableViews - @defer": "Deferrable views, also known as @defer blocks, reduce the initial bundle size of your application by deferring the loading of code that is not strictly necessary for the initial rendering of a page.",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - DeferrableViews - @defer - triggers": ".",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - DeferrableViews - @defer - triggers - on idle": "Triggers when the browser is idle.",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - DeferrableViews - @defer - triggers - on viewport": "Triggers when specified content enters the viewport",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - DeferrableViews - @defer - triggers - on interaction": "Triggers when the user interacts with specified element.",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - DeferrableViews - @defer - triggers - on hover": "Triggers when the mouse hovers over specified area.",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - DeferrableViews - @defer - triggers - on immediate": "Triggers immediately after non-deferred content has finished rendering.",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - DeferrableViews - @defer - triggers - on timer": "Triggers after a specific duration.",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - DeferrableViews - @defer - triggers - when condition": "The when trigger accepts a custom conditional expression and loads the deferred content when the condition becomes truthy.",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - DeferrableViews - @defer - triggers - prefetch": ".",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - DeferrableViews - @placeholder": "The @placeholder is an optional block that declares what content to show before the @defer block is triggered.",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - DeferrableViews - @loading": "The @loading block is an optional block that allows you to declare content that is shown while deferred dependencies are loading. It replaces the @placeholder block once loading is triggered.",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - DeferrableViews - @loading - minimum": "minimum - the minimum amount of time that this placeholder should be shown",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - DeferrableViews - @loading - after": "after - the amount of time to wait after loading begins before showing the loading template",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - DeferrableViews - @error": "The @error block is an optional block that displays if deferred loading fails. Similar to @placeholder and @loading, the dependencies of the @error block are eagerly loaded.",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Differential - Angular8": "",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Differential - ng build": "All bundling is done with the ng build command and the -prod extension, without requiring special actions. ng build --configuration=production",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Differential - Bundles": "Differential Loading in Angular is a technique that allows Angular to generate two separate bundles for modern and legacy browsers:",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Differential - Bundles - Modern": "Modern Bundle → Uses ES2015+ syntax (smaller, faster).",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Differential - Bundles - Legacy": "Legacy Bundle → Uses ES5 syntax with polyfills (for older browsers).",
	"CI - Packaging - Optimization - CodeFetching - PreLoading": "Preloading strategies are specified in the RouterModule.forRoot() method.",
	"CI - Packaging - Optimization - CodeFetching - PreLoading - preloadingStrategy": "RouterModule.forRoot(routes, { preloadingStrategy: PreloadAllModules })",
	"CI - Packaging - Optimization - CodeFetching - PreLoading - preloadingStrategy - NoPreloading": "default",
	"CI - Packaging - Optimization - CodeFetching - PreLoading - preloadingStrategy - PreloadAllModules": "Preloads all lazy-loaded modules in the background.",
	"CI - Packaging - Optimization - CodeFetching - PreLoading - preloadingStrategy - Custom": "create class that implements PreloadingStrategy",
	"CI - Packaging - tools - ng-packagr": "",

	"CI - Building": "SECTION",
	"CI - Building - Compilation - Type - ByTime": "When you run the ng build or ng serve CLI commands, the type of compilation (JIT or AOT) depends on the value of the aot property in your build configuration specified in angular.json. By default, aot is set to true for new CLI applications.",
	"CI - Building - Compilation - Type - ByTime - JIT - default": "JIT was the default until Angular 8. AOT is the default starting in Angular 9.",
	"CI - Building - Compilation - Type - ByTime - AOT": "The Angular compiler extracts the metadata once and generates a factory for TypicalComponent. When it needs to create a TypicalComponent instance, Angular calls the factory, which produces a new visual element, bound to a new instance of the component class with its injected dependency.",
	"CI - Building - Compilation - Type - ByTime - AOT - Phases - CodeAnalisis": "In this phase, the TypeScript compiler and AOT collector create a representation of the source. It emits the .d.ts type definition files with type information that the AOT compiler needs to generate application code.",
	"CI - Building - Compilation - Type - ByTime - AOT - Phases - CodeGeneration": "In this phase, the compiler's StaticReflector interprets the metadata collected in phase 1, performs additional validation of the metadata, and throws an error if it detects a metadata restriction violation.",
	"CI - Building - Compilation - Type - ByTime - AOT - Phases - TemplateTypeChecking": "In this optional phase, the Angular template compiler uses the TypeScript compiler to validate the binding expressions in templates. You can enable this phase explicitly by setting the strictTemplates configuration option; see Angular compiler options.",
	"CI - Building - Compilation - Type - ByPlace - CSR - default": "Angular by default, uses client-side rendering.",
	"CI - Building - Compilation - Type - ByPlace - SSG": "To prerender a static page (SSR) (1) Add SSR ng add @angular/ssr (2) generate the static pages: ng build",
	"CI - Building - Compilation - Type - ByPlace - SSG - discoverRoutes": "Whether the builder should process the Angular Router configuration to find all unparameterized routes and prerender them.",
	"CI - Building - Compilation - Type - ByPlace - SSG - routesFile": "The path to a file that contains a list of all routes to prerender, separated by newlines. This option is useful if you want to prerender routes with parameterized URLs.",
	"CI - Building - Compilation - Type - ByPlace - SSG - routesFile - parameterized": "You can prerender parameterized routes using the routesFile option. An example of a parameterized route is product/:id, where id is dynamically provided. To specify these routes, they should be listed in a text file, with each route on a separate line.",
	"CI - Building - Compilation - Type - ByPlace - SSR": ".",
	"CI - Building - Compilation - Type - ByPlace - SSR - hydration": "Hydration can be enabled for server-side rendered (SSR) applications only.",
	"CI - Building - Compilation - Type - ByPlace - SSR - hydration - reuse": "Angular tries to match existing DOM elements to the applications structure at runtime and reuses DOM nodes when possible. Without hydration enabled, server-side rendered Angular applications will destroy and re-render the application's DOM, which may result in a visible UI flicker.",
	"CI - Building - Compilation - Type - ByPlace - SSR - hydration - provideClientHydration": "If you have a custom setup you can enable hydration manually by importing provideClientHydration from @angular/platform-browser. You'll then add that provider to your app's bootstrapping providers list.",
	"CI - Building - Compilation - Type - ByPlace - SSR - hydration - ngSkipHydration": "The ngSkipHydration attribute will force Angular to skip hydrating the entire component and its children.",
	"CI - Building - Compilation - Type - ByPlace - SSR - hydration - ngSkipHydration - attribute": "you can add the ngSkipHydration attribute to a component's tag in order to skip hydrating the entire component. <app-example ngSkipHydration />",
	"CI - Building - Compilation - Type - ByPlace - SSR - hydration - ngSkipHydration - host": "Alternatively you can set ngSkipHydration as a host binding. host: {ngSkipHydration: 'true'},",
	"CI - Building - Compilation - Type - ByPlace - SSR - hydration - triggers": "You can specify hydrate triggers that control when Angular loads and hydrates deferred content. These are additional triggers that can be used alongside regular @defer triggers.",
	"CI - Building - Compilation - Type - ByPlace - SSR - hydration - triggers - hydrate on": "hydrate on specifies a condition for when hydration is triggered for the @defer block.",
	"CI - Building - Compilation - Type - ByPlace - SSR - hydration - triggers - hydrate on - idle": "Triggers when the browser is idle..",
	"CI - Building - Compilation - Type - ByPlace - SSR - hydration - triggers - hydrate on - viewport": "Triggers when specified content enters the viewport.",
	"CI - Building - Compilation - Type - ByPlace - SSR - hydration - triggers - hydrate on - interaction": "Triggers when the user interacts with specified element.",
	"CI - Building - Compilation - Type - ByPlace - SSR - hydration - triggers - hydrate on - hover": "Triggers when the mouse hovers over specified area.",
	"CI - Building - Compilation - Type - ByPlace - SSR - hydration - triggers - hydrate on - immediate": "Triggers immediately after non-deferred content has finished rendering.",
	"CI - Building - Compilation - Type - ByPlace - SSR - hydration - triggers - hydrate on - timer": "Triggers after a specific duration.",
	"CI - Building - Compilation - Type - ByPlace - SSR - hydration - triggers - hydrate when": "The hydrate when trigger accepts a custom conditional expression and loads the deferrable view's dependencies and hydrates the content when the condition becomes truthy.",
	"CI - Building - Compilation - Type - ByPlace - SSR - hydration - triggers - hydrate never": "The hydrate never allows users to specify that the content in the defer block should remain dehydrated indefinitely, effectively becoming static content. Note that this applies to the initial render only. During a subsequent client-side render, a @defer block with hydrate never would still fetch dependencies, as hydration only applies to initial load of server-side rendered content. In the example below, subsequent client-side renders would load the @defer block dependencies on viewport.",
	"CI - Building - Compilation - Type - ByPlace - SSR - AngularUniversal": "Angular Universal generates static application pages on the server for server-side rendering (SSR).",
	"CI - Building - Compilation - Type - ByPlace - SSR - create": "ng new --ssr",
	"CI - Building - Compilation - Type - ByPlace - SSR - add": "ng add @angular/ssr",
	"CI - Building - Compilation - Type - ByPlace - SSR - files - server.ts": "The server.ts file configures a Node.js Express server and Angular server-side rendering. CommonEngine is used to render an Angular application.",
	"CI - Building - Compilation - Type - ByPlace - SSR - files - src/main.server.ts": "In Angular v17 and later, server.ts is no longer used by ng serve. The dev server will use main.server.ts directly to perform server side rendering.",
	"CI - Building - Compilation - Type - ByPlace - SSR - files - src/app/app.config.server.ts": "",
	"CI - Building - Compilation - Type - ByPlace - Hybrid": "Hybrid rendering combines the benefits of server-side rendering (SSR), pre-rendering (also known as 'static site generation' or SSG) and client-side rendering (CSR) to optimize your Angular application. It allows you to render different parts of your application using different strategies, giving you fine-grained control over how your app is delivered to users.",
	"CI - Building - Compilation - Compiler - CLI": "Angular CLI automates the end-to-end development process. The app's initialization, configuration, and development process become straightforward and easy. With a CLI (Command Line Interface), we can create a new project, add new features, and run tests (unit tests and end-to-end tests) by just typing a few simple commands.",
	"CI - Building - Compilation - Compiler - CLI - ng-build": "build only",
	"CI - Building - Compilation - Compiler - CLI - ng-serve": "build and serve locally",
	"CI - Building - Compilation - Compiler - CLI - Bazel (Angular 8.0)": "CLI has integrated a new experimental build tool called Bazel.",
	"CI - Building - Compilation - Compiler - Ivy (Angular 8.0)": "Ivy is a new template compiler to build next-gen rendering pipelines in the current version.",
	"CI - Building - Compilation - Compiler - Ivy - advantages": "The advantages of Ivy are: Smaller Bundles. Reduced Payload Size. Faster Rebuild times. Enhance Backwards Compatibility . Pre-compiled Code shipment . Dismissal of metadata.json. Rise of meta programming. Improve template type checking. Broad Compatibility with existing Angular applications.",
	"CI - Building - Compilation - Compiler - Ivy - local": "Recompile only the changed components and allow quicker compiling.",
	"CI - Building - Compilation - Compiler - Ivy - treeshakable": "The unused code gets removed so that the application concentrates on the code used.",
	"CI - Building - Environments": "src/environments/ directory and configure the project to use file replacements. The project's src/environments/ directory contains the base configuration file, environment.ts, which provides the default configuration for production. You can override default values for additional environments, such as development and staging, in target-specific configuration files.",
	"CI - Building - Environments - environment.ts - create": "ng generate environments",
	"CI - Building - Environments - environment.ts - configure - configurations": "Modify the angular.json file to include the new environment configuration. Open the angular.json file and find the configurations section under projects > my-angular-app > architect > build.",
	"CI - Building - Environments - environment.ts - configure - serve": "Additionally, update the serve options in the angular.json to include the new staging configuration",
	"CI - Building - Environments - environment.ts - base": "The base file environment.ts, contains the default environment settings.",
	"CI - Building - Environments - environment.ts - default": "The build command uses environment.ts as the build target when no environment is specified. ng build --prod --configuration=usa",
	"CI - Building - Environments - environment.ts - Production": "Angular app development is one of the most chosen services for web app development in today's time. And by default, Angular operates in debug mode that counts some affirmation checks and runs ChangeDetection twice. It will make sure that there are no unexpected changes to binding values.",
	"CI - Building - Environments - ngx-env/builder": "ngx-env/builder makes managing environment variables in Angular projects a breeze.",

  "CI - Integration": "SECTION",
	"CI - Integration - Execution - Bootstrapping": "To run your application in a browser.",
	"CI - Integration - Execution - Bootstrapping - Automatic - ng-app": "Automatic bootstrapping can be used to add the ng-app directive to the application’s root. <body ng-app=''> ... </body>",
	"CI - Integration - Execution - Bootstrapping - Manual": "It is extremely useful in places where professionals wish to perform other tasks and operations before Angular compiles the page.",
	"CI - Integration - Execution - Bootstrapping - Manual - BrowserModule": "To run your application in a browser.",
	"CI - Integration - Execution - Bootstrapping - Manual - angular.json": "So the working of the Angular application starts with the configuration file ANGULAR.JSON.",
	"CI - Integration - Execution - Bootstrapping - Manual - angular.json - main.ts": "Next comes the MAIN.TS file that acts as the entry point for the configuration file. It helps in creating the browser environment that enables it to run the application.",
	"CI - Integration - Execution - Bootstrapping - Manual - angular.json - index.html": "The main HTML page that is served when someone visits your site. The CLI automatically adds all JavaScript and CSS files when building your app, so you typically don't need to add any <script> or<link> tags here manually.",
	"CI - Integration - Execution - Bootstrapping - Manual - BootstrappingModule": "It is also called as the RootModule or AppModule. The bootstrapping module is mentioned in the AppModule class. ",
	"CI - Integration - Execution - Bootstrapping - Manual - BootstrappingModule - RootComponent": "each app has at least a root component",
	"CI - Integration - Execution - Bootstrapping - Manual - BootstrappingModule - bootstrap": "The @NgModule decorator accepts an optional bootstrap array that may contain one or more components. Every Angular application has a bootstrapping module. Components listed in bootstrap are automatically included in the NgModule's declarations.",
	"CI - Integration - Execution - Bootstrapping - Manual - BootstrappingModule - bootstrap - bootstrapModule": "You can use the bootstrapModule method from either platformBrowser or platformServer to start an Angular application. When run, this function locates any elements on the page with a CSS selector that matches the listed componet(s) and renders those components on the page.",
	"CI - Integration - Execution - Bootstrapping - Manual - BootstrappingModule - bootstrap - bootstrapApplication": "Bootstraps an instance of an Angular application and renders a standalone component as the application's root component.",
	"CI - Integration - Execution - Bootstrapping - Manual - BootstrappingModule - bootstrap - process": "When you bootstrap an application from an NgModule, the collected providers of this module and all of the providers of its imports are eagerly loaded and available to inject for the entire application.",
	"CI - Integration - Execution - Threads - Multithreading - Workers - ServiceWorkers - Angular5": "@angular/service-worker A service worker is a script that runs in the web browser and manages caching for an application. Service workers function as a network proxy. They intercept all outgoing HTTP requests made by the application and can choose how to respond to them. For example, they can query a local cache and deliver a cached response if one is available.",
	"CI - Integration - Execution - Threads - Multithreading - Workers - ServiceWorkers - manifest": "To support these behaviors, the Angular service worker loads a manifest file from the server. The manifest describes the resources to cache and includes hashes of every file's contents. When an update to the application is deployed, the contents of the manifest change, informing the service worker that a new version of the application should be downloaded and cached. This manifest is generated from a CLI-generated configuration file called ngsw-config.json.",
	"CI - Integration - Execution - Threads - Multithreading - Workers - ServiceWorkers - installation": "Importing ServiceWorkerModule into your AppModule doesn't just register the service worker, it also provides a few services you can use to interact with the service worker and control the caching of your app.",
	"CI - Integration - Execution - Threads - Multithreading - Workers - ServiceWorkers - bypass": "bypassing the service worker with a specified request: this.http.get(‘api/users’, { headers: { ‘ngsw-bypass’: true } });",
	"CI - Integration - Execution - Schematics": "A schematic is a template-based code generator that supports complex logic. It is a set of instructions for transforming a software project by generating or modifying code.",
	"CI - Integration - Execution - Schematics - CLI": "The Angular CLI uses schematics to apply transforms to a web-app project.",
	"CI - Integration - Security - XSS - innerHTML - DONT": "Avoid using innerHTML or outerHTML to dynamically generate HTML content. Instead, utilize Angular's template syntax to safely render dynamic content.",
	"CI - Integration - Security - XSS - bindings": "Angular’s built-in mechanisms for data binding, such as interpolation ({{ }}) and property binding ([ ]), automatically sanitize user input, making it safe to render in the browser.",
	"CI - Integration - Security - XSS - DomPurify": "",
	"CI - Integration - Security - XSS - DomSanitizer": "use Angular’s built-in DomSanitizer service to sanitize the input before rendering it in the DOM. constructor(private sanitizer: DomSanitizer) {}",
	"CI - Integration - Security - XSS - DomSanitizer - bypassSecurityTrustHtml": "DOM Sanitize for HTML",
	"CI - Integration - Security - XSS - DomSanitizer - bypassSecurityTrustStyle": "DOM Sanitize for Styles",
	"CI - Integration - Security - XSS - DomSanitizer - bypassSecurityTrustScript": "DOM Sanitize for Script URLs",
	"CI - Integration - Security - XSS - DomSanitizer - bypassSecurityTrustUrl": "DOM Sanitize for URL/resource URLs.",
	"CI - Integration - Security - XSS - DomSanitizer - bypassSecurityTrustResourceUrl": "DOM Sanitize for resource URLs like iframe sources.",
	"CI - Integration - Security - XSS - SafeHtml": "This interface will internally use the DomSanitizer, so that we don't have to use it directly",
	"CI - Integration - Security - XSS - SafeStyle": "This interface will internally use the DomSanitizer, so that we don't have to use it directly",
	"CI - Integration - Security - XSS - SafeScript": "This interface will internally use the DomSanitizer, so that we don't have to use it directly",
	"CI - Integration - Security - XSS - SafeUrl": "This interface will internally use the DomSanitizer, so that we don't have to use it directly",
	"CI - Integration - Security - XSS - SafeValue": "This interface will internally use the DomSanitizer, so that we don't have to use it directly",
 
	"CD - Monitor": "SECTION",
	"CD - Monitor - Debug - sourceMap": "Angular generates source maps by default during development, which map your compiled JavaScript code back to the original TypeScript code. Ensure source maps are enabled in your tsconfig.json: 'compilerOptions': { 'sourceMap': true }",
	"CD - Monitor - Debug - AngularAugury - deprecated": "",
	"CD - Monitor - Debug - AngularDevTools": "",
	"CD - Monitor - Debug - AngularGlobal": "(1) ng serve --open (2) Open the browser developer console or press F12. (3) In the Console tab, type ng, and press Enter. All the default functions of the global ng object will be listed as shown in the following screenshot.",
	"CD - Monitor - Debug - AngularGlobal - Angular9": "The Angular team has exposed the global object ng, which is a lifesaver that makes the debugging process much easier.",
	"CD - Monitor - Testing - TestBed": "The TestBed is the most important of the Angular testing utilities. The TestBed creates a dynamically-constructed Angular test module that emulates an Angular @NgModule.",
	"CD - Monitor - Testing - Artifacts - Directives": "",
	"CD - Monitor - Testing - Artifacts - Components": "",
	"CD - Monitor - Testing - Artifacts - Pipes": "",
	"CD - Monitor - Testing - Artifacts - Services": "",
	"CD - Monitor - Testing - Operation - ng test": "",
	"CD - Monitor - Testing - Operation - ng test - --codeCoverage": "To generate a coverage report run the following command in the root of your project. ng test --no-watch --code-coverage",
	"CD - Monitor - Testing - Operation - location": "",
	"CD - Monitor - Testing - Operation - location - sibling": "It's a good idea to put unit test spec files in the same folder as the application source code files that they test: Such tests are painless to find, You see at a glance if a part of your application lacks tests , Nearby tests can reveal how a part works in context , When you move the source (inevitable), you remember to move the test , When you rename the source file (inevitable), you remember to rename the test file",
	"CD - Monitor - Testing - Operation - location - folder": "Application integration specs can test the interactions of multiple parts spread across folders and modules. They don't really belong to any part in particular, so they don't have a natural home next to any one file. It's often better to create an appropriate folder for them in the tests directory.",
	"CD - Monitor - Testing - Operation - .spec.ts": "The test file extension must be .spec.ts so that tooling can identify it as a file with tests (also known as a spec file)."

}