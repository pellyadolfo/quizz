{
	"Angular": "SECTION",
	"Angular - vs React": "https://blog.stackademic.com/the-future-of-angular-will-it-disappear-one-day-61603a9d542d",

	"BuildingBlocks": "SECTION",
	"BuildingBlocks - NgModules": "basic building blocks of an Angular application",
	"BuildingBlocks - NgModules - Features - Responsibilities": "An NgModule has two main responsibilities: Declaring components, directives, and pipes that belong to the NgModule. Add providers to the injector for components, directives, and pipes that import the NgModule",
	"BuildingBlocks - NgModules - Features - Multiplicity": "app always has at least a root module that enables bootstrapping, and typically has many more feature modules",
	"BuildingBlocks - NgModules - Structure - @NgModule": "NgModules are classes decorated with @NgModule.",
	"BuildingBlocks - NgModules - Structure - @NgModule - Properties - declarations": "Declares the components, directives, and pipes that belong to this NgModule.",
	"BuildingBlocks - NgModules - Structure - @NgModule - Properties - exports": "The subset of declarations that should be visible and usable in the component templates of other NgModules.",
	"BuildingBlocks - NgModules - Structure - @NgModule - Properties - imports": "Other modules whose exported classes are needed by component templates declared in this NgModule.",
	"BuildingBlocks - NgModules - Structure - @NgModule - Properties - providers": "Creators of services that this NgModule contributes to the global collection of services, they become accessible in all parts of the app. (You can also specify providers at the component level, which is often preferred.).",
	"BuildingBlocks - NgModules - Structure - @NgModule - Properties - providers - forRoot": "Some NgModules define a static forRoot method that accepts some configuration and returns an array of providers. The name 'forRoot' is a convention that indicates that these providers are intended to be added exclusively to the root of your application during bootstrap. providers: [ CustomMenuModule.forRoot(/* some config */), ],",
	"BuildingBlocks - NgModules - Structure - @NgModule - Properties - providers - forChild": "Some NgModules may define a static forChild that indicates the providers are intended to be added to components within your application hierarchy. providers: [ CustomMenuModule.forChild(/* some config */), ],",
	"BuildingBlocks - NgModules - Structure - @NgModule -'Properties - entryComponents": "components that are not found in html and created dynamically with ComponentFactoryResolver.",
	"BuildingBlocks - NgModules - Structure - @NgModule - Properties - bootstrap": "It is the main application view, also called the root component, which hosts all other app views. Only the root NgModule should set this bootstrap property. Angular creates and inserts into the index.html host web page",
	"BuildingBlocks - NgModules - Built-in - RootModule": "It is also called as the AppModule. The bootstrapping module is mentioned in the AppModule class.",
	"BuildingBlocks - NgModules - Built-in - RootModule - bootstrap": "The @NgModule decorator accepts an optional bootstrap array that may contain one or more components. Every Angular application has a bootstrapping module. Components listed in bootstrap are automatically included in the NgModule's declarations.",
	"BuildingBlocks - NgModules - Built-in - RootModule - bootstrap - bootstrapModule": "You can use the bootstrapModule method from either platformBrowser or platformServer to start an Angular application. When run, this function locates any elements on the page with a CSS selector that matches the listed componet(s) and renders those components on the page.",
	"BuildingBlocks - NgModules - Built-in - RootModule - bootstrap - bootstrapApplication": "Bootstraps an instance of an Angular application and renders a standalone component as the application's root component.",
	"BuildingBlocks - NgModules - Built-in - RootModule - bootstrap - process": "When you bootstrap an application from an NgModule, the collected providers of this module and all of the providers of its imports are eagerly loaded and available to inject for the entire application.",
	"BuildingBlocks - NgModules - Built-in - RouterModule": "a service that lets you define a navigation path among the different application states and view hierarchies in your app. Presents a component for anu URL. It is not part of the Angular core. It is in its own library package, @angular/router",
	"BuildingBlocks - NgModules - Built-in - BrowserModule": ".",
	"BuildingBlocks - NgModules - Built-in - FormsModule": "Exports the required providers and directives for template-driven forms, making them available for import by NgModules that import this module.",
	"BuildingBlocks - NgModules - Built-in - ReactiveFormsModule": "Exports the required infrastructure and directives for reactive forms, making them available for import by NgModules that import this module.",
	"BuildingBlocks - NgModules - Built-in - HttpClientModule": ".",
	"BuildingBlocks - NgModules - Built-in - FeatureModules": "Feature modules are NgModules for the purpose of organizing code.",
	"BuildingBlocks - NgModules - Built-in - FeatureModules - Domain": ".",
	"BuildingBlocks - NgModules - Built-in - FeatureModules - Routed": ".",
	"BuildingBlocks - NgModules - Built-in - FeatureModules - Routing": ".",
	"BuildingBlocks - NgModules - Built-in - FeatureModules - Service": ".",
	"BuildingBlocks - NgModules - Built-in - FeatureModules - Widget": ".",
	"BuildingBlocks - Components": "a component and template",
	"BuildingBlocks - Components - Structure - @Component": "each app has at least a root component",
	"BuildingBlocks - Components - Structure - @Component - Multiplicity": "A component can only be declared in one module. if we want to use our component in multiple modules Just wrap your component into a module. Why not create a components module?",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector": "Every component defines a CSS selector that determines how the component is used",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector - HostElement": "Angular creates an instance of a component for every HTML element that matches the component's selector. The DOM element that matches a component's selector is that component's host element. The contents of a component's template are rendered inside its host element.",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector - Types - Type": "Matches elements based on their HTML tag name, or node name. e.g. profile-photo",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector - Types - Type - Preferred": "The vast majority of components should use a custom element name as their selector. All custom element names should include a hyphen as described by the HTML specification. By default, Angular reports an error if it encounters a custom tag name that does not match any available components, preventing bugs due to mistyped component names.",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector - Types - Attribute": "Matches elements based on the presence of an HTML attribute and, optionally, an exact value for that attribute. e.g. [dropzone]",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector - Types - Attribute - use": "You should consider an attribute selector when you want to create a component on a standard native element. For example, if you want to create a custom button component, you can take advantage of the standard <button> element by using an attribute selector: selector: 'button[yt-upload]',",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector - Types - Class": "Matches elements based on the presence of a CSS class. e.g. .menu-item",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector - Types - Class - :not": "Angular supports the :not pseudo-class. You can append this pseudo-class to any other selector to narrow which elements a component's selector matches. For example, you could define a [dropzone] attribute selector and prevent matching textarea elements: selector: '[dropzone]:not(textarea)',",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector - Types - Combined": "You can combine multiple selectors by concatenating them. For example, you can match <button> elements that specify type='reset'. e.g. selector: 'button[type='reset']', ",
	"BuildingBlocks - Components - Structure - @Component - Properties - selector - Types - Combined - Comma": "You can also define multiple selectors with a comma-separated list: selector: 'drop-zone, [dropzone]',",
	"BuildingBlocks - Components - Structure - @Component - Properties - templateUrl": "The module-relative address of this component's HTML template. Alternatively, you can provide the HTML template inline, as the value of the template property. This template defines the component's host view.",
	"BuildingBlocks - Components - Structure - @Component - Properties - styleUrl": "Components can optionally include CSS styles that apply to that component's DOM.",
	"BuildingBlocks - Components - Structure - @Component - Properties - styleUrl - embedded": "styles: ` img { border-radius: 50%; } `,",
	"BuildingBlocks - Components - Structure - @Component - Properties - styleUrl - separated": "styleUrl: 'profile-photo.css',",
	"BuildingBlocks - Components - Structure - @Component - Properties - styleUrl - Scope": "Every component has a view encapsulation setting that determines how the framework scopes a component's styles. There are three view encapsulation modes: Emulated, ShadowDom, and None. You can specify the mode in the @Component decorator:",
	"BuildingBlocks - Components - Structure - @Component - Properties - styleUrl - Scope - Emulated": "By default, Angular uses emulated encapsulation so that a component's styles only apply to elements defined in that component's template. In this mode, the framework generates a unique HTML attribute for each component instance, adds that attribute to elements in the component's template, and inserts that attribute into the CSS selectors defined in your component's styles.",
	"BuildingBlocks - Components - Structure - @Component - Properties - styleUrl - Scope - ShadowDom": "This mode scopes styles within a component by using the web standard Shadow DOM API. When enabling this mode, Angular attaches a shadow root to the component's host element and renders the component's template and styles into the corresponding shadow tree. This mode strictly guarantees that only that component's styles apply to elements in the component's template. Global styles cannot affect elements in a shadow tree and styles inside the shadow tree cannot affect elements outside of that shadow tre",
	"BuildingBlocks - Components - Structure - @Component - Properties - styleUrl - Scope - None": "This mode disables all style encapsulation for the component. Any styles associated with the component behave as global styles.",
	"BuildingBlocks - Components - Structure - @Component - Properties - imports": "To use a component, directive, or pipe, you must add it to the imports array in the @Component decorator:",
	"BuildingBlocks - Components - Structure - @Component - Properties - standalone": "By default, Angular components are standalone, meaning that you can directly add them to the imports array of other components.",
	"BuildingBlocks - Components - Structure - @Component - Properties - standalone - Angular14": "Standalone Components allowed us to write components that didn’t need to rely on the old-school NgModules. Since then, standalone has matured, stabilized, and become the recommended way to write Angular apps.",
	"BuildingBlocks - Components - Structure - @Component - Properties - standalone - Angular19": "And now, in v19, Angular’s flipping the switch: standalone is the default for components, directives, and pipes. No more typing standalone: true—it’s baked in. Now, when you generate a new component, you won’t need to wrap it in a module or even explicitly mark it as standalone.",
	"BuildingBlocks - Components - Structure - @Component - Properties - providers": "An array of dependency injection providers for services that the component requires",
	"BuildingBlocks - Components - Structure - @Component - Properties - Host - hosts": "A component can bind properties, attributes, and events to its host element. This behaves identically to bindings on elements inside the component's template, but instead defined with the host property in the @Component decorator:",
	"BuildingBlocks - Components - Structure - @Component - Properties - Host - HostBinding": "@HostBinding lets you bind host properties and attributes to properties and methods:  @HostBinding('attr.aria-valuenow')",
	"BuildingBlocks - Components - Structure - @Component - Properties - Host - HostBinding - hostPropertyName": "The DOM property that is bound to a data property. This field also accepts: classes, prefixed by class. styles, prefixed by style. attributes, prefixed by attr.",
	"BuildingBlocks - Components - Structure - @Component - Properties - Host - HostListener": "@HostListener lets you bind event listeners to the host element. The decorator accepts an event name and an optional array of arguments: @HostListener('keydown', ['$event'])",
	"BuildingBlocks - Components - Structure - @Component - Properties - Host - HostListener - eventName": "The DOM event to listen for.",
	"BuildingBlocks - Components - Lifecycle": "constructor -> ngOnInit() -> ngOnChanges() -> ngDoCheck() -> ngAfterContentInit() -> ngAfterContentChecked() -> ngAfterViewInit() -> ngAfterViewChecked() -> ngOnDestroy()",
	"BuildingBlocks - Components - Lifecycle - Creation - constructor": "",
	"BuildingBlocks - Components - Lifecycle - Change - ngOnInit": "Runs once after Angular has initialized all the component's inputs.",
	"BuildingBlocks - Components - Lifecycle - Change - ngOnChanges": "Runs every time the component's inputs have changed.",
	"BuildingBlocks - Components - Lifecycle - Change - ngDoCheck": "Runs every time this component is checked for changes.",
	"BuildingBlocks - Components - Lifecycle - Change - ngAfterContentInit": "Runs once after the component's content has been initialized.",
	"BuildingBlocks - Components - Lifecycle - Change - ngAfterContentChecked": "Runs every time this component content has been checked for changes.",
	"BuildingBlocks - Components - Lifecycle - Change - ngAfterViewInit": "Runs once after the component's view has been initialized.",
	"BuildingBlocks - Components - Lifecycle - Change - ngAfterViewChecked": "Runs every time the component's view has been checked for changes.",
	"BuildingBlocks - Components - Lifecycle - Rendering - afterNextRender": "Runs once the next time that all components have been rendered to the DOM.",
	"BuildingBlocks - Components - Lifecycle - Rendering - afterRender": "Runs every time all components have been rendered to the DOM.",
	"BuildingBlocks - Components - Lifecycle - Destruction - ngOnDestroy": "Runs once before the component is destroyed.",
	"BuildingBlocks - Components - @angular/elements package": "exports a createCustomElement() API that provides a bridge from Angular's component interface and change detection functionality to the built-in DOM API",
	"BuildingBlocks - Router - RouterModule - Config - Singleton": "configures the router as singleton via the RouterModule.forRoot method, and adds the result to the AppModule's imports array",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray": "export const routes: Routes = [ { path: 'first-component', component: FirstComponent }, ... ];",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - path": ".",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - component": ".",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - Guards": "Guards in Angular provide a robust way to control navigation in your application. { path: 'first-component', component: FirstComponent, canActivate: [yourGuardFunction] }",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - Guards - registering": "To use the guard, you must provide it in your Angular module. @NgModule({ providers: [AuthGuard], })",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - Guards - Types - CanActivate": "The CanActivate guard checks whether a route can be activated. This is useful for protecting routes that should not be accessible unless certain conditions are met, like user authentication.",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - Guards - Types - CanActivateChild": "Similar to CanActivate, but it works on child routes. Useful for feature modules with multiple child routes.",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - Guards - Types - CanDeactivate": "This guard works when you're navigating away from a component. It is often used to warn the user about unsaved changes.",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - Guards - Types - CanLoad": "CanLoad checks if a module should be lazy-loaded or not. This is important if you want to prevent unauthorized users from downloading parts of your application.",
	"BuildingBlocks - Router - RouterModule - Config - 1-RoutesArray - Guards - Types - Resolve": "A Resolve guard fetches data before navigation completes. The data can be used to populate route parameters.",
	"BuildingBlocks - Router - RouterModule - Config - 2-AddRoutes": "<li><a routerLink='/first-component' routerLinkActive='active' ariaCurrentWhenActive='page'>First Component</a></li>",
	"BuildingBlocks - Router - RouterModule - Config - 2-AddRoutes - params - routerLink": "",
	"BuildingBlocks - Router - RouterModule - Config - 2-AddRoutes - params - routerLinkActive": "",
	"BuildingBlocks - Router - RouterModule - Config - 2-AddRoutes - Wildcard": "{ path: '**', component: <component-name> }",
	"BuildingBlocks - Router - RouterModule - Config - 2-AddRoutes - 404": "{ path: '**', component: PageNotFoundComponent }",
	"BuildingBlocks - Router - RouterModule - Config - 2-AddRoutes - redirect": "{ path: '',   redirectTo: '/first-component', pathMatch: 'full' }",
	"BuildingBlocks - Router - RouterModule - Config - 3-router-outlet": "The routed views render in the <router-outlet></router-outlet>",
	"BuildingBlocks - Router - RouterModule - Audit - State": "You can access the current RouterState from anywhere in the application using the Router service and the routerState property.",
	"BuildingBlocks - Router - RouterModule - Audit - events": "During each navigation, the Router emits navigation events through the Router.events property. NavigationStart, RouteConfigLoadStart, RouteConfigLoadEnd, RoutesRecognized, GuardsCheckStart, ChildActivationStart, ActivationStart, GuardsCheckEnd, ResolveStart, ResolveEnd, ActivationEnd, ChildActivationEnd, NavigationEnd, NavigationCancel, NavigationError, Scroll",
	"BuildingBlocks - Router - RouterModule - Resolvers": "A Resolver is a class that implements the Resolve interface of Angular Router. In fact, Resolver is a service that has to be [provided] in the root module. Basically, a Resolver acts like middleware, which can be executed before a component is loaded. They allow applications to retrieve data first from an API response before the component gets loaded, allowing for route navigation.",
	"BuildingBlocks - Router - RouterModule - <base href>": "<base href=''>",

	"Data": "SECTION",
	"Data - Props": ".",
	"Data - Props - Components - Inputs": "When you use a component, you commonly want to pass some data to it. A component specifies the data that it accepts by declaring inputs. input properties are similar to props.",
	"Data - Props - Components - Inputs - resolution": "Angular records inputs statically at compile-time. Inputs cannot be added or removed at run-time.",
	"Data - Props - Components - Inputs - Standard - InputSignal": "The input function returns an InputSignal. You can read the value by calling the signal: value = input(0);",
	"Data - Props - Components - Inputs - Standard - typed": "You can explicitly declare a type for the input by specifying a generic parameter to the function: value = input<number>();",
	"Data - Props - Components - Inputs - Standard - compute": "Create a computed expression that reads the value input: label = computed(() => `The slider's value is ${this.value()}`); ",
	"Data - Props - Components - Inputs - Standard - required": "You can declare that an input is required by calling input.required instead of input: value = input.required<number>();",
	"Data - Props - Components - Inputs - Standard - Alias": "You can specify the alias option to change the name of an input in templates. value = input(0, {alias: 'sliderValue'}); <custom-slider [sliderValue]='50' />",
	"Data - Props - Components - Inputs - Standard - Configured": "The input function accepts a config object as a second parameter that lets you change the way that input works.",
	"Data - Props - Components - Inputs - Standard - Configured - transform": "You can specify a transform function to change the value of an input when it's set by Angular. label = input('', {transform: trimString});",
	"Data - Props - Components - Inputs - Standard - Configured - transform - pure": "Input transform functions should always be pure functions. Relying on state outside the transform function can lead to unpredictable behavior.",
	"Data - Props - Components - Inputs - Standard - Configured - transform - type": "When you specify an input transform, the type of the transform function's parameter determines the types of values that can be set to the input in a template.",
	"Data - Props - Components - Inputs - Standard - Configured - transform - type - booleanAttribute": "booleanAttribute imitates the behavior of standard HTML boolean attributes, where the presence of the attribute indicates a 'true' value. However, Angular's booleanAttribute treats the literal string 'false' as the boolean false.",
	"Data - Props - Components - Inputs - Standard - Configured - transform - type - numberAttribute": "numberAttribute attempts to parse the given value to a number, producing NaN if parsing fails.",
	"Data - Props - Components - Inputs - Model": "Model inputs are a special type of input that enable a component to propagate new values back to its parent component.",
	"Data - Props - Components - Inputs - Model - 2WayBinding": "CustomSlider can write values into its value model input, which then propagates those values back to the volume property: template: '<custom-slider [(value)]='volume' />',",
	"Data - Props - Components - Inputs - Model - Events": "When you declare a model input in a component or directive, Angular automatically creates a corresponding output for that model. The output's name is the model input's name suffixed with 'Change'.",
	"Data - Props - Components - Inputs - Model - required": "You can mark a model input as required or provide an alias in the same way as a standard input.",
	"Data - Props - Components - Inputs - Model - Alias": "You can mark a model input as required or provide an alias in the same way as a standard input.",
	"Data - Props - Components - Inputs - Model - Configured": "Model inputs do not support input transforms.",
	"Data - Props - Components - Inputs - @Input": "While the Angular team recommends using the signal-based input function for new projects, the original decorator-based @Input API remains fully supported. <custom-slider [value]='50' /> @Input() value = 0;",
	"Data - Props - Components - Inputs - @Input - Configured": "The @Input decorator accepts a config object that lets you change the way that input works.",
	"Data - Props - Components - Inputs - @Input - Configured - required": "You can specify the required option to enforce that a given input must always have a value.",
	"Data - Props - Components - Inputs - @Input - Configured - transform": "You can specify a transform function to change the value of an input when it's set by Angular. This transform function works identically to transform functions for signal-based inputs described above.",
	"Data - Props - Components - Inputs - @Input - Configured - Alias": "You can specify the alias option to change the name of an input in templates. @Input({alias: 'sliderValue'}) value = 0;",
	"Data - Props - Components - Inputs - @Input - Configured - Setter": "When using decorator-based inputs, a property implemented with a getter and setter can be an input: ",
	"Data - Props - Components - Inputs - @Input - Configured - Getter": "",
	"Data - Props - Components - Inputs - @Input - Component": "In addition to the @Input decorator, you can also specify a component's inputs with the inputs property in the @Component decorator. This can be useful when a component inherits a property from a base class: inputs: ['disabled'],",
	"Data - Props - Components - Inputs - @Input - Component - Alias": "You can additionally specify an input alias in the inputs list by putting the alias after a colon in the string: inputs: ['disabled: sliderDisabled'],",
	"Data - Props - Components - Ouputs - CustomEvents": "Angular components can define custom events by assigning a property to the output function. <expandable-panel (panelClosed)='savePanelState()' /> - panelClosed = output<void>();",
	"Data - Props - Components - Ouputs - CustomEvents - OutputEmitterRef": "The output function returns an OutputEmitterRef.",
	"Data - Props - Components - Ouputs - CustomEvents - propagation": "Angular custom events do not bubble up the DOM. When extending a component class, outputs are inherited by the child class.",
	"Data - Props - Components - Ouputs - CustomEvents - names": "Output names are case-sensitive. Always use camelCase output names. Avoid prefixing output names with 'on'.",
	"Data - Props - Components - Ouputs - CustomEvents - names - alias": "<custom-slider (valueChanged)='saveVolume()'/>  changed = output({alias: 'valueChanged'});",
	"Data - Props - Components - Ouputs - CustomEvents - emit": "You can emit an event by calling the emit method on the OutputEmitterRef: this.panelClosed.emit();",
	"Data - Props - Components - Ouputs - CustomEvents - emit - data": "You can pass event data when calling emit: this.valueChanged.emit(7);",
	"Data - Props - Components - Ouputs - CustomEvents - subscribe": "When creating a component dynamically, you can programmatically subscribe to output events from the component instance. The OutputRef type includes a subscribe method:",
	"Data - Props - Components - Ouputs - CustomEvents - subscribe - OutputRefSubscription": "The subscribe function returns an OutputRefSubscription with an unsubscribe method:",
	"Data - Props - Components - Ouputs - CustomEvents - UNsubscribe": "eventSubscription.unsubscribe();",
	"Data - Props - Components - Ouputs - @Output": "While the Angular team recommends using the output function for new projects, the original decorator-based @Output API remains fully supported.",
	"Data - Props - Components - Ouputs - @Output - use": "You can alternatively define custom events by assigning a property to a new EventEmitter and adding the @Output decorator: @Output() panelClosed = new EventEmitter<void>();",
	"Data - Props - Components - Ouputs - @Output - name - Alias": "The @Output decorator accepts a parameter that lets you specify a different name for the event in a template: @Output('valueChanged') changed = new EventEmitter<number>(); - <custom-slider (valueChanged)='saveVolume()' />",
	"Data - Props - Components - Ouputs - Component": "In addition to the @Output decorator, you can also specify a component's outputs with the outputs property in the @Component decorator. This can be useful when a component inherits a property from a base class: outputs: ['valueChanged'],",
	"Data - Props - Components - Ouputs - Component - outputs": "outputs: ['valueChanged'],",
	"Data - Props - Components - Ouputs - Component - outputs - Alias": "You can additionally specify an output alias in the outputs list by putting the alias after a colon in the string: outputs: ['valueChanged: volumeChanged'],",
	"Data - Props - Components - Interaction": "component communication scenarios in which two or more components share information.",
	"Data - Props - Components - Interaction - InputOutput - Input": "Pass data from parent to child with input binding (1) Add @Input() title:string, to child, (2) Add childTitle:string = 'This text is passed to child', to parent, (3) do the binding in the template < child-selector [title]='childTitle' >< /child-selector >",
	"Data - Props - Components - Interaction - InputOutput - Input + Setter": "Intercept input property changes with a setter (1) Add @Input() set name(name: string) { ... } to child, (2) Add name attribute to parent (3) do the binding in the template < app-name-child [name]='name' >< /app-name-child >",
	"Data - Props - Components - Interaction - InputOutput - Input + ngOnChanges()": "Intercept input property changes with ngOnChanges() (1) Add @Input() major: number, to child, (2) Add major: number = 1, to parent, (3) do the binding in ngOnChanges() in child",
	"Data - Props - Components - Interaction - InputOutput - Output": "Parent listens for child event with EventEmitted as @Output() (1) Child exposed and EventEmitted as @Output() voted = new EventEmitter< boolean >(), (2) The parent binds an event handler called onVoted() that responds to the child event payload $event and updates a counter.",
	"Data - Props - Components - Interaction - LocalVariable": "Parent interacts with child via local variable",
	"Data - Props - Components - Interaction - LocalVariable - AddVariable": "(1) Place a template reference variable in children tag in parents template < countdown-timer #timer >< /countdown-timer >",
	"Data - Props - Components - Interaction - LocalVariable - UseVariable": "(2) Use the reference in parent to acces children's variables, e.g. timer.start()",
	"Data - Props - Components - Interaction - ViewChild": "The ViewChild decorator returns the first element that matches a given directive, component, or template reference selector.",
	"Data - Props - Components - Interaction - ViewChild - targets - Directive": "",
	"Data - Props - Components - Interaction - ViewChild - targets - DOMElements": "ViewChild makes it possible to access native DOM elements that have a template reference variable.",
	"Data - Props - Components - Interaction - ViewChild - targets - DOMElements - from": "@ViewChild('someInput') someInput!: ElementRef;",
	"Data - Props - Components - Interaction - ViewChild - targets - DOMElements - to": "<input #someInput placeholder='Your favorite sea creature'>",
	"Data - Props - Components - Interaction - ViewChild - targets - ChildComponents": "ViewChild makes it possible to access a child component and call methods or access instance variables that are available to the child.",
	"Data - Props - Components - Interaction - ViewChild - targets - ChildComponents - from": "@ViewChild(PupComponent) pup!: PupComponent;",
	"Data - Props - Components - Interaction - ViewChild - targets - ChildComponents - to": "export class PupComponent implements OnInit { ... }",
	"Data - Props - Components - Interaction - ViewChild - Inject": "Parent calls a @ViewChild() (1) Inject child component into parent with @ViewChild(CountdownTimerComponent) private timerComponent: CountdownTimerComponent,",
	"Data - Props - Components - Interaction - Services": "Parent and children communicate via a servicee",
	"Data - Props - Components - Interaction - Services - Subject": "",
	"Data - Props - Components - Interaction - Services - Subject - steps - 1.Declare": "(1) In Service: Declare service with Subject- private messageSubject = new Subject<string>();",
	"Data - Props - Components - Interaction - Services - Subject - steps - 2.Observable": "(2) In Service: Get Observable from Subject - messageObservable$ = this.messageSubject.asObservable(); best practice to expose only the Observable (using asObservable()) to prevent components from being able to emit values directly.",
	"Data - Props - Components - Interaction - Services - Subject - steps - 3.Method": "(3) In Service: Create method writes to the Observable - sendMessage(message: string) { this.messageSubject.next(message); }",
	"Data - Props - Components - Interaction - Services - Subject - steps - 4.Write": "(5) In Sender Component: use the method to write in the Observable - sendMessage(message: string) { this.dataService.sendMessage(message); }",
	"Data - Props - Components - Interaction - Services - Subject - steps - 5.Subscriber": "(4) In Receiver Component: Subscriber to Observable - this.subscription = this.dataService.messageObservable$ .subscribe(message => { ... }); ",
	"Data - Props - Components - Interaction - Services - Subject - type": "Consider using interfaces to type your Subjects",
	"Data - Props - Components - Interaction - Services - Subject - cleanup": "Implement proper cleanup using ngOnDestroy",
	"Data - Props - Components - Interaction - Services - Subject - errors": "Create a separate error Subject or use a state object that includes error information: interface State<T> { data: T | null; error: Error | null; }",
	"Data - Props - Components - Interaction - Services - Signals": "",
	"Data - Props - Components - Interaction - Services - Signals - Angular16": "A signal is a wrapper around a value that notifies interested consumers when that value changes. Signals can contain any value, from primitives to complex data structures.",
	"Data - Props - Components - Interaction - Services - Signals - steps - 1.Create": "const count = signal(0);",
	"Data - Props - Components - Interaction - Services - Signals - steps - 2.Read": "console.log('The count is: ' + count());",
	"Data - Props - Components - Interaction - Services - Signals - steps - 3.Write - set": "count.set(3);",
	"Data - Props - Components - Interaction - Services - Signals - steps - 4.Write - update": "count.update(value => value + 1);",
	"Data - Props - Components - Querying": "A component can define queries that find child elements and read values from their injectors.",
	"Data - Props - Components - Querying - View": "View queries retrieve results from the elements in the component's view — the elements defined in the component's own template. You can query for a single result with the viewChild function..",
	"Data - Props - Components - Querying - Content": "Content queries retrieve results from the elements in the component's content— the elements nested inside the component in the template where it's used. You can query for a single result with the contentChild function.",
	"Data - Props - Components - Querying - Required": "If some cases, especially with viewChild, you know with certainty that a specific child is always available. In other cases, you may want to strictly enforce that a specific child is present. For these cases, you can use a required query. header = viewChild.required(CustomCardHeader);",
	"Data - Props - Components - Querying - Locators": "This first parameter for each query decorator is its locator.",
	"Data - Props - Components - DOMInteraction": "Angular handles most DOM creation, updates, and removals for you. However, you might rarely need to directly interact with a component's DOM.",
	"Data - Props - Components - DOMInteraction - ElementRef": "Components can inject ElementRef to get a reference to the component's host element: console.log(elementRef.nativeElement);",
	"Data - Props - Components - DOMInteraction - Renderer2": "The Renderer2 class is an abstraction provided by Angular in the form of a service that allows to manipulate elements of your app without having to touch the DOM directly. This is the recommended approach because it then makes it easier to develop apps that can be rendered in environments that don’t have DOM access, like on the server, in a web worker or on native mobile.",
	"Data - State": ".",
	"Data - State - Management - Components": "Component state is the simplest form of state management in Angular. It involves storing data within individual components. Each component has its own state, and data is passed down through the component hierarchy using input and output bindings.",
	"Data - State - Management - Components - use": "This approach is suitable for small to moderately complex applications where data doesn't need to be shared extensively.",
	"Data - State - Management - Services": "Services act as centralized stores for application data.",
	"Data - State - Management - Services - use": "Ideal for medium to large-scale applications with asynchronous data and moderate complexity.",
	"Data - State - Management - Services - RxJS": ".",
	"Data - State - Management - Services - RxJS - Observables": "The most basic approach to state management in Angular uses services with observables.",
	"Data - State - Management - Services - RxJS - Subject": ".",
	"Data - State - Management - Services - RxJS - BehaviouralSubject": ".",
	"Data - State - Management - Services - Signals - Angular16": "A signal is a wrapper around a value that notifies interested consumers when that value changes. Signals can contain any value, from primitives to complex data structures.",
	"Data - State - Management - Services - ComputedSignals": "Computed signal are read-only signals that derive their value from other signals. You define computed signals using the computed function and specifying a derivation:",
	"Data - State - Management - Services - ComputedSignals - eval": "",
	"Data - State - Management - Services - ComputedSignals - memo": "",
	"Data - State - Management - Services - ComputedSignals - write": "You cannot directly assign values to a computed signal. That is, doubleCount.set(3); produces a compilation error, ",
	"Data - State - Management - NgRx": "NgRx provides a robust state management solution based on Redux principles. It introduces a unidirectional data flow and a centralized store for managing the application state.",
	"Data - State - Management - NgRx - use": "NgRx Store is most suitable for large and complex applications where state management becomes critical.",
	"Data - NgForms": ".",
	"Data - NgForms - FormsModule - TemplateDriven": "<form (ngSubmit)='onSubmit()' #heroForm='ngForm' >",
	"Data - NgForms - FormsModule - TemplateDriven - async": ".",
	"Data - NgForms - FormsModule - TemplateDriven - directive - ngForm": "Angular automatically creates and attaches an NgForm directive to the < form > tag. The ngForm directive supplements the form element with additional features. ngForm Directive: It gives access to the methods and properties of an Angular form instance by creating one.",
	"Data - NgForms - FormsModule - TemplateDriven - directive - ngModel": "Using ngModel to create declarative syntax makes form attributes having two-way data binding. <input name='first' ngModel required #first='ngModel'>",
	"Data - NgForms - FormsModule - TemplateDriven - directive - Validation": "Template-driven forms rely on directives in the template to create and manipulate the underlying object model.",
	"Data - NgForms - FormsModule - TemplateDriven - directive - Validation - types - Sync": "immediately return either a set of validation errors or null",
	"Data - NgForms - FormsModule - TemplateDriven - directive - Validation - types - Async": "return a Promise or Observable that later emits a set of validation errors or null",
	"Data - NgForms - FormsModule - TemplateDriven - directive - Validation - Built-in": "min, max, required, requiredTrue, email, minLegth, maxLength, pattern, nullVaidator, compose, composeAsync",
	"Data - NgForms - FormsModule - TemplateDriven - directive - Validation - Custom": "functions that take a control instance and immediately return either a set of validation errors or null",
	"Data - NgForms - FormsModule - TemplateDriven - directive - Validation - custom": "Create a function receiving AbstractControl as argument. Adding to template-driven forms or to Reactive Forms",
	"Data - NgForms - FormsModule - TemplateDriven - directive - ngSubmit": "",
	"Data - NgForms - ReactiveFormsModule - Reactive": ".",
	"Data - NgForms - ReactiveFormsModule - Reactive - state": "Each change to the form state returns a new state, which maintains the integrity of the model between changes.",
	"Data - NgForms - ReactiveFormsModule - Reactive - sync": ".",
	"Data - NgForms - ReactiveFormsModule - Reactive - observable": "Reactive forms are built around observable streams.",
	"Data - NgForms - ReactiveFormsModule - Reactive - Module - ReactiveFormsModule": "To use reactive form controls, import ReactiveFormsModule from the @angular/forms package and add it to your NgModule's imports array.",
	"Data - NgForms - ReactiveFormsModule - Reactive - directive - formGroup": "Associate the FormGroup model and view <form [formGroup]='profileForm'> ... </>",
	"Data - NgForms - ReactiveFormsModule - Reactive - FormBuilder": "Creating multiple form control instances manually can become very repetitive when dealing with multiple forms. The FormBuilder service provides convenience methods to handle generating controls. Underneath, the FormBuilder is creating and returning the instances in the same manner, but with much less work.",
	"Data - NgForms - ReactiveFormsModule - Reactive - FormBuilder - AbstractControl": "AbstractControl is the parent class of FormArray, FormGroup, and FormControl.",
	"Data - NgForms - ReactiveFormsModule - Reactive - FormBuilder - FormControl": "It communicates with an HTML Form element like input or select tag, this API handles the individual form value and validation state.",
	"Data - NgForms - ReactiveFormsModule - Reactive - FormBuilder - FormGroup": "FormGroup is a top-level API that maintains the values, properties and validation state of a group of AbstractControl instances in Angular.",
	"Data - NgForms - ReactiveFormsModule - Reactive - FormBuilder - FormArray": "A FormArray is an alternative to a FormGroup for managing any number of unnamed controls. As with FormGroup instances, you can dynamically insert and remove controls from a FormArray, and the FormArray instance's value and validation status is calculated from its child controls. However, you don't need to define a key for each control by name.",
	"Data - NgForms - ReactiveFormsModule - Reactive - Validation": "Add validator functions directly to the form control model (FormControl) in the component class. Angular then calls these functions whenever the value of the control changes.",
	"Data - NgForms - ReactiveFormsModule - Reactive - Validation - markAsXXXXX": "MarkAllAsTouched (Angular 8), markAsDirty,  markAsTouched, and  markAsPending.",
	"Data - DataFetching - HttpClientModule - HttpClient": "The HttpClientAPI rests on the XMLHttpRequest interface exposed by the browsers.",
	"Data - DataFetching - HttpClientModule - HttpClient - declare - @angular/http": "@angular/http (deprecated Angular 8.0)",
	"Data - DataFetching - HttpClientModule - HttpClient - declare - @angular/common/http": "offers a simplified client HTTP API (HttpClient) for Angular applications that rests on 2 options exposed by browsers: HttpXhrBackend that uses XmlHttpRequest API and JsonpClientBackend that uses JSONP technique.",
	"Data - DataFetching - HttpClientModule - HttpClient - inject": " providers: [ provideHttpClient(), ]",
	"Data - DataFetching - HttpClientModule - HttpClient - inject - withFetch": "",
	"Data - DataFetching - HttpClientModule - HttpClient - inject - withInterceptors": "",
	"Data - DataFetching - HttpClientModule - HttpClient - inject - withRequestsMadeViaParent": "",
	"Data - DataFetching - HttpClientModule - HttpClient - inject - withJsonpSupport": "",
	"Data - DataFetching - HttpClientModule - HttpClient - inject - withXsrfConfiguration": "",
	"Data - DataFetching - HttpClientModule - HttpClient - inject - withNoXsrfProtection": "",
	"Data - DataFetching - HttpClientModule - HttpClient - requests": "HttpClient has methods corresponding to the different HTTP verbs used to make requests, both to load data and to apply mutations on the server.",
	"Data - DataFetching - HttpClientModule - HttpClient - requests - fetch": "Each method returns an RxJS Observable which, when subscribed, sends the request and then emits the results when the server responds.",
	"Data - DataFetching - HttpClientModule - HttpClient - requests - fetch - GET": "return this.http.get< Hero >(this.heroesUrl, hero, httpOptions)",
	"Data - DataFetching - HttpClientModule - HttpClient - requests - fetch - URLParams": "const httpOptions = { params: new HttpParams().set('name', term) },",
	"Data - DataFetching - HttpClientModule - HttpClient - requests - fetch - Observable": "Observables created by HttpClient may be subscribed any number of times and will make a new backend request for each subscription.",
	"Data - DataFetching - HttpClientModule - HttpClient - requests - fetch - format": ".",
	"Data - DataFetching - HttpClientModule - HttpClient - requests - fetch - format - json": "JSON data of the given generic type",
	"Data - DataFetching - HttpClientModule - HttpClient - requests - fetch - format - text": "string data.",
	"Data - DataFetching - HttpClientModule - HttpClient - requests - fetch - format - arraybuffer": "ArrayBuffer containing the raw response bytes",
	"Data - DataFetching - HttpClientModule - HttpClient - requests - fetch - format - blob": "Blob instance.",
	"Data - DataFetching - HttpClientModule - HttpClient - requests - update - POST": "return this.http.post< Hero >(this.heroesUrl, hero, httpOptions)",
	"Data - DataFetching - HttpClientModule - HttpClient - requests - headers - Headers": "httpOptions.headers = httpOptions.headers.set('Authorization', 'my-new-auth-token'),",
	"Data - DataFetching - HttpClientModule - HttpClient - Interceptor": "With interception, you declare interceptors that inspect and transform HTTP requests from your application to the server.",
	"Data - DataFetching - HttpClientModule - HttpClient - Security - XSRFProtection": "By default, an interceptor sends this cookie on all mutating requests (POST, etc.) to relative URLs but not on GET/HEAD requests or on requests with an absolute URL.",

	"View": "SECTION",
	"View - Templates": "The template is simply an HTML view where binding controls can display data to the properties of the Angular component as side effects. Defines the DOM. < button (click)='deleteHero()' >Delete hero< /button >",
	"View - Templates - Location - *.component.ts": "Templates are usually found within either the template property of a *.component.ts file",
	"View - Templates - Location - *.component.html": "Templates can also be found on a *.component.html file.",
	"View - Templates - Render - Layouts - ng-content": "<ng-content> The <ng-content> element is neither a component nor DOM element. Instead, it is a special placeholder that tells Angular where to render content. Angular's compiler processes all <ng-content> elements at build-time. You cannot insert, remove, or modify <ng-content> at run time. You cannot add directives, styles, or arbitrary attributes to <ng-content>.",
	"View - Templates - Render - Layouts - ng-content - Multiple": "Angular supports projecting multiple different elements into different <ng-content> placeholders based on CSS selector. <ng-content select='card-title'></ng-content>",
	"View - Templates - Render - Layouts - ng-content - Fallback": "Angular can show fallback content for a component's <ng-content> placeholder if that component doesn't have any matching child content. You can specify fallback content by adding child content to the <ng-content> element itself.",
	"View - Templates - Render - Layouts - ng-content - Aliasing": "Angular supports a special attribute, ngProjectAs, that allows you to specify a CSS selector on any element. Whenever an element with ngProjectAs is checked against an <ng-content> placeholder, Angular compares against the ngProjectAs value instead of the element's identity:",
	"View - Templates - Render - Layouts - ng-template": "<ng-template> Angular element for rendering HTML. It is never displayed directly. Angular replaces the < ng-template > and its contents with a comment. Contains the template of the components. Also used when a template must be inserted in the DOM with Template Reference Variables",
	"View - Templates - Render - Layouts - ng-template - TemplateRef": "<ng-template> elements are represented as instances of the TemplateRef class.",
	"View - Templates - Render - Layouts - ng-container": "<ng-container> Groups multiple elements together or marks a location in a template without rendering a real element in the DOM.",
	"View - Templates - Render - Layouts - ng-container - ngTemplateOutlet": "take the template itself and instantiate it anywhere on the page, using the ngTemplateOutlet directive",
	"View - Templates - Variables": "Angular has two types of variable declarations in templates: local template variables and template reference variables.",
	"View - Templates - Variables - Local": "Angular's @let syntax allows you to define a local variable and re-use it across a template, similar to the JavaScript let syntax.",
	"View - Templates - Variables - Local - reassigned": "A key difference between @let and JavaScript's let is that @let cannot be reassigned after declaration.",
	"View - Templates - Variables - Local - scope": "@let declarations are scoped to the current view and its descendants. Angular creates a new view at component boundaries and wherever a template might contain dynamic content, such as control flow blocks, @defer blocks, or structural directives.",
	"View - Templates - Variables - References": "< input #phone placeholder='phone number' > A template reference variable is often a reference to a DOM element within a template. It can also be a reference to an Angular component or directive or a web component. You can use template reference variables to read information from one part of the template in another part of the same template.",
	"View - Templates - Variables - References - toDOM": "a DOM element within a template (including custom elements)",
	"View - Templates - Variables - References - toComponent": "<input #taskInput placeholder='Enter task name'>",
	"View - Templates - Variables - References - toDirective": "<section dropZone #firstZone='dropZone'> ... </section>",
	"View - Templates - Variables - References - toTemplateRef": ".",
	"View - Templates - Binding": "Angular supports 6 binding types between Component and DOM: Event binding (click), Property binding [hero], Attribute Binding [attr.colspan], interpolations {{hero.name}} and 2 way [(ngModel)]",
	"View - Templates - Binding - Output - 1-Property binding": "Sets a property. ng-bind-src (canonical form) vs [src]",
	"View - Templates - Binding - Output - 2-AttributeBinding": "< tr >< td [attr.colspan]='1 + 1' >One-Two< /td >< /tr >",
	"View - Templates - Binding - Output - 2-AttributeBinding - Class": "< div [class.special]='isSpecial' >Special< /div >",
	"View - Templates - Binding - Output - 2-AttributeBinding - Style": "< button [style.color]=\"isSpecial ? 'red' : 'green'\" >",
	"View - Templates - Binding - Output - 3-Interpolation": "Interpolation refers to embedding expressions into marked up text.",
	"View - Templates - Binding - Output - 3-Interpolation - {{ ... }}": "By default, interpolation uses the double curly braces {{ and }} as delimiters. <h3>Current customer: {{ currentCustomer }}</h3>",
	"View - Templates - Binding - Output - 3-Interpolation - ?.": "safe navigation operator ( ?. ). The current hero's name is {{currentHero?.name}}",
	"View - Templates - Binding - Output - 3-Interpolation - !": "non-null assertion operator. The hero's name is {{hero!.name}}",
	"View - Templates - Binding - Output - 3-Interpolation - $any": "you can use the $any cast function to cast the expression to the any type: {{$any(hero).marker}}",
	"View - Templates - Binding - Output - 4-ReferenceBinding": "ref-text (canonical form) vs #text",
	"View - Templates - Binding - Input - 5-EventBinding": "on-click (canonical form) vs (click)",
	"View - Templates - Binding - Input - 5-EventBinding - Event handler": "$event",
	"View - Templates - Binding - Both - 6-2WayBinding": "ng-model-src (canonical form) instead [(src)]",
	"View - Templates - Binding - Both - 6-2WayBinding - [(ngModel)]=": "< input [value]=\"currentHero.name\" input)=\"currentHero.name=$event.target.value\" >  === < input [ngModel]=\"currentHero.name\" (ngModelChange)=\"currentHero.name=$event\" >",
	"View - Templates - Pipes": "Pipes are simple functions to use in template expressions to accept an input value and return a transformed value.",
	"View - Templates - Pipes - Types": "When writing a custom pipe in Angular you can specify whether you define a pure or an impure pipe: pure: false/true",
	"View - Templates - Pipes - Types - Pure": "Pure function as a function that doesn’t have an internal state. A pure change is either a change to a primitive input value (String, Number, Boolean, Symbol) or a changed object reference (Date, Array, Function, Object).",
	"View - Templates - Pipes - Types - Impure": "Impure function as a function that has an internal state. An impure pipe is called often, as often as every keystroke or mouse-move.",
	"View - Templates - Pipes - Types - AsyncPipe": "The AsyncPipe accepts a Promise or Observable as input and subscribes to the input automatically, eventually returning the emitted values. The AsyncPipe is also stateful. The pipe maintains a subscription to the input Observable and keeps delivering values from that Observable as they arrive.",
	"View - Templates - Pipes - Creating - Built-in": "Angular comes with a stock of pipes such as DatePipe, UpperCasePipe, LowerCasePipe, CurrencyPipe, and PercentPipe. They are all available for use in any template.",
	"View - Templates - Pipes - Creating - Custom": "create a class with @Pipe decorator and implement the method transform() of the PipeTransform class.",
	"View - Templates - Pipes - Invoking - Arguments": "<p>Price is {{ price | currency : “USD$” : 0.00 }}</p> ",
	"View - Templates - Pipes - Chaining - Chain": "<p>Average is {{ average | uppercase | number}}</p> ",
	"View - Templates - Directives": "In Angular, directives are markers on a DOM element (such as an attribute, element name, comment, or CSS class) that tells Angular’s HTML compiler ($compile) to attach a specified behavior to that DOM element or transform the DOM element and its children.",
	"View - Templates - Directives - @Directive": "transfor the DOM: components, structural, attribute, predefined and custom directives",
	"View - Templates - Directives - Structural": "They typically change the DOM layout by adding or removing DOM elements. *ngFor=\"let hero of heroes\". *ngIf=\"selectedHero\"",
	"View - Templates - Directives - Structural - Built-in - *": "They usually have an asterisk (*) prefix.",
	"View - Templates - Directives - Structural - Built-in - Conditional - *ngIf": "Conditionally creates or disposes of subviews from the template.",
	"View - Templates - Directives - Structural - Built-in - Conditional - @if () { }": "",
	"View - Templates - Directives - Structural - Built-in - Conditional - @else if () { }": "",
	"View - Templates - Directives - Structural - Built-in - Conditional - @else { }": "",
	"View - Templates - Directives - Structural - Built-in - Conditional - *ngSwitch": "A set of directives that switch among alternative views.",
	"View - Templates - Directives - Structural - Built-in - Conditional - NgSwitchCase": "Structural directive that adds its element to the DOM when its bound value equals the switch value and removes its bound value when it doesn't equal the switch value.",
	"View - Templates - Directives - Structural - Built-in - Conditional - NgSwitchDefault": "Structural directive that adds its element to the DOM when there is no selected NgSwitchCase.",
	"View - Templates - Directives - Structural - Built-in - Conditional - @switch { }": "While the @if block is great for most scenarios, the @switch block provides an alternate syntax to conditionally render data. Its syntax closely resembles JavaScript's switch statement.",
	"View - Templates - Directives - Structural - Built-in - Loop - *ngFor": "Repeat a node for each item in a list.",
	"View - Templates - Directives - Structural - Built-in - Loop - *ngFor - with index": "< div *ngFor='let hero of heroes, let i=index' >{{i + 1}} - {{hero.name}}< /div >",
	"View - Templates - Directives - Structural - Built-in - Loop - *ngFor - with trackBy": "To customize the default tracking algorithm, NgForOf supports trackBy option. trackBy takes a function which has two arguments: index and item. If trackBy is given, Angular tracks changes by the return value of the function. < div *ngFor='let hero of heroes, trackBy: trackByHeroes' > <br/> trackByHeroes(index: number, heroes: any): string {   return heroes.name;  }  ",
	"View - Templates - Directives - Structural - Built-in - Loop - @for () { }": "The @for block loops through a collection and repeatedly renders the content of a block.",
	"View - Templates - Directives - Structural - Built-in - Loop - @for () { } - $count": "Number of items in a collection iterated over",
	"View - Templates - Directives - Structural - Built-in - Loop - @for () { } - $index": "Index of the current row",
	"View - Templates - Directives - Structural - Built-in - Loop - @for () { } - $first": "Whether the current row is the first row",
	"View - Templates - Directives - Structural - Built-in - Loop - @for () { } - $last": "Whether the current row is the last row",
	"View - Templates - Directives - Structural - Built-in - Loop - @for () { } - $even": "Whether the current row index is even",
	"View - Templates - Directives - Structural - Built-in - Loop - @for () { } - $odd": "Whether the current row index is odd",
	"View - Templates - Directives - Structural - Custom": "Custom structural directives allow you to manipulate the DOM’s structure based on certain conditions.",
	"View - Templates - Directives - Attribute": "They typically change the appearance or behavior of an element, component, or another directive. They typically don’t change the DOM layout. [(ngModel)]=\"hero.name\"",
	"View - Templates - Directives - Attribute - Built-in - NgClass": "",
	"View - Templates - Directives - Attribute - Built-in - NgClass - expresion": "<div [ngClass]=\"isSpecial ? 'special' : ''\">This div is special</div>",
	"View - Templates - Directives - Attribute - Built-in - NgClass - method": "To use NgClass with a method: 1. add the method to the component class. 2. In the template, add the ngClass property binding>",
	"View - Templates - Directives - Attribute - Built-in - NgStyle": "",
	"View - Templates - Directives - Attribute - Built-in - NgStyle - method": "To use NgStyle: 1. add a method to the component class. 2. add an ngStyle property binding",
	"View - Templates - Directives - Attribute - Built-in - NgModel": "Use the NgModel directive to display a data property and update that property when the user makes changes.",
	"View - Templates - Directives - Attribute - Built-in - NgModel - use": "Add an [(ngModel)] binding on an HTML <form> element and set it equal to the property <input [(ngModel)]='currentItem.name' id='example-ngModel'>",
	"View - Templates - Directives - Attribute - Built-in - NgModel - ControlValueAccessor": "The NgModel directive works for an element supported by a ControlValueAccessor. Angular provides value accessors for all of the basic HTML form elements.",
	"View - Templates - Directives - Attribute - Built-in - NgModel - DefaultValueAccessor": "To apply [(ngModel)] to a non-form built-in element or a third-party custom component, you have to write a value accessor. For more information, see the API documentation on DefaultValueAccessor.",
	"View - Templates - Directives - Attribute - Custom": "You can also write your own Attribute directives - ng generate directive highlight creates src/app/highlight.directive.ts, and a corresponding test file src/app/highlight.directive.spec.ts.",
	"View - Templates - Directives - Custom": "",
	"View - Templates - Directives - Custom - EventEmitter": "Directives typically raise custom events with an Angular EventEmitter. The directive creates an EventEmitter and exposes it as a property. The directive calls EventEmitter.emit(payload) to fire an event, passing in a message payload, which can be anything. Parent directives listen for the event by binding to this property and accessing the payload through the $event object.",
	"View - Templates - Directives - DirectiveCompositionAPI": "The directive composition API lets you apply directives to a component's host element from within the component TypeScript class.",
	"View - Templates - Directives - DirectiveCompositionAPI - Angular19": "",
	"View - Templates - Directives - DirectiveCompositionAPI - hostDirectives": "",
	"View - Templates - Directives - DirectiveCompositionAPI - hostDirectives - DI": "A component or directive that specifies hostDirectives can inject the instances of those host directives and vice versa.",
	"View - Templates - Directives - DirectiveCompositionAPI - hostDirectives - component": "You apply directives to a component by adding a hostDirectives property to a component's decorator. We call such directives host directives. hostDirectives: [MenuBehavior],",
	"View - Templates - Directives - DirectiveCompositionAPI - hostDirectives - component - compile": "Angular applies host directives statically at compile time. You cannot dynamically add directives at runtime.",
	"View - Templates - Directives - DirectiveCompositionAPI - hostDirectives - component - render": "When the framework renders a component, Angular also creates an instance of each host directive.",
	"View - Templates - Directives - DirectiveCompositionAPI - hostDirectives - component - inputs": "By explicitly specifying the inputs and outputs, consumers of the component with hostDirective can bind them in a template: <admin-menu menuId='top-menu' (menuClosed)='logMenuClosed()'>",
	"View - Templates - Directives - DirectiveCompositionAPI - hostDirectives - component - outputs": "",
	"View - Templates - Directives - DirectiveCompositionAPI - hostDirectives - component - alias": "Furthermore, you can alias inputs and outputs from hostDirective to customize the API of your component:",
	"View - Templates - Directives - DirectiveCompositionAPI - hostDirectives - directive": "You can also add hostDirectives to other directives, in addition to components. This enables the transitive aggregation of multiple behaviors.",
	"View - Templates - Directives - DirectiveCompositionAPI - hostDirectives - directive - order": "Host directives go through the same lifecycle as components and directives used directly in a template. However, host directives always execute their constructor, lifecycle hooks, and bindings before the component or directive on which they are applied.",
	"View - Internationalization": "For APP. Internationalization is the process of designing and preparing your APP to be usable in different languages.",
	"View - Internationalization - Localization": "For TEXT. Localization is the process of translating the TEXT of your internationalized app into specific languages for particular locales.",
	"View - Internationalization - Localization - translate": "(1) mark the text with a custom attribute, named i18n=\"<meaning>|<description>@@customId\" <br/><br/> (2) Add script to packages.json 'scripts': { 'i18n:extract': 'ng xi18n --output-path src/locales' } <br/><br/> (3) run npm run i18n:extract  <br/><br/> (4) open up scr/locales/messages.xlf. For each html element marked with the i18n directive, a trans-unit will be created.  <br/><br/> (5) create a new xlf file src/locales/messages.<locale>.xlf for each locale <br/><br/> (6) Add a script that builds the application for each locale we want to support on angular.json <br/><br/> (7) npm run start npm run start:fr -- --port 4201 <br/>  npm run start:gr -- --port 4202",

	"Logic": "SECTION",
	"Logic - Services": "Services helps us to share common business logic, data and functions with different components of an Angular application.",
	"Logic - Services - Structure": "The service itself is a class that CLI generated",
	"Logic - Services - Lifecycle - Creation - CLI": "ng generate service User.",
	"Logic - Services - Language": "The Angular Language Service is a way to get completions, errors, hints, and navigation inside your Angular templates whether they are external in an HTML file or embedded in annotations/decorators in a string. The Angular Language Service autodetects that you are opening an Angular file, reads your tsconfig.json file, finds all the templates you have in your application, and then provides language services for any templates that you open. npm install --save-dev @angular/language-service",
	"Logic - DI": "inject services. Service are implemented through dependency injection.",
	"Logic - DI - Providers": "Providers tell the injector how to create the service. They are used to define how a dependency should be instantiated.",
	"Logic - DI - Providers - Types": "A provider can be any object or value, but most of the time, it is a class that provides a service or functionality.",
	"Logic - DI - Providers - Types - Services - Injectable": "service is decorated with @Injectable() to make it a Provider",
	"Logic - DI - Providers - Types - Services - Injectable - providedIn": "By default, this decorator has a providedIn property, which creates a provider for the service. ",
	"Logic - DI - Injectors": "An Angular injector is responsible for creating service instances (relies on providers) and injecting them (into components, directives, pipes, and other services).",
	"Logic - DI - Injectors - Hierarchical": "Angular has a Hierarchical Dependency Injection system. An Angular application is a tree of components. Each component instance has its own injector. The tree of components parallels the tree of injectors.",
	"Logic - DI - Injectors - Hierarchical - Tuning": "While having this level of configurability sounds unnecessarily complicated, it allows you to fine-tune which dependency to use in your consuming code.",
	"Logic - DI - Injectors - Hierarchical - Resolution": "When a component requests a dependency, Angular tries to satisfy that dependency with a provider registered in that component's own injector. If the component's injector lacks the provider, it passes the request up to its parent component's injector. If that injector can't satisfy the request, it passes it along to its parent injector. The requests keep bubbling up until Angular finds an injector that can handle the request or runs out of ancestor injectors. If it runs out of ancestors, Angular throws an error.",
	"Logic - DI - Injectors - Hierarchical - Sandboxing": "Sometimes you want multiple instances of a service at the same level of the component hierarchy. A good example is a service that holds state for its companion component instance. You need a separate instance of the service for each component. Each service has its own work-state, isolated from the service-and-state of a different component. This is called sandboxing because each service and component instance has its own sandbox to play in..",
	"Logic - DI - Injectors - Creation - Auto": "You don't have to create injectors. Under the hood Angular creates an application-wide root injector for you during the bootstrap process. It creates additional child injectors as needed.",
	"Logic - DI - Injectors - Creation - Custom": "Creating a custom injector in Angular is straightforward. You can use the Injector.create() method to create an injector with specific providers. const customInjector = Injector.create({ providers: [ { provide: MyService, useClass: MyService }, ], });",
	"Logic - DI - Registration": "You must register a service provider with an injector, or it won't know how to create the service.",
	"Logic - DI - Registration - Scope - Platform": "A special singleton platform injector shared by all applications on the page.",
	"Logic - DI - Registration - Scope - Platform - Injectable - providedIn": "providedIn: 'platform'.",
	"Logic - DI - Registration - Scope - Root": "When you add a service provider to the root application injector, it’s available throughout the app. Another way to limit provider scope is by adding the service you want to limit to the component’s providers array. Providing a service in the component limits the service only to that component",
	"Logic - DI - Registration - Scope - Root - Bootstrap": "Angular creates an application-wide injector for you during the bootstrap process.",
	"Logic - DI - Registration - Scope - Root - CLI": "ng generate service - registers a provider with the root injector for your service by including provider metadata in the @Injectable decorator",
	"Logic - DI - Registration - Scope - Root - Injectable - providedIn": "providedIn: 'root' specifies that Angular should provide the service in the root injector.",
	"Logic - DI - Registration - Scope - Root - forRoot": "configure services and providers that are intended to be singletons and eager",
	"Logic - DI - Registration - Scope - Root - forChild() ": "provider that is visible only to the children modules of our module, in case they are lazy loaded. As each lazy module is loaded on demand, it has its own injector..",
	"Logic - DI - Registration - Scope - Root - Singleton": "Declare tha the service should be provided in the application root. Include the service in the AppModule or in a module that is only imported by the AppModule.",
	"Logic - DI - Registration - Scope - Root - preferred": "If you can get away with providing to the Root Injector so that you only have one instance of dependency for your application, then you should.",
	"Logic - DI - Registration - Scope - Module": "with a specific NgModule, the same instance of a service is available to all components in that NgModule.  at the component level, you get a new instance of the service with each new instance of that component",
	"Logic - DI - Registration - Scope - Module - Injectable - providedIn": "deprecated. @Injectable({ providedIn: UserModule, }). Specify that a service should be provided in a particular @NgModule. if you use providedIn, the injectable is registered as a provider of the Module without adding it to the providers of the module.",
	"Logic - DI - Registration - Scope - Module - providers": "You can configure the providers array to add fine-grained control to your providers [{ provide: MyService, howToProvide: OtherDependency }]",
	"Logic - DI - Registration - Scope - Module - providers - provide": "The provide property holds the token that serves as the key for both locating a dependency value and registering the provider",
	"Logic - DI - Registration - Scope - Module - providers - howToProvide": "",
	"Logic - DI - Registration - Scope - Module - providers - definition": "The second property is always a provider definition object, which you can think of as a recipe for creating the dependency value. There are many ways to create dependency values just as there are many ways to write a recipe: useClass (create new instance), useValue (provide a ready made object), useFactory (he provider is a factory function), useExisting (use existing instance)",
	"Logic - DI - Registration - Scope - Module - providers - howToProvide - useClass": "useClass - Replace the current dependency with a new instance of something else",
	"Logic - DI - Registration - Scope - Module - providers - howToProvide - useExisting": "useExisting - Replace the current dependency with an existing dependency",
	"Logic - DI - Registration - Scope - Module - providers - howToProvide - useValue": "useValue - Replace the current dependency with a new value",
	"Logic - DI - Registration - Scope - Module - providers - howToProvide - useFactory": "useFactory - Use a factory method to determine which dependency to use based on a dynamic value",
	"Logic - DI - Registration - Scope - Component - Constructor": "we can use our dependency in the application by injecting it into the consuming code as a constructor parameter: constructor(private myService: MyService) { }.",
	"Logic - DI - Registration - Scope - Component - @Inject - Angular14": "In Angular v14, you have a new option to use the inject() function instead of injecting the service into the consumer as a constructor parameter.",
	"Logic - DI - Registration - Scope - Component - @Inject - InjectionToken": "@Inject(INJECTION_TOKEN) where const export INJECTION_TOKEN = new InjectionToken<UserConfig>('userconfig', { providedIn: 'root', factory: () => defaultUserConfig }); ",
	"Logic - DI - Registration - Scope - Component - providers": "",
	"Logic - DI - Registration - Scope - Element": ".",
	"Logic - DI - Registration - Scope - Null": "Equivalent to undefined. The injectable is not provided in any scope automatically and must be",
	"Logic - DI - Registration - Scope - Null - Injectable - providedIn": "providedIn: 'null'.",
	"Logic - DI - Registration - Scope - Any": "Provides a unique instance in each lazy loaded module while all eagerly loaded modules share one instance.",
	"Logic - DI - Registration - Scope - Any - Injectable - providedIn": "providedIn: 'any'. This option is DEPRECATED.",

  "CICD - Bundling": "SECTION",
	"CICD - Bundling - Optimization - CodeReduction - Resources - OptimizeImages - NgOptimizedImage": "The NgOptimizedImage directive makes it easy to adopt performance best practices for loading images.",
	"CICD - Bundling - Optimization - CodeReduction - TreeShakable - Providers": "Tree shaking is the ability to remove code that is not referenced in an application from the final bundle.",
	"CICD - Bundling - Optimization - CodeReduction - TreeShakable - Providers - Angular6": "Tree-shakable providers give Angular the ability to remove services that are not used in your application from the final output. This significantly reduces the size of your bundles.",
	"CICD - Bundling - Optimization - CodeReduction - TreeShakable - Providers - Default": "Ideally, if an application is not injecting a service, it should not be included in the final output. However, it turns out that the Angular compiler cannot identify at build time if the service will be required or not. Because it's always possible to inject a service directly using injector.get(Service), Angular cannot identify all of the places in your code where this injection could happen, so it has no choice but to include the service in the injector regardless. Thus, services provided in modules are not tree-shakable.",
	"CICD - Bundling - Optimization - CodeReduction - TreeShakable - Providers - Configure": "To create providers that are tree-shakable, the information that used to be specified in the module should be specified in the @Injectable decorator on the service itself. @Injectable({ providedIn: 'root', useFactory: () => new Service('dependency'), })",
	"CICD - Bundling - Optimization - CodeFecthing - Loading - Router - Lazy": "{ path: '/student', loadChildren: './student/student.module#StudentModule' } <br/>Now, looks as: <br/>{ path: '/student', loadChildren: () => import('./student/student.module').then(s => s.StudentModule) } With standalone components, Angular’s routing system can now lazily load components at the route level much more easily.",
	"CICD - Bundling - Optimization - CodeFecthing - Loading - DeferrableViews - Angular17": "Deferrable Views: This one’s a game-changer for performance optimization. Standalone components can be lazy-loaded right in the template, making it easier than ever to defer loading parts of your app until they’re actually needed. This means faster load times and a smoother user experience.",
	"CICD - Bundling - Optimization - CodeFecthing - Loading - DeferrableViews - @defer": "Deferrable views, also known as @defer blocks, reduce the initial bundle size of your application by deferring the loading of code that is not strictly necessary for the initial rendering of a page.",
	"CICD - Bundling - Optimization - CodeFecthing - Loading - DeferrableViews - @defer - triggers": ".",
	"CICD - Bundling - Optimization - CodeFecthing - Loading - DeferrableViews - @defer - triggers - on idle": "Triggers when the browser is idle.",
	"CICD - Bundling - Optimization - CodeFecthing - Loading - DeferrableViews - @defer - triggers - on viewport": "Triggers when specified content enters the viewport",
	"CICD - Bundling - Optimization - CodeFecthing - Loading - DeferrableViews - @defer - triggers - on interaction": "Triggers when the user interacts with specified element.",
	"CICD - Bundling - Optimization - CodeFecthing - Loading - DeferrableViews - @defer - triggers - on hover": "Triggers when the mouse hovers over specified area.",
	"CICD - Bundling - Optimization - CodeFecthing - Loading - DeferrableViews - @defer - triggers - on immediate": "Triggers immediately after non-deferred content has finished rendering.",
	"CICD - Bundling - Optimization - CodeFecthing - Loading - DeferrableViews - @defer - triggers - on timer": "Triggers after a specific duration.",
	"CICD - Bundling - Optimization - CodeFecthing - Loading - DeferrableViews - @defer - triggers - when condition": "The when trigger accepts a custom conditional expression and loads the deferred content when the condition becomes truthy.",
	"CICD - Bundling - Optimization - CodeFecthing - Loading - DeferrableViews - @defer - triggers - prefetch": ".",
	"CICD - Bundling - Optimization - CodeFecthing - Loading - DeferrableViews - @placeholder": "The @placeholder is an optional block that declares what content to show before the @defer block is triggered.",
	"CICD - Bundling - Optimization - CodeFecthing - Loading - DeferrableViews - @loading": "The @loading block is an optional block that allows you to declare content that is shown while deferred dependencies are loading. It replaces the @placeholder block once loading is triggered.",
	"CICD - Bundling - Optimization - CodeFecthing - Loading - DeferrableViews - @loading - minimum": "minimum - the minimum amount of time that this placeholder should be shown",
	"CICD - Bundling - Optimization - CodeFecthing - Loading - DeferrableViews - @loading - after": "after - the amount of time to wait after loading begins before showing the loading template",
	"CICD - Bundling - Optimization - CodeFecthing - Loading - DeferrableViews - @error": "The @error block is an optional block that displays if deferred loading fails. Similar to @placeholder and @loading, the dependencies of the @error block are eagerly loaded.",
	"CICD - Bundling - Optimization - CodeFecthing - Loading - Differential - Angular8": "Differential loading lets you serve up different bundles to different browsers. This generally translates into two things: modern syntax and polyfills. On a newer browser that supports recent syntax changes in JavaScript (such as arrow functions in ES2015 or async functions in ES2017), it’d be great to ship to code as-is with as few polyfills as possible to keep download time low. On legacy browsers, we’ll need both transpiled code and more polyfills to make things work. This way, newer browsers aren’t punished for legacy browsers by having to load a massive bundle, but legacy browsers aren't left in the dust. Differential loading in Angular 8.0 forms a part of Manfred Steyer's project, ngx-build-modern. All bundling is done with the ng build command and the -prod extension, without requiring special actions.",
	"CICD - Bundling - tools - ng-packagr": "",

	"CICD - Building": "SECTION",
	"CICD - Building - Environments": "src/environments/ directory and configure the project to use file replacements. The project's src/environments/ directory contains the base configuration file, environment.ts, which provides the default configuration for production. You can override default values for additional environments, such as development and staging, in target-specific configuration files.",
	"CICD - Building - Environments - environment.ts - create": "ng generate environments",
	"CICD - Building - Environments - environment.ts - configure - configurations": "Modify the angular.json file to include the new environment configuration. Open the angular.json file and find the configurations section under projects > my-angular-app > architect > build.",
	"CICD - Building - Environments - environment.ts - configure - serve": "Additionally, update the serve options in the angular.json to include the new staging configuration",
	"CICD - Building - Environments - environment.ts - base": "The base file environment.ts, contains the default environment settings.",
	"CICD - Building - Environments - environment.ts - default": "The build command uses environment.ts as the build target when no environment is specified.",
	"CICD - Building - Environments - environment.ts - Production": "Angular app development is one of the most chosen services for web app development in today's time. And by default, Angular operates in debug mode that counts some affirmation checks and runs ChangeDetection twice. It will make sure that there are no unexpected changes to binding values.",
	"CICD - Building - Environments - ngx-env/builder": "ngx-env/builder makes managing environment variables in Angular projects a breeze.",
	"CICD - Building - Compilation - ng-build": "",
	"CICD - Building - Compilation - Types - JIT": "With JIT, the compilation happens during run-time in the browser. It is the default way used by Angular. The commands used for JIT compilation are – ng build ng serve ",
	"CICD - Building - Compilation - Types - AOT": "The code is rendered faster because it gets converted from TypeScript (or HTML) to JavaScript during the build process itself. AOT is more suitable for the production environment whereas JIT is much suited for local development. ng build --aot ng server –aot",
	"CICD - Building - Compilation - Types - AOT2": "AOT compilation in AngularJS app development helps convert the TypeScript code into polished JavaScript code and optimizes and compresses the entire code before running it. This is one of the primary features of Angular, which are default features used to increase website speeds.",
	"CICD - Bundling - Compilation - Types - SSR - Universal": "Angular Universal generates static application pages on the server through a process called server-side rendering (SSR).",
	"CICD - Building - Compilation - Compiler - AngularCLI": "Angular CLI automates the end-to-end development process. The app's initialization, configuration, and development process become straightforward and easy. With a CLI (Command Line Interface), we can create a new project, add new features, and run tests (unit tests and end-to-end tests) by just typing a few simple commands.",
	"CICD - Building - Compilation - Compiler - Bazel (Angular 8.0)": "CLI has integrated a new experimental build tool called Bazel.",
	"CICD - Building - Compilation - Compiler - Ivy (Angular 8.0)": "Ivy is a new template compiler to build next-gen rendering pipelines in the current version.",
	"CICD - Building - Compilation - Compiler - Ivy - advantages": "The advantages of Ivy are: Smaller Bundles. Reduced Payload Size. Faster Rebuild times. Enhance Backwards Compatibility . Pre-compiled Code shipment . Dismissal of metadata.json. Rise of meta programming. Improve template type checking. Broad Compatibility with existing Angular applications.",
	"CICD - Building - Compilation - Compiler - Ivy - local": "Recompile only the changed components and allow quicker compiling.",
	"CICD - Building - Compilation - Compiler - Ivy - treeshakable": "The unused code gets removed so that the application concentrates on the code used.",

  "CICD - Execution": "SECTION",
	"CICD - Execution - Threads - Multithreading - Workers - Service workers - Angular5": "@angular/service-worker A service worker is a script that runs in the web browser and manages caching for an application. Service workers function as a network proxy. They intercept all outgoing HTTP requests made by the application and can choose how to respond to them. For example, they can query a local cache and deliver a cached response if one is available.",
	"CICD - Execution - Threads - Multithreading - Workers - Service workers - manifest": "To support these behaviors, the Angular service worker loads a manifest file from the server. The manifest describes the resources to cache and includes hashes of every file's contents. When an update to the application is deployed, the contents of the manifest change, informing the service worker that a new version of the application should be downloaded and cached. This manifest is generated from a CLI-generated configuration file called ngsw-config.json.",
	"CICD - Execution - Threads - Multithreading - Workers - Service workers - installation": "Importing ServiceWorkerModule into your AppModule doesn't just register the service worker, it also provides a few services you can use to interact with the service worker and control the caching of your app.",
	"CICD - Execution - Threads - Multithreading - Workers - Service workers - bypass": "bypassing the service worker with a specified request: this.http.get(‘api/users’, { headers: { ‘ngsw-bypass’: true } });",

  "CICD - Audit": "SECTION",
	"CICD - Audit - debug - Angular Global (Angular9)": "The Angular team has exposed the global object ng, which is a lifesaver that makes the debugging process much easier.",
	"CICD - Audit - debug - Angular Global": "(1) ng serve --open (2) Open the browser developer console or press F12. (3) In the Console tab, type ng, and press Enter. All the default functions of the global ng object will be listed as shown in the following screenshot.",
	"CICD - Audit - test - TestBed": "The TestBed is the most important of the Angular testing utilities. The TestBed creates a dynamically-constructed Angular test module that emulates an Angular @NgModule.",
	"CICD - Audit - ChangeDetection - OnPush": "Change detection is one of the most common features developers use for app development. It can mainly detect when the user's data got altered or changed with updates of the DOM to reflect the changes.  <br/>Here, framework components have the information they use to obtain data from their parent components. Angular parses the component tree and contains the data for any difference from its previous value when an async event occurs.<br/>Through the strict equality operator, checking for any differences is done for the app performance. This operator checks for connection changes in the branch's inputs or components. And, thereby, a new memory allotment is done for the input's current values.",
	"CICD - Audit - ChangeDetection - Detach": "When you plan to develop a website with Angular, it follows a tree section with a change detector. We can infiltrate this change detector (ChangeDetectorRef) to detach the CD tree's element or connect it to the CD tree Therefore, when Angular runs CD on the element tree, its element with its sub-tree will be skipped. Developers execute this by the use of the ChangeDetectorRef class."

}