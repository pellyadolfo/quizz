{

	"Microservices": "SECTION",
	"Microservices 0": "https://www.linkedin.com/posts/brijpandeyji_if-youre-serious-about-building-agentic-activity-7316688827127877632-ykoc?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Microservices 1": "https://www.linkedin.com/posts/brijpandeyji_if-youre-serious-about-building-agentic-activity-7310872123235880960-VtCh?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Microservices 2": "https://www.linkedin.com/posts/brijpandeyji_premium-quality-free-api-courses-if-youre-activity-7320914227114729474-rIOw?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Microservices 3": "https://www.linkedin.com/posts/adityajaiswal7_from-monolith-to-microservices-devops-journey-activity-7317766593223041025--mpT?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Microservices 4": "https://www.linkedin.com/posts/josifha-ashmi-j-1770b4193_end-to-end-microservice-architecture-activity-7321027710422523904-fvAY?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Microservices 5": "https://www.linkedin.com/posts/yogita-jangra-973555204_graphql-vs-rest-api-activity-7324714714209419264-IR8R/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Microservices 6": "https://www.linkedin.com/posts/milan-jovanovic_the-best-way-to-build-microservices-starting-activity-7325765845928878082-UNH5/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Microservices 7": "https://www.linkedin.com/posts/adityajaiswal7_end-to-end-micro-services-architecture-with-activity-7319953494226923522-x-3I/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Microservices 8": "https://www.linkedin.com/posts/nikkisiapno_the-most-popular-database-caching-strategies-activity-7317494932640878595-wpnj?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Microservices 9": "https://www.linkedin.com/posts/vijay-kumar-anuganti_service-meshes-activity-7326968595110866945-pn_N?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Microservices 10": "https://www.linkedin.com/posts/bavicnative_master-istio-your-path-to-cloud-native-network-expertise-activity-7327543059934511104-JEfc/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Microservices 11": "https://www.linkedin.com/posts/shantanu-shende-17800a324_developer-backend-pythondeveloper-activity-7318113943007158272-Xs4s/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Microservices 13": "https://www.linkedin.com/posts/vijay-kumar-anuganti_service-meshes-activity-7326968595110866945-pn_N?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Microservices 14": "https://www.linkedin.com/posts/sabaribalajip_springboot-javadevelopers-realworldengineering-activity-7327531722386956289-XzpA?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Microservices 15": "",
	"Microservices 16": "",
	"Microservices 17": "",
	"Microservices 18": "",
	"Microservices 19": "",
	"Microservices 20": "",
	"Microservices - Monolithic": "Build an application with a monolithic architecture. For example: a single Java WAR file. a single directory hierarchy of Rails or NodeJS code",
	"Microservices - Microlith": "Microlith architectures represent a hybrid approach to software design, positioned between traditional monolithic systems and highly distributed microservices. Technically, a microlith consists of a compact, modular component that groups related functionalities into a single deployable unit",
	"Microservices - Microlith 0": "https://www.linkedin.com/posts/activity-7317191602723041280-LiaL/?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Microservices - Microlith - Decomposition": "Unlike microservices, which promote extreme decomposition into independently running services, microliths aim for a more balanced granularity—bundling tightly connected features together to simplify development and reduce the complexity of managing numerous services",
	"Microservices - Microlith - Decomposition - DDD": "Each microlith typically encapsulates its own logic and data and interacts with other components through well-defined APIs. This design encourages domain-driven development, allowing teams to focus on specific business capabilities while maintaining a scalable and maintainable architecture.",
	"Microservices - Microlith - Decomposition - Modular": "Modular units – Groups related features into a single component",
	"Microservices - Microlith - Deploy": "The rise of containerization (Docker) and orchestration tools (Kubernetes) has made deploying and managing microliths more efficient, facilitating agile workflows through practices like continuous integration, automated testing, and infrastructure automation",
	"Microservices - Microlith - Deploy - Independent": "Independent deployment – Can be updated without affecting others",
	"Microservices - Moduliths": "",
	"Microservices - NanoServices": "",
	"Microservices - SelfContainedSystems": "",
	"Microservices - SystemOfSystems": "",
	"Microservices - Microservice": "Loosely coupled collaborating services / self-contained deployment units.",
	"Microservices - Microservice - Priorities": "(4) Client > (1) CommunicationStyle > (5) Service > (2) Processing > (6) Middleware > (3) Storage",

	"Client": "SECTION",
	"Client - UI - Aggregation": "",
	"Client - UI - Aggregation - UIComposition": "Each team develops a client-side UI component, such an AngularJS directive, that implements the region of the page/screen for their service. A UI team is responsible implementing the page skeletons that build pages/screens by composing multiple, service-specific UI components.",
	"Client - UI - Aggregation - BFF": "Backends for Frontends Pattern (BFF): Creates dedicated backend services for each frontend, optimizing performance and user experience tailored to each platform.",
	"Client - UI - Aggregation - ServiceComposition": "Each team developers a web application that generates the HTML fragment that implements the region of the page for their service. A UI team is responsible for developing the page templates that build pages by performing server-side aggregation (e.g. server-side include style mechanism) of the service-specific HTML fragments.",
	"Client - UI - Patterns - RPC": "Use RPC for inter-service communication. The client uses a request/reply-based protocol to make requests to a service.",
	"Client - UI - Patterns - Messaging": "Use asynchronous messaging for inter-service communication. Services communicating by exchanging messages over messaging channels.",
	"Client - ServiceDiscovery": "Auto-discovery of microservices for seamless communication.",
	"Client - ServiceDiscovery - Registry": "Implement a service registry, which is a database of services, their instances and their locations.",
	"Client - ServiceDiscovery - Registry - Tools - etcd": "Discovery service protocol helps new etcd member to discover all other members in cluster bootstrap phase using a shared discovery URL.",
	"Client - ServiceDiscovery - Registry - Tools - Eureka": "",
	"Client - ServiceDiscovery - Registry - Tools - Consul": "",
	"Client - ServiceDiscovery - Registry - Tools - Zookeeper": "Tools like Zookeeper help manage and coordinate distributed services, ensuring they work together smoothly.",
	"Client - ServiceDiscovery - Registry - Tools - AlibabNacos": "",
	"Client - ServiceDiscovery - Registration": "Service instances are registered with the service registry on startup and deregistered on shutdown. Client of the service and/or routers query the service registry to find the available instances of a service. A service registry might invoke a service instance’s health check API to verify that it is able to handle requests",
	"Client - ServiceDiscovery - Registration - SelfRegistration": "A service instance is responsible for registering itself with the service registry. On startup the service instance registers itself (host and IP address) with the service registry and makes itself available for discovery. The client must typically periodically renew its registration so that the registry knows it is still alive. On shutdown, the service instance unregisters itself from the service registry.",
	"Client - ServiceDiscovery - Registration - 3rdPartyRegistration": "A 3rd party registrar is responsible for registering and unregistering a service instance with the service registry. When the service instance starts up, the registrar registers the service instance with the service registry. When the service instance shuts downs, the registrar unregisters the service instance from the service registry.",
	"Client - ServiceDiscovery - Discovery - ClientSide": "When making a request to a service, the client obtains the location of a service instance by querying a Service Registry, which knows the locations of all service instances.",
	"Client - ServiceDiscovery - Discovery - ServerSide": "When making a request to a service, the client makes a request via a router (a.k.a load balancer) that runs at a well known location. The router queries a service registry, which might be built into the router, and forwards the request to an available service instance.",
	"Client - ServiceDiscovery - Endpoints": "",
	"Client - ServiceDiscovery - Endpoints - Kubernetes - EndpointsAPI": "For kubernetes, services register their node information to Endpoints objects, so we can directly give deployment permissions to read the cluster's Endpoints object to get the node information.",
	"Client - ServiceDiscovery - DNS-SD": "DNS Service Discovery is an extensions to the DNS protocol to browse the network for services.",
	"Client - ServiceDiscovery - Standards - BDXL": "Business Document Metadata Service Location (BDXL)",
	"Client - ServiceDiscovery - Standards - SMP": "Service Metadata Publishing (SMP)",
	"Client - Caching": "Storing frequently used data in a temporary location that is faster to access than the original source.",
	"Client - Caching - Goal - access": "",
	"Client - Caching - Goal - load": "Cacheability isn't just about the transfer, it's also about decreasing server load in a lot of applications.",
	"Client - Caching - Layers": "HTTP caching involves client, forward proxy, reverse proxy and server.",
	"Client - Caching - Layers - Client": "",
	"Client - Caching - Layers - Client - CDN": "",
	"Client - Caching - Layers - Client - CDN - Static": "Cache static assets and public API responses at edge locations.",
	"Client - Caching - Layers - Client - CDN - Accept": "Configure cache keys by URL + headers (Accept, Accept-Language)",
	"Client - Caching - Layers - Client - CDN - TTL": "Typical TTL: 1 minute to 1 hour for dynamic content",
	"Client - Caching - Layers - Transport - Headers": "HTTP response headers: Expires, Cache-Control, ETag, Last-Modified",
	"Client - Caching - Layers - Transport - Headers - Cache-Control": "Use Cache-Control headers for browser caching",
	"Client - Caching - Layers - Transport - Headers - Expire": ".",
	"Client - Caching - Layers - Transport - Headers - ETag": "Implement ETag/Last-Modified for conditional requests. ETags (Entity Tags) are HTTP response headers (ETag) that act as unique identifiers for a specific version of a resource. They help browsers and servers determine whether a cached resource is still fresh or needs to be re-downloaded.",
	"Client - Caching - Layers - Transport - Headers - Last-Modified": "Implement ETag/Last-Modified for conditional requests",
	"Client - Caching - Layers - Transport - Headers - private, no-cache": "For dynamic content: private, no-cache with validation",
	"Client - Caching - Layers - Application": "",
	"Client - Caching - Layers - Database": "",
	"Client - Caching - Layers - Database - query": "Enable query cache (MySQL, PostgreSQL)",
	"Client - Caching - Layers - Database - materializedViews": "Use materialized views for complex queries",
	"Client - Caching - Layers - Database - memory": "Configure appropriate memory allocations",
	"Client - Caching - Strategies - Driver - Consumer - CacheAside": "Lazy Loading. First checks the cache. If data is found (a cache hit) use it. If not found (a cache miss), retrieves from database and store in cache.",
	"Client - Caching - Strategies - Driver - Provider - WriteThrough": "When data is updated, it is written to the cache and the database simultaneously.",
	"Client - Caching - Strategies - Driver - Provider - WriteBack": "Data is written to the cache first and then to the database 'asynchronously.",
	"Client - Caching - Strategies - Driver - Provider - WriteAround": "Bypasses the cache for writes, writing directly to the database. The cache is updated only on subsequent reads.",
	"Client - Caching - Strategies - Driver - Cache - ReadThrough": "The cache acts as data loader. If data isn't in the cache, it's retrieved from the database and stored in the cache.",
	"Client - Caching - Strategies - Driver - Cache - RefreshAhead": "The cache proactively refreshes data before it expires.",
	"Client - Caching - Strategies - Eviction": "Cache Invalidation.",
	"Client - Caching - Strategies - Eviction - TTL": "𝐓𝐢𝐦𝐞 𝐭𝐨 𝐋𝐢𝐯𝐞 (𝐓𝐓𝐋) - Items are evicted after a set time limit (expiry time). - Prevents stale data, useful in distributed systems. - Example: DNS records have TTL values, so if an IP address changes, clients don’t hold onto outdated mappings.",
	"Client - Caching - Strategies - Eviction - FIFO": "𝐅𝐢𝐫𝐬𝐭 𝐈𝐧, 𝐅𝐢𝐫𝐬𝐭 𝐎𝐮𝐭 (𝐅𝐈𝐅𝐎) - Evicts the oldest stored item first, regardless of usage. - Simple to implement but may remove still-relevant data. - Example: Simple queue-based caching systems.",
	"Client - Caching - Strategies - Eviction - LRU": "𝐋𝐞𝐚𝐬𝐭 𝐑𝐞𝐜𝐞𝐧𝐭𝐥𝐲 𝐔𝐬𝐞𝐝 (𝐋𝐑𝐔) - Removes the least recently accessed item first. - Works well when older data is less likely to be used again. - Example: Browsers use LRU to discard old pages from memory when opening new tabs.",
	"Client - Caching - Strategies - Eviction - LFU": "𝐋𝐞𝐚𝐬𝐭 𝐅𝐫𝐞𝐪𝐮𝐞𝐧𝐭𝐥𝐲 𝐔𝐬𝐞𝐝 (𝐋𝐅𝐔) - Evicts the least accessed items over time. - Prioritizes keeping frequently used items in cache. - Example: CDNs use LFU to keep trending videos in cache while removing rarely watched ones.",
	"Client - Caching - Strategies - Eviction - MRU": "𝐌𝐨𝐬𝐭 𝐑𝐞𝐜𝐞𝐧𝐭𝐥𝐲 𝐔𝐬𝐞𝐝 (𝐌𝐑𝐔) - Opposite of LRU – evicts the most recently accessed item first. - Useful when recent data becomes obsolete quickly. - Example: In a music streaming app, the last played song is less likely to be played again, making MRU a better choice.",
	"Client - Caching - Strategies - Eviction - RR": "𝐑𝐚𝐧𝐝𝐨𝐦 𝐑𝐞𝐩𝐥𝐚𝐜𝐞𝐦𝐞𝐧𝐭 (𝐑𝐑) - Randomly evicts an item when the cache is full. - Low overhead, but less predictable performance. - Example: Some network routers use RR for managing limited memory, avoiding complex eviction policies.",
	"Client - Caching - Strategies - Eviction - TT": "𝐓𝐰𝐨-𝐓𝐢𝐞𝐫𝐞𝐝 𝐂𝐚𝐜𝐡𝐢𝐧𝐠 - Uses a fast in-memory cache (e.g., Redis) & a slower persistent cache (e.g., disk-based). - Optimizes speed & storage by balancing hot and cold data. - Example: A CDN stores frequently accessed content in RAM (L1 cache) while keeping less-accessed content on disk (L2 cache) to balance performance and cost.",
	"Client - Caching - Tools - Redis": "",
	"Client - Caching - Tools - Memcache": "",
	"Client - Caching - Tools - VarnishCache": ".",
	"Client - Versioning": "",
	"Client - ResponseSize - Compression": "Request and response payloads can be compressed using algorithms such as gzip to reduce transmitted data volume. This speeds up upload and download times.",
	"Client - ResponseSize - Compression - Headers": "HTTP response headers: Accept-Encoding, Content-Encoding",
	"Client - ResponseSize - Pagination": "Pagination is a common optimization technique when result sets are large. By streaming results back to the client in pages, service responsiveness can be improved.",
	"Client - ResponseSize - Pagination - OffsetBased": "This technique uses an offset and a limit parameter to define the starting point and the number of records to return. Example: GET /orders?offset=0&limit=3 ",
	"Client - ResponseSize - Pagination - CursorBased": "This technique uses a cursor (a unique identifier) to mark the position in the dataset. Typically, the cursor is an encoded string that points to a specific record. Example: GET /orders?cursor=xxx ",
	"Client - ResponseSize - Pagination - PageBased": "This technique specifies the page number and the size of each page. Example: GET /items?page=2&size=3 ",
	"Client - ResponseSize - Pagination - KeysetBased": "This technique uses a key to filter the dataset, often the primary key or another indexed column. Example: GET /items?after_id=102&limit=3 ",
	"Client - ResponseSize - Pagination - TimeBased": "This technique uses a timestamp or date to paginate through records. Example: GET /items?start_time=xxx&end_time=yyy ",
	"Client - ResponseSize - Pagination - Hybrid": "This technique combines multiple pagination techniques to leverage their strengths. Example: Combining cursor and time-based pagination for efficient scrolling through time-ordered records. ",

	"CommunicationStyle": "SECTION",
	"CommunicationStyle - Patterns - SOAP": "A heavyweight protocol that uses XML-based messaging, offering strict security and reliability for enterprise applications. ",
	"CommunicationStyle - Patterns - REST": "",
	"CommunicationStyle - Patterns - GraphQL": "",
	"CommunicationStyle - Patterns - gRPC": "",
	"CommunicationStyle - Patterns - WebSocket": "",
	"CommunicationStyle - Discussion - ServiceComplexity": "REST: Simple, cacheable APIs - GraphQL: Complex, nested data needs",
	"CommunicationStyle - Discussion - RequirementsStability": "REST: Stable client requirements - GraphQL: Rapidly evolving client needs",
	"CommunicationStyle - Discussion - RealTime": "REST: NO - GraphQL: Real-time updates (subscriptions)",

	"Service": "SECTION",
	"Service - Reliability": ".",
	"Service - Reliability - Retries": "Auto-retry failed requests for resilience.",
	"Service - Reliability - Timeout": ".",
	"Service - Reliability - Failback": "Failback involves a full migration back to the production status quo—a recovery if you will—at the validated conclusion of a disaster. ",
	"Service - Reliability - Failover": "Failover refers to the process of automatically and seamlessly switching to a backup system or component when the primary system fails.",
	"Service - Reliability - CircuitBreaker": "Prevents cascading failures.",
	"Service - Reliability - CircuitBreaker - Tools - Hystrix": "",
	"Service - Reliability - CircuitBreaker - Tools - Istio": "",
	"Service - Reliability - CircuitBreaker - Tools - Resilience4j": "Resilience4j is a lightweight, easy-to-use library, which offers a powerful circuit breaker implementation inspired by Netflix Hystrix but designed with functional programming approach.",
	"Service - Reliability - CircuitBreaker - Tools - Sentinel": "It is an open-source library that provides monitoring of services and controls the traffic. It can be used to implement circuit breaking, rate limiting. Sentinel can work in both Java and other languages.",
	"Service - Reliability - CircuitBreaker - Tools - AmazonAppMesh": "Amazon App Mesh is a managed service mesh that allows you to monitor and control services running on AWS.",
	"Service - Reliability - Bulkhead": "Compartmentalize your application's resources so that failure of any one of your dependencies is not propagated into the entire system",
	"Service - Reliability - Bulkhead - Tools - Resilience4j": "",
	"Service - Reliability - Redundancy": "",
	"Service - Publishing - WAF": "HTTP - WAFs analyze HTTP traffic for malicious requests.",
	"Service - Publishing - WAF - Layer7": ".",
	"Service - Publishing - APIGateway": "API gateway is the single entry point for all clients. API Gateway is primarily meant for external client-to-service communication.",
	"Service - Publishing - APIGateway - Location": "An API Gateway acts as a gatekeeper for microservices.",
	"Service - Publishing - APIGateway - Functions - traffic": "Traffic manager at Layer 7 of OSI Model. The main purpose of an API gateway is to accept traffic from outside your network and distribute it internally.",
	"Service - Publishing - APIGateway - Functions - traffic - Input - SingleInteractionPoint": "By serving as the central point of communication, API Gateway streamlines interactions.",
	"Service - Publishing - APIGateway - Functions - traffic - Routing - LoadBalancing": "Load Balancing: Distributes incoming API requests across multiple backend services to ensure availability and performance.",
	"Service - Publishing - APIGateway - Functions - traffic - Routing - RequestRouting": "Request Routing: Directs API calls (proxied or broadcasted) to the appropriate backend services based on rules or conditions.",
	"Service - Publishing - APIGateway - Functions - traffic - Output - ResultsAggregation": "The Gateway aggregates results from disparate services, providing a consolidated response to the client, thus improving efficiency.",
	"Service - Publishing - APIGateway - Functions - security": "Security.",
	"Service - Publishing - APIGateway - Functions - security - SSL": "SSL/TLS Termination: Encrypts data in transit to ensure secure communication.",
	"Service - Publishing - APIGateway - Functions - security - DDoS": "Mitigates Distributed Denial of Service (DDoS) attacks by blocking malicious traffic.",
	"Service - Publishing - APIGateway - Functions - security - DDoS - RateLimiting": "Sets a cap on the number of requests that can be made to an API within a specified time frame.",
	"Service - Publishing - APIGateway - Functions - security - DDoS - Throttling": "Throttling doesn’t block requests but slows down the rate at which requests are processed.",
	"Service - Publishing - APIGateway - Functions - security - CircuitBreaker": "Circuit Breaker: Act as a circuit breaker to prevent a single failed microservice from bringing down the entire system.",
	"Service - Publishing - APIGateway - Functions - security - Authentication": "API Gateway centralizes authentication and authorization, managing security protocols centrally and ensuring secure communication between clients and services. Supports OAuth, JWT, API keys, and other authentication methods to secure APIs..",
	"Service - Publishing - APIGateway - Functions - security - Validation": "Request and Response validation: Validate the microservice requests and responses and ensure they conform to the expected format and structure. This helps prevent errors and ensure the proper functioning of the microservice.",
	"Service - Publishing - APIGateway - Functions - security - CORS": "Cross-Origin Resource Sharing (CORS) Management: Handling requests from other domains.",
	"Service - Publishing - APIGateway - Functions - security - ErrorHandling": "Error Handling: Provide a consistent way to handle errors and generate error responses to clients even when backend services are unavailable or return unexpected results.",
	"Service - Publishing - APIGateway - Functions - performance": ".",
	"Service - Publishing - APIGateway - Functions - performance - Caching": "Caching: Stores frequent API responses to reduce latency and improve performance.",
	"Service - Publishing - APIGateway - Functions - formatting": "Protocol & Format Handling",
	"Service - Publishing - APIGateway - Functions - formatting - Translation": "Protocol Translation: Supports REST, GraphQL, gRPC, WebSockets, and SOAP to accommodate different communication methods.",
	"Service - Publishing - APIGateway - Functions - formatting - FormatHandling": "Request/Response Transformation: Modifies incoming and outgoing requests, such as converting XML to JSON.",
	"Service - Publishing - APIGateway - Functions - formatting - Transformation": "Request and Response Transformation: Modifying requests and responses for compatibility. It can translate between protocols. For example, if a client sends a request using HTTP/1.1, but the backend service expects requests in gRPC format, the API Gateway can translate the HTTP request into a gRPC request before forwarding it to the backend service. Likewise, when the backend service responds with data in gRPC format, the API Gateway can translate it back into HTTP format before sending it back to the client.",
	"Service - Publishing - APIGateway - Functions - integration": "Integration & Automation",
	"Service - Publishing - APIGateway - Functions - integration - Discovery": "Backend Service Discovery: Dynamically connects with backend services using service registries.",
	"Service - Publishing - APIGateway - Functions - integration - EDA": "Webhooks & Event-Driven Integration: Supports event-based workflows for real-time API interactions.",
	"Service - Publishing - APIGateway - Functions - lifecycle": "Developer Experience & API Lifecycle Management",
	"Service - Publishing - APIGateway - Functions - lifecycle - Versioning": "API Versioning: Allows multiple API versions to coexist, making updates easier.",
	"Service - Publishing - APIGateway - Functions - lifecycle - Mock": "Mock Responses & Testing: Enables testing API behavior without backend implementation.",
	"Service - Publishing - APIGateway - Functions - lifecycle - Documentation": "API Documentation & Developer Portals: Provides auto-generated documentation and interactive portals for developers.",
	"Service - Publishing - APIGateway - Functions - audit": "",
	"Service - Publishing - APIGateway - Functions - audit - logging": "Logging & Monitoring: Tracks API usage and performance with logging tools like AWS CloudWatch or Prometheus.",
	"Service - Publishing - APIGateway - Functions - audit - metrics": "Analytics & Metrics: Provides insights into API usage patterns, error rates, and latency for better decision-making.",
	"Service - Publishing - APIGateway - Functions - audit - metering": "API Metering and Billing: Tracking API usage for reporting and billing.",
	"Service - Publishing - APIGateway - Tools - Kong API Gateway": ".",
	"Service - Publishing - APIGateway - Tools - NGINX API Gateway": ".",
	"Service - Publishing - APIGateway - Tools - AWS API Gateway": ".",
	"Service - Publishing - APIGateway - Tools - Apigee (Google Cloud)": ".",
	"Service - Publishing - APIGateway - Tools - Azure API Management": ".",
	"Service - Publishing - APIGateway - Tools - SpringCloudGateway": ".",
	"Service - Publishing - APIGateway - Tools - WSO2": ".",
	"Service - Publishing - APIGateway - Tools - Ocelot": ".",
	"Service - Publishing - APIGateway - Tools - Traefik": ".",
	"Service - Publishing - Comparison - APIGateway vs LoadBalancer vs ReverseProxy": "While load balancers, reverse proxies, and API Gateways share the goal of optimizing and managing web traffic, they serve distinct functions:",
	"Service - Publishing - Comparison - APIGateway vs LoadBalancer vs ReverseProxy - LoadBalancer": "Distributing traffic among servers. Used to handle heavy traffic and ensure even load distribution.",
	"Service - Publishing - Comparison - APIGateway vs LoadBalancer vs ReverseProxy - ReverseProxy": "Acts as an intermediary between clients and servers, providing security and control. Manages SSL encryption, serves static content, and controls access to internal servers.",
	"Service - Publishing - Comparison - APIGateway vs LoadBalancer vs ReverseProxy - APIGateway": "Manages interactions between clients and backend services in a microservices architecture. Provides functionalities like routing, aggregation, and security in addition to handling requests.",
	"Service - Security": ".",

	"Processing": "SECTION",
	"Processing - Decomposition": "",
	"Processing - Decomposition - IDEALS": "IDEALS is considered an equivalent of the SOLID principles from object oriented design in the world of microservices.",
	"Processing - Decomposition - IDEALS - InterfaceSegregation": "Interfaces catering to the specific needs of each type of client. DDD",
	"Processing - Decomposition - IDEALS - Deployability": "Ability to deploy each service independently.",
	"Processing - Decomposition - IDEALS - EventDriven": "Availability over consistency, services to be activated by an asynchronous message or event instead of a synchronous call.  ",
	"Processing - Decomposition - IDEALS - AvailabilityOverConsistency": "Microservices sacrify consistency to improve availabity (CAP Theorem). Okay with eventual consistency.",
	"Processing - Decomposition - IDEALS - LooseCoupling": "LooseCoupling.",
	"Processing - Decomposition - IDEALS - SRP": "The original Single Responsibility Principle (SRP) is about having cohesive functionality in an OO class.",
	"Processing - Decomposition - DDD": "",
	"Processing - Aggregation": "",
	"Processing - Aggregation - Hosting - ServicePerContainer": "Package the service as a (Docker) container image and deploy each service instance as a container",
	"Processing - Aggregation - Hosting - ServicePerVM": "Package the service as a virtual machine image and deploy each service instance as a separate VM",
	"Processing - Aggregation - Hosting - ServicePerHost": "Deploy each single service instance on its own host",
	"Processing - Aggregation - Hosting - MultiServicePerHost": "Run multiple instances of different services on a host (Physical or Virtual machine). There are various ways of deploying a service instance on a shared host including: Deploy each service instance as a JVM process. For example, a Tomcat or Jetty instances per service instance. Deploy multiple service instances in the same JVM. For example, as web applications or OSGI bundles.",

	"Middleware": "SECTION",
	"Middleware - ServiceToService - ServiceMesh": "A service mesh is a configurable infrastructure layer for microservices that makes communication between service instances flexible, reliable, and fast. The mesh provides service discovery, load balancing, encryption, authentication and authorization, support for the circuit breaker pattern, and other capabilities.",
	"Middleware - ServiceToService - ServiceMesh - Structure": "This layer is composed of containerized microservices.",
	"Middleware - ServiceToService - ServiceMesh - Functions - traffic - Intercommunication": "A service mesh's primary purpose is to manage internal service-to-service communication.",
	"Middleware - ServiceToService - ServiceMesh - Functions - traffic - LoadBalancing": ".",
	"Middleware - ServiceToService - ServiceMesh - Functions - traffic - Routing": "The main purpose of a service mesh is to route and manage traffic within your network.",
	"Middleware - ServiceToService - ServiceMesh - Functions - reliability - Retries": ".",
	"Middleware - ServiceToService - ServiceMesh - Functions - reliability - Timeouts": ".",
	"Middleware - ServiceToService - ServiceMesh - Functions - security - mTLSEncryption": ".",
	"Middleware - ServiceToService - ServiceMesh - Functions - observability - logging": ".",
	"Middleware - ServiceToService - ServiceMesh - Functions - observability - tracing": ".",
	"Middleware - ServiceToService - ServiceMesh - Functions - observability - monitoring": ".",
	"Middleware - ServiceToService - ServiceMesh - Functions - error - FailureHandling": ".",
	"Middleware - ServiceToService - ServiceMesh - Tools - Istio": "",
	"Middleware - ServiceToService - ServiceMesh - Tools - Linkerd": "",
	"Middleware - ServiceToBackend - Outbox": "In this method, Domain Events are not written directly to a event bus. Instead of that, it is written to a table in the 'outbox' role of the service that stores the event in its own database. The second step is to receive these events written to the outbox table by an independent service and write them to the event bus.",
	"Middleware - ServiceToBackend - Outbox - Pros": "Pros + Guarantees atomic database updates and event publishing + Avoids event loss",
	"Middleware - ServiceToBackend - Outbox - Cons": "Cons - Requires polling and operational overhead - Adds slight latency (eventual consistency)",
	"Middleware - ServiceToBackend - EventBus": " - Facilitates communication between microservices through an event-driven architecture. - Ensures asynchronous processing of events across services.",
	"Middleware - ServiceToBackend - EDA": "Each service emits and reacts to events (via Kafka, RabbitMQ, etc.), enabling decentralized control.",
	"Middleware - ServiceToBackend - EDA - Pros": "Pros + Loosely coupled services + Scalable and fault-tolerant + Resilient to service downtime Cons - Harder to trace/debug workflows - Eventual consistency",
	"Middleware - ServiceToBackend - EDA - Cons": "Cons - Harder to trace/debug workflows - Eventual consistency",

	"Storage": "SECTION",
	"Storage - Consistency": "Eventual Consistency.",
	"Storage - Consistency - Approaches": "3 inconsistency approaches: remove by design, address, accept",
	"Storage - Consistency - Approaches - EventSourcing+CQRS": "(1) remove inconsistenct by design (event sourcing + CQRS)",
	"Storage - Consistency - Approaches - SAGA": "(2) address the inconsistency (saga)",
	"Storage - Consistency - Approaches - accept": "(3) accept the inconsistency",
	"Storage - State - Stateless": "Stateless microservices do not maintain any state or store session-specific data between requests. Each request a stateless microservice receives is processed independently, without relying on previous interactions.",
	"Storage - State - Stateful": " Stateful microservices are those that maintain the state of user sessions or interactions. Scaling, load balancing... becomes difficult.",
	"Storage - Aggregation - DB - DatabasePerService": "Each service manages its own data. Promotes loose coupling but requires eventual consistency handling.",
	"Storage - Aggregation - DB - SharedDatabase": "Use a (single) database that is shared by multiple services. Each service freely accesses data owned by other services using local ACID transactions.",

	"CI": "SECTION",
	"CI - Code - Chassis": "A base framework or even another service which can be reused across different services. This pattern cuts down on the redundancy factor and complexity across services by abstracting the common logic to a separate layer.",
	"CI - Packaging - Sidecar": "In a microservice architecture, it’s very common to have multiple services/apps that often require common functionalities like logging, configuration, monitoring & networking services. These functionalities can be implemented and run as a separate service within the same container or in a separate container. A sidecar pattern is a single-node pattern made up of two containers.",
	"CI - Packaging - Sidecar - application": "The first is the application container which contains the core logic of the application (primary application). Without this container, application wouldn’t exist.",
	"CI - Packaging - Sidecar - sidecar": "In addition, there is a Sidecar container used to extend/enhance the functionalities of the primary application by running another container in parallel on the same container group (Pod). Since sidecar runs on the same Pod as the main application container it shares the resources — filesystem, disk, network etc.,",
	"CI - Testing": "Unit Testing, Integration Testing, Contract Testing, End-to-End Testing",
	"CI - Testing - TestCases - Negative": "These verify how the API handles invalid inputs, errors, and edge cases.",
	"CI - Testing - TestCases - Positive": "These verify that the API works as expected under normal conditions.",
	"CI - Testing - TestCases - SchemaValidation": "Schema validation ensures that the structure, data types, and format of API responses and requests match the expected schema (usually defined in JSON Schema, OpenAPI/Swagger, or XML Schema). It checks if the API adheres to its contract, preventing unexpected data issues.",
	"CI - Testing - TestCases - SchemaValidation - Manual - Postman": "Use the pm.response.to.have.jsonSchema() assertion.",
	"CI - Testing - TestCases - SchemaValidation - Manual - Ajv": "Fast JSON schema JS validator",
	"CI - Testing - TestCases - SchemaValidation - Automated - chai-json-schema": ".",
	"CI - Testing - TestCases - SchemaValidation - Automated - Pact": "Contract testing with schema validation",
	"CI - Testing - TestCases - SchemaValidation - Automated - RestAssured": ".body(matchesJsonSchemaInClasspath())",
	"CI - Testing - Types - UnitTesting": "The scope of unit testing can be sociable or solitary concerning a service. The smaller the unit will be under test, the easier it is to determine the behavior of modules and probe the collaborators as well as interactions between objects and their dependencies. Since the cyclomatic complexity of the unit is inferior, Quality Analysis (QA) engineers can evaluate whether or not the units are isolated from their collaborators by using this testing strategy. Both the sociable and solitary unit testing styles are frequently used simultaneously in the same codebase to tackle different testing issues. The motive behind testing the domain layer is to emulate DML statements and certify that all collaborators use the real domain objects in correct sequence. During the unit testing, engineers can verify the logic used to generate map responses or other requests from external remote dependencies. As far as resources and service layer are concerned, they validate that each component correctly interacts with its collaborator, thereby monitoring the request/response cycle in a repeatable and consistent manner.",
	"CI - Testing - Types - UnitTesting - RestAssured": "✅ Real-time API testing scenarios ✅ Serialization & Deserialization ✅ Auth mechanisms (Basic, OAuth2, Bearer Tokens) ✅ Schema Validation, File Upload/Download ✅ TestNG Parallel Execution setup ✅ Mocking APIs, Caching, Rate Limiting https://www.linkedin.com/posts/neha-sharma-0a0906148_restapi-activity-7317064488115953664-LIY7?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"CI - Testing - Types - UnitTesting - SoapUI": "",
	"CI - Testing - Types - UnitTesting - Postman": "",
	"CI - Testing - Types - UnitTesting - Insomnia": "",
	"CI - Testing - Types - Mocking": "",
	"CI - Testing - Types - Mocking - Tools - WireMock": "",
	"CI - Testing - Types - Mocking - Tools - Mockoon": "",
	"CI - Testing - Types - RegressionTesting": "This test ensures that bug fixes or new features shouldn’t break the existing behaviors of APIs.",
	"CI - Testing - Types - ContractTesting": "Contract testing is a sort of a black box that verifies the contract between an external service call and its API provider endpoint. There are two types of contract testing, including: Integration contract testing, Consumer-driven contract testing",
	"CI - Testing - Types - ContractTesting - Integration contract testing": "In integration contract testing, each component needs to be called independently, and it must meet the contract agreement anticipated by a consuming service. The best way to deal with this is to carry out a test against the double. On a side note, it’s critical to run a separate set of tests periodically to confirm that there are no changes against your test doubles. However, a failure in these tests can slow down the deployment pipeline and disrupt the functionality of an IT infrastructure or distributed system. One best possible way to handle intermittent test failures is by updating your test doubles, and probably the code too so as to bring them back into high coherence and consistency with external services.",
	"CI - Testing - Types - ContractTesting - Consumer-driven contract testing": "In consumer-driven contract testing, consumers will delineate the way in which they want to consume a service. The consumer contracts can be made in a mutually consented language and schema between the producer and consumer. The service providers will test a service against the replicas of the individual contracts, and then make changes to that particular service without impacting the nature of other services.",
	"CI - Testing - Types - ContractTesting - Tools - Pact": "",
	"CI - Testing - Types - ContractTesting - Tools - Dredd": "",
	"CI - Testing - Types - FunctionalTesting": "This creates a test plan based on the functional requirements and compares the results with the expected results.",
	"CI - Testing - Types - IntegrationTesting": "Validates the interaction between integrated units/modules or multiple APIs to ensure they work together as expected.",
	"CI - Testing - Types - E2ETesting": "Verifies the entire flow of an application by testing APIs along with their integrated components, simulating real user scenarios.",
	"CI - Testing - Types - SmokeTesting": "This is done after API development is complete. Simply validate if the APIs are working and nothing breaks.",
	"CI - Testing - Types - UITesting": "This tests the UI interactions with the APIs to make sure the data can be displayed properly.",
	"CI - Testing - Types - SecurityTesting": "Identifies and mitigates security vulnerabilities, ensuring that APIs are protected against common threats like injection attacks, authorization flaws, etc.",
	"CI - Testing - Types - SecurityTesting - Tools - OWASP ZAP": "",
	"CI - Testing - Types - SecurityTesting - Tools - BurpSuite": "",
	"CI - Testing - Types - LoadTesting": "Evaluates API performance under expected load conditions, determining its ability to handle concurrent users and transactions.",
	"CI - Testing - Types - StressTesting": "Evaluates the API's stability and performance under extreme conditions by pushing it beyond its operational limits.",
	"CI - Testing - Types - StressTesting - Tools - k6": "",
	"CI - Testing - Types - StressTesting - Tools - JMeter": "",
	"CI - Testing - Types - FuzzTesting": "Inputs unexpected or invalid data to the API to identify vulnerabilities or unexpected behavior due to malformed data.",
	"CI - Testing - Types - NegativeTesting": "Focuses on validating the API's ability to handle unexpected inputs, error scenarios, and boundary conditions.",
	"CI - Testing - Tools - Postman": "",
	"CI - Testing - Tools - KatalanStudio": "",
	"CI - Testing - Tools - SoapUI": "",
	"CI - Testing - Tools - Chakram": "",
	"CI - Testing - Tools - Hippie-Swagger": "",
	"CI - Testing - Tools - RESTAssured": "",
	"CI - Testing - Tools - RestSwarp": "",
	"CI - Testing - Tools - Apigee": "",
	"CI - Testing - Tools - KarateDSL": "",

	"CD": "SECTION",
	"CD - Deploy - Migration": "Migration strategies",
	"CD - Deploy - Migration - StranglerFigPattern": "The StranglerFigPattern is a software architectural pattern used to gradually migrate from a monolithic application to microservices or modernize a legacy system. It involves replacing functionalities incrementally, one component at a time, while keeping the existing system operational.",
	"CD - Deploy - Migration - StranglerFigPattern - facade": "This is achieved by introducing a facade (or proxy) that redirects calls to the old system to the new, modernized components as they become available. The old system is gradually 'strangled' as the new services take over its functionalities. ",
	"CD - Deploy - Migration - ParallelRunning": "Run both versions simultaneously during transition",
	"CD - Deploy - Migration - AutomatedTranslation": "Convert between versions at API boundary",
	"CD - Deploy - Migration - FacadePattern": "Create a facade service that routes to appropriate version",
	"CD - Deploy - Migration - StranglerFig": "The Strangler Fig is a metaphor for incrementally building a new application around the legacy application. The legacy application is the tree, and the new application is the Strangler Fig. Over time, functionality is migrated from the legacy application to the Strangler Fig application. The Strangler Fig application gradually increases in size while the legacy application shrinks. Moreover, new functionality can be implemented directly in the Strangler Fig application.",
	"CD - Observability": "Observability (logs, traces, metrics, events): Monitoring + Alerting/visualization + Distributed systems tracing infrastructure + Log aggregation/analytics: Log aggregation - Application metrics - Audit logging - Distributed tracing - Exception tracking - Health check API - Log deployments and changes",
	"CD - Observability - Tools": "",
	"CD - Observability - Documentation - Tools - Swagger": "Automatically validates responses against the API spec.",
	"CD - Observability - Documentation - Tools - Swagger - Springfox - deprecated": "Avoid SpringFox (Swagger 2.x) for Spring Boot 3.1.x.",
	"CD - Observability - Documentation - Tools - Swagger - OpenAPI": "Use SpringDoc OpenAPI v2.x (springdoc-openapi-starter-webmvc-ui).",
	"CD - Automation - Configure - Externalize": "Externalize all application configuration including the database credentials and network location. On startup, a service reads the configuration from an external source, e.g. OS environment variables, etc.",

	"CICD": "SECTION",
	"CICD - Kubernetes - CI - Package - Containerization - CreateContainer:": ".",
	"CICD - Kubernetes - CI - Package - Containerization - CreateContainer - AzurePipelines:": ".",
	"CICD - Kubernetes - CI - Package - Containerization - CreateContainer - AWS CodePipeline:": ".",
	"CICD - Kubernetes - CI - Package - Containerization - PushToRegistry:": ".",
	"CICD - Kubernetes - CI - Package - Containerization - PushToRegistry - AzureContainerRegistry": ".",
	"CICD - Kubernetes - CI - Package - Containerization - PushToRegistry - AWS ECR": ".",
	"CICD - Kubernetes - CD - Deployment 0": "https://www.linkedin.com/posts/activity-7318276132963799040-1TDp/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"CICD - Kubernetes - CD - Deployment 1": "",
	"CICD - Kubernetes - CD - Deployment 2": "",
	"CICD - Kubernetes - CD - Deployment 3": "",
	"CICD - Kubernetes - CD - Deployment 4": "",
	"CICD - Kubernetes - CD - Deployment 5": "",
	"CICD - Kubernetes - CD - Deployment 6": "",
	"CICD - Kubernetes - CD - Deployment 7": "",
	"CICD - Kubernetes - CD - Deployment 8": "",
	"CICD - Kubernetes - CD - Deployment 9": "",
	"CICD - Kubernetes - CD - Deployment - SetupCluster": ".",
	"CICD - Kubernetes - CD - Deployment - SetupCluster - AKS": ".",
	"CICD - Kubernetes - CD - Deployment - SetupCluster - AWS EKS": ".",
	"CICD - Kubernetes - CD - Deployment - SetupCluster - Security:": ".",
	"CICD - Kubernetes - CD - Deployment - SetupCluster - Security - RBAC:": ".",
	"CICD - Kubernetes - CD - Deployment - SetupCluster - Security - NetworkPolicies:": ".",
	"CICD - Kubernetes - CD - Deployment - SetupCluster - Security - SecretsManagement:": ".",
	"CICD - Kubernetes - CD - Deployment - SetupCluster - Performance:": ".",
	"CICD - Kubernetes - CD - Deployment - CreateDeploymentWorkload:": ".",
	"CICD - Kubernetes - CD - Deployment - CreateProbes:": ".",
	"CICD - Kubernetes - CD - Operation - ConfigureAutoScaling:": ".",
	"CICD - Kubernetes - CD - Operation - ConfigureServiceMesh": ".",
	"CICD - Kubernetes - CD - Operation - ConfigureServiceMesh - AWS AppMesh": ".",
	"CICD - Kubernetes - CD - Operation - ConfigureAPIGateway:": ".",
	"CICD - Kubernetes - CD - Operation - ConfigureAPIGateway - AzureLoadBalancer:": ".",
	"CICD - Kubernetes - CD - Operation - ConfigureAPIGateway - AWS APIGateway:": ".",
	"CICD - Kubernetes - CD - Operation - CreateIngress:": ".",
	"CICD - Kubernetes - CD - Observability - ConfigureLogging:": ".",
	"CICD - Kubernetes - CD - Observability - ConfigureMonitoring:": ".",
	"CICD - Kubernetes - CD - Observability - ConfigureMonitoring - AzureMonitor": ".",
	"CICD - Kubernetes - CD - Observability - ConfigureMonitoring - AWS X-Ray": ".",
	"CICD - Kubernetes - CD - Observability - ConfigureAlerts:": "."

}