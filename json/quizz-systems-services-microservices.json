{

	"Microservices": "SECTION",
	"Microservices - Monolithic": "Build an application with a monolithic architecture. For example: a single Java WAR file. a single directory hierarchy of Rails or NodeJS code",
	"Microservices - Microlith": "",
	"Microservices - Moduliths": "",
	"Microservices - NanoServices": "",
	"Microservices - SelfContainedSystems": "",
	"Microservices - SystemOfSystems": "",
	"Microservices - Microservice": "Loosely coupled collaborating services / self-contained deployment units.",
	"Microservices - Microservice - Priorities": "(4) Client > (1) CommunicationStyle > (5) Service > (2) Processing > (6) Middleware > (3) Storage",

	"Microservices - Client": "SECTION",
	"Microservices - Client - UI - Aggregation": "",
	"Microservices - Client - UI - Aggregation - UIComposition": "Each team develops a client-side UI component, such an AngularJS directive, that implements the region of the page/screen for their service. A UI team is responsible implementing the page skeletons that build pages/screens by composing multiple, service-specific UI components.",
	"Microservices - Client - UI - Aggregation - Backend4Frontend": "optimises communication between clients and services by defining a separate API gateway for each kind of client.",
	"Microservices - Client - UI - Aggregation - ServiceComposition": "Each team developers a web application that generates the HTML fragment that implements the region of the page for their service. A UI team is responsible for developing the page templates that build pages by performing server-side aggregation (e.g. server-side include style mechanism) of the service-specific HTML fragments.",
	"Microservices - Client - UI - Patterns - RPC": "Use RPC for inter-service communication. The client uses a request/reply-based protocol to make requests to a service.",
	"Microservices - Client - UI - Patterns - Messaging": "Use asynchronous messaging for inter-service communication. Services communicating by exchanging messages over messaging channels.",
	"Microservices - Client - ServiceDiscovery": "",
	"Microservices - Client - ServiceDiscovery - Registry": "Implement a service registry, which is a database of services, their instances and their locations.",
	"Microservices - Client - ServiceDiscovery - Registry - Tools - etcd": "Discovery service protocol helps new etcd member to discover all other members in cluster bootstrap phase using a shared discovery URL.",
	"Microservices - Client - ServiceDiscovery - Registry - Tools - Eureka": "",
	"Microservices - Client - ServiceDiscovery - Registry - Tools - Consul": "",
	"Microservices - Client - ServiceDiscovery - Registry - Tools - Zookeeper": "Tools like Zookeeper help manage and coordinate distributed services, ensuring they work together smoothly.",
	"Microservices - Client - ServiceDiscovery - Registry - Tools - AlibabNacos": "",
	"Microservices - Client - ServiceDiscovery - Registration": "Microservices - Service instances are registered with the service registry on startup and deregistered on shutdown. Client of the service and/or routers query the service registry to find the available instances of a service. A service registry might invoke a service instance’s health check API to verify that it is able to handle requests",
	"Microservices - Client - ServiceDiscovery - Registration - SelfRegistration": "A service instance is responsible for registering itself with the service registry. On startup the service instance registers itself (host and IP address) with the service registry and makes itself available for discovery. The client must typically periodically renew its registration so that the registry knows it is still alive. On shutdown, the service instance unregisters itself from the service registry.",
	"Microservices - Client - ServiceDiscovery - Registration - 3rdPartyRegistration": "A 3rd party registrar is responsible for registering and unregistering a service instance with the service registry. When the service instance starts up, the registrar registers the service instance with the service registry. When the service instance shuts downs, the registrar unregisters the service instance from the service registry.",
	"Microservices - Client - ServiceDiscovery - Discovery - ClientSide": "When making a request to a service, the client obtains the location of a service instance by querying a Service Registry, which knows the locations of all service instances.",
	"Microservices - Client - ServiceDiscovery - Discovery - ServerSide": "When making a request to a service, the client makes a request via a router (a.k.a load balancer) that runs at a well known location. The router queries a service registry, which might be built into the router, and forwards the request to an available service instance.",
	"Microservices - Client - ServiceDiscovery - Endpoints": "",
	"Microservices - Client - ServiceDiscovery - Endpoints - Kubernetes - EndpointsAPI": "For kubernetes, services register their node information to Endpoints objects, so we can directly give deployment permissions to read the cluster's Endpoints object to get the node information.",
	"Microservices - Client - ServiceDiscovery - DNS-SD": "DNS Service Discovery is an extensions to the DNS protocol to browse the network for services.",
	"Microservices - Client - ServiceDiscovery - Standards - BDXL": "Business Document Metadata Service Location (BDXL)",
	"Microservices - Client - ServiceDiscovery - Standards - SMP": "Microservices - Service Metadata Publishing (SMP)",
	"Microservices - Client - Caching": "Storing frequently used data in a temporary location that is faster to access than the original source.",
	"Microservices - Client - Caching - Goal - access": "",
	"Microservices - Client - Caching - Goal - load": "Cacheability isn't just about the transfer, it's also about decreasing server load in a lot of applications.",
	"Microservices - Client - Caching - Layers": "HTTP caching involves client, forward proxy, reverse proxy and server.",
	"Microservices - Client - Caching - Layers - Client": "",
	"Microservices - Client - Caching - Layers - Client - CDN": "",
	"Microservices - Client - Caching - Layers - Client - CDN - Static": "Cache static assets and public API responses at edge locations.",
	"Microservices - Client - Caching - Layers - Client - CDN - Accept": "Configure cache keys by URL + headers (Accept, Accept-Language)",
	"Microservices - Client - Caching - Layers - Client - CDN - TTL": "Typical TTL: 1 minute to 1 hour for dynamic content",
	"Microservices - Client - Caching - Layers - Transport - Headers": "HTTP response headers: Expires, Cache-Control, ETag, Last-Modified",
	"Microservices - Client - Caching - Layers - Transport - Headers - Cache-Control": "Use Cache-Control headers for browser caching",
	"Microservices - Client - Caching - Layers - Transport - Headers - Expire": ".",
	"Microservices - Client - Caching - Layers - Transport - Headers - ETag": "Implement ETag/Last-Modified for conditional requests. ETags (Entity Tags) are HTTP response headers (ETag) that act as unique identifiers for a specific version of a resource. They help browsers and servers determine whether a cached resource is still fresh or needs to be re-downloaded.",
	"Microservices - Client - Caching - Layers - Transport - Headers - Last-Modified": "Implement ETag/Last-Modified for conditional requests",
	"Microservices - Client - Caching - Layers - Transport - Headers - private, no-cache": "For dynamic content: private, no-cache with validation",
	"Microservices - Client - Caching - Layers - Application": "",
	"Microservices - Client - Caching - Layers - Application - CacheAsidePattern:": "",
	"Microservices - Client - Caching - Layers - Database": "",
	"Microservices - Client - Caching - Layers - Database - query": "Enable query cache (MySQL, PostgreSQL)",
	"Microservices - Client - Caching - Layers - Database - materializedViews": "Use materialized views for complex queries",
	"Microservices - Client - Caching - Layers - Database - memory": "Configure appropriate memory allocations",
	"Microservices - Client - Caching - Strategies - Write - WriteThrough": "By simultaneously writing to the cache and the database.",
	"Microservices - Client - Caching - Strategies - Write - WriteBack": "Data is written to the cache first and then to the database 'asynchronously.",
	"Microservices - Client - Caching - Strategies - Write - WriteAround": "Bypasses the cache for writes, writing directly to the database. The cache is updated only on subsequent reads.",
	"Microservices - Client - Caching - Strategies - Read - ClientSideCaching": "Data is cached on the client's device.",
	"Microservices - Client - Caching - Strategies - Read - CacheAside": "This strategy grants applications explicit control over the caching process.",
	"Microservices - Client - Caching - Strategies - Read - ReadThrough": "The cache acts as the primary data source. If data isn't in the cache, it's retrieved from the database and stored in the cache.",
	"Microservices - Client - Caching - Strategies - Read - RefreshAhead": "The cache proactively refreshes data before it expires.",
	"Microservices - Client - Caching - Strategies - Eviction": "Cache Invalidation.",
	"Microservices - Client - Caching - Strategies - Eviction - LRU": "𝐋𝐞𝐚𝐬𝐭 𝐑𝐞𝐜𝐞𝐧𝐭𝐥𝐲 𝐔𝐬𝐞𝐝 (𝐋𝐑𝐔) - Removes the least recently accessed item first. - Works well when older data is less likely to be used again. - Example: Browsers use LRU to discard old pages from memory when opening new tabs.",
	"Microservices - Client - Caching - Strategies - Eviction - LFU": "𝐋𝐞𝐚𝐬𝐭 𝐅𝐫𝐞𝐪𝐮𝐞𝐧𝐭𝐥𝐲 𝐔𝐬𝐞𝐝 (𝐋𝐅𝐔) - Evicts the least accessed items over time. - Prioritizes keeping frequently used items in cache. - Example: CDNs use LFU to keep trending videos in cache while removing rarely watched ones.",
	"Microservices - Client - Caching - Strategies - Eviction - MRU": "𝐌𝐨𝐬𝐭 𝐑𝐞𝐜𝐞𝐧𝐭𝐥𝐲 𝐔𝐬𝐞𝐝 (𝐌𝐑𝐔) - Opposite of LRU – evicts the most recently accessed item first. - Useful when recent data becomes obsolete quickly. - Example: In a music streaming app, the last played song is less likely to be played again, making MRU a better choice.",
	"Microservices - Client - Caching - Strategies - Eviction - TTL": "𝐓𝐢𝐦𝐞 𝐭𝐨 𝐋𝐢𝐯𝐞 (𝐓𝐓𝐋) - Items are evicted after a set time limit (expiry time). - Prevents stale data, useful in distributed systems. - Example: DNS records have TTL values, so if an IP address changes, clients don’t hold onto outdated mappings.",
	"Microservices - Client - Caching - Strategies - Eviction - FIFO": "𝐅𝐢𝐫𝐬𝐭 𝐈𝐧, 𝐅𝐢𝐫𝐬𝐭 𝐎𝐮𝐭 (𝐅𝐈𝐅𝐎) - Evicts the oldest stored item first, regardless of usage. - Simple to implement but may remove still-relevant data. - Example: Simple queue-based caching systems.",
	"Microservices - Client - Caching - Strategies - Eviction - RR": "𝐑𝐚𝐧𝐝𝐨𝐦 𝐑𝐞𝐩𝐥𝐚𝐜𝐞𝐦𝐞𝐧𝐭 (𝐑𝐑) - Randomly evicts an item when the cache is full. - Low overhead, but less predictable performance. - Example: Some network routers use RR for managing limited memory, avoiding complex eviction policies.",
	"Microservices - Client - Caching - Strategies - Eviction - TT": "𝐓𝐰𝐨-𝐓𝐢𝐞𝐫𝐞𝐝 𝐂𝐚𝐜𝐡𝐢𝐧𝐠 - Uses a fast in-memory cache (e.g., Redis) & a slower persistent cache (e.g., disk-based). - Optimizes speed & storage by balancing hot and cold data. - Example: A CDN stores frequently accessed content in RAM (L1 cache) while keeping less-accessed content on disk (L2 cache) to balance performance and cost.",
	"Microservices - Client - Caching - Tools - Redis": "",
	"Microservices - Client - Caching - Tools - Memcache": "",
	"Microservices - Client - Caching - Tools - VarnishCache": ".",
	"Microservices - Client - Versioning": "",
	"Microservices - Client - Versioning - Migration": "Migration strategies",
	"Microservices - Client - Versioning - Migration - ParallelRunning": "Run both versions simultaneously during transition",
	"Microservices - Client - Versioning - Migration - AutomatedTranslation": "Convert between versions at API boundary",
	"Microservices - Client - Versioning - Migration - FacadePattern": "Create a facade service that routes to appropriate version",
	"Microservices - Client - Versioning - Migration - StranglerFig": "The Strangler Fig is a metaphor for incrementally building a new application around the legacy application. The legacy application is the tree, and the new application is the Strangler Fig. Over time, functionality is migrated from the legacy application to the Strangler Fig application. The Strangler Fig application gradually increases in size while the legacy application shrinks. Moreover, new functionality can be implemented directly in the Strangler Fig application.",
	"Microservices - Client - ResponseSize - Compression": "HTTP response headers: Accept-Encoding, Content-Encoding",
	"Microservices - Client - ResponseSize - Pagination": "",
	"Microservices - Client - ResponseSize - Pagination - OffsetBased": "This technique uses an offset and a limit parameter to define the starting point and the number of records to return. Example: GET /orders?offset=0&limit=3 ",
	"Microservices - Client - ResponseSize - Pagination - CursorBased": "This technique uses a cursor (a unique identifier) to mark the position in the dataset. Typically, the cursor is an encoded string that points to a specific record. Example: GET /orders?cursor=xxx ",
	"Microservices - Client - ResponseSize - Pagination - PageBased": "This technique specifies the page number and the size of each page. Example: GET /items?page=2&size=3 ",
	"Microservices - Client - ResponseSize - Pagination - KeysetBased": "This technique uses a key to filter the dataset, often the primary key or another indexed column. Example: GET /items?after_id=102&limit=3 ",
	"Microservices - Client - ResponseSize - Pagination - TimeBased": "This technique uses a timestamp or date to paginate through records. Example: GET /items?start_time=xxx&end_time=yyy ",
	"Microservices - Client - ResponseSize - Pagination - Hybrid": "This technique combines multiple pagination techniques to leverage their strengths. Example: Combining cursor and time-based pagination for efficient scrolling through time-ordered records. ",

	"Microservices - CommunicationStyle": "SECTION",
	"Microservices - CommunicationStyle - Patterns - SOAP": "A heavyweight protocol that uses XML-based messaging, offering strict security and reliability for enterprise applications. ",
	"Microservices - CommunicationStyle - Patterns - REST": "",
	"Microservices - CommunicationStyle - Patterns - GraphQL": "",
	"Microservices - CommunicationStyle - Patterns - gRPC": "",
	"Microservices - CommunicationStyle - Patterns - WebSocket": "",
	"Microservices - CommunicationStyle - Discussion - ServiceComplexity": "REST: Simple, cacheable APIs - GraphQL: Complex, nested data needs",
	"Microservices - CommunicationStyle - Discussion - RequirementsStability": "REST: Stable client requirements - GraphQL: Rapidly evolving client needs",
	"Microservices - CommunicationStyle - Discussion - RealTime": "REST: NO - GraphQL: Real-time updates (subscriptions)",

	"Microservices - Service": "SECTION",
	"Microservices - Service - Reliability": ".",
	"Microservices - Service - Reliability - Retries": "Auto-retry failed requests for resilience.",
	"Microservices - Service - Reliability - CircuitBreaker": "Prevents cascading failures.",
	"Microservices - Service - Reliability - CircuitBreaker - Tools - Hystrix": "",
	"Microservices - Service - Reliability - CircuitBreaker - Tools - Istio": "",
	"Microservices - Service - Reliability - CircuitBreaker - Tools - Resilience4j": "Resilience4j is a lightweight, easy-to-use library, which offers a powerful circuit breaker implementation inspired by Netflix Hystrix but designed with functional programming approach.",
	"Microservices - Service - Reliability - CircuitBreaker - Tools - Sentinel": "It is an open-source library that provides monitoring of services and controls the traffic. It can be used to implement circuit breaking, rate limiting. Sentinel can work in both Java and other languages.",
	"Microservices - Service - Reliability - CircuitBreaker - Tools - AmazonAppMesh": "Amazon App Mesh is a managed service mesh that allows you to monitor and control services running on AWS.",
	"Microservices - Service - Reliability - Bulkhead": "Compartmentalize your application's resources so that failure of any one of your dependencies is not propagated into the entire system",
	"Microservices - Service - Reliability - Bulkhead - Tools - Resilience4j": "",
	"Microservices - Service - Publishing - WAF": "HTTP - WAFs analyze HTTP traffic for malicious requests.",
	"Microservices - Service - Publishing - WAF - Layer7": ".",
	"Microservices - Service - Publishing - APIGateway": "API gateway is the single entry point for all clients. API Gateway is primarily meant for external client-to-service communication.",
	"Microservices - Service - Publishing - APIGateway - Location": "An API Gateway acts as a gatekeeper for microservices.",
	"Microservices - Service - Publishing - APIGateway - Functions - protocol": "Protocol & Format Handling",
	"Microservices - Service - Publishing - APIGateway - Functions - protocol - Translation": "Protocol Translation: Supports REST, GraphQL, gRPC, WebSockets, and SOAP to accommodate different communication methods.",
	"Microservices - Service - Publishing - APIGateway - Functions - protocol - FormatHandling": "Request/Response Transformation: Modifies incoming and outgoing requests, such as converting XML to JSON.",
	"Microservices - Service - Publishing - APIGateway - Functions - traffic": "Traffic manager at Layer 7 of OSI Model. The main purpose of an API gateway is to accept traffic from outside your network and distribute it internally.",
	"Microservices - Service - Publishing - APIGateway - Functions - traffic - Input - SingleInteractionPoint": "By serving as the central point of communication, API Gateway streamlines interactions.",
	"Microservices - Service - Publishing - APIGateway - Functions - traffic - Input - RateLimiting": "Sets a cap on the number of requests that can be made to an API within a specified time frame.",
	"Microservices - Service - Publishing - APIGateway - Functions - traffic - Input - Throttling": "Throttling doesn’t block requests but slows down the rate at which requests are processed.",
	"Microservices - Service - Publishing - APIGateway - Functions - traffic - Routing - LoadBalancing": "Load Balancing: Distributes incoming API requests across multiple backend services to ensure availability and performance.",
	"Microservices - Service - Publishing - APIGateway - Functions - traffic - Routing - RequestRouting": "Request Routing: Directs API calls (proxied or broadcasted) to the appropriate backend services based on rules or conditions.",
	"Microservices - Service - Publishing - APIGateway - Functions - traffic - Output - ResultsAggregation": "The Gateway aggregates results from disparate services, providing a consolidated response to the client, thus improving efficiency.",
	"Microservices - Service - Publishing - APIGateway - Functions - security": "Security.",
	"Microservices - Service - Publishing - APIGateway - Functions - security - DDoSProtection": "Mitigates Distributed Denial of Service (DDoS) attacks by blocking malicious traffic.",
	"Microservices - Service - Publishing - APIGateway - Functions - security - SSL": "SSL/TLS Termination: Encrypts data in transit to ensure secure communication.",
	"Microservices - Service - Publishing - APIGateway - Functions - security - CORS": "Cross-Origin Resource Sharing (CORS) Management: Handling requests from other domains.",
	"Microservices - Service - Publishing - APIGateway - Functions - security - authentication": "API Gateway centralizes authentication and authorization, managing security protocols centrally and ensuring secure communication between clients and services. Supports OAuth, JWT, API keys, and other authentication methods to secure APIs..",
	"Microservices - Service - Publishing - APIGateway - Functions - security - validation": "Request and Response validation: Validate the microservice requests and responses and ensure they conform to the expected format and structure. This helps prevent errors and ensure the proper functioning of the microservice.",
	"Microservices - Service - Publishing - APIGateway - Functions - security - CircuitBreaker": "Circuit Breaker: Act as a circuit breaker to prevent a single failed microservice from bringing down the entire system.",
	"Microservices - Service - Publishing - APIGateway - Functions - security - ErrorHandling": "Error Handling: Provide a consistent way to handle errors and generate error responses to clients even when backend services are unavailable or return unexpected results.",
	"Microservices - Service - Publishing - APIGateway - Functions - integration": "Integration & Automation",
	"Microservices - Service - Publishing - APIGateway - Functions - integration - Transformation": "Request and Response Transformation: Modifying requests and responses for compatibility. It can translate between protocols. For example, if a client sends a request using HTTP/1.1, but the backend service expects requests in gRPC format, the API Gateway can translate the HTTP request into a gRPC request before forwarding it to the backend service. Likewise, when the backend service responds with data in gRPC format, the API Gateway can translate it back into HTTP format before sending it back to the client.",
	"Microservices - Service - Publishing - APIGateway - Functions - integration - Discovery": "Backend Service Discovery: Dynamically connects with backend services using service registries.",
	"Microservices - Service - Publishing - APIGateway - Functions - integration - Caching": "Caching: Stores frequent API responses to reduce latency and improve performance.",
	"Microservices - Service - Publishing - APIGateway - Functions - integration - EDA": "Webhooks & Event-Driven Integration: Supports event-based workflows for real-time API interactions.",
	"Microservices - Service - Publishing - APIGateway - Functions - lifecycle": "Developer Experience & API Lifecycle Management",
	"Microservices - Service - Publishing - APIGateway - Functions - lifecycle - Versioning": "API Versioning: Allows multiple API versions to coexist, making updates easier.",
	"Microservices - Service - Publishing - APIGateway - Functions - lifecycle - Mock": "Mock Responses & Testing: Enables testing API behavior without backend implementation.",
	"Microservices - Service - Publishing - APIGateway - Functions - lifecycle - Documentation": "API Documentation & Developer Portals: Provides auto-generated documentation and interactive portals for developers.",
	"Microservices - Service - Publishing - APIGateway - Functions - audit": "",
	"Microservices - Service - Publishing - APIGateway - Functions - audit - logging": "Logging & Monitoring: Tracks API usage and performance with logging tools like AWS CloudWatch or Prometheus.",
	"Microservices - Service - Publishing - APIGateway - Functions - audit - metrics": "Analytics & Metrics: Provides insights into API usage patterns, error rates, and latency for better decision-making.",
	"Microservices - Service - Publishing - APIGateway - Functions - audit - metering": "API Metering and Billing: Tracking API usage for reporting and billing.",
	"Microservices - Service - Publishing - APIGateway - Tools - Kong API Gateway": ".",
	"Microservices - Service - Publishing - APIGateway - Tools - NGINX API Gateway": ".",
	"Microservices - Service - Publishing - APIGateway - Tools - AWS API Gateway": ".",
	"Microservices - Service - Publishing - APIGateway - Tools - Apigee (Google Cloud)": ".",
	"Microservices - Service - Publishing - APIGateway - Tools - Azure API Management": ".",
	"Microservices - Service - Publishing - APIGateway - Tools - SpringCloudGateway": ".",
	"Microservices - Service - Publishing - APIGateway - Tools - WSO2": ".",
	"Microservices - Service - Publishing - APIGateway - Tools - Ocelot": ".",
	"Microservices - Service - Publishing - APIGateway - Tools - Traefik": ".",
	"Microservices - Service - Publishing - Comparison - APIGateway vs LoadBalancer vs ReverseProxy": "While load balancers, reverse proxies, and API Gateways share the goal of optimizing and managing web traffic, they serve distinct functions:",
	"Microservices - Service - Publishing - Comparison - APIGateway vs LoadBalancer vs ReverseProxy - LoadBalancer": "Optimizes resource utilization by distributing traffic among servers. Used to handle heavy traffic and ensure even load distribution.",
	"Microservices - Service - Publishing - Comparison - APIGateway vs LoadBalancer vs ReverseProxy - ReverseProxy": "Acts as an intermediary between clients and servers, providing security and control. Manages SSL encryption, serves static content, and controls access to internal servers.",
	"Microservices - Service - Publishing - Comparison - APIGateway vs LoadBalancer vs ReverseProxy - APIGateway": "Manages interactions between clients and backend services in a microservices architecture. Provides functionalities like routing, aggregation, and security in addition to handling requests.",
	"Microservices - Service - Security": ".",

	"Microservices - Processing": "SECTION",
	"Microservices - Processing - Decomposition": "",
	"Microservices - Processing - Decomposition - IDEALS": "IDEALS is considered an equivalent of the SOLID principles from object oriented design in the world of microservices.",
	"Microservices - Processing - Decomposition - IDEALS - InterfaceSegregation": "Interfaces catering to the specific needs of each type of client.",
	"Microservices - Processing - Decomposition - IDEALS - Deployability": "Deployability (is on you) acknowledges that in the microservice era, which is also the DevOps era, there are critical design decisions and technology choices developers need to make regarding packaging, deploying and running microservices. ",
	"Microservices - Processing - Decomposition - IDEALS - EventDriven": "Availability over consistency, services to be activated by an asynchronous message or event instead of a synchronous call.  ",
	"Microservices - Processing - Decomposition - IDEALS - AvailabilityOverConsistency": "Microservices sacrify consistency to improve availabity (CAP Theorem). Okay with eventual consistency.",
	"Microservices - Processing - Decomposition - IDEALS - LooseCoupling": "LooseCoupling.",
	"Microservices - Processing - Decomposition - IDEALS - SRP": "The original Single Responsibility Principle (SRP) is about having cohesive functionality in an OO class.",
	"Microservices - Processing - Aggregation": "",
	"Microservices - Processing - Aggregation - ServicePerContainer": "Package the service as a (Docker) container image and deploy each service instance as a container",
	"Microservices - Processing - Aggregation - ServicePerVM": "Package the service as a virtual machine image and deploy each service instance as a separate VM",
	"Microservices - Processing - Aggregation - ServicePerHost": "Deploy each single service instance on its own host",
	"Microservices - Processing - Aggregation - MultiServicePerHost": "Run multiple instances of different services on a host (Physical or Virtual machine). There are various ways of deploying a service instance on a shared host including: Deploy each service instance as a JVM process. For example, a Tomcat or Jetty instances per service instance. Deploy multiple service instances in the same JVM. For example, as web applications or OSGI bundles.",
	"Microservices - Processing - Aggregation - DatabasePerService": "Each service manages its own data. Promotes loose coupling but requires eventual consistency handling.",

	"Microservices - Middleware": "SECTION",
	"Microservices - Middleware - ServiceMesh": "A service mesh is a configurable infrastructure layer for microservices that makes communication between service instances flexible, reliable, and fast. The mesh provides service discovery, load balancing, encryption, authentication and authorization, support for the circuit breaker pattern, and other capabilities.",
	"Microservices - Middleware - ServiceMesh - Structure": "This layer is composed of containerized microservices.",
	"Microservices - Middleware - ServiceMesh - Functions - traffic - Intercommunication": "A service mesh's primary purpose is to manage internal service-to-service communication.",
	"Microservices - Middleware - ServiceMesh - Functions - traffic - LoadBalancing": ".",
	"Microservices - Middleware - ServiceMesh - Functions - traffic - Routing": "The main purpose of a service mesh is to route and manage traffic within your network.",
	"Microservices - Middleware - ServiceMesh - Functions - traffic - Retries": ".",
	"Microservices - Middleware - ServiceMesh - Functions - traffic - Timeouts": ".",
	"Microservices - Middleware - ServiceMesh - Functions - security - mTLSEncryption": ".",
	"Microservices - Middleware - ServiceMesh - Functions - observability - logging": ".",
	"Microservices - Middleware - ServiceMesh - Functions - observability - tracing": ".",
	"Microservices - Middleware - ServiceMesh - Functions - observability - monitoring": ".",
	"Microservices - Middleware - ServiceMesh - Functions - error - FailureHandling": ".",
	"Microservices - Middleware - ServiceMesh - Tools - Istio": "",
	"Microservices - Middleware - ServiceMesh - Tools - Linkerd": "",

	"Microservices - Storage": "SECTION",
	"Microservices - Storage - Consistency": "(0) Eventual Consistency.",
	"Microservices - Storage - Consistency - Approaches": "3 inconsistency approaches: remove by design, address, accept",
	"Microservices - Storage - Consistency - Approaches - design": "(1) remove inconsistenct by design (event sourcing + CQRS)",
	"Microservices - Storage - Consistency - Approaches - address": "(2) address the inconsistency (saga)",
	"Microservices - Storage - Consistency - Approaches - accept": "(3) accept the inconsistency",
	"Microservices - Storage - State - Stateless": "Stateless microservices do not maintain any state or store session-specific data between requests. Each request a stateless microservice receives is processed independently, without relying on previous interactions.",
	"Microservices - Storage - State - Stateful": " Stateful microservices are those that maintain the state of user sessions or interactions. Scaling, load balancing... becomes difficult.",

	"Microservices - CI": "SECTION",
	"Microservices - CI - Packaging - Sidecar": "In a microservice architecture, it’s very common to have multiple services/apps that often require common functionalities like logging, configuration, monitoring & networking services. These functionalities can be implemented and run as a separate service within the same container or in a separate container. A sidecar pattern is a single-node pattern made up of two containers.",
	"Microservices - CI - Packaging - Sidecar - application": "The first is the application container which contains the core logic of the application (primary application). Without this container, application wouldn’t exist.",
	"Microservices - CI - Packaging - Sidecar - sidecar": "In addition, there is a Sidecar container used to extend/enhance the functionalities of the primary application by running another container in parallel on the same container group (Pod). Since sidecar runs on the same Pod as the main application container it shares the resources — filesystem, disk, network etc.,",
	"Microservices - CI - Testing": "Unit Testing, Integration Testing, Contract Testing, End-to-End Testing",
	"Microservices - CI - Testing - UnitTesting": "The scope of unit testing can be sociable or solitary concerning a service. The smaller the unit will be under test, the easier it is to determine the behavior of modules and probe the collaborators as well as interactions between objects and their dependencies. Since the cyclomatic complexity of the unit is inferior, Quality Analysis (QA) engineers can evaluate whether or not the units are isolated from their collaborators by using this testing strategy. Both the sociable and solitary unit testing styles are frequently used simultaneously in the same codebase to tackle different testing issues. The motive behind testing the domain layer is to emulate DML statements and certify that all collaborators use the real domain objects in correct sequence. During the unit testing, engineers can verify the logic used to generate map responses or other requests from external remote dependencies. As far as resources and service layer are concerned, they validate that each component correctly interacts with its collaborator, thereby monitoring the request/response cycle in a repeatable and consistent manner.",
	"Microservices - CI - Testing - UnitTesting - RestAssured": "✅ Real-time API testing scenarios ✅ Serialization & Deserialization ✅ Auth mechanisms (Basic, OAuth2, Bearer Tokens) ✅ Schema Validation, File Upload/Download ✅ TestNG Parallel Execution setup ✅ Mocking APIs, Caching, Rate Limiting https://www.linkedin.com/posts/neha-sharma-0a0906148_restapi-activity-7317064488115953664-LIY7?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Microservices - CI - Testing - UnitTesting - SoapUI": "",
	"Microservices - CI - Testing - UnitTesting - Postman": "",
	"Microservices - CI - Testing - RegressionTesting": "This test ensures that bug fixes or new features shouldn’t break the existing behaviors of APIs.",
	"Microservices - CI - Testing - ContractTesting": "Contract testing is a sort of a black box that verifies the contract between an external service call and its API provider endpoint. There are two types of contract testing, including: Integration contract testing, Consumer-driven contract testing",
	"Microservices - CI - Testing - ContractTesting - Integration contract testing": "In integration contract testing, each component needs to be called independently, and it must meet the contract agreement anticipated by a consuming service. The best way to deal with this is to carry out a test against the double. On a side note, it’s critical to run a separate set of tests periodically to confirm that there are no changes against your test doubles. However, a failure in these tests can slow down the deployment pipeline and disrupt the functionality of an IT infrastructure or distributed system. One best possible way to handle intermittent test failures is by updating your test doubles, and probably the code too so as to bring them back into high coherence and consistency with external services.",
	"Microservices - CI - Testing - ContractTesting - Consumer-driven contract testing": "In consumer-driven contract testing, consumers will delineate the way in which they want to consume a service. The consumer contracts can be made in a mutually consented language and schema between the producer and consumer. The service providers will test a service against the replicas of the individual contracts, and then make changes to that particular service without impacting the nature of other services.",
	"Microservices - CI - Testing - FunctionalTesting": "This creates a test plan based on the functional requirements and compares the results with the expected results.",
	"Microservices - CI - Testing - IntegrationTesting": "Integration testing takes place in the staging environment to integrate individual services after analyzing the functionality of communication pathways and interactions between them. Unlike monolithic or SOA, microservices architecture depends on the Inter-Process Communication (IPC) mechanism to function appropriately, which is why the interactions between services must be verified. Automated tests need to be written for mapping out the success and error cases through the integration with external services and data stores. Running gateway integration tests will defect interface errors, such as incorrect SSL handling and missing HTTP headers, at the protocol level. And the persistence integration test ensures that each component and protocol client must respond as an external dependency in case of timeouts and partial failures.",
	"Microservices - CI - Testing - E2ETesting": "End-to-End (E2E) testing ascertains that the overall system is accurately working as well as the network infrastructure (load balancers, firewall, and more) is correctly configured. E2E tests, however, need to be run at the finest coarse granularity possible to test the functionality of the entire system. In this, QA engineers verify the behavior of the fully-integrated process and make sure that the system collectively meets its business requirements, regardless of the Service Component Architecture in use. With the help of functional testing, developers can determine if an integrated system or app functions as stated in the requirements.",
	"Microservices - CI - Testing - SmokeTesting": "This is done after API development is complete. Simply validate if the APIs are working and nothing breaks.",
	"Microservices - CI - Testing - UITesting": "This tests the UI interactions with the APIs to make sure the data can be displayed properly.",
	"Microservices - CI - Testing - SecurityTesting": "This tests the APIs against all possible external threats.",
	"Microservices - CI - Testing - LoadTesting": "This tests applications’ performance by simulating different loads. Then we can calculate the capacity of the application.",
	"Microservices - CI - Testing - StressTesting": "We deliberately create high loads to the APIs and test if the APIs are able to function normally.",
	"Microservices - CI - Testing - FuzzTesting": "This injects invalid or unexpected input data into the API and tries to crash the API. In this way, it identifies the API vulnerabilities.",

	"Microservices - CD": "SECTION",
	"Microservices - CD - Code": "",
	"Microservices - CD - Code - Chassis": "A base framework or even another service which can be reused across different services. This pattern cuts down on the redundancy factor and complexity across services by abstracting the common logic to a separate layer.",
	"Microservices - CD - Deploy": "Service Discovery + Publishing + Commnication Style + Deployment",
	"Microservices - CD - Deploy - Kubernetes - Containerization - CreateContainer:": ".",
	"Microservices - CD - Deploy - Kubernetes - Containerization - RunContainer:": ".",
	"Microservices - CD - Deploy - Kubernetes - Containerization - PushToRegistry:": ".",
	"Microservices - CD - Deploy - Kubernetes - CreateDeploymentWorkload:": ".",
	"Microservices - CD - Deploy - Kubernetes - CreateProves:": ".",
	"Microservices - CD - Deploy - Kubernetes - CreateIngress:": ".",
	"Microservices - CD - Deploy - Kubernetes - ConfigureAPIGateway:": ".",
	"Microservices - CD - Deploy - Kubernetes - ConfigureServiceMess:": ".",
	"Microservices - CD - Deploy - Kubernetes - ConfigureAutoScaling:": ".",
	"Microservices - CD - Deploy - Kubernetes - Observability - ConfigureMonitoring:": ".",
	"Microservices - CD - Deploy - Kubernetes - Observability - ConfigureLogging:": ".",
	"Microservices - CD - Deploy - Kubernetes - Observability - ConfigureAlerts:": ".",
	"Microservices - CD - Deploy - Kubernetes - ClusterSecurity - RBAC:": ".",
	"Microservices - CD - Deploy - Kubernetes - ClusterSecurity - NetworkPolicies:": ".",
	"Microservices - CD - Deploy - Kubernetes - ClusterSecurity - SecretsManagement:": ".",
	"Microservices - CD - Deploy - Kubernetes - Security:": ".",
	"Microservices - CD - Deploy - Kubernetes - Performance:": ".",
	"Microservices - CD - Deploy - Migration - StranglerFigPattern": "The StranglerFigPattern is a software architectural pattern used to gradually migrate from a monolithic application to microservices or modernize a legacy system. It involves replacing functionalities incrementally, one component at a time, while keeping the existing system operational.",
	"Microservices - CD - Deploy - Migration - StranglerFigPattern - facade": "This is achieved by introducing a facade (or proxy) that redirects calls to the old system to the new, modernized components as they become available. The old system is gradually 'strangled' as the new services take over its functionalities. ",
	"Microservices - CD - Operate:": ".",
	"Microservices - CD - Monitor - Observability": "Observability (logs, traces, metrics, events): Monitoring + Alerting/visualization + Distributed systems tracing infrastructure + Log aggregation/analytics: Log aggregation - Application metrics - Audit logging - Distributed tracing - Exception tracking - Health check API - Log deployments and changes",
	"Microservices - CD - Monitor - Observability - Monitoring": "",
	"Microservices - CD - Monitor - Observability - Logging": "",
	"Microservices - CD - Monitor - Observability - Alerting": "",
	"Microservices - CD - Monitor - Observability - UseCases - Log aggregation": "Use a centralized logging service that aggregates logs from each service instance. The users can search and analyze the logs. They can configure alerts that are triggered when certain messages appear in the logs.",
	"Microservices - CD - Monitor - Observability - UseCases - Application metrics": "Instrument a service to gather statistics about individual operations. Aggregate metrics in centralized metrics service, which provides reporting and alerting. There are two models for aggregating metrics: push - the service pushes metrics to the metrics service pull - the metrics services pulls metrics from the service",
	"Microservices - CD - Monitor - Observability - UseCases - Audit logging": "Record user activity in a database.",
	"Microservices - CD - Monitor - Observability - UseCases - Distributed tracing": "Instrument services with code that: Assigns each external request a unique external request id. Passes the external request id to all services that are involved in handling the request. Includes the external request id in all log messages. Records information (e.g. start time, end time) about the requests and operations performed when handling a external request in a centralized service. This instrumentation might be part of the functionality provided by a Microservice Chassis framework.",
	"Microservices - CD - Monitor - Observability - UseCases - Exception tracking": "Report all exceptions to a centralized exception tracking service that aggregates and tracks exceptions and notifies developers.",
	"Microservices - CD - Monitor - Observability - UseCases - Health check API": "A service has an health check API endpoint (e.g. HTTP /health) that returns the health of the service. The API endpoint handler performs various checks, such as: the status of the connections to the infrastructure services used by the service instance, the status of the host, e.g. disk space, application specific logic A health check client - a monitoring service, service registry or load balancer - periodically invokes the endpoint to check the health of the service instance.",
	"Microservices - CD - Monitor - Observability - UseCases - Log deployments and changes": "Log every deployment and every change to the (production) environment.",
	"Microservices - CD - Monitor - Observability - Tools - Prometheus": "Prometheus is an open-source toolkit for monitoring and alerting based on an embedded times-series database, a query DSL and various mechanics for scraping metrics data off endpoints.",
	"Microservices - CD - Monitor - Observability - Tools - Graphana": ".",
	"Microservices - CD - Monitor - Observability - Tools - Datadog": ".",
	"Microservices - CD - Monitor - Observability - Tools - ELKStack": ".",
	"Microservices - CD - Monitor - Observability - Tools - Splunk": ".",
	"Microservices - CD - Monitor - Observability - Tools - Jaeger": ".",
	"Microservices - CD - Monitor - Observability - Tools - Zipkin": ".",
	"Microservices - CD - Monitor - Observability - Tools - SpringCloudSleuth": "Spring Cloud Sleuth provides Spring Boot auto-configuration for distributed tracing. Spring Cloud Sleuth will not work with Spring Boot 3.x onward. The last major version of Spring Boot that Sleuth will support is 2.x.",
	"Microservices - CD - Configure": ".",
	"Microservices - CD - Configure - Externalize": "Externalize all application configuration including the database credentials and network location. On startup, a service reads the configuration from an external source, e.g. OS environment variables, etc.",
	"Microservices - CD - Configure - Tools - KubernetesConfigMaps": ".",
	"Microservices - CD - Configure - Tools - KubernetesSecrets": ".",
	"Microservices - CD - Configure - Tools - SpringCloudConfig": ".",
	"Microservices - CD - Configure - Tools - Consul": "."

}