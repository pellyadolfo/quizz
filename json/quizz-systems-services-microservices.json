{

	"Microservices": "SECTION",
	"Microservices - Monolithic": "Build an application with a monolithic architecture. For example: a single Java WAR file. a single directory hierarchy of Rails or NodeJS code",
	"Microservices - Microservice": "Define an architecture that structures the application as a set of loosely coupled, collaborating services.",
	"Microservices - Principles - IDEALS": "IDEALS is considered an equivalent of the SOLID principles from object oriented design in the world of microservices.",
	"Microservices - Principles - IDEALS - InterfaceSegregation": "Interfaces catering to the specific needs of each type of client.",
	"Microservices - Principles - IDEALS - Deployability": "Deployability (is on you) acknowledges that in the microservice era, which is also the DevOps era, there are critical design decisions and technology choices developers need to make regarding packaging, deploying and running microservices. ",
	"Microservices - Principles - IDEALS - EventDriven": "Availability over consistency, services to be activated by an asynchronous message or event instead of a synchronous call.  ",
	"Microservices - Principles - IDEALS - AvailabilityOverConsistency": "Microservices sacrify consistency to improve availabity (CAP Theorem). Okay with eventual consistency.",
	"Microservices - Principles - IDEALS - LooseCoupling": "LooseCoupling.",
	"Microservices - Principles - IDEALS - SingleResponsibility": "The original Single Responsibility Principle (SRP) is about having cohesive functionality in an OO class.",
	"Microservices - Priorities": "(0) Eventual Consistency (1) Decomposition + Storage (2) Service Discovery + Publishing + Commnication Style + Deployment (3) UI + Testing + Configuration + Observability + Security + Reliability +  ",
	"Microservices - Priorities - (0) EventualConsistency": "(0) Eventual Consistency.",
	"Microservices - Priorities - (0) EventualConsistency - Approaches": "3 inconsistency approaches: remove by design, address, accept",
	"Microservices - Priorities - (0) EventualConsistency - Approaches - design": "(1) remove inconsistenct by design (event sourcing + CQRS)",
	"Microservices - Priorities - (0) EventualConsistency - Approaches - address": "(2) address the inconsistency (saga)",
	"Microservices - Priorities - (0) EventualConsistency - Approaches - accept": "(3) accept the inconsistency",
	"Microservices - Priorities - (1) Decomposition + Storage": "(1) Decomposition + Storage",
	"Microservices - Priorities - (2) Service Discovery + Publishing + Commnication Style + Deployment": "(2) Service Discovery + Publishing + Commnication Style + Deployment",
	"Microservices - Priorities - (3) UI + Testing + Configuration + Observability + Security + Reliability": "(3) UI + Testing + Configuration + Observability + Security + Reliability",

	"Client": "SECTION",
	"Client - Consumption - RPC": "Use RPC for inter-service communication. The client uses a request/reply-based protocol to make requests to a service.",
	"Client - Consumption - Messaging": "Use asynchronous messaging for inter-service communication. Services communicating by exchanging messages over messaging channels.",
	"Client - Aggregation": "",
	"Client - Aggregation - ClientSide - UIComposition": "Each team develops a client-side UI component, such an AngularJS directive, that implements the region of the page/screen for their service. A UI team is responsible implementing the page skeletons that build pages/screens by composing multiple, service-specific UI components.",
	"Client - Aggregation - ClientSide - Backend4Frontend": "optimises communication between clients and services by defining a separate API gateway for each kind of client.",
	"Client - Aggregation - ClientSide - ServiceComposition": "Each team developers a web application that generates the HTML fragment that implements the region of the page for their service. A UI team is responsible for developing the page templates that build pages by performing server-side aggregation (e.g. server-side include style mechanism) of the service-specific HTML fragments.",
	"Client - ServiceDiscovery": "",
	"Client - ServiceDiscovery - ClientSide": "When making a request to a service, the client obtains the location of a service instance by querying a Service Registry, which knows the locations of all service instances.",
	"Client - ServiceDiscovery - ServerSide": "When making a request to a service, the client makes a request via a router (a.k.a load balancer) that runs at a well known location. The router queries a service registry, which might be built into the router, and forwards the request to an available service instance.",
	"Client - ServiceDiscovery - Registry": "Implement a service registry, which is a database of services, their instances and their locations. Service instances are registered with the service registry on startup and deregistered on shutdown. Client of the service and/or routers query the service registry to find the available instances of a service. A service registry might invoke a service instance’s health check API to verify that it is able to handle requests",
	"Client - ServiceDiscovery - Registry - SelfRegistration": "A service instance is responsible for registering itself with the service registry. On startup the service instance registers itself (host and IP address) with the service registry and makes itself available for discovery. The client must typically periodically renew its registration so that the registry knows it is still alive. On shutdown, the service instance unregisters itself from the service registry.",
	"Client - ServiceDiscovery - Registry - 3rdPartyRegistration": "A 3rd party registrar is responsible for registering and unregistering a service instance with the service registry. When the service instance starts up, the registrar registers the service instance with the service registry. When the service instance shuts downs, the registrar unregisters the service instance from the service registry.",
	"Client - ServiceDiscovery - Registry - Product - Eureka": "",
	"Client - ServiceDiscovery - Registry - Product - Consul": "",
	"Client - ServiceDiscovery - Registry - Product - Zookeeper": "Tools like Zookeeper help manage and coordinate distributed services, ensuring they work together smoothly.",
	"Client - ServiceDiscovery - Standards - BDXL": "Business Document Metadata Service Location (BDXL)",
	"Client - ServiceDiscovery - Standards - SMP": "Service Metadata Publishing (SMP)",
	"Client - Caching": "",

	"Layer7": "SECTION",
	"Layer7 - Protocols - HTTP": "",
	"Layer7 - Protocols - HTTP - keep-alive": "Keep Connections Alive: Enable HTTP keep-alive to avoid re-establishing connections for every request.",
	"Layer7 - Protocols - HTTP2": "HTTP/2 began as the SPDY protocol, developed primarily at Google",
	"Layer7 - Protocols - HTTP2 - Goal": "Reducing server latency",
	"Layer7 - Protocols - HTTP2 - Features - Binary": "binary framing layer. As opposed to HTTP/1.1, which keeps all requests and responses in plain text format, HTTP/2 uses the binary framing layer to encapsulate all messages in binary format, while still maintaining HTTP semantics, such as verbs, methods, and headers.",
	"Layer7 - Protocols - HTTP2 - Features - Headers - compression": "Small files load more quickly than large ones. To speed up web performance, both HTTP/1.1 and HTTP/2 compress HTTP messages to make them smaller. However, HTTP/2 uses a more advanced compression method called HPACK that eliminates redundant information in HTTP header packets. This eliminates a few bytes from every HTTP packet. Given the volume of HTTP packets involved in loading even a single webpage, those bytes add up quickly, resulting in faster loading.",
	"Layer7 - Protocols - HTTP2 - Features - Prioritization": "Stream prioritization not only solves the possible issue of requests competing for the same resource, but also allows developers to customize the relative weight of requests to better optimize application performance.",
	"Layer7 - Protocols - HTTP2 - Features - Multiplexing": "HTTP/1.1 loads resources one after the other, so if one resource cannot be loaded, it blocks all the other resources behind it. In contrast, HTTP/2 is able to use a single TCP connection to send multiple streams of data at once so that no one resource blocks any other resource. HTTP/2 does this by splitting data into binary-code messages and numbering these messages so that the client knows which stream each binary message belongs to.",
	"Layer7 - Protocols - HTTP2 - Features - Push": "Server push: Typically, a server only serves content to a client device if the client asks for it. However, this approach is not always practical for modern webpages, which often involve several dozen separate resources that the client must request. HTTP/2 solves this problem by allowing a server to 'push' content to a client before the client asks for it. The server also sends a message letting the client know what pushed content to expect – like if Bob had sent Alice a Table of Contents of his novel before sending the whole thing.",
	"Layer7 - Protocols - HTTP3 - Transport": "Both HTTP/1.1 and HTTP/2 use TCP as their transport, whereas HTTP/3 is based on Google’s QUIC – a transport layer network protocol that implements user space congestion control over UDP (User Datagram Protocol).",
	"Layer7 - Publishing - Features - Reliability": ".",
	"Layer7 - Publishing - Features - Reliability - Retries": ".",
	"Layer7 - Publishing - Features - Reliability - CircuitBreaker": "Prevents cascading failures.",
	"Layer7 - Publishing - Features - Reliability - CircuitBreaker - Product - Hystrix": "",
	"Layer7 - Publishing - Features - Reliability - CircuitBreaker - Product - Istio": "",
	"Layer7 - Publishing - Features - Reliability - CircuitBreaker - Product - Resilience4j": "Resilience4j is a lightweight, easy-to-use library, which offers a powerful circuit breaker implementation inspired by Netflix Hystrix but designed with functional programming approach.",
	"Layer7 - Publishing - Features - Reliability - CircuitBreaker - Product - Sentinel": "It is an open-source library that provides monitoring of services and controls the traffic. It can be used to implement circuit breaking, rate limiting. Sentinel can work in both Java and other languages.",
	"Layer7 - Publishing - Features - Reliability - CircuitBreaker - Product - AmazonAppMesh": "Amazon App Mesh is a managed service mesh that allows you to monitor and control services running on AWS.",
	"Layer7 - Publishing - Features - Reliability - Bulkhead": ".",
	"Layer7 - Publishing - Features - WAF": "HTTP - WAFs analyze HTTP traffic for malicious requests.",
	"Layer7 - Publishing - Features - WAF - Layer7": ".",
	"Layer7 - Publishing - Products - APIGateway": "API gateway is the single entry point for all clients. API Gateway is primarily meant for external client-to-service communication.",
	"Layer7 - Publishing - Products - APIGateway - Location": "An API Gateway acts as a gatekeeper for microservices.",
	"Layer7 - Publishing - Products - APIGateway - Functions - protocol": "Protocol & Format Handling",
	"Layer7 - Publishing - Products - APIGateway - Functions - protocol - Translation": "Protocol Translation: Supports REST, GraphQL, gRPC, WebSockets, and SOAP to accommodate different communication methods.",
	"Layer7 - Publishing - Products - APIGateway - Functions - protocol - FormatHandling": "Request/Response Transformation: Modifies incoming and outgoing requests, such as converting XML to JSON.",
	"Layer7 - Publishing - Products - APIGateway - Functions - traffic": "Traffic manager at Layer 7 of OSI Model. The main purpose of an API gateway is to accept traffic from outside your network and distribute it internally.",
	"Layer7 - Publishing - Products - APIGateway - Functions - traffic - SingleInteractionPoint": "In a microservices ecosystem, the number of services communicating with each other can quickly grow as new features are added, leading to complexity. By serving as the central point of communication, the API Gateway streamlines interactions. Instead of services communicating directly, they interface with the Gateway, which then manages communication with other services.",
	"Layer7 - Publishing - Products - APIGateway - Functions - traffic - RateLimiting": "Rate Limiting & Throttling: Controls how many requests a client can make within a time frame to prevent abuse and overload.",
	"Layer7 - Publishing - Products - APIGateway - Functions - traffic - LoadBalancing": "Load Balancing: Distributes incoming API requests across multiple backend services to ensure availability and performance.",
	"Layer7 - Publishing - Products - APIGateway - Functions - traffic - RequestRouting": "Request Routing: Directs API calls to the appropriate backend services based on rules or conditions.",
	"Layer7 - Publishing - Products - APIGateway - Functions - traffic - RequestRouting - proxy": "Some requests are simply proxied/routed to the appropriate service.",
	"Layer7 - Publishing - Products - APIGateway - Functions - traffic - RequestRouting - broadcast": "Other requests by fanning out to multiple services.",
	"Layer7 - Publishing - Products - APIGateway - Functions - traffic - ResultsAggregation": "The Gateway aggregates results from disparate services, providing a consolidated response to the client, thus improving efficiency.",
	"Layer7 - Publishing - Products - APIGateway - Functions - security": "Security.",
	"Layer7 - Publishing - Products - APIGateway - Functions - security - DDoSProtection": "Mitigates Distributed Denial of Service (DDoS) attacks by blocking malicious traffic.",
	"Layer7 - Publishing - Products - APIGateway - Functions - security - SSL": "SSL/TLS Termination: Encrypts data in transit to ensure secure communication.",
	"Layer7 - Publishing - Products - APIGateway - Functions - security - CORS": "Cross-Origin Resource Sharing (CORS) Management: Handling requests from other domains.",
	"Layer7 - Publishing - Products - APIGateway - Functions - security - authentication": "API Gateway centralizes authentication and authorization, managing security protocols centrally and ensuring secure communication between clients and services. Supports OAuth, JWT, API keys, and other authentication methods to secure APIs..",
	"Layer7 - Publishing - Products - APIGateway - Functions - security - validation": "Request and Response validation: Validate the microservice requests and responses and ensure they conform to the expected format and structure. This helps prevent errors and ensure the proper functioning of the microservice.",
	"Layer7 - Publishing - Products - APIGateway - Functions - security - CircuitBreaker": "Circuit Breaker: Act as a circuit breaker to prevent a single failed microservice from bringing down the entire system.",
	"Layer7 - Publishing - Products - APIGateway - Functions - security - ErrorHandling": "Error Handling: Provide a consistent way to handle errors and generate error responses to clients even when backend services are unavailable or return unexpected results.",
	"Layer7 - Publishing - Products - APIGateway - Functions - integration": "Integration & Automation",
	"Layer7 - Publishing - Products - APIGateway - Functions - integration - Transformation": "Request and Response Transformation: Modifying requests and responses for compatibility. It can translate between protocols. For example, if a client sends a request using HTTP/1.1, but the backend service expects requests in gRPC format, the API Gateway can translate the HTTP request into a gRPC request before forwarding it to the backend service. Likewise, when the backend service responds with data in gRPC format, the API Gateway can translate it back into HTTP format before sending it back to the client.",
	"Layer7 - Publishing - Products - APIGateway - Functions - integration - Discovery": "Backend Service Discovery: Dynamically connects with backend services using service registries.",
	"Layer7 - Publishing - Products - APIGateway - Functions - integration - Caching": "Caching: Stores frequent API responses to reduce latency and improve performance.",
	"Layer7 - Publishing - Products - APIGateway - Functions - integration - EDA": "Webhooks & Event-Driven Integration: Supports event-based workflows for real-time API interactions.",
	"Layer7 - Publishing - Products - APIGateway - Functions - lifecycle": "Developer Experience & API Lifecycle Management",
	"Layer7 - Publishing - Products - APIGateway - Functions - lifecycle - Versioning": "API Versioning: Allows multiple API versions to coexist, making updates easier.",
	"Layer7 - Publishing - Products - APIGateway - Functions - lifecycle - Mock": "Mock Responses & Testing: Enables testing API behavior without backend implementation.",
	"Layer7 - Publishing - Products - APIGateway - Functions - lifecycle - Documentation": "API Documentation & Developer Portals: Provides auto-generated documentation and interactive portals for developers.",
	"Layer7 - Publishing - Products - APIGateway - Functions - audit": "",
	"Layer7 - Publishing - Products - APIGateway - Functions - audit - logging": "Logging & Monitoring: Tracks API usage and performance with logging tools like AWS CloudWatch or Prometheus.",
	"Layer7 - Publishing - Products - APIGateway - Functions - audit - metrics": "Analytics & Metrics: Provides insights into API usage patterns, error rates, and latency for better decision-making.",
	"Layer7 - Publishing - Products - APIGateway - Functions - audit - metering": "API Metering and Billing: Tracking API usage for reporting and billing.",
	"Layer7 - Publishing - Products - APIGateway - Tools - Kong API Gateway": ".",
	"Layer7 - Publishing - Products - APIGateway - Tools - NGINX API Gateway": ".",
	"Layer7 - Publishing - Products - APIGateway - Tools - AWS API Gateway": ".",
	"Layer7 - Publishing - Products - APIGateway - Tools - Apigee (Google Cloud)": ".",
	"Layer7 - Publishing - Products - APIGateway - Tools - Azure API Management": ".",
	"Layer7 - Publishing - Products - APIGateway - Tools - SpringCloudGateway": ".",
	"Layer7 - Publishing - Products - APIGateway - Tools - WSO2": ".",
	"Layer7 - Publishing - Products - APIGateway - Tools - Ocelot": ".",
	"Layer7 - Publishing - Products - APIGateway - Tools - Traefik": ".",
	"Layer7 - Publishing - Comparison - APIGateway vs LoadBalancer vs ReverseProxy": "While load balancers, reverse proxies, and API Gateways share the goal of optimizing and managing web traffic, they serve distinct functions:",
	"Layer7 - Publishing - Comparison - APIGateway vs LoadBalancer vs ReverseProxy - LoadBalancer": "Optimizes resource utilization by distributing traffic among servers. Used to handle heavy traffic and ensure even load distribution.",
	"Layer7 - Publishing - Comparison - APIGateway vs LoadBalancer vs ReverseProxy - ReverseProxy": "Acts as an intermediary between clients and servers, providing security and control. Manages SSL encryption, serves static content, and controls access to internal servers.",
	"Layer7 - Publishing - Comparison - APIGateway vs LoadBalancer vs ReverseProxy - APIGateway": "Manages interactions between clients and backend services in a microservices architecture. Provides functionalities like routing, aggregation, and security in addition to handling requests.",
	"Layer7 - Publishing - Features - Audit - Documentation - Swagger": "",
	"Layer7 - Publishing - Features - Audit - Documentation - Swagger - Codegen": "",
	"Layer7 - Publishing - Features - Audit - Documentation - Swagger - Editor": "",
	"Layer7 - Publishing - Features - Audit - Documentation - Swagger - UI": "",
	"Layer7 - Publishing - Features - Audit - Documentation - OpenAPI": "",
	"Layer7 - Publishing - Features - Audit - Documentation - Postman": "",
	"Layer7 - Publishing - Features - Audit - Documentation - ReDoc": "",
	"Layer7 - Publishing - Features - Audit - Testing": "Unit Testing, Integration Testing, Contract Testing, End-to-End Testing",
	"Layer7 - Publishing - Features - Audit - Testing - Unit Testing": "The scope of unit testing can be sociable or solitary concerning a service. The smaller the unit will be under test, the easier it is to determine the behavior of modules and probe the collaborators as well as interactions between objects and their dependencies. Since the cyclomatic complexity of the unit is inferior, Quality Analysis (QA) engineers can evaluate whether or not the units are isolated from their collaborators by using this testing strategy. Both the sociable and solitary unit testing styles are frequently used simultaneously in the same codebase to tackle different testing issues. The motive behind testing the domain layer is to emulate DML statements and certify that all collaborators use the real domain objects in correct sequence. During the unit testing, engineers can verify the logic used to generate map responses or other requests from external remote dependencies. As far as resources and service layer are concerned, they validate that each component correctly interacts with its collaborator, thereby monitoring the request/response cycle in a repeatable and consistent manner.",
	"Layer7 - Publishing - Features - Audit - Testing - Unit Testing - RestAssured": "✅ Real-time API testing scenarios ✅ Serialization & Deserialization ✅ Auth mechanisms (Basic, OAuth2, Bearer Tokens) ✅ Schema Validation, File Upload/Download ✅ TestNG Parallel Execution setup ✅ Mocking APIs, Caching, Rate Limiting https://www.linkedin.com/posts/neha-sharma-0a0906148_restapi-activity-7317064488115953664-LIY7?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Layer7 - Publishing - Features - Audit - Testing - Unit Testing - SoapUI": "",
	"Layer7 - Publishing - Features - Audit - Testing - Unit Testing - Postman": "",
	"Layer7 - Publishing - Features - Audit - Testing - Contract Testing": "Contract testing is a sort of a black box that verifies the contract between an external service call and its API provider endpoint. There are two types of contract testing, including: Integration contract testing, Consumer-driven contract testing",
	"Layer7 - Publishing - Features - Audit - Testing - Contract Testing - Integration contract testing": "In integration contract testing, each component needs to be called independently, and it must meet the contract agreement anticipated by a consuming service. The best way to deal with this is to carry out a test against the double. On a side note, it’s critical to run a separate set of tests periodically to confirm that there are no changes against your test doubles. However, a failure in these tests can slow down the deployment pipeline and disrupt the functionality of an IT infrastructure or distributed system. One best possible way to handle intermittent test failures is by updating your test doubles, and probably the code too so as to bring them back into high coherence and consistency with external services.",
	"Layer7 - Publishing - Features - Audit - Testing - Contract Testing - Consumer-driven contract testing": "In consumer-driven contract testing, consumers will delineate the way in which they want to consume a service. The consumer contracts can be made in a mutually consented language and schema between the producer and consumer. The service providers will test a service against the replicas of the individual contracts, and then make changes to that particular service without impacting the nature of other services.",
	"Layer7 - Publishing - Features - Audit - Testing - Integration Testing": "Integration testing takes place in the staging environment to integrate individual services after analyzing the functionality of communication pathways and interactions between them. Unlike monolithic or SOA, microservices architecture depends on the Inter-Process Communication (IPC) mechanism to function appropriately, which is why the interactions between services must be verified. Automated tests need to be written for mapping out the success and error cases through the integration with external services and data stores. Running gateway integration tests will defect interface errors, such as incorrect SSL handling and missing HTTP headers, at the protocol level. And the persistence integration test ensures that each component and protocol client must respond as an external dependency in case of timeouts and partial failures.",
	"Layer7 - Publishing - Features - Audit - Testing - E2E Testing": "End-to-End (E2E) testing ascertains that the overall system is accurately working as well as the network infrastructure (load balancers, firewall, and more) is correctly configured. E2E tests, however, need to be run at the finest coarse granularity possible to test the functionality of the entire system. In this, QA engineers verify the behavior of the fully-integrated process and make sure that the system collectively meets its business requirements, regardless of the Service Component Architecture in use. With the help of functional testing, developers can determine if an integrated system or app functions as stated in the requirements.",
	"Layer7 - Publishing - Features - Audit - Observability": "Observability (logs, traces, metrics, events): Monitoring + Alerting/visualization + Distributed systems tracing infrastructure + Log aggregation/analytics: Log aggregation - Application metrics - Audit logging - Distributed tracing - Exception tracking - Health check API - Log deployments and changes",
	"Layer7 - Publishing - Features - Audit - Observability - Log aggregation": "Use a centralized logging service that aggregates logs from each service instance. The users can search and analyze the logs. They can configure alerts that are triggered when certain messages appear in the logs.",
	"Layer7 - Publishing - Features - Audit - Observability - Application metrics": "Instrument a service to gather statistics about individual operations. Aggregate metrics in centralized metrics service, which provides reporting and alerting. There are two models for aggregating metrics: push - the service pushes metrics to the metrics service pull - the metrics services pulls metrics from the service",
	"Layer7 - Publishing - Features - Audit - Observability - Audit logging": "Record user activity in a database.",
	"Layer7 - Publishing - Features - Audit - Observability - Distributed tracing": "Instrument services with code that: Assigns each external request a unique external request id. Passes the external request id to all services that are involved in handling the request. Includes the external request id in all log messages. Records information (e.g. start time, end time) about the requests and operations performed when handling a external request in a centralized service. This instrumentation might be part of the functionality provided by a Microservice Chassis framework.",
	"Layer7 - Publishing - Features - Audit - Observability - Exception tracking": "Report all exceptions to a centralized exception tracking service that aggregates and tracks exceptions and notifies developers.",
	"Layer7 - Publishing - Features - Audit - Observability - Health check API": "A service has an health check API endpoint (e.g. HTTP /health) that returns the health of the service. The API endpoint handler performs various checks, such as: the status of the connections to the infrastructure services used by the service instance, the status of the host, e.g. disk space, application specific logic A health check client - a monitoring service, service registry or load balancer - periodically invokes the endpoint to check the health of the service instance.",
	"Layer7 - Publishing - Features - Audit - Observability - Log deployments and changes": "Log every deployment and every change to the (production) environment.",
	"Layer7 - Publishing - Features - Audit - Observability - Tools - Prometheus": "Prometheus is an open-source toolkit for monitoring and alerting based on an embedded times-series database, a query DSL and various mechanics for scraping metrics data off endpoints.",
	"Layer7 - Publishing - Features - Audit - Observability - Tools - Graphana": ".",
	"Layer7 - Publishing - Features - Audit - Observability - Tools - Datadog": ".",
	"Layer7 - Publishing - Features - Audit - Observability - Tools - ELKStack": ".",
	"Layer7 - Publishing - Features - Audit - Observability - Tools - Splunk": ".",
	"Layer7 - Publishing - Features - Audit - Observability - Tools - Jaeger": ".",
	"Layer7 - Publishing - Features - Audit - Observability - Tools - Zipkin": ".",
	"Layer7 - Publishing - Features - Audit - Observability - Tools - SpringCloudSleuth": "Spring Cloud Sleuth provides Spring Boot auto-configuration for distributed tracing. Spring Cloud Sleuth will not work with Spring Boot 3.x onward. The last major version of Spring Boot that Sleuth will support is 2.x.",


	"Interaction": "SECTION",
	"Interaction - SOAP": "A heavyweight protocol that uses XML-based messaging, offering strict security and reliability for enterprise applications. ",
	"Interaction - SOAP - Tools - JAX-WS": "",
	"Interaction - REST": "",
	"Interaction - REST - Requirements - Constraints - (6 from thesis)": "Uniform Interface, Stateless, Cacheable, Client-Server, Layered System, Code on Demand (optional)",
	"Interaction - REST - Requirements - Constraints - 1. Uniform Interface": "*(1) Resource-Based (Individual resources are identified in requests using URIs as resource identifiers), (2) Manipulation of Resources Through Representations (When a client holds a representation of a resource, including any metadata attached, it has enough information to modify or delete the resource on the server, provided i has permission to do so). (3) Self-descriptive Messages (Each message includes enough information to describe how to process the message). (4) Hypermedia as the Engine of Application State (HATEOAS) (Clients deliver state via body contents, query-string parameters, request headers and the requested URI (the resource name). Services deliver state to clients via body content, response codes, and response headers. This is technically referred-to as hypermedia (or hyperlinks within hypertext).",
	"Interaction - REST - Requirements - Constraints - 2. Stateless": "As REST is an acronym for REpresentational State Transfer, statelessness is key. Essentially, what this means is that the necessary state to handle the request is contained within the request itself, whether as part of the URI, query-string parameters, body, or headers. The URI uniquely identifies the resource and the body contains the state (or state change) of that resource. Then after the server does it's processing, the appropriate state, or the piece(s) of state that matter, are communicated back to the client via headers, status and response body.",
	"Interaction - REST - Requirements - Constraints - 3. Cacheable": "As on the World Wide Web, clients can cache responses. Responses must therefore, implicitly or explicitly, define themselves as cacheable, or not, to prevent clients reusing stale or inappropriate data in response to further requests. Well-managed caching partially or completely eliminates some client–server interactions, further improving scalability and performance.",
	"Interaction - REST - Requirements - Constraints - 4. Client-Server": "The uniform interface separates clients from servers. This separation of concerns means that, for example, clients are not concerned with data storage, which remains internal to each server, so that the portability of client code is improved. Servers are not concerned with the user interface or user state, so that servers can be simpler and more scalable. Servers and clients may also be replaced and developed independently, as long as the interface is not altered.",
	"Interaction - REST - Requirements - Constraints - 5. Layered System": "A client cannot ordinarily tell whether it is connected directly to the end server, or to an intermediary along the way. Intermediary servers may improve system scalability by enabling load-balancing and by providing shared caches. Layers may also enforce security policies.",
	"Interaction - REST - Requirements - Constraints - 6. Code on Demand (optional)": "Servers are able to temporarily extend or customize the functionality of a client by transferring logic to it that it can execute. Examples of this may include compiled components such as Java applets and client-side scripts such as JavaScript. Complying with these constraints, and thus conforming to the REST architectural style, will enable any kind of distributed hypermedia system to have desirable emergent properties, such as performance, scalability, simplicity, modifiability, visibility, portability and reliability. NOTE: The only optional constraint of REST architecture is code on demand. If a service violates any other constraint, it cannot strictly be referred to as RESTful.",
	"Interaction - REST - Requirements - Richardson Maturity Model": "",
	"Interaction - REST - Requirements - Richardson Maturity Model - Level0": "Level 0: Level 0 uses its implementing protocol (normally HTTP, but it doesn't have to be) like a transport protocol (Swamp of POX).",
	"Interaction - REST - Requirements - Richardson Maturity Model - Level1": "Level 1: Resources. When your API can distinguish between different resources, it might be level 1. This level uses multiple URIs, where every URI is the entry point to a specific resource.",
	"Interaction - REST - Requirements - Richardson Maturity Model - Level2": "Level 2: HTTP verbs. This level indicates that your API should use the protocol properties in order to deal with scalability and failures. Don't use a single POST method for all, but make use of GET when you are requesting resources, and use the DELETE method when you want to delete a resources. Also, use the response codes of your application protocol. Don't use 200 (OK) code when something went wrong for instance. ",
	"Interaction - REST - Requirements - Richardson Maturity Model - Level3": "Level 3: Hypermedia controls Level 3, the highest level, uses HATEOAS to deal with discovering the possibilities of your API towards the clients.",
	"Interaction - REST - Protocols": "Typically HTTP but nothing makes HTTP mandatory. Can be SNMP, SMTP and others to use.",
	"Interaction - REST - Design": ".",
	"Interaction - REST - Design - 1-ObjectModel": "(1) Identify Object Model. Identifying the objects which will be presented as resources.",
	"Interaction - REST - Design - 2-ResourceURIs": "(2) Decide the resource URIs.",
	"Interaction - REST - Design - 2-ResourceURIs - endpoints": "These resource URIs are endpoints for RESTful services..",
	"Interaction - REST - Design - 2-ResourceURIs - nouns": "These URIs do not use any verb or operation. URIs should all be nouns only.",
	"Interaction - REST - Design - 3-Representations": "(3) Determine Representations in either XML or JSON format.",
	"Interaction - REST - Design - 4-HTTPMethods": "(4) Assign HTTP Methods.",
	"Interaction - REST - Design - 4-HTTPMethods - GET": "Use GET requests to retrieve resource representation/information only – and not to modify it in any way.",
	"Interaction - REST - Design - 4-HTTPMethods - GET - Response - ifItem": "Responses if item: 200 (OK), single user. 404 (Not Found), if ID not found or invalid.",
	"Interaction - REST - Design - 4-HTTPMethods - GET - Response - ifCollection": "Responses if collection: 200 (OK), list of users.",
	"Interaction - REST - Design - 4-HTTPMethods - GET - Properties - Safe": "As GET requests do not change the state of the resource, these are said to be safe methods.",
	"Interaction - REST - Design - 4-HTTPMethods - GET - Properties - Idempotent": "Additionally, GET APIs should be idempotent.",
	"Interaction - REST - Design - 4-HTTPMethods - GET - Operations - Pagination": "Use pagination, sorting and filtering to navigate big lists.",
	"Interaction - REST - Design - 4-HTTPMethods - POST": "Create a new resource into the collection of resources.",
	"Interaction - REST - Design - 4-HTTPMethods - POST - Response - ifItem": "Responses if item: Avoid using POST on single resource.",
	"Interaction - REST - Design - 4-HTTPMethods - POST - Response - ifCollection": "Responses if collection: 201 (Created), ‘Location’ header with link to /users/{id} containing new ID.",
	"Interaction - REST - Design - 4-HTTPMethods - PUT": "Update existing resource (if the resource does not exist then API may decide to create a new resource or not).",
	"Interaction - REST - Design - 4-HTTPMethods - PUT - Response - ifItem": "Responses if item: 200 (OK) or 204 (No Content). Use 404 (Not Found), if ID not found or invalid.",
	"Interaction - REST - Design - 4-HTTPMethods - PUT - Response - ifCollection": "Responses if collection: 404 (Not Found), unless you want to update every resource in the entire collection of resource.",
	"Interaction - REST - Design - 4-HTTPMethods - PUT - Operations - Caching": "If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale. Responses to this method are not cacheable.",
	"Interaction - REST - Design - 4-HTTPMethods - DELETE": "delete resources (identified by the Request-URI). If you DELETE a resource, it’s removed from the collection of resource.",
	"Interaction - REST - Design - 4-HTTPMethods - DELETE - Response - ifItem": "Responses if item: 200 (OK). 404 (Not Found), if ID not found or invalid.",
	"Interaction - REST - Design - 4-HTTPMethods - DELETE - Response - ifCollection": "Responses if collection: 404 (Not Found), unless you want to delete the whole collection — use with caution.",
	"Interaction - REST - Design - 4-HTTPMethods - DELETE - Properties - Idempotent": "DELETE operations are idempotent. Repeatedly calling DELETE API on that resource will not change the outcome – however calling DELETE on a resource a second time will return a 404 (NOT FOUND) since it was already removed. Some may argue that it makes DELETE method non-idempotent. It’s a matter of discussion and personal opinion. ",
	"Interaction - REST - Design - 4-HTTPMethods - DELETE - Operations - Caching": "If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale. Responses to this method are not cacheable.",
	"Interaction - REST - Design - 4-HTTPMethods - PATCH": "make partial update on a resource. If you see PUT requests also modify a resource entity so to make more clear – PATCH method is the correct choice for partially updating an existing resource and PUT should only be used if you’re replacing a resource in its entirety. Support for PATCH in browsers, servers, and web application frameworks is not universal. PATCH method is not a replacement for the POST or PUT methods. It applies a delta (diff) rather than replacing the entire resource.",
	"Interaction - REST - Design - 4-HTTPMethods - PATCH - Response - ifItem": "Responses if item: 200 (OK) or 204 (No Content). Use 404 (Not Found), if ID not found or invalid.",
	"Interaction - REST - Design - 4-HTTPMethods - PATCH - Response - ifCollection": "Responses if collection: 404 (Not Found), unless you want to modify the collection itself.",
	"Interaction - REST - Design - 4-HTTPMethods - OPTIONS": "This method allows the client of the REST API to determine, which HTTP method ( GET, HEAD, POST, PUT, DELETE ) can be used for a resource identified by requested URI, without initiating a resource request by using any particular HTTP method.",
	"Interaction - REST - Design - 4-HTTPMethods - OPTIONS - Operations - Caching": "Response to this method are not cacheable.",
	"Interaction - REST - Design - 4-HTTPMethods - HEAD": "returns all of the HTTP headers, just like GET, but provides no body content. All of the same rules regarding content caching can be applied, regarding headers in the request/response.",
	"Interaction - REST - Design - 4-HTTPMethods - HTTP POST vs HTTP PUT vs HTTP PATCH": "PUT is for creating or conmpletely updating a single resource when you know the URL (e.g. create update object). It is idempotent. POST is to create when you do not know the URL (e.g.adding item to a collection). No idempotent, PATCH is to update part of a resource when you know the URL. Idempotent",
	"Interaction - REST - Design - 5-Other": "(5) You need to work on other aspects of the application as well: Logging, Security, Discovery etc.",
	"Interaction - REST - ContentNegotiation": "HTTP response headers: Content-Type, Accept",
	"Interaction - REST - Versioning": "",
	"Interaction - REST - Versioning - /v1/": "(1) Using URI: /api/v1/customer/{id}",
	"Interaction - REST - Versioning - Accept": "(2) Using Accept header: Accept: application/vnd.example.v1+json",
	"Interaction - REST - Versioning - Accept-version": "(3) Using Custom Request Header: Accept-version: v1",
	"Interaction - REST - Security": "Enforce HTTPS, use OAuth 2.0, implement rate limiting, and validate all inputs.",
	"Interaction - REST - Caching": "The basic purpose of HTTP caching is to provide a mechanism for applications to scale better and perform faster.",
	"Interaction - REST - Caching - headers": "HTTP response headers: Expires, Cache-Control, ETag, Last-Modified",
	"Interaction - REST - Caching - scope": "HTTP caching involves client, forward proxy, reverse proxy and server.",
	"Interaction - REST - Caching - proxy": "A typical proxy caches idempotent and nullipotent requests.",
	"Interaction - REST - Caching - proxy - Nullipotent": "GET and HEAD. Safe or nullipotent methods. Read-only. They do not modify the state on the server.",
	"Interaction - REST - Caching - proxy - Idempotent": "PUT (override), DELETE (after first), OPTIONS and TRACE. Multiple identical requests has the same effect in server. Developers must adhere to when implementing RESTful APIs over HTTP.",
	"Interaction - REST - Caching - proxy - NoIdempotent": "Responses to POST are not idempotent. They are not cacheable UNLESS the response includes appropriate Cache-Control or Expires header fields.",
	"Interaction - REST - ResponseSize - Compression": "HTTP response headers: Accept-Encoding, Content-Encoding",
	"Interaction - REST - ResponseSize - Pagination": "GET - Limit large datasets (?page=1&size=10).",
	"Interaction - REST - ResponseSize - Filtering": "GET - Focused searches (?name=sketech).",
	"Interaction - REST - ResponseSize - Sorting": "GET - Organize results (?sort=name).",
	"Interaction - REST - Tools - JAX-RS": "JAX-RS is a standard defined in Java Specification Request 311 (JSR-311). JAX-RS is only a specification and it needs a compatible implementation to be used.",
	"Interaction - REST - Tools - JAX-RS - JAX-RS 1.0 - 2008": "When JAX-RS 1.0 was first unveiled back in 2008.",
	"Interaction - REST - Tools - JAX-RS - JAX-RS 1.1 - 2010": "From version 1.1 on, JAX-RS is an official part of Java EE 6. A notable feature of being an official part of Java EE is that no configuration is necessary to start using JAX-RS.",
	"Interaction - REST - Tools - JAX-RS - JAX-RS 2.0 - 2011": "In January 2011 the JCP formed the JSR 339 expert group to work on JAX-RS 2.0.",
	"Interaction - REST - Tools - JAX-RS - JAX-RS 2.1 - 2017": "On 2017-08-22 JAX-RS 2.1[4] specification final release was published. Main new supported features include server-sent events, reactive clients, and JSON-B.[5]",
	"Interaction - REST - Tools - JAX-RS - Impl - Jersey": "Jersey RESTful Web Services framework is open source, production quality, framework for developing RESTful Web Services in Java that provides support for JAX-RS APIs and serves as a JAX-RS (JSR 311 & JSR 339) Reference Implementation.",
	"Interaction - REST - Tools - JAX-RS - Impl - RestEasy": "JBoss's JAX-RS project.",
	"Interaction - REST - Tools - JAX-RS - Impl - Restlet ": "probably the first REST framework, which existed prior to JAX-RS.",
	"Interaction - REST - Tools - JAX-RS - Impl - CXF": "which is a merger between XFire and Celtix (an Open Source ESB, sponsored by IONA and originally hosted at ObjectWeb).",
	"Interaction - REST - Tools - JAX-RS - Impl - ApacheWink": "",
	"Interaction - REST - Tools - SpringMVC": "Spring MVC module provides capabilities to write RESTful web services.",

	"Service - Processing": "SECTION",
	"Service - Processing - Patterns - Chassis": "A base framework or even another service which can be reused across different services. This pattern cuts down on the redundancy factor and complexity across services by abstracting the common logic to a separate layer.",
	"Service - Processing - Patterns - Sidecar": "In a microservice architecture, it’s very common to have multiple services/apps that often require common functionalities like logging, configuration, monitoring & networking services. These functionalities can be implemented and run as a separate service within the same container or in a separate container. A sidecar pattern is a single-node pattern made up of two containers.",
	"Service - Processing - Patterns - Sidecar - application": "The first is the application container which contains the core logic of the application (primary application). Without this container, application wouldn’t exist.",
	"Service - Processing - Patterns - Sidecar - sidecar": "In addition, there is a Sidecar container used to extend/enhance the functionalities of the primary application by running another container in parallel on the same container group (Pod). Since sidecar runs on the same Pod as the main application container it shares the resources — filesystem, disk, network etc.,",
	"Service - Processing - Migration - StranglerPattern": "The Strangler pattern is a software architectural pattern used to gradually migrate from a monolithic application to microservices or modernize a legacy system. It involves replacing functionalities incrementally, one component at a time, while keeping the existing system operational.",
	"Service - Processing - Migration - StranglerPattern - facade": "This is achieved by introducing a facade (or proxy) that redirects calls to the old system to the new, modernized components as they become available. The old system is gradually 'strangled' as the new services take over its functionalities. ",
	"Service - Processing - Configuration": "Externalize all application configuration including the database credentials and network location. On startup, a service reads the configuration from an external source, e.g. OS environment variables, etc.",
	"Service - Processing - Aggregation": "",
	"Service - Processing - Aggregation - MultiServicePerHost": "Run multiple instances of different services on a host (Physical or Virtual machine). There are various ways of deploying a service instance on a shared host including: Deploy each service instance as a JVM process. For example, a Tomcat or Jetty instances per service instance. Deploy multiple service instances in the same JVM. For example, as web applications or OSGI bundles.",
	"Service - Processing - Aggregation - ServicePerHost": "Deploy each single service instance on its own host",
	"Service - Processing - Aggregation - ServicePerVM": "Package the service as a virtual machine image and deploy each service instance as a separate VM",
	"Service - Processing - Aggregation - ServicePerContainer": "Package the service as a (Docker) container image and deploy each service instance as a container",
	"Service - Processing - Aggregation - DatabasePerService": "Each service manages its own data. Promotes loose coupling but requires eventual consistency handling.",

	"Middleware": "SECTION",
	"Middleware - ServiceMesh": "A service mesh is a configurable infrastructure layer for microservices that makes communication between service instances flexible, reliable, and fast. The mesh provides service discovery, load balancing, encryption, authentication and authorization, support for the circuit breaker pattern, and other capabilities.",
	"Middleware - ServiceMesh - Structure": "This layer is composed of containerized microservices.",
	"Middleware - ServiceMesh - Goal - intercommunication": "A service mesh's primary purpose is to manage internal service-to-service communication.",
	"Middleware - ServiceMesh - Goal - routing": "The main purpose of a service mesh is to route and manage traffic within your network.",
	"Middleware - ServiceMesh - Tools - Istio": "",
	"Middleware - Caching": "",
	"Middleware - Caching - Tools - Redis": "",
	"Middleware - Caching - Tools - Memcache": ""

}