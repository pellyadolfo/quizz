{			

	"Messaging - EIP": "SECTION",
	"Messaging - EIP ": "Enterprise Integration Patterns",
	"Messaging - EIP - Integration Style. File Transfer": "How can I integrate multiple applications so that they work together and can exchange information? Have each application produce files containing information that other applications need to consume. Integrators take the responsibility of transforming files into different formats. Produce the files at regular intervals according to the nature of the business.",
	"Messaging - EIP - Integration Style. Shared Database": "How can I integrate multiple applications so that they work together and can exchange information? Integrate applications by having them store their data in a single Shared Database.",
	"Messaging - EIP - Integration Style. Remote Procedure Invocation": "How can I integrate multiple applications so that they work together and can exchange information? Develop each application as a large-scale object or component with encapsulated data. Provide an interface to allow other applications to interact with the running application.",
	"Messaging - EIP - Integration Style. Messaging": "How can I integrate multiple applications so that they work together and can exchange information? Use Messaging to transfer packets of data frequently, immediately, reliably, and asynchronously, using customizable formats.",
	"Messaging - EIP - Messaging Systems. ": "",

	"Messaging - EDA": "SECTION",
	"Messaging - EDA - definition": "Event-Driven Architecture is a software design approach in which components of the system communicate by sending and receiving events.",
	"Messaging - EDA - Components": ".",
	"Messaging - EDA - Components - Producers": "Event Producers: Components that emit events.",
	"Messaging - EDA - Components - Consumers": "Event Consumers: Components that respond to events.",
	"Messaging - EDA - Components - Channels": "Event Channel: The medium that transmits events from producers to consumers.",
	"Messaging - EDA - Components - Channels - Broker": "To handle large volumes of events in Node.js, consider using a message broker such as Redis, RabbitMQ, or Apache Kafka. These tools provide persistence, queuing, and reliability, making it easier to scale your event-driven system.",
	"Messaging - EDA - Components - Channels - Broker - Goal": "Decoupling 2 applications and allowing parallel asynchronous processing.",
	"Messaging - EDA - Components - Channels - Broker - Features - Model - push/pull": "",
	"Messaging - EDA - Components - Channels - Broker - Features - Multiplicity - Multiple vs Single Consumers": "",
	"Messaging - EDA - Components - Channels - Broker - Features - Multiplicity - Multiple vs Single Delivery": "",
	"Messaging - EDA - Components - Channels - Broker - Features - Reliability - Guaranteed": "This guarantee does come with a heavy performance price because the broker must securely persist the message in its message store prior to acknowledging the message to the producer.",
	"Messaging - EDA - Components - Channels - Broker - Features - Reliability - Dead Letter Queue": "",
	"Messaging - EDA - Components - Channels - Broker - Features - Persistence": "Messages are persisted for some (configurable) duration is no consumer available.",
	"Messaging - EDA - Components - Channels - Broker - Features - Persistence - Message Copies": "",
	"Messaging - EDA - Components - Channels - Broker - Features - Order": "",
	"Messaging - EDA - Components - Channels - Broker - QoS - QoS 0": "QoS 0: At most once delivery",
	"Messaging - EDA - Components - Channels - Broker - QoS - QoS 1": "QoS 1: At least once delivery",
	"Messaging - EDA - Components - Channels - Broker - QoS - QoS 2": "QoS 2: Exactly once delivery",
	"Messaging - EDA - Components - Channels - Broker - Types - Pull": "Messages are NOT pushed to receivers. Receivers have to poll the broker to receive messages.",
	"Messaging - EDA - Components - Channels - Broker - Types - Pull - EDA - Components - Channels - ": "Queues",
	"Messaging - EDA - Components - Channels - Broker - Types - Pull - Formats - JMS PTP": "",
	"Messaging - EDA - Components - Channels - Broker - Types - Pull - Formats - AMQP": "",
	"Messaging - EDA - Components - Channels - Broker - Types - Pull - Formats - ZeroMQ": "",
	"Messaging - EDA - Components - Channels - Broker - Types - Pull - Formats - AWS SQS": "",
	"Messaging - EDA - Components - Channels - Broker - Types - Pull - Formats - Custom": "",
	"Messaging - EDA - Components - Channels - Broker - Types - Push": "Messages are pushed to subscribers as and when they are sent by publishers.",
	"Messaging - EDA - Components - Channels - Broker - Types - Push - EDA - Components - Channels - ": "Topics",
	"Messaging - EDA - Components - Channels - Broker - Types - Push - Formats - JMS Format": "",
	"Messaging - EDA - Components - Channels - Broker - Types - Push - Formats - AMQP": "",
	"Messaging - EDA - Components - Channels - Broker - Types - Push - Formats - MQTT": "",
	"Messaging - EDA - Components - Channels - Broker - Types - Push - Formats - STOMP": "",
	"Messaging - EDA - Components - Channels - Broker - Types - Push - Formats - WAMP": "",
	"Messaging - EDA - Components - Channels - Broker - Types - Push - Formats - ZeroMQ": "",
	"Messaging - EDA - Components - Channels - Broker - Types - Push - Formats - Custom": "",
	"Messaging - EDA - Components - Channels - Brokers - Mosquito": "",
	"Messaging - EDA - Components - Channels - Brokers - Pushy": "",
	"Messaging - EDA - Components - Channels - Brokers - VerneMQ": "",
	"Messaging - EDA - Components - Channels - Brokers - IBM Bluemix": "",
	"Messaging - EDA - Components - Channels - Brokers - IBM IoT MessageSight": "",
	"Messaging - EDA - Components - Channels - Brokers - IBM WebSphere MQ Telemetry": "",
	"Messaging - EDA - Components - Channels - Brokers - HiveMQ": "",
	"Messaging - EDA - Components - Channels - Brokers - Azure IoT": "",
	"Messaging - EDA - Components - Channels - Brokers - ThingMQ": "",
	"Messaging - EDA - Components - Channels - Brokers - ThingStudio": "",
	"Messaging - EDA - Components - Channels - Brokers - cloudMQTT": "",
	"Messaging - EDA - Components - Channels - Brokers - Heroku CloudMQTT": "",
	"Messaging - EDA - Components - Channels - Brokers - MachineHead": "",
	"Messaging - EDA - Components - Channels - Brokers - RabbitMQ": "",
	"Messaging - EDA - Components - Channels - Brokers - ActiveMQ": "",
	"Messaging - EDA - Components - Channels - Brokers - Mercury": "This is a message broker that enables some common messaging patterns over WebSockets.",
	"Messaging - EDA - Components - Channels - Brokers - JMS PTP": "",
	"Messaging - EDA - Components - Channels - Brokers - ZeroMQ": "",
	"Messaging - EDA - Components - Channels - Brokers - AWS SQS": "",
	"Messaging - EDA - Components - Channels - Brokers - AWS SNS": "",
	"Messaging - EDA - Components - Channels - Brokers - AWS Kinesis": "",
	"Messaging - EDA - Components - Channels - Brokers - AWS AmazonMQ": "",
	"Messaging - EDA - Components - Channels - Brokers - Kafka": "Apache Kafka is developed in Scala and started out at LinkedIn. Kafka only provides a total order over messages within a partition, not between different partitions in a topic.",
	"Messaging - EDA - Components - Channels - Brokers - Microsoft Azure Event Hubs": "",
	"Messaging - EDA - Components - Channels - Brokers - Google pub/sub": "",
	"Messaging - EDA - Components - Channels - Brokers - Spark Streams": "",
	"Messaging - EDA - Problems": "https://itnext.io/resolving-common-issues-in-event-driven-architecture-a3afe8f3ef7b",
	"Messaging - EDA - Problems - Event Loss": "",
	"Messaging - EDA - Problems - Event Duplication": "",
	"Messaging - EDA - Problems - Event Ordering Issues": "",
	"Messaging - EDA - Problems - Performance Issues": "",
	"Messaging - EDA - Problems - Fault Tolerance": "",
	"Messaging - Datasync": "",
	"Messaging - Datasync - Products": "",
	"Messaging - Datasync - Products - Firebase": "",
	"Messaging - Datasync - Products - RethinkDB": "",

	"Messaging - Formats": "SECTION",
	"Messaging - Formats - JMS Format": "",
	"Messaging - Formats - AMQP": "",
	"Messaging - Formats - MQTT": "",
	"Messaging - Formats - STOMP": "",
	"Messaging - Formats - STOMP - Brokers - RabbitMQ": "",
	"Messaging - Formats - STOMP - Brokers - ActiveMQ": "",
	"Messaging - Formats - WAMP": "",
	"Messaging - Formats - Channels (Pusher)": "",
	"Messaging - Formats - ZeroMQ": "",
	"Messaging - Formats - Custom": "",
	

	"Protocols - MQTT": "SECTION",

	"Protocols - AMQP": "SECTION",

	"Protocols - ZeroMQ": "SECTION",

	"Protocols - XMPP": "SECTION",
	"Protocols - XMPP - Products - Jabber": "",


	"Protocols - PointToPoint": "SECTION",
	"Protocols - PointToPoint - RealTime - Sockets": "",
	"Protocols - PointToPoint - RealTime - WebSockets": "",
	"Protocols - PointToPoint - RealTime - WebSockets - Products - Socket.io": "",
	"Protocols - PointToPoint - RealTime - WebSockets - STOMP": "",
	"Protocols - PointToPoint - RealTime - WebSockets - WAMP": "",
	"Protocols - PointToPoint - RealTime - WebSockets - Channels (Pusher)": "",

	"Formats - Protobuff": "SECTION",
	"Formats - Protobuff - features - binary": "Protobuf is binary-based",
	"Formats - Protobuff - features - contracts": "Everyone uses the same proto file to generate packages to serialize and deserialize.",
	"Formats - Protobuff - features - fast": "faster to transport, a lot faster than JSON during serialization and deserialization.",

	"Formats - JSON": "SECTION",

	"Formats - XML": "SECTION"
}