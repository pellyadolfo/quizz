{
	"Java": "SECTION",
	"Java TODO 0": "https://www.linkedin.com/posts/ashish-pratap-singh_java-developer-interview-coding-questions-activity-7322108220930428928-8TeX?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Java TODO 1": "https://www.linkedin.com/posts/sakshiku945_oops-concepts-in-java-ugcPost-7321927763915862016-Z4w7/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Java TODO 2": "https://www.linkedin.com/posts/sushjava_java-notes-activity-7319299308581736448-k72e?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Java TODO 3": "https://www.linkedin.com/posts/arpit-singh-89a4221a8_java-important-interviews-questions-related-activity-7321028788316733440-2RnQ?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Java TODO 4": "https://www.linkedin.com/posts/i-am-madhuk_java-questions-activity-7314852785139654656-iHri?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Java TODO 5": "https://www.linkedin.com/posts/alexxubyte_systemdesign-coding-interviewtips-activity-7316849496330522624-WyZy?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Java TODO 6": "https://www.linkedin.com/posts/satya619_the-mystery-of-the-frozen-workflow-deadlock-activity-7316301675852398594-wH4S?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Java TODO 7": "https://www.linkedin.com/posts/tauseeffayyaz_softwareengineering-dsa-coding-activity-7311624113716977664-KM6K/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Java TODO 8": "https://www.linkedin.com/posts/navdeep-singh-3aaa14161_everyone-hates-dynamic-programming-dp-activity-7312111362019577857-fAQd?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Java TODO 9": "https://www.linkedin.com/posts/sushjava_java-softwaredevelopment-javaevolution-activity-7322381458596081665-uJKy?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Java TODO 10": "https://www.linkedin.com/posts/abish-dev_master-maven-simplify-builds-with-pom-power-activity-7323618787331559424-3GNs?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Java TODO 11": "https://www.linkedin.com/posts/shaheen-aziz-9153a7102_cleanarchitecture-softwarearchitecture-softwaredevelopment-activity-7315259693633830913-X11p?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Java TODO 12": "https://www.linkedin.com/posts/shaik-vazeem_corejavainterviewquestionsanswers-activity-7323363048738500608--bLH?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Java TODO 13": "https://www.linkedin.com/posts/yogesh-patil-9848871a7_javastreamapi-activity-7326088740358041601-BR-T?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Java TODO 14": "https://www.linkedin.com/posts/pksingh90_the-most-used-spring-annotations-activity-7314892326785413120--AkG/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Java TODO 15": "https://www.linkedin.com/posts/sushjava_100-java-programs-activity-7326349857604988929-MBl3?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Java TODO 16": "https://www.linkedin.com/posts/ashish-pratap-singh_collection-framework-prep-guide-activity-7327178677132099584-v2fh?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Java TODO 17": "https://www.linkedin.com/posts/sushjava_java-softwaredevelopment-javaevolution-activity-7322381458596081665-uJKy/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Java TODO 18": "https://www.linkedin.com/posts/hmida-rojbani_java-jspecify-nullsafety-activity-7328733176929923072-9LZH/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Java TODO 19": "https://www.linkedin.com/posts/maheshma_java-activity-7331129385766264835-xHow?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Java TODO 20": "https://javaalmanac.io/",
	"Java TODO 21": "https://www.linkedin.com/posts/sooryamani-agnihotri_java-full-notes-activity-7330817918886137856-w6HK/?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Java TODO 22": "Write Once, Run Anywhere (WORA)",
	"Java TODO 23": "",
	"Java TODO 24": "",
	"Java TODO 25": "",
	"Java TODO 26": "",
	"Java TODO 27": "",
	"Java TODO 28": "",
	"Java TODO 29": "",

	"Features": "SECTION",
	"Features ": "https://javaalmanac.io/jdk/",
	"Features - Java1": "",
	"Features - Java2": "",
	"Features - Java3": "",
	"Features - Java4": "",
	"Features - Java5": "",
	"Features - Java5 - Generics": "",
	"Features - Java5 - Annotations": "",
	"Features - Java5 - Autoboxing": "",
	"Features - Java5 - Enums": "",
	"Features - Java5 - StaticImports": "",
	"Features - Java5 - Varargs": "public String formatWithVarArgs(String... values) { ... }",
	"Features - Java6": "",
	"Features - Java6 - JAXB": "",
	"Features - Java6 - JAF": "",
	"Features - Java7": "",
	"Features - Java7 - Try-with": "",
	"Features - Java7 - DiamondOperator": "",
	"Features - Java7 - MethodHandles": "",
	"Features - Java7 - MultiCatch": "",
	"Features - Java7 - ForkJoinFramework": "",
	"Features - Java8": "",
	"Features - Java8 - FunctionalProgramming": "Java 8 introduced functional programming paradigms, which simplify and improve how developers write code. This helps in writing cleaner, more readable, and concise code.",
	"Features - Java8 - StreamAPI": "A powerful abstraction for processing collections of data in a functional style. Operations like filtering, mapping, and reducing large data sets are now easier and faster.",
	"Features - Java8 - Concurrency": "Java 8 introduced parallel streams, which enable developers to process data in parallel with minimal effort, improving performance in multi-core systems.",
	"Features - Java8 - LambdaExpressions": "",
	"Features - Java8 - MethodReferences": "",
	"Features - Java8 - DefaultMethods": "",
	"Features - Java8 - DateAndTimeAPI": "The new java.time package provides a modern, immutable, and thread-safe way to handle date and time, replacing the old, clunky java.util.Date and java.util.Calendar.",
	"Features - Java9": "",
	"Features - Java9 - Language - ModuleSystem": "Modular System – Jigsaw Project Let’s start with the big one – bringing modularity into the Java platform. A modular system provides capabilities similar to OSGi framework’s system. Modules have a concept of dependencies, can export a public API and keep implementation details hidden/private.",
	"Features - Java9 - Language - PrivateMethodsInInterfaces": "Interface Private Method Interfaces in the upcoming JVM version can have private methods, which can be used to split lengthy default methods:",
	"Features - Java9 - API - HTTP/2Client": "Incubator. A long-awaited replacement of the old HttpURLConnection. The new API is located under the java.net.http package. It should support both HTTP/2 protocol and WebSocket handshake, with performance that should be comparable with the Apache HttpClient, Netty and Jetty.",
	"Features - Java9 - API - VarHandles": "The API resides under java.lang.invoke and consists of VarHandle and MethodHandles. It provides equivalents of java.util.concurrent.atomic and sun.misc.Unsafe operations upon object fields and array elements with similar performance. With Java 9 Modular system access to sun.misc.Unsafe will not be possible from application code.",
	"Features - Java9 - API - CompactStrings": "",
	"Features - Java9 - API - ReactiveStreams": "The class java.util.concurrent.Flow provides interfaces that support the Reactive Streams publish-subscribe framework. These interfaces support interoperability across a number of asynchronous systems running on JVMs. We can use utility class SubmissionPublisher to create custom components.",
	"Features - Java9 - API - EnhancedDeprecation": "",
	"Features - Java9 - API - ProcessAPI": "The process API has been improved for controlling and managing operating-system processes.",
	"Features - Java9 - API - ImageAPI": "The interface java.awt.image.MultiResolutionImage encapsulates a set of images with different resolutions into a single object. We can retrieve a resolution-specific image variant based on a given DPI metric and set of image transformations or retrieve all of the variants in the image.",
	"Features - Java9 - API - ImmutableSet": "java.util.Set.of() – creates an immutable set of a given elements. In Java 8 creating a Set of several elements would require several lines of code. Now we can do it as simple as: Set<String> strKeySet = Set.of('key', 'key2', 'key3');",
	"Features - Java9 - Tools - JShell": "JShell Command Line Tool JShell is read–eval–print loop – REPL for short.",
	"Features - Java9 - Tools - JLink": "",
	"Features - Java9 - JVM - JVMLogging": "This feature introduces a common logging system for all components of the JVM.",
	"Features - Java9 - JVM - AOTJITCompiler": "Introduced.",
	"Features - Java10": "",
	"Features - Java10 - Language - var": "We don’t provide the data type of message. Instead, we mark the message as a var, and the compiler infers the type of message from the type of the initializer present on the right-hand side.",
	"Features - Java10 - API - copyOf(Collection)": "java.util.List, java.util.Map and java.util.Set each got a new static method copyOf(Collection). It returns the unmodifiable copy of the given Collection.",
	"Features - Java10 - API - toUnmodifiable": "java.util.stream.Collectors get additional methods to collect a Stream into unmodifiable List, Map or Set:",
	"Features - Java10 - API - Optional.orElseThrow": "java.util.Optional, java.util.OptionalDouble, java.util.OptionalIntand java.util.OptionalLongeach got a new method orElseThrow()which doesn’t take any argument and throws NoSuchElementExceptionif no value is present:",
	"Features - Java10 - Tools - RootCertificates": "The cacerts keystore, which was initially empty so far, is intended to contain a set of root certificates that can be used to establish trust in the certificate chains used by various security protocols. As a result, critical security components such as TLS didn’t work by default under OpenJDK builds. With Java 10, Oracle has open-sourced the root certificates in Oracle’s Java SE Root CA program in order to make OpenJDK builds more attractive to developers and to reduce the differences between those builds and Oracle JDK builds.",
	"Features - Java10 - JVM - Graal VM": ".",
	"Features - Java10 - JVM - ContainerAwareness": "JVMs are now aware of being run in a Docker container and will extract container-specific configuration instead of querying the operating system itself – it applies to data like the number of CPUs and total memory that have been allocated to the container. However, this support is only available for Linux-based platforms. This new support is enabled by default and can be disabled in the command line with the JVM option: -XX:-UseContainerSupport",
	"Features - Java11": "",
	"Features - Java11 - Language - LocalVariableLambda": "Local Variable Syntax for Lambda Parameters. One of the key features introduced in Java 10 was local variable type inference. It allowed the use of var as the type of the local variable instead of the actual type. The compiler inferred the type based on the value assigned to the variable. Java 11 addresses this by supporting the above syntax. This makes the usage of var uniform in both local variables and lambda parameters. (var s1, var s2) -> s1 + s2",
	"Features - Java11 - API - String.class": ":",
	"Features - Java11 - API - HTTPClient": ":",
	"Features - Java11 - API - Files.readString": "",
	"Features - Java11 - API - Files.writeString": "",
	"Features - Java11 - API - Collection.toArray": "",
	"Features - Java11 - API - Predicate.not()": "The Predicate.not() static method has been added to Java 11 in order to negate an existing Predicate.",
	"Features - Java11 - API - class.isNestmateOf": "JVM access rules allow access to private members between nestmates; however, in previous Java versions, the reflection API denied the same access. Java 11 fixes this issue and provides means to query the new class file attributes using the reflection API",
	"Features - Java11 - Tools - FlightRecorder": "Java Flight Recorder (JFR) is now open-source in Open JDK, whereas it used to be a commercial product in Oracle JDK. JFR is a profiling tool that we can use to gather diagnostics and profiling data from a running Java application.",
	"Features - Java11 - Tools - autocompilation": "we don’t need to compile the Java source files with javac explicitly anymore: we can directly run the file using the java command: $ java HelloWorld.java",
	"Features - Java11 - JVM - OpenJDK": "Java 10 was the last free Oracle JDK release that we could use commercially without a license. Starting with Java 11, there’s no free long-term support (LTS) from Oracle. Thankfully, Oracle continues to provide Open JDK releases, which we can download and use without charge.",
	"Features - Java11 - JVM - GC - Epsilon": "A new garbage collector called Epsilon is available for use in Java 11 as an experimental feature. It’s called a No-Op (no operations) because it allocates memory but does not actually collect any garbage. Thus, Epsilon is applicable for simulating out of memory errors.",
	"Features - Java11 - JVM - GC - ZGC": "Introduced a low latency garbage collector, ZGC, as an experimental feature with low pause times",
	"Features - Java11 - JVM - CONSTANT_Dynamic": "Dynamic Class-File Constants Java class-file format is extended to support a new constant-pool form named CONSTANT_Dynamic. Loading the new constant-pool will delegate creation to a bootstrap method, just as linking an invokedynamic call site delegates linkage to a bootstrap method. This feature enhances performance and targets language designers and compiler implementors.",
	"Features - Java12": "",
	"Features - Java12 - Language - SwitchExpressions": "Switch Expressions (JEP 361). First introduced. The most popular feature introduced in Java 12 is the Switch Expressions. As a demonstration, let’s compare the old and new switch statements.",
	"Features - Java12 - Language - PatternMatching": "Pattern Matching for instanceof (Preview) Another preview feature introduced in Java 12 is pattern matching for instanceof. In previous Java versions, when using, for example, if statements together with instanceof, we would have to explicitly typecast the object to access its features:",
	"Features - Java12 - API - String": "String Class New Methods Java 12 comes with two new methods in the String class. The first one – indent adjusts the indentation of each line based on the integer parameter. If the parameter is greater than zero, new spaces will be inserted at the beginning of each line. On the other hand, if the parameter is less than zero, it removes spaces from the begging of each line. If a given line does not contain sufficient white space, then all leading white space characters are removed.",
	"Features - Java12 - API - File::mismatch": "File::mismatch Method Java 12 introduced a new mismatch method in the nio.file.Files utility class",
	"Features - Java12 - API - TeeingCollector": "Teeing Collector A new teeing collector was introduced in Java 12 as an addition to the Collectors class",
	"Features - Java12 - API - CompactNumberFormatting": "Compact Number Formatting Java 12 comes with a new number formatter – the CompactNumberFormat. It’s designed to represent a number in a shorter form, based on the patterns provided by a given locale.",
	"Features - Java12 - JVM - GC - Shenandoah": "Shenandoah: A Low-Pause-Time Garbage Collector Shenandoah is an experimental garbage collection (GC) algorithm, for now not included in the default Java 12 builds. It reduces the GC pause times by doing evacuation work simultaneously with the running Java threads. This means that with Shenandoah, pause times are not dependent on the heap’s size and should be consistent. Garbage collecting a 200 GB heap or a 2 GB heap should have a similar low pause behavior. Shenandoah will become part of mainline JDK builds since version 15.",
	"Features - Java12 - JVM - GC - CDS": "Default CDS Archives The Class Data Sharing (CDS) feature helps reduce the startup time and memory footprint between multiple Java Virtual Machines. It uses a built-time generated default class list that contains the selected core library classes.",
	"Features - Java13": "",
	"Features - Java13 - Language - SwitchExpressions": "adding a new yield statement",
	"Features - Java13 - Language - TextBlocks": "String myWallOfText = ””” multirow text ””” ",
	"Features - Java13 - API - LegacySocketAPI": "Reimplement the Legacy Socket API (JEP 353) We have seen Socket (java.net.Socket and java.net.ServerSocket) APIs as an integral part of Java since its onset. However, they were never modernized in the last twenty years. Written in legacy Java and C, they were cumbersome and difficult to maintain.",
	"Features - Java13 - JVM - GC - CDS": "Dynamic CDS Archives (JEP 350) Class data sharing (CDS) has been a prominent feature of Java HotSpot VM for a while now. It allows class metadata to be shared across different JVMs to reduce startup time and memory footprint. JDK 10 extended this ability by adding application CDS (AppCDS) – to give developers the power to include application classes in the shared archive. JDK 12 further enhanced this feature to include CDS archives by default.",
	"Features - Java13 - JVM - GC - ZGC": "ZGC: Uncommit Unused Memory (JEP 351) The Z Garbage Collector was introduced in Java 11 as a low-latency garbage collection mechanism, such that GC pause times never exceeded 10 ms. However, unlike other HotSpot VM GCs such as G1 and Shenandoah, it was not equipped to return unused heap memory to the operating system. Java 13 added this capability to the ZGC. We now get a reduced memory footprint along with performance improvement.",
	"Features - Java14": "",
	"Features - Java14 - Language - PatternMatching": "Pattern Matching for instanceof. JDK 14 has introduced pattern matching for instanceof with the aim of eliminating boilerplate code and make the developer’s life a little bit easy.",
	"Features - Java14 - Language - SwitchExpressions": "have been standardized so that they are part and parcel of the development kit.",
	"Features - Java14 - Language - Records": "RecordsRecords were introduced to reduce repetitive boilerplate code in data model POJOs.",
	"Features - Java14 - Language - TextBlocks": "Text Blocks (JEP 368) Text blocks continue their journey to getting a mainstream upgrade and are still available as preview features. In addition to the capabilities from JDK 13 to make multiline strings easier to use, in their second preview, text blocks now have two new escape sequences:",
	"Features - Java14 - Language - NullPointerExceptions": "Helpful NullPointerExceptions (JEP 358) adding the capability to point out what exactly was null in a given line of code.",
	"Features - Java14 - Tools - EventStreaming": "JFR Event Streaming (JEP 349) With this enhancement, JDK’s flight recorder data is now exposed so that it can be continuously monitored. This involves modifications to the package jdk.jfr.consumer so that users can now read or stream the recording data directly.",
	"Features - Java14 - JVM - ForeignMemoryAccessAPI": "Foreign Memory Access API (JEP 370). Introduced.",
	"Features - Java14 - JVM - GC - G1": "NUMA-Aware Memory Allocation for G1 (JEP 345) Non-uniform memory access (NUMA) was not implemented so far for the G1 garbage collector, unlike the Parallel collector. Looking at the performance improvement that it offers to run a single JVM across multiple sockets, this JEP was introduced to make the G1 collector NUMA-aware as well. At this point, there’s no plan to replicate the same to other HotSpot collectors.",
	"Features - Java14 - JVM - GC - ZGC": "ZGC on Windows (JEP 365) and macOS (JEP 364) – Experimental The Z Garbage Collector, a scalable, low-latency garbage collector, was first introduced in Java 11 as an experimental feature. But initially, the only supported platform was Linux/x64. After receiving positive feedback on ZGC for Linux, Java 14 has ported its support to Windows and macOS as well. Though still an experimental feature, it’s all set to become production-ready in the next JDK release.",
	"Features - Java14 - JVM - GC - CMS": "Concurrent Mark Sweep (CMS) Garbage Collector (JEP 363) – deprecated by Java 9, this GC has been succeeded by G1 as the default GC. Also, there are other more performant alternatives to use now, such as ZGC and Shenandoah, hence the removal",
	"Features - Java15": "",
	"Features - Java15 - Language - PatternMatching": "Pattern Matching Type Checks (JEP 375) The pattern matching feature was previewed in Java 14, and Java 15 aims to continue its preview status with no new enhancements. As a review, the goal of this feature is to remove a lot of boilerplate code that typically comes with the instanceof operator",
	"Features - Java15 - Language - Records": "Java 15 aims to refine.",
	"Features - Java15 - Language - SealedClasses": "Sealed Classes (JEP 360). Part of Project Amber. Introduced. Restricted Inheritance: A sealed class or interface restricts which other classes or interfaces may extend or implement it.",
	"Features - Java15 - Language - HiddenClasses": "Hidden Classes (JEP 371) A new feature being introduced in Java 15 is known as hidden classes. While most developers won’t find a direct benefit from them, anyone who works with dynamic bytecode or JVM languages will likely find them useful. The goal of hidden classes is to allow the runtime creation of classes that are not discoverable. This means they cannot be linked by other classes, nor can they be discovered via reflection. Classes such as these typically have a short lifecycle, and thus, hidden classes are designed to be efficient with both loading and unloading. Note that current versions of Java do allow for the creation of anonymous classes similar to hidden classes. However, they rely on the Unsafe API. Hidden classes have no such dependency.",
	"Features - Java15 - Language - TextBlocks": "",
	"Features - Java15 - Language - LocalInterfacesAndEnums": "",
	"Features - Java15 - API - ForeignMemoryAccessAPI": "Incubation.",
	"Features - Java15 - JVM - GC - ZGC": "In Java 15, ZGC (JEP 377) will be no longer be experimental.",
	"Features - Java15 - JVM - GC - Shenandoah": "In Java 15, Shenandoah (JEP 379) will be no longer be experimental.",
	"Features - Java16": "",
	"Features - Java16 - Language - PatternMatching": "Pattern Matching for instanceof (JEP-394) Pattern matching for the instanceof keyword has been added as of Java 16.",
	"Features - Java16 - Language - Records": "incremental changes.",
	"Features - Java16 - Language - SealedClasses": "Sealed Classes (JEP-397). ",
	"Features - Java16 - Language - StaticMembersInInnerClasses": "",
	"Features - Java16 - API - Proxy": "Invoke Default Methods From Proxy Instances (JDK-8159746) As an enhancement to the default method in Interfaces, with the release of Java 16, support has been added to java.lang.reflect.InvocationHandler invoke default methods of an interface via a dynamic proxy using reflection.",
	"Features - Java16 - API - DayPeriod": "Day Period Support (JDK-8247781) A new addition to the DateTimeFormatter is the period-of-day symbol “B“, which provides an alternative to the am/pm format:",
	"Features - Java16 - API - Stream.toList": "Add Stream.toList Method (JDK-8180352) The aim is to reduce the boilerplate with some commonly used Stream collectors, such as Collectors.toList and Collectors.toSet:",
	"Features - Java17": "",
	"Features - Java17 - Language - PatternMatching - Switch": "Pattern Matching for Switch (Preview) (JEP 406).",
	"Features - Java17 - Language - SealedClasses": "Sealed Classes (JEP 409) Sealed classes are part of Project Amber, and this JEP officially introduces a new feature to the language, although it was available in preview mode in the JDK versions 15 and 16. The feature restricts which other classes or interfaces may extend or implement a sealed component. Showing another improvement related to pattern matching combined with the JEP 406 will allow a more sophisticated and cleaner inspection of the type, cast and act code pattern.",
	"Features - Java17 - API - ForeignFunctionMemoryAPI": "The Foreign Function and Memory API allow Java developers to access code from outside the JVM and manage memory out of the heap. The goal is to replace the JNI API and improve the security and performance compared to the old one. This API is another feature developed by Project Panama, and it has been evolved and predeceased by JEPs 393, 389, 383 and 370.",
	"Features - Java17 - API - DeserializationFilters": "Context-Specific Deserialization Filters (JEP 415) JEP 290, first introduced in JDK 9, enabled us to validate incoming serialized data from untrusted sources, a common source of many security issues. That validation happens at the JVM level, giving more security and robustness. With JEP 415, applications can configure context-specific and dynamically selected deserialization filters defined at the JVM level. Each deserialization operation will invoke such filters.",
	"Features - Java18": "",
	"Features - Java18 - Language - PatternMatching - Switch": "refined.",
	"Features - Java19": "",
	"Features - Java19 - Language - PatternMatching - Switch": "refined.",
	"Features - Java19 - Language - RecordPatterns": "Introduced. A record pattern is a construct that allows us to match values against a record type and bind variables to the corresponding components of the record.",
	"Features - Java19 - JVM - VirtualThreads": "Project Loom. Introduced. ",
	"Features - Java20": "",
	"Features - Java20 - Language - PatternMatching - Switch": "refined.",
	"Features - Java20 - Language - ScopedValues": "ScopedValues (JEP 429). Incubating. Similar to ThreadLocal.",
	"Features - Java20 - Language - RecordPatterns": "Refined.",
	"Features - Java20 - JVM - VirtualThreads": "Refined.",
	"Features - Java21": "",
	"Features - Java21 - Language - PatternMatching - Switch": "improved.",
	"Features - Java21 - Language - StringLiteral": "String Literal (JEP 430) Java offers several mechanisms for composing strings with string literals and expressions. Some of these are String concatenation, StringBuilder class, String class format() method, and the MessageFormat class. Java 21 introduces string templates. These complement Java’s existing string literals and text blocks by coupling literal text with template expressions and template processors to produce the desired results.",
	"Features - Java21 - Language - SequencedCollections": "Sequenced Collections (JEP 431) Java 21 introduced three new interfaces to represent sequenced collections, sequenced sets, and sequenced maps.",
	"Features - Java21 - Language - ScopedValues": "Introduced.",
	"Features - Java21 - Language - RecordPatterns": "Refined.",
	"Features - Java21 - API - EncapsulationAPI": "Key Encapsulation Mechanism API (JEP 452). Introduced. A new KEM API to enable applications to use KEM algorithms.",
	"Features - Java21 - JVM - StructuredConcurrency": "Java 21 introduced some new changes.",
	"Features - Java22": "",
	"Features - Java22 - UnnamedVariablesAndPatterns": "",
	"Features - Java22 - StatementsBeforeSuper": "",
	"Features - Java22 - StringTemplates": "",
	"Features - Java22 - ImplicitClassAndMain": "Java finally supports writing a program without defining an explicit class or a main method with its standard template.",
	"Features - Java22 - API - ForeignFunctionMemoryAPI": "This API allows developers to invoke foreign functions, i.e., functions outside the JVM ecosystem, and access memory that is foreign to the JVM.",
	"Features - Java22 - ClassFileAPI": "The Class File API standardizes the process of reading, parsing, and transforming Java .class files.",
	"Features - Java22 - StreamGatherers": "Custom intermediate operations in the Streams API with Stream::gather(Gatherer).",
	"Features - Java22 - StructuredConcurrency": "A pattern of coding style that aims to reduce the common pitfalls and drawbacks of concurrent programming.",
	"Features - Java22 - ScopedValues": "Scoped values enable storing and sharing immutable data within and across threads. Scoped values introduce a new type, ScopedValue<>. We write the values once, and they remain immutable throughout their lifecycle.",
	"Features - Java22 - MultiFileSourcePrograms": "Java 11 introduced executing a single Java file without explicitly compiling it using the javac command. This was very efficient and quick. The downside is that when there are dependent Java source files, we cannot its advantage. Starting with Java 22, we can finally run multi-file Java programs",
	"Features - Java22 - RegionPinningG1": "With Java 22, the G1 Garbage Collector finally supports region pinning. This removes the need for Java threads to pause the G1 GC while using JNI.",
	"Features - Java23": "",
	"Features - Java23 - Language - ScopedValues": "Scoped Values introduce a new way to manage variable scope, allowing developers to define variables with a limited lifetime.",
	"Features - Java23 - StructuredConcurrency": "Structured Concurrency simplifies concurrent programming by introducing a high-level API for writing concurrent code.",
	"Features - Java23 - FlexibleConstructorBodies": "Flexible Constructor Bodies enhance the constructor syntax, enabling developers to write more expressive and concise code. This feature allows for improved code organization and reusability.",
	"Features - Java23 - ImplicitClassAndMain": "Implicitly Declared Classes and Instance Methods streamline record and data class definitions, reducing boilerplate code. This feature simplifies the creation of classes and methods.",
	"Features - Java23 - ModuleImportDeclarations": "Module Import Declarations improve module dependency management, making it easier to declare and manage module dependencies.",
	"Features - Java23 - MarkdownDocumentationComments": "Markdown Documentation Comments enhance Javadoc functionality, allowing developers to write documentation comments using Markdown syntax.",
	"Features - Java23 - DefaultZGCCollector": "The ZGC (Z Garbage Collector) becomes the default garbage collector in Java 23, providing improved performance and responsiveness.",
	"Features - Java23 - StreamGatherers": "Stream Gatherers enhance the Stream API, providing more efficient and flexible ways to collect and process data.",
	"Features - Java23 - ClassFileAPI": "The Class-File API provides a programmatic interface for reading, writing, and manipulating class files.",
	"Features - Java23 - PrimitiveTypes": "This feature extends pattern matching to support primitive types, enabling more expressive and concise code.",
	"Features - Java23 - JMS9.0": "JMS 9.0 updates the Java Management Service, providing improved monitoring, management, and troubleshooting capabilities.",
	"Features - Java24": "",
	"Features - Java24 - SimpleSourceFileAndInstanceMainMethod": "",
	"Features - Java24 - GenerationalShenandoah": "",
	"Features - Java24 - CompactObjectHeaders": "",
	"Features - Java24 - RestrictJNI": "",
	"Features - Java24 - LateBarrierExpansionG1": "",
	"Features - Java24 - KeyDerivationFunctionAPI": "",
	"Features - Java24 - Removex86Port": "",
	"Features - Java24 - AoTClassLoadingAndLinking": "",
	"Features - Java24 - ClassFileAPI": "",
	"Features - Java24 - StreamGatherers": "",
	"Features - Java24 - DisableSecurityManager": "",
	"Features - Java24 - ScopedValues": "",
	"Features - Java24 - ModuleImportDeclarations": "",
	"Features - Java24 - StructuredConcurrency": "",
	"Features - Java24 - ZGCRemoveNonGenerationalMode": "",
	"Features - Java24 - FlexibleConstructorBodies": "",
	"Features - Java24 - PrimitiveTypes": "",
	"Features - Java24 - SynchronizeVirtualThreads": "",
	"Features - Java24 - LinkingRunTimeImages": "",
	"Features - Java24 - QuantumResistantCryptography": "",

	"Data": "SECTION",
	"Data - Variables - Literals": "",
	"Data - Variables - Literals - List - null": "",
	"Data - Variables - Literals - List - short": "",
	"Data - Variables - Literals - List - int": "",
	"Data - Variables - Literals - List - FloatingPoint - float": "",
	"Data - Variables - Literals - List - FloatingPoint - double": "",
	"Data - Variables - Literals - List - char": "",
	"Data - Variables - Literals - List - boolean": "",
	"Data - Variables - Literals - List - String": "",
	"Data - Variables - Literals - List - Text": "",
	"Data - Variables - Literals - List - Escape": "",
	"Data - Variables - DataTypes - Primitives": "",
	"Data - Variables - DataTypes - Primitives - List - byte": "Size: 8 bits (1 byte) - Range: -128 to 127 - Default: 0 - Example: byte b = 100;",
	"Data - Variables - DataTypes - Primitives - List - short": "Size: 16 bits (2 bytes) - Range: -32,768 to 32,767 - Default: 0 - Example: short s = 10000;",
	"Data - Variables - DataTypes - Primitives - List - int": "Size: 32 bits (4 bytes) - Range: -2³¹ to 2³¹-1 (-2,147,483,648 to 2,147,483,647) - Default: 0 - Example: int i = 100000;",
	"Data - Variables - DataTypes - Primitives - List - long": "Size: 64 bits (8 bytes) - Range: -2⁶³ to 2⁶³-1 - Default: 0L - Example: long l = 10000000000L; (Note the 'L' suffix)",
	"Data - Variables - DataTypes - Primitives - List - float": "Size: 32 bits (4 bytes) - Range: Approximately ±3.40282347E+38F - Default: 0.0f - Example: float f = 3.14f; (Note the 'f' suffix)",
	"Data - Variables - DataTypes - Primitives - List - double": "Size: 64 bits (8 bytes) - Range: Approximately ±1.79769313486231570E+308 - Default: 0.0d - Example: double d = 3.1415926535;",
	"Data - Variables - DataTypes - Primitives - List - char": "Size: 16 bits (2 bytes) - Range: '\u0000' (0) to '\uffff' (65,535) - Default: '\u0000' - Example: char c = 'A';",
	"Data - Variables - DataTypes - Primitives - List - boolean": "Size: Not precisely defined (JVM-dependent) - Values: true or false - Default: false - Example: boolean flag = true;",
	"Data - Variables - DataTypes - Primitives - Autoboxing - Boxing": "Boxing in Java refers to the automatic conversion of primitive types into their corresponding wrapper class objects. This is part of Java's autoboxing feature introduced in Java 5.",
	"Data - Variables - DataTypes - Primitives - Autoboxing - Unboxing": "The reverse process (converting wrapper objects back to primitives)",
	"Data - Variables - DataTypes - Primitives - Storage": "Stored on the stack (except when part of an object)",
	"Data - Variables - DataTypes - Reference - Interfaces": "Interfaces Define Behavior, Not State. You cannot create an object of an interface (e.g., new Runnable() is invalid).",
	"Data - Variables - DataTypes - Reference - Interfaces - Declaration": ".",
	"Data - Variables - DataTypes - Reference - Interfaces - Members": ".",
	"Data - Variables - DataTypes - Reference - Interfaces - Members - Fields": ".",
	"Data - Variables - DataTypes - Reference - Interfaces - Members - Methods - Types - Constructor": "Not allowed",
	"Data - Variables - DataTypes - Reference - Interfaces - Members - Methods - Types - Abstract - Java1": "",
	"Data - Variables - DataTypes - Reference - Interfaces - Members - Methods - Types - Default - Java8": "",
	"Data - Variables - DataTypes - Reference - Interfaces - Members - Methods - Types - Static - Java8": "",
	"Data - Variables - DataTypes - Reference - Interfaces - Members - Methods - Types - Private - Java9": "Accessible only by default and static methods in the interface.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - NonDeclared - NestedInterfaces": "A nested interface is any interface whose declaration occurs within the body of another class or interface declaration. A nested interface may be a member interface or a local interface",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - NonDeclared - LocalInterfaces": "No possible.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByHierarchy - Static": "",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByHierarchy - Abstract": "",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByHierarchy - Subinterfaces": "",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByHierarchy - Superinterfaces": "",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByHierarchy - Sealed": "",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByHierarchy - Permitted": "The optional permits clause in a normal interface declaration specifies all the classes and interfaces intended as direct subclasses and direct subinterfaces of the interface being declared",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByHierarchy - TopLevelInterfaces": "A top level interface is an interface declared directly in a compilation unit",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - Strictfp": "",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - Generic": "",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - Functional": "Annonymous Inner Class -> Callback Hell -> Functional Interfaces + Default Methods -> Lambda Expressions -> Method References",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - Functional - Functional Interfaces": "A functional interface is an interface that is not declared sealed and has just one abstract method (aside from the methods of Object), and thus represents a single function contract.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - Functional - Functional Interfaces - annotation": "@FunctionalInterface",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - Functional - Functional Interfaces - types by function": "Suppliers, Consumers, Predicates, Operators.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - Functional - Functional Interfaces - Default Methods": "So it’d be really frustrating if we had lambdas in Java 8 but couldn’t use those with the standard collections library since backwards compatibility can’t be sacrificed. Due to the problem described above a new concept was introduced",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - Functional - Functional Interfaces - Default Methods ": "Virtual extension methods or defender methods.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - Functional - Functional Interfaces - Default Methods - public (Java 8)": "implicit",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - Functional - Functional Interfaces - Default Methods - static (Java 8)": "allowed",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - Functional - Functional Interfaces - Default Methods - private (Java 9)": "allowed",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - Functional - Functional Interfaces - Default Methods - final": "forbidden",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - Functional - Functional Interfaces - Default Methods - synchronize": "forbidden",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - Functional - Method Reference": "A method reference to a static method. A method reference to an instance method of an object of a particular type. A method reference to an instance method of an existing object. A method reference to a constructor.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - Functional - Method Reference - static method": "s -> Integer.parseInt(s) vs Integer::parseInt",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - Functional - Method Reference - instance method of an object of a particular type": "(String s) -> s.toUpperCase() vs String::toUpperCase",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - Functional - Method Reference - instance method of an existing object": "() -> books.size() vs books::size",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - Functional - Method Reference - constructor": "() -> new Foo() vs Foo::new",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces": "An annotation interface (§9.6) is an interface declared with distinct syntax, intended to be implemented by reflective representations of annotations.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @Target": "The @Target annotation takes one or more values from the java.lang.annotation.ElementType enum. Where the Annotation Can Be Applied.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @Target - MODULE": "Modules (Java 9+).",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @Target - PACKAGE": "Packages (rarely used).",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @Target - TYPE": "Classes, interfaces, enums, records.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @Target - FIELD": "Fields (including enum constants).",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @Target - CONSTRUCTOR": "Constructors.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @Target - METHOD": "Methods.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @Target - PARAMETER": "Method/constructor parameters.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @Target - LOCAL_VARIABLE": "Local variables.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @Target - ANNOTATION_TYPE": "Other annotations (meta-annotations).",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @Target - TYPE_PARAMETER": "Generic type parameters (Java 8+).",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @Target - RECORD_COMPONENT": "Record component declarations.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @Target - TYPE_USE": "Any type reference (Java 8+).",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @Retention": "It determines the lifecycle of an annotation by defining its retention policy. The options are defined in java.lang.annotation.RetentionPolicy",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @Retention - SOURCE": "The annotation is discarded by the compiler (used only in source code). Example: @Override, @SuppressWarnings.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @Retention - CLASS": "The annotation is stored in the .class file but not available at runtime. Rarely used directly; default if @Retention is omitted.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @Retention - RUNTIME": "The annotation is stored in the .class file and accessible at runtime via reflection. Example: JUnit’s @Test, Spring’s @Autowired.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @Inherited": "The annotation interface java.lang.annotation.Inherited is used to indicate that annotations on a class C corresponding to a given annotation interface are inherited by subclasses of C.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @Override": "Programmers occasionally overload a method declaration when they mean to override it, leading to subtle problems. T",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @SupressWarnings": "Java compilers are increasingly capable of issuing helpful 'lint-like' warnings. To encourage the use of such warnings, there should be some way to disable a warning in a part of the program when the programmer knows that the warning is inappropriate.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @SupressWarnings - control": "The annotation interface SuppressWarnings supports programmer control over warnings otherwise issued by a Java compiler. It defines a single element that is an array of String.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @Deprecated": "Programmers are sometimes discouraged from using certain program elements (modules, classes, interfaces, fields, methods, and constructors) because they are considered dangerous or because a better alternative exists.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @Deprecated - forRemoval() - Java11": "When false (default): API is deprecated but no removal planned yet",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @Deprecated - sincel() - Java11": ".",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @SafeVarargs": "The @SafeVarargs annotation is a Java annotation that indicates a method with a varargs parameter is safe to use without causing heap pollution warnings. It was introduced in Java 7 to suppress unchecked warnings that occur when working with varargs (variable arguments) of generic types.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @Repeatable": "The annotation interface java.lang.annotation.Repeatable is used on the declaration of a repeatable annotation interface to indicate its containing annotation interface.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - AnnotationInterfaces - Predefined - @FunctionalInterface": "The annotation interface FunctionalInterface is used to indicate that an interface is meant to be a functional interface.",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - Annotations": "An annotation is a marker which associates information with a program element, but has no effect at run time",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - Annotations - Normal": ".",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - Annotations - Marker": ".",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - Annotations - SingleElement": ".",
	"Data - Variables - DataTypes - Reference - Interfaces - Types - ByValue - Annotations - ": ".",
	"Data - Variables - DataTypes - Reference - Classes": ".",
	"Data - Variables - DataTypes - Reference - Classes - Declarations": ".",
	"Data - Variables - DataTypes - Reference - Classes - Members": ".",
	"Data - Variables - DataTypes - Reference - Classes - Members - InstanceInitializers": "Code that runs before constructors { ... }",
	"Data - Variables - DataTypes - Reference - Classes - Members - InstanceInitializers - PatternMatching - Java23": "Code that runs before constructors { ... }",
	"Data - Variables - DataTypes - Reference - Classes - Members - Fields": ".",
	"Data - Variables - DataTypes - Reference - Classes - Members - Constructors": ".",
	"Data - Variables - DataTypes - Reference - Classes - Members - Constructors - Default": "If a class contains no constructor declarations, then a default constructor is implicitly declared.",
	"Data - Variables - DataTypes - Reference - Classes - Members - Constructors - Modifiers": ".",
	"Data - Variables - DataTypes - Reference - Classes - Members - Constructors - Modifiers - public": ".",
	"Data - Variables - DataTypes - Reference - Classes - Members - Constructors - Modifiers - protected": ".",
	"Data - Variables - DataTypes - Reference - Classes - Members - Constructors - Modifiers - private": ".",
	"Data - Variables - DataTypes - Reference - Classes - Members - Constructors - Body - super()": ".",
	"Data - Variables - DataTypes - Reference - Classes - Members - Constructors - Body - super() - implicit - Java22": "Implicit vs Explicit: If you don't explicitly call super(), the compiler will insert a no-argument super() call as the first statement of your constructor.",
	"Data - Variables - DataTypes - Reference - Classes - Members - Constructors - Body - super() - before - Java22": "Statements before super",
	"Data - Variables - DataTypes - Reference - Classes - Members - Constructors - Body - this()": ".",
	"Data - Variables - DataTypes - Reference - Classes - Members - Constructors - PrimaryConstructors - Java23": "public class Person(String name, int age) { ... } equivalent to public class Person { private final String name; private final int age; public Person(String name, int age) { this.name = name; this.age = age; } }",
	"Data - Variables - DataTypes - Reference - Classes - Members - Constructors - PrimaryConstructors - final": "Primary constructor parameters become private final fields",
	"Data - Variables - DataTypes - Reference - Classes - Members - Constructors - EnhancedConstructors - Java23": "public Circle(double... dimensions) { ... }",
	"Data - Variables - DataTypes - Reference - Classes - Members - Constructors - PatternMatchingInConstructors - Java23": "",
	"Data - Variables - DataTypes - Reference - Classes - Members - Constructors - Delegation - Java23": "public Rectangle() { this(sideLength: 1); } public Rectangle(int sideLength)  this(width: sideLength, height: sideLength); }",
	"Data - Variables - DataTypes - Reference - Classes - Members - Constructors - Validation - Java23": "public Product( @NonNull String name, @Positive double price, @Size(min=1) List<String> categories) { ... }",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods": ".",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods - Modifiers": ".",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods - Modifiers - private - Java9": "interface can have private methods but can only be used within the interface. Cannot be default or abstract",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods - Modifiers - abstract": "An abstract method declaration introduces the method as a member, providing its signature, result, and throws clause if any, but does not provide an implementation. A method that is not abstract may be referred to as a concrete method.",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods - Modifiers - abstract - class": "The declaration of an abstract method m must appear directly within an abstract class (call it A) unless it occurs within an enum declaration; otherwise, a compile-time error occurs.",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods - Modifiers - abstract - override": "An abstract class can override an abstract method by providing another abstract method declaration.",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods - Modifiers - abstract - instance": "An instance method that is not abstract can be overridden by an abstract method.",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods - Modifiers - static": "A static method in Java is a method that belongs to the class itself rather than an instance (object) of the class.",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods - Modifiers - static - classMethod": "A method that is declared static is called a class method.",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods - Modifiers - static - instanceMethod": "A method that is not declared static is called an instance method, and sometimes called a non-static method.",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods - Modifiers - static - this": "the keywords this and super are prohibited in a static context.",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods - Modifiers - static - super": "the keywords this and super are prohibited in a static context.",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods - Modifiers - static - references": "References to an instance method from a static context or a nested class or interface are restricted.",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods - Modifiers - final": "A method can be declared final to prevent subclasses from overriding or hiding it.",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods - Modifiers - synchronized": "A synchronized method acquires a monitor before it executes.",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods - Modifiers - synchronized - static": "For a class (static) method, the monitor associated with the Class object for the method's class is used.",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods - Modifiers - synchronized - non-static": "For an instance method, the monitor associated with this (the object for which the method was invoked) is used.",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods - Modifiers - native": "A method that is native is implemented in platform-dependent code, typically written in another programming language such as C.",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods - Modifiers - strictfp": "Strictfp method become strictfp. Obsolete on Java17.",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods - MethodHandles - Java7": "Method handles are a low-level mechanism used for method lookup and invocation.",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods - MethodHandles - Reflection": "They are often compared to reflection, because both the Reflection API and method handles provide a means to invoke methods, constructors, and access fields.",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods - Overloading": "If two methods of a class (whether both declared in the same class, or both inherited by a class, or one declared and one inherited) have the same name but signatures that are not override-equivalent, then the method name is said to be overloaded.",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods - Result": "The result of a method declaration either declares the type of value that the method returns (the return type), or uses the keyword void to indicate that the method does not return a value.",
	"Data - Variables - DataTypes - Reference - Classes - Members - Methods - Throws": "A throws clause is used to denote any checked exception classes that the statements in a method or constructor body can throw.",
	"Data - Variables - DataTypes - Reference - Classes - Types - NonDeclared - AnonymousClasses": "They enable you to declare and instantiate a class at the same time. They are like local classes except that they do not have a name.",
	"Data - Variables - DataTypes - Reference - Classes - Types - NonDeclared - SyntheticClasses": "",
	"Data - Variables - DataTypes - Reference - Classes - Types - NonDeclared - UnnamedClasses - Java24": "This new syntax is possible by implicit declaration of classes and instance methods by JVM. void main() { println('Hello, World'); }",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - StaticClasses": ".",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - AbstractClasses": ".",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - LocalClasses": "Local classes are classes that are defined in a block, which is a group of zero or more statements between balanced braces. You typically find local classes defined in the body of a method.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - HiddenClasses - Java15": "",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - HiddenClasses - Features - NonDiscoverable": "Cannot be found via reflection (Class::forName, ClassLoader::findLoadedClass)",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - HiddenClasses - Features - Shortlived": "Designed for classes with temporary lifetimes",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - HiddenClasses - Features - NoClassLoader": "Not associated with any specific class loader",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - HiddenClasses - Features - HighPerformance": "Optimized for frameworks that generate classes dynamically",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - HiddenClasses - Benefits - Footprint": "Reduced memory footprint: Since they're not bound to class loaders",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - HiddenClasses - Benefits - Introspection": "Better security: Hidden from introspection by default",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - HiddenClasses - Benefits - Performance": "Improved performance: Optimized for dynamic class use cases",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - HiddenClasses - Benefits - Metadata": "Cleaner metadata: Doesn't pollute the JVM's class metadata space long-term",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - HiddenClasses - UsecCases - LanguageRuntimes": "e.g., for dynamic languages on the JVM",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - HiddenClasses - UsecCases - FrameworkImplementations": "Framework implementations that generate classes dynamically",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - HiddenClasses - UsecCases - ProxyClasses": "Proxy classes that don't need long-term visibility",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - HiddenClasses - UsecCases - LambdaExpressions": "Lambda expressions (the Java language uses this internally for lambda implementations)",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - HiddenClasses - Lifecycle - Creation": "Hidden classes are created using the Lookup::defineHiddenClass method.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - HiddenClasses - Lifecycle - Creation - Reflection": "Cannot be instantiated via reflection.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - HiddenClasses - Lifecycle - Creation - Pool": "Cannot have constant pool patching.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - HiddenClasses - Lifecycle - Initialization": "No static initializer: Hidden classes cannot run < clinit > (class initializer).",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - NestedClasses": "A nested class is a member of its enclosing class.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - NestedClasses - StaticNestedClasses": "Nested classes that are declared static are called static nested classes.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - InnerClasses": "Non-static nested classes are called inner classes. Non-static nested classes (inner classes) have access to other members of the enclosing class, even if they are declared private.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - InnerClasses - Members - Static": "Inner classes can now declare static members, including: Static fields, Static methods, Static initializers, Static nested classes and interfaces",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - SubClasses": "",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - SubClasses - Methods - Visibility - Inherit - static": "A class does not inherit private or static methods from its superinterface types.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - SubClasses - Methods - Visibility - Inherit - private": "A class does not inherit private or static methods from its superinterface types.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - SubClasses - Methods - Visibility - Inherit - changing": "When extending a class in Java, you can change the visibility (access modifier) of inherited methods, but only to make them more visible, not less.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - SubClasses - Methods - Visibility - Inherit - changing - LiskovSubstitution": "This follows the Liskov Substitution Principle, which states that a subclass should be usable wherever its parent class is expected.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - SubClasses - Methods - Visibility - Override": ".",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - SuperClasses": "",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - SealedClasses - Java15": "",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - SealedClasses - Features - RestrictedInheritance": "A sealed class or interface restricts which other classes or interfaces may extend or implement it.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - SealedClasses - Features - ExplicitPermissions": "You explicitly declare the permitted subclasses in the sealed class's declaration.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - SealedClasses - Features - Hierarchy:": "Three Types of Classes in the hierarchy: Sealed class/interface (the root), Permitted subclasses (explicitly allowed to extend), Final, sealed, or non-sealed subclasses",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - SealedClasses - Requirements - Accessible": "The permitted subclasses must be accessible to the sealed class (same module or package).",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - SealedClasses - Requirements - Extend": "Every permitted subclass must directly extend the sealed class.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - SealedClasses - Requirements - Modifiers": "Permitted subclasses must use one of these modifiers: final, sealed, non-sealed.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - SealedClasses - Requirements - Modifiers - final": "Cannot be extended further",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - SealedClasses - Requirements - Modifiers - sealed": "Can only be extended by its own permitted subclasses.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - SealedClasses - Requirements - Modifiers - non-sealed": "Can be extended by any class (reopens inheritance).",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByHierarchy - FinalClasses": "",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - StricfpClasses": "strictfp class Calculator { ... } All methods in a strictfp class implicitly become strictfp",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - EnumClasses": ".",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - EnumClasses - LocalEnum": "No possible.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - EnumClasses - Modifiers - static": "A nested enum class is implicitly static. That is, every member enum class and local enum class is static. It is permitted for the declaration of a member enum class to redundantly specify the static modifier, but it is not permitted for the declaration of a local enum class",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - EnumClasses - Modifiers - final": "An enum class is implicitly final if its declaration contains no enum constants that have a class body.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - EnumClasses - Modifiers - sealed": "An enum class E is implicitly sealed if its declaration contains at least one enum constant that has a class body. The permitted direct subclasses of E are the anonymous classes implicitly declared by the enum constants that have a class body..",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - EnumClasses - EnumConstants": ".",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - ValueBasedClasses - Java16": "Starting with Java 16 (as part of JEP 390), the compiler generates warnings when programs synchronize on instances of value-based classes. This is part of Java's gradual migration toward value objects (a preview feature in later versions) and primitive classes.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - ValueBasedClasses - Definition - Immutable": "Are immutable (all fields are final)",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - ValueBasedClasses - Definition - equals()": "Have implementations of equals(), hashCode(), and toString() based solely on values",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - ValueBasedClasses - Definition - Operations": "Do not use identity-sensitive operations (like synchronization).",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - ValueBasedClasses - Definition - Final": "Are final and have no accessible constructors (instances obtained via factory methods)",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - ValueBasedClasses - Examples": "Examples include: Wrapper classes (Integer, Long, Double, etc.), Optional, LocalDate, LocalTime, and other java.time classes",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records": "Records are designed as immutable data carriers.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Java14": "Records are a special kind of class introduced in Java 16 (JEP 395) as a preview feature in Java 14.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Features - Syntax": "Concise syntax: Eliminates boilerplate code for simple data carriers",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Features - Immutable": "All fields are final by default",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Features - Immutable - Final": "A record class is implicitly final. It is permitted for the declaration of a record class to redundantly specify the final modifier.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Features - Immutable - Invariants": "The automatic equals(), hashCode(), and toString() implementations rely on immutability",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Features - Immutable - DefensiveCopy": "When a Record contains mutable objects, you should implement defensive copying to maintain immutability guarantees. Instantiate a internal copy of the parameters.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Features - Immutable - Reflection": "Records are designed to be immutable, and their components are implicitly final. If you try to modify a record field via reflection: IllegalAccessException",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Features - Immutable - Mutability": "If you need mutable components: Don't use records",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Features - OOP - Extend": "The JVM has a hard single-inheritance model for classes (unlike interfaces which support multiple inheritance). Records are implicitly declared as final classes that extend java.lang.Record, which consumes their one allowed superclass slot:",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Features - OOP - Implement": "Records can implement interfaces (multiple allowed)",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Features - OOP - Inherit": "No subclassing, are final",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Features - OOP - Composition": "Use composition instead of inheritance",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Components - Constructor - Canonical": "Records generate a canonical constructor that initializes all components. The constructor parameters match the record declaration order exactly. Point(int x, int y) { this.x = x; this.y = y; }",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Components - Constructor - Canonical - Modify": "If you want to add validation, transformations, or logging, you must explicitly declare the canonical constructor and then add your logic:",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Components - Constructor - Compact": "Compact constructor is syntactic sugar for simple validations without manual field assignment.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Components - Constructor - Compact - Modify": "If you only need to add validation but still want the auto-assignment, you can use the compact constructor (a shorthand for the canonical constructor): Point { ... }",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Components - Methods - Accesors": "Records generate accessor methods (like getters) with the same names as the components.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Components - Methods - Accesors - BuilderPattern": "you can still implement the Builder pattern: public PersonBuilder firstName(String firstName) { this.firstName = firstName; return this; }",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Components - Methods - SyntheticMethods": "Equals, hashCode, and toString are automatically generated.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Components - Features - Generated": "Automatically generated: Constructor, Accessor methods, equals(), hashCode(), toString()",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Components - Features - Generated - Parameters": "Components: The parameters in the record header (name, age in the example) become private final fields",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Components - Features - Generated - Constructor": "Canonical constructor: Automatically generated to initialize all components",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Components - Features - Generated - Accessors": "Accessors: Methods like name() and age() are generated (not getX() style)",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Lifecycle - Creation": "public record Person(String name, int age) {}",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Customization": "Limited customization: You can override the auto-generated methods",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Customization - extend": "Cannot extend other classes (implicitly extends java.lang.Record)",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Customization - abstract": "Cannot be abstract",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Customization - final": "All fields are final",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Customization - fields": "Cannot declare instance fields (only the components in the header)",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Customization - native": "No native methods",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Usage - Carriers": "Transparent carriers: Components are directly accessible",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Usage - Carriers - DTOs": "Ideal for DTOs (Data Transfer Objects)",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Usage - Carriers - ValueObjects": "Value objects in domain-driven design",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Usage - Carriers - ValueObjects - Hierarchies": "Records are implicitly final. Cannot create hierarchies of value objects",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Usage - Carriers - Temporary": "Temporary data carriers",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Usage - Carriers - Return": "Multiple return values from methods",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Usage - Carriers - Lombok": "Cases where you'd normally use Lombok's @Data or @Value",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Usage - JPA": "Records can theoretically work with JPA/Hibernate, but they present several challenges due to their immutable nature and design constraints.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Usage - JPA - Constructor": "Records must use their canonical constructor. JPA typically requires a no-arg constructor + setters.",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Usage - JPA - Constructor - Workaround": "Workaround: Hibernate 6.2+ supports constructor injection",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Usage - JPA - Proxies": "Records are final and cannot be proxied normally. This breaks: Lazy loading, Performance optimizations, Some association handling",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Usage - JPA - Proxies - Workaround": "Configure Hibernate to disable proxies: hibernate.bytecode.enable_enhancement=false",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Usage - JPA - Bidirectional": "Bidirectional Relationships. Records cannot have setter methods for associations",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Usage - JPA - Bidirectional - Workaround": "Use helper methods or DTOs",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Usage - JPA - DirtyChecking": "Immutability Conflicts: Hibernate relies on dirty checking via property access. Records don't allow field modification after construction",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Usage - JPA - DirtyChecking - Workaround": "Forces full object replacement instead of incremental updates",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Usage - JPA - Recommendations - read": "Use Records as DTOs for read operations",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Usage - JPA - Recommendations - write": "For write operations, use traditional mutable entities",
	"Data - Variables - DataTypes - Reference - Classes - Types - ByValue - Records - Usage - JPA - Recommendations - hybrid": "For hybrid cases, consider: Immutable entities with Hibernate 6.2+ - @Immutable annotation for read-only entities - Constructor expression in JPQL",
	"Data - Variables - DataTypes - Reference - String": "",
	"Data - Variables - DataTypes - Reference - String - String.isBlank() - Java11": "",
	"Data - Variables - DataTypes - Reference - String - String.lines() - Java11": "",
	"Data - Variables - DataTypes - Reference - String - String.strip() - Java11": "",
	"Data - Variables - DataTypes - Reference - String - String.stripLeading() - Java11": "",
	"Data - Variables - DataTypes - Reference - String - String.stripTrailing() - Java11": "",
	"Data - Variables - DataTypes - Reference - String - String.repeat() - Java11": "",
	"Data - Variables - DataTypes - Reference - String - StringTemplates": "",
	"Data - Variables - DataTypes - Reference - String - StringTemplates - BasicInterpolation": "int x = 10, y = 20; String s = STR.'\\{x} + \\{y} = \\{x + y}';",
	"Data - Variables - DataTypes - Reference - String - StringTemplates - Formatting": "String formatted = FMT.'%05d\\{x} and %7.2f\\{Math.PI}';",
	"Data - Variables - DataTypes - Reference - String - StringTemplates - Multiline": "",
	"Data - Variables - DataTypes - Reference - Objects": "",
	"Data - Variables - DataTypes - Reference - Objects - EqualsHashcode": "",
	"Data - Variables - DataTypes - Reference - Objects - EqualsHashcode - Collections": "If two objects are equal (as per equals() method), they must have the same hashCode(). This ensures consistent behavior in hash-based collections.",
	"Data - Variables - DataTypes - Reference - Objects - EqualsHashcode - Collisions": "If two objects have the same hashCode(), they are not guaranteed to be equal. Collisions can occur, where different objects share the same hash code.",
	"Data - Variables - DataTypes - Reference - Objects - Lifecycle - Creation": "",
	"Data - Variables - DataTypes - Reference - Objects - Lifecycle - Logging - hashcode": "",
	"Data - Variables - DataTypes - Reference - Objects - Lifecycle - Logging - equals": "",
	"Data - Variables - DataTypes - Reference - Objects - Lifecycle - Logging - toString": "",
	"Data - Variables - DataTypes - Reference - Objects - Lifecycle - Logging - Overriding": "Overriding equals() requires overriding hashCode() as well. Failing to do so can lead to inconsistent behavior in collections.",
	"Data - Variables - DataTypes - Reference - Objects - Lifecycle - Reflection": "",
	"Data - Variables - DataTypes - Reference - Objects - Lifecycle - Reflection - MethodHandle (Java 7)": "A method handle is a typed, directly executable reference to an underlying method, constructor, field, or similar low-level operation, with optional transformations of arguments or return values.",
	"Data - Variables - DataTypes - Reference - Objects - Lifecycle - Reflection - MethodHandle vs Reflection": "From a performance standpoint, the MethodHandles API can be much faster than the Reflection API since the access checks are made at creation time rather than at execution time.",
	"Data - Variables - DataTypes - Reference - Objects - Lifecycle - Reflection - VarHandle (Java 9)": "Generally, a variable handle is just a typed reference to a variable. The variable can be an array element, instance or static field of the class. The VarHandle class provides write and read access to variables under specific conditions. VarHandles are immutable and have no visible state. What’s more, they cannot be sub-classed.",
	"Data - Variables - DataTypes - Reference - Objects - Lifecycle - Reflection - VarHandle - Goal": "The goal of VarHandle is to define a standard for invoking equivalents of java.util.concurrent.atomic and sun.misc.Unsafe operations on fields and array elements. Those operations are in majority atomic or ordered operations. For example, atomic field incrementation.",
	"Data - Variables - DataTypes - Reference - Objects - Lifecycle - Reflection - VarHandle - SaferThanUnsafe": "VarHandles are type-checked and don't allow arbitrary memory access",
	"Data - Variables - DataTypes - Reference - Objects - Lifecycle - Reflection - VarHandle - Atomic": "*More flexible than Atomic classes**: Can be used with any field, not just specially declared ones",
	"Data - Variables - DataTypes - Reference - Objects - Lifecycle - Reflection - VarHandle - StandardAPI": "Part of java.lang.invoke package, not an internal API",
	"Data - Variables - DataTypes - Reference - Objects - Lifecycle - Reflection - VarHandle - Usage": "VarHandles are particularly important for library authors who need fine-grained control over memory operations while maintaining portability across Java versions.",
	"Data - Variables - DataTypes - Reference - Objects - Lifecycle - Reflection - VarHandle - Usage - example": "COUNT = MethodHandles.lookup().findVarHandle(Counter.class, 'count', int.class);",
	"Data - Variables - DataTypes - Reference - Objects - Lifecycle - Copy": "",
	"Data - Variables - DataTypes - Reference - Objects - Lifecycle - Copy - DeepCopy": "A deep copy refers to creating an entirely new copy of an object, including its nested or referenced objects. In a deep copy, changes made to the copied object do not affect the original object and vice versa. This is because the deep copy creates new instances for all referenced objects as well.",
	"Data - Variables - DataTypes - Reference - Objects - Lifecycle - Removal": "",
	"Data - Variables - DataTypes - Reference - Objects - Lifecycle - Removal - finalize() - deprecated": "",
	"Data - Variables - DataTypes - Reference - Objects - Lifecycle - Removal - CleanerAPI - Java9": "",
	"Data - Variables - DataTypes - Reference - Objects - Lifecycle - Removal - Try-with-resources - Java7": "For deterministic cleanup",
	"Data - Variables - DataTypes - Reference - Objects - Lifecycle - Removal - PhantomReferences": "",
	"Data - Variables - DataTypes - Reference - Collections": ".",
	"Data - Variables - DataTypes - Reference - Collections - Primitives": "Collections like ArrayList can only store objects, not primitives",
	"Data - Variables - DataTypes - Reference - Collections - Array": "",
	"Data - Variables - DataTypes - Generics": "",
	"Data - Variables - DataTypes - Generics - Class": "",
	"Data - Variables - DataTypes - Generics - Interface": "",
	"Data - Variables - DataTypes - Generics - Method": "",
	"Data - Variables - DataTypes - Generics - Bounded": "<T extends Comparable<T>>",
	"Data - Variables - DataTypes - Generics - Wildcards": "In generic code, the question mark (?), called the wildcard, represents an unknown type. The wildcard can be used in a variety of situations: as the type of a parameter, field, or local variable; sometimes as a return type (though it is better programming practice to be more specific). The wildcard is never used as a type argument for a generic method invocation, a generic class instance creation, or a supertype.",
	"Data - Variables - DataTypes - Generics - Wildcards - UpperBounded": "To declare an upper-bounded wildcard, use the wildcard character ('?'), followed by the extends keyword, followed by its upper bound. Note that, in this context, extends is used in a general sense to mean either 'extends' (as in classes) or 'implements' (as in interfaces).",
	"Data - Variables - DataTypes - Generics - Wildcards - UnBounded": "The unbounded wildcard type is specified using the wildcard character (?), for example, List<?>. This is called a list of unknown type.",
	"Data - Variables - DataTypes - Generics - Wildcards - LowerBounded": "A lower bounded wildcard is expressed using the wildcard character ('?'), following by the super keyword, followed by its lower bound: <? super A>.",
	"Data - Variables - DataTypes - Generics - Diamond Operator - Generic Instantiation (Java 7)": "Java 7 introduced the diamond operator ( <> ) in generic class instantiation contexts. List<String> list2 = new ArrayList<>(),",
	"Data - Variables - DataTypes - Generics - Diamond Operator - Generic Instantiation )Java 9)": "Java 9 enhanced the type inference algorithm to tell whether the inferred type is denotable when analyzing an anonymous class that supports the diamond operator. Iterator <String> iter = new Iterator <> () { }",
	"Data - Variables - DataTypes - Operations - Checking": "Type checking in Java refers to the process of verifying that the types of variables, expressions, and operations are compatible and correctly used according to the language's type system.",
	"Data - Variables - DataTypes - Operations - Checking - StaticallyTyped": " Java is a statically-typed language, which means type checking occurs at compile-time rather than runtime.",
	"Data - Variables - DataTypes - Operations - Checking - SpeculativeAttribution - Java8": "In Java 8, the implementation of type-checking at compiler level was based on Speculative Attribution. In Speculative Attribution, the same tree can be type-checked against multiple targets at runtime. This is particularly used in target typing for lambda expressions, resolving diamond expressions for generics, etc.",
	"Data - Variables - DataTypes - Operations - Checking - TieredAttribution - Java9": "A JDK Enhancement Proposal (JEP 215) was proposed for type checking of poly expressions. The newly proposed way is known as Tiered Attribution. It focuses on improving performance by implementing a different way of type-checking that reduces redundant steps but gives the same results as current type-checking implementation.",
	"Data - Variables - DataTypes - Operations - Inference - var - Java 10": "In Java 10, this is how we could declare a local variable: var message = 'Hello, Java 10', We don’t provide the data type of message. Instead, we mark the message as a var, and the compiler infers the type of message from the type of the initializer present on the right-hand side.",
	"Data - Variables - DataTypes - Operations - Inference - var - keyword": "Another thing to note is that var is not a keyword – this ensures backward compatibility for programs using var say, as a function or variable name. var is a reserved type name, just like int.",
	"Data - Variables - DataTypes - Operations - Inference - var - overhead": "there is no runtime overhead in using var nor does it make Java a dynamically typed language. The type of the variable is still inferred at compile time and cannot be changed later.",
	"Data - Variables - DataTypes - Operations - Inference - var - object": "the inferred type of obj isn’t Object. var obj = new Object() {},",
	"Data - Variables - DataTypes - Operations - Inference - var - wrong - initializer": "var won’t work without the initializer: var n, // error:",
	"Data - Variables - DataTypes - Operations - Inference - var - wrong - null": "Nor would it work if initialized with null: var emptyList = null,",
	"Data - Variables - DataTypes - Operations - Inference - var - wrong - local": "Note that this feature is available only for local variables with the initializer. It cannot be used for member variables, method parameters, return types, etc. public var = 'hello', // error:",
	"Data - Variables - DataTypes - Operations - Inference - var - wrong - lambda": "Lambda expression needs explicit target type, and hence var cannot be used: var p = (String s) -> s.length() > 10, // error:",
	"Data - Variables - DataTypes - Operations - Inference - var - wrong - array": "Array needs explicit target type, and hence var cannot be used: var arr = { 1, 2, 3 }, // error",
	"Data - Variables - DataTypes - Operations - Casting": "",
	"Data - Variables - DataTypes - Operations - Conversion - Identity": "",
	"Data - Variables - DataTypes - Operations - Conversion - WideningPrimitive": "",
	"Data - Variables - DataTypes - Operations - Conversion - NarrowingPrimitive": "",
	"Data - Variables - DataTypes - Operations - Conversion - WideningAndNarrowingPrimitive": "",
	"Data - Variables - DataTypes - Operations - Conversion - WideningReference": "",
	"Data - Variables - DataTypes - Operations - Conversion - NarrowingReference": "",
	"Data - Variables - DataTypes - Operations - Conversion - Boxing": "",
	"Data - Variables - DataTypes - Operations - Conversion - Unboxing": "",
	"Data - Variables - DataTypes - Operations - Conversion - Unchecked": "",
	"Data - Variables - DataTypes - Operations - Conversion - Capture": "",
	"Data - Variables - DataTypes - Operations - Conversion - String": "",
	"Data - Variables - DataTypes - Operations - Conversion - Forbidden": "",
	"Data - Variables - DataTypes - Operations - Serialization": "",
	"Data - Variables - DataTypes - Operations - Serialization - DeserializationFilters - Java9": "Deserialization filters are a security feature introduced in Java 9 (JEP 290) to help protect against malicious serialization attacks. They provide a way to validate incoming serialized data before deserialization occurs.",
	"Data - Variables - DataTypes - Operations - Serialization - DeserializationFilters - Benefits - Validate": "Validate classes before they're deserialized",
	"Data - Variables - DataTypes - Operations - Serialization - DeserializationFilters - Benefits - Restrict": "Restrict which classes can be deserialized",
	"Data - Variables - DataTypes - Operations - Serialization - DeserializationFilters - Benefits - Limit": "Limit resource consumption during deserialization (array sizes, graph depth, etc.)",
	"Data - Variables - DataTypes - Operations - Serialization - DeserializationFilters - Types - GlobalFilter": "Applies to all deserialization in the JVM. ObjectInputFilter.Config.setSerialFilter(filter);",
	"Data - Variables - DataTypes - Operations - Serialization - DeserializationFilters - Types - ContextSpecificFilter": "Applies to specific ObjectInputStream instances. ois.setObjectInputFilter(filter);",
	"Data - Variables - DataTypes - Operations - Serialization - DeserializationFilters - Types - ThreadLocalFilter": "Temporarily applies to the current thread. ObjectInputFilter.Config.setThreadContextFilter(filter);",
	"Data - Variables - DataTypes - Operations - Contexts - Assignment": "",
	"Data - Variables - DataTypes - Operations - Contexts - Invokation": "",
	"Data - Variables - DataTypes - Operations - Contexts - String": "",
	"Data - Variables - DataTypes - Operations - Contexts - Casting": "",
	"Data - Variables - DataTypes - Operations - Contexts - Numeric": "",
	"Data - Variables - DataTypes - Operations - Contexts - Testing": "",
	"Data - Variables - Declaration": ".",
	"Data - Variables - Declaration - Typing": ".",
	"Data - Variables - Declaration - Naming": ".",
	"Data - Variables - Declaration - Assignment - UnnamedVariables - Java21": "Unnamed patterns and variables are a preview feature introduced in Java 21 (JEP 443) to improve code readability and maintainability by allowing developers to explicitly mark unused pattern variables or local variables that must be declared but aren't used.",
	"Data - Variables - Declaration - Assignment - UnnamedVariables - Usage - IgnoringReturnValues": "var _ = s.toLowerCase();",
	"Data - Variables - Declaration - Assignment - UnnamedVariables - Usage - PatternMatching": "if (p instanceof Point(_, int y)) { ... }",
	"Data - Variables - Declaration - Assignment - UnnamedVariables - Usage - Try-with-resources": "try (var _ = ScopedContext.acquire()) { ... ]",
	"Data - Variables - Declaration - Assignment - UnnamedVariables - Usage - EnhancedForLoops": "List<String> strings = List.of('a', 'b', 'c'); for (var _ : strings) { ... }",
	"Data - Variables - Declaration - Assignment - UnnamedVariables - Usage - MultiplePatternsInSwitch": "case Integer _ -> System.out.println('Got an Integer');",
	"Data - Variables - Declaration - Assignment - Expressions": ".",
	"Data - Variables - Declaration - Assignment - Statements": ".",
	"Data - Variables - Declaration - Assignment - Parameters": ".",
	"Data - Variables - Declaration - Assignment - ArrayInitializers": ".",
	"Data - Variables - Declaration - Assignment - Enum": ".",
	"Data - Variables - Declaration - Assignment - Anonymous": ".",
	"Data - Variables - Declaration - Assignment - MemberClasses": ".",
	"Data - Variables - Declaration - Assignment - MemberInterfaces": ".",
	"Data - Variables - Declaration - Assignment - StaticInitializers": ".",
	"Data - Variables - Declaration - Assignment - InstanceInitializers": ".",
	"Data - Variables - Declaration - Assignment - Constructors": ".",

	"Logic": "SECTION",
	"Logic - Sync - Imperative - ControlFlow - Statements": "",
	"Logic - Sync - Imperative - ControlFlow - Expressions": "",
	"Logic - Sync - Imperative - ControlFlow - Expressions - FloatingPoint": "",
	"Logic - Sync - Imperative - ControlFlow - Expressions - FloatingPoint - Strictfp": "Strict floating-point semantics refers to Java's adherence to precise IEEE 754 floating-point arithmetic standards, ensuring consistent results across all platforms.",
	"Logic - Sync - Imperative - ControlFlow - Expressions - FloatingPoint - Scope": "float and double",
	"Logic - Sync - Imperative - ControlFlow - Expressions - FloatingPoint - Strictfp - Requirements - IEEE 754": "All floating-point operations (float and double) follow IEEE 754 rules exactly",
	"Logic - Sync - Imperative - ControlFlow - Expressions - FloatingPoint - Strictfp - Requirements - Intermediate": "Intermediate calculations don't use higher precision than specified by the type",
	"Logic - Sync - Imperative - ControlFlow - Expressions - FloatingPoint - Strictfp - Requirements - Results": "Results are identical across different platforms and hardware",
	"Logic - Sync - Imperative - ControlFlow - Expressions - FloatingPoint - Strictfp - <Java17": "Required strictfp keyword to enforce strict behavior",
	"Logic - Sync - Imperative - ControlFlow - Expressions - FloatingPoint - Strictfp - Java17": "Strict behavior became default, making strictfp redundant. Now all platforms must use strict IEEE 754 floating-point semantics (32-bit for float, 64-bit for double), ensuring identical results everywhere.",
	"Logic - Sync - Imperative - ControlFlow - Expressions - EvaluatingOrder": "",
	"Logic - Sync - Imperative - ControlFlow - Expressions - Operators": "",
	"Logic - Sync - Imperative - ControlFlow - Conditions": "",
	"Logic - Sync - Imperative - ControlFlow - Conditions - if": "",
	"Logic - Sync - Imperative - ControlFlow - Conditions - if - then": "",
	"Logic - Sync - Imperative - ControlFlow - Conditions - if - else": "",
	"Logic - Sync - Imperative - ControlFlow - Conditions - switch - :": "",
	"Logic - Sync - Imperative - ControlFlow - Conditions - switch - break:": "",
	"Logic - Sync - Imperative - ControlFlow - Conditions - switch - -> - Java12": "Arrow Syntax (->) for Cases: String dayType = switch (day) { case 'Mon', 'Tue', 'Wed', 'Thu', 'Fri' -> 'Weekday'; case 'Sat', 'Sun' -> 'Weekend'; default -> 'Unknown'; };",
	"Logic - Sync - Imperative - ControlFlow - Conditions - switch - return - Java12": "int numLetters = switch (fruit) { case 'Apple' -> 5; case 'Banana' -> 6; default -> -1; };",
	"Logic - Sync - Imperative - ControlFlow - Conditions - switch - yield - Java13": "",
	"Logic - Sync - Imperative - ControlFlow - Conditions - switch - enums - Java13": "String rgb = switch (color) { case RED -> '#FF0000'; case GREEN -> '#00FF00'; case BLUE -> '#0000FF'; };",
	"Logic - Sync - Imperative - ControlFlow - Conditions - switch - TypePatterns - Java17": "case Long l    -> String.format('long %d', l);",
	"Logic - Sync - Imperative - ControlFlow - Conditions - switch - Null - Java17": "case null      -> System.out.println('null!');",
	"Logic - Sync - Imperative - ControlFlow - Conditions - switch - GuardedPatterns - Java17": "case String s when s.length() > 10 -> System.out.println('Long string');",
	"Logic - Sync - Imperative - ControlFlow - Conditions - switch - Dominance - Java17": "The compiler ensures patterns are checked in the right order (more specific before more general): switch (shape) { case Rectangle r ->  case Square s    ->  default ->  } - Square must come before Rectangle if Square extends Rectangle",
	"Logic - Sync - Imperative - ControlFlow - Conditions - switch - ExhaustivenessChecking - Java18": "If switch covers all possible subtypes of a sealed class, default is unnecessary.",
	"Logic - Sync - Imperative - ControlFlow - Conditions - switch - Primitives - Java23": "case 1, 2, 3, 4, 5 -> 'Weekday';.",
	"Logic - Sync - Imperative - ControlFlow - Conditions - switch - Array - Java23": "case int[] array -> 'Array of ints, length ' + array.length;",
	"Logic - Sync - Imperative - ControlFlow - Iterators": "",
	"Logic - Sync - Imperative - ControlFlow - Iterators - while": "",
	"Logic - Sync - Imperative - ControlFlow - Iterators - do": "",
	"Logic - Sync - Imperative - ControlFlow - Iterators - for": "",
	"Logic - Sync - Imperative - ControlFlow - Iterators - break": "",
	"Logic - Sync - Imperative - ControlFlow - Iterators - continue": "",
	"Logic - Sync - Imperative - ControlFlow - Throwable": "",
	"Logic - Sync - Imperative - ControlFlow - Throwable - Exceptions": "An exception is an event that occurs during the execution of a program that disrupts the normal flow of instructions.",
	"Logic - Sync - Imperative - ControlFlow - Throwable - Exceptions - CheckedExceptions": "These types of exceptions need to be handled during the compile time of the program. These exceptions can be handled by the try-catch block or by using throws keyword otherwise the program will give a compilation error.",
	"Logic - Sync - Imperative - ControlFlow - Throwable - Exceptions - CheckedExceptions - Exception": "Checked exceptions are the subclass of the Exception class. These types of exceptions need to be handled during the compile time of the program. These exceptions can be handled by the try-catch block or by using throws keyword otherwise the program will give a compilation error.",
	"Logic - Sync - Imperative - ControlFlow - Throwable - Exceptions - CheckedExceptions - Handling": "",
	"Logic - Sync - Imperative - ControlFlow - Throwable - Exceptions - CheckedExceptions - Handling - Try": "",
	"Logic - Sync - Imperative - ControlFlow - Throwable - Exceptions - CheckedExceptions - Handling - Try - try-with-resources (Java 7)": "Java 7 introduced the try-with-resources statement, where resources will be closed automatically after the execution. It requires an additional variable for the resources to be assigned. But Java 9 manages the same with the final or effectively final variables. The effectively final variable is the variable or the parameter whose values will never be changed once it is initialized.",
	"Logic - Sync - Imperative - ControlFlow - Throwable - Exceptions - CheckedExceptions - Handling - Try - try-with-resources - requires additional variable (Java 7)": "InputStream inputStream = new FileInputStream('test.txt'), try (InputStream stream = inputStream) {} catch (IOException e) {}",
	"Logic - Sync - Imperative - ControlFlow - Throwable - Exceptions - CheckedExceptions - Handling - Try - try-with-resources - no requires additional variable (Java 9)": "InputStream inputStream = new FileInputStream('test.txt'), try (inputStream) {} catch (IOException e) {}",
	"Logic - Sync - Imperative - ControlFlow - Throwable - Exceptions - UncheckedExceptions": "Unchecked exceptions are checked at run time.",
	"Logic - Sync - Imperative - ControlFlow - Throwable - Exceptions - UncheckedExceptions - RuntimeException": "Derived from RuntimeException",
	"Logic - Sync - Imperative - ControlFlow - Throwable - Exceptions - UncheckedExceptions - Handling": "No handling is required",
	"Logic - Sync - Imperative - ControlFlow - Throwable - Errors": "Errors are not subject to the Catch or Specify Requirement. Errors are those exceptions indicated by Error and its subclasses.",
	"Logic - Sync - Functional - ControlFlow - PatternMatching": "",
	"Logic - Sync - Functional - ControlFlow - PatternMatching - instanceof - <Java16": "if (obj instanceof String) { ... }",
	"Logic - Sync - Functional - ControlFlow - PatternMatching - instanceof - Java16": "if (obj instanceof String s) { ... }",
	"Logic - Sync - Functional - ControlFlow - PatternMatching - instanceof - Primitives - Java23": "if (obj instanceof Integer i) { ... }",
	"Logic - Sync - Functional - ControlFlow - PatternMatching - instanceof - PrimitivesType": "No possible: if (obj instanceof integer i) { ... }",
	"Logic - Sync - Functional - Streams": "",
	"Logic - Async - Reactive - JavaFlowAPI": "",
	"Logic - Async - Reactive - JavaFlowAPI - Objects - Publisher<T>": "Produces items for subscribers",
	"Logic - Async - Reactive - JavaFlowAPI - Objects - Subscriber<T>": "Consumes items from publishers",
	"Logic - Async - Reactive - JavaFlowAPI - Objects - Subscription": "Controls flow between Publisher and Subscriber",
	"Logic - Async - Reactive - JavaFlowAPI - Objects - Processor<T,R>": "Acts as both Publisher and Subscriber (for transformation pipelines)",
	"Logic - Async - Reactive - JavaFlowAPI - Tools": "While Java 9 provides the interfaces, you typically use implementations like Project Reactor or RxJava in applications rather than implementing them directly.",
	"Logic - Async - Reactive - JavaFlowAPI - Tools - Spring": "Spring WebFlux builds on Reactive Streams",
	"Logic - Async - Reactive - JavaFlowAPI - Tools - JakartaEE": "Used in JAX-RS 2.1 (Server-Sent Events)",
	"Logic - Async - Reactive - JavaFlowAPI - Tools - ProjectReactor": "implement these interfaces",
	"Logic - Async - Reactive - JavaFlowAPI - Tools - RxJava 2+": "implement these interfaces",
	"Logic - Async - Reactive - JavaFlowAPI - Tools - AkkaStreams": "implement these interfaces",

	"CI - Coding - Security - RootCertificates": "",
	"CI - Coding - Security - RootCertificates - Java 10": "One of the enhancements to JDK 10 includes, for the first time, a set of root CA (Certificate Authority) certificates incorporated into the OpenJDK source. As specified by Java Enhancement Proposal (JEP 319), providing root CA certificates makes 'OpenJDK builds more attractive to developers' and 'reduces [sic] the differences between those builds and Oracle JDK builds.'",
	"CI - Coding - Security - RootCertificates - cacert": "Root certificates are stored, by default, in a keystore file called cacerts. Prior to JDK 10, the source code contained an empty cacerts file, disabling the ability to establish trust and effectively rendering many important security protocols unuseable. To work around this shortcoming, developers had to roll their own cacerts keystore by manually populating it with a set of root certificates. ",

	"CI - Packaging": "SECTION",
	"CI - Packaging - Packages": "PROGRAMS are organized as sets of packages.",
	"CI - Packaging - Packages - Members": "The members of a package are classes and interfaces, which are declared in compilation units of the package, and subpackages, which may contain compilation units and subpackages of their own.",
	"CI - Packaging - Modules": "If a set of packages is sufficiently cohesive, then the packages may be grouped into a module.",
	"CI - Packaging - Modules - Benefits - Encapsulation": "Before modules, Java relied on classpath-based access, where all classes in the classpath were visible to each other, leading to: Unintended usage of internal APIs (e.g., sun.misc.Unsafe).",
	"CI - Packaging - Modules - Benefits - Encapsulation - exports": "Modules enforce explicit exports, allowing only specified packages to be accessible outside the module. Non-exported packages are hidden, even if classes inside are public.",
	"CI - Packaging - Modules - Benefits - Encapsulation - exports..to": "exports com.example.api to com.example.client;",
	"CI - Packaging - Modules - Benefits - Encapsulation - export optional - Java23": ".",
	"CI - Packaging - Modules - Benefits - Encapsulation - opens": "For Runtime Reflection Access. Allows deep reflection (e.g., setAccessible(true)) on the package’s types at runtime. Does not grant compile-time access (unless also exports). Used for frameworks like Spring, Hibernate, or JPA that rely on reflection.",
	"CI - Packaging - Modules - Benefits - Encapsulation - opens..to": "opens com.example.internal to spring.core;",
	"CI - Packaging - Modules - Benefits - Encapsulation - uses - Java23": "",
	"CI - Packaging - Modules - Benefits - Encapsulation - provides - Java23": "",
	"CI - Packaging - Modules - Benefits - Encapsulation - requires - Java23": "",
	"CI - Packaging - Modules - Benefits - Encapsulation - permits - Java23": "permits resources com.example.resources.*;",
	"CI - Packaging - Modules - Benefits - Encapsulation - Dependency": "Unlike traditional classpath-based systems, modules provide versionless dependencies (though versioning is handled by build tools like Maven/Gradle). Helps avoid dependency conflicts and classloading issues.",
	"CI - Packaging - Modules - Benefits - Encapsulation - SplitPackage": "A split package occurs when two or more modules (or JARs on the classpath) contain classes in the same package.",
	"CI - Packaging - Modules - Benefits - Security": "By hiding internal APIs (e.g., com.sun.*), modules reduce the attack surface. Applications can depend only on what they declare, avoiding accidental use of unsupported APIs.",
	"CI - Packaging - Modules - Benefits - Performance": "Modules allow smaller runtime images (via jlink), as unused modules can be excluded. The JVM can optimize performance by knowing module boundaries ahead of time..",
	"CI - Packaging - Modules - Modules": "",
	"CI - Packaging - Modules - Modules - JDKInternals - Java9": "Most internal JDK APIs (packages starting with sun.*, com.sun.*, jdk.*, etc.) that were previously accessible are now encapsulated and not available by default.",
	"CI - Packaging - Modules - Config - requires": "Modules require explicit dependencies (requires directive), ensuring missing dependencies are detected at startup. Preventiing JARHell.",
	"CI - Packaging - Modules - Config": ".",
	"CI - Packaging - Modules - Config - module-info.java": ".",
	"CI - Packaging - Modules - Config - module-info.java - requires": "The dependency is mandatory at both compile-time and runtime but not exposed to dependents",
	"CI - Packaging - Modules - Config - module-info.java - requires transitive": "The dependency is mandatory at both compile-time and runtime and exposed to dependents.",
	"CI - Packaging - Modules - Config - module-info.java - requires static": "The dependency is mandatory at compile-time but optional at runtime and not exposed to dependents.",
	"CI - Packaging - Modules - Migration": "Designed to be backward-compatible (non-modular JARs still work via the 'unnamed module'). Gradual adoption possible (e.g., automatic modules for libraries not yet modularized).",
	"CI - Packaging - External - JNI": "",
	"CI - Packaging - External - ForeignMemoryAccessAPI - Java14": "The Foreign Memory Access API is a modern Java feature (introduced in Java 14 as an incubator module and finalized in Java 22) that provides safe and efficient access to memory outside the Java heap, including native memory, persistent memory, and memory-mapped files.",
	"CI - Packaging - External - ForeignMemoryAccessAPI - Components - MemorySegment": "Represents a contiguous region of memory.",
	"CI - Packaging - External - ForeignMemoryAccessAPI - Components - MemoryAddress": "Location within a memory segment.",
	"CI - Packaging - External - ForeignMemoryAccessAPI - Components - MemoryLayout": "Describes the arrangement of data in memory.",
	"CI - Packaging - External - ForeignMemoryAccessAPI - Components - SegmentAllocator": "Allocates memory segments.",
	"CI - Packaging - External - ForeignMemoryAccessAPI - Components - VarHandle": "Type-safe access to memory locations.",
	"CI - Packaging - External - ForeignFunctionAndMemoryAPI - Java18": "The Foreign Function & Memory API (FFM API) is a modern Java API for efficiently calling native code (C, C++, etc.) and managing off-heap memory without using the deprecated Java Native Interface (JNI). Introduced as an incubating feature in Java 16 (JEP 389) and refined in later versions, it aims to simplify native interoperation while improving performance and safety.",
	"CI - Packaging - External - ForeignLinkerAPI - Java16": "The Foreign Linker API was introduced as an incubator feature in Java 16 (JEP 389), providing a statically-typed, pure-Java access to native code. This API is part of Project Panama's goal to improve Java's interoperability with native code..",
	"CI - Packaging - CompilationUnit": "",
	"CI - Packaging - CompilationUnit - java.lang": "Every compilation unit implicitly imports every public class or interface declared in the predefined package java.lang, as if the declaration import java.lang.*; appeared at the beginning of each compilation unit immediately after any package declaration. As a result, the names of all those classes and interfaces are available as simple names in every compilation unit.",
	"CI - Packaging - CompilationUnit - Types - Ordinary": "",
	"CI - Packaging - CompilationUnit - Types - Ordinary - Parts": "",
	"CI - Packaging - CompilationUnit - Types - Ordinary - Parts - PackageDeclaration": "A package declaration, giving the fully qualified name of the package to which the compilation unit belongs. A compilation unit that has no package declaration is part of an unnamed package.",
	"CI - Packaging - CompilationUnit - Types - Ordinary - Parts - PackageDeclaration - Observable": "A package is observable if and only if at least one of the following is true: • An ordinary compilation unit containing a declaration of the package is observable (§7.3). • A subpackage of the package is observable",
	"CI - Packaging - CompilationUnit - Types - Ordinary - Parts - PackageDeclaration - Observable - Always": "The packages java, java.lang, and java.io are always observable.",
	"CI - Packaging - CompilationUnit - Types - Ordinary - Parts - PackageDeclaration - Visible": "A package is visible to a module M if and only if an ordinary compilation unit containing a declaration of the package is visible to M.",
	"CI - Packaging - CompilationUnit - Types - Ordinary - Parts - PackageDeclaration - UniquelyVisible": "A package is uniquely visible to a module M if and only if one of the following holds: • An ordinary compilation unit associated with M contains a declaration of the package, and M does not read any other module that exports the package to M. • No ordinary compilation unit associated with M contains a declaration of the package, and M reads exactly one other module that exports the package to M.",
	"CI - Packaging - CompilationUnit - Types - Ordinary - Parts - ImportDeclaration": "import declarations that allow classes and interfaces from other packages, and static members of classes and interfaces, to be referred to using their simple names.",
	"CI - Packaging - CompilationUnit - Types - Ordinary - Parts - ImportDeclaration - Qualified": "Without the use of an appropriate import declaration, a reference to a class or interface declared in another package, or a reference to a static member of another class or interface, would typically need to use a fully qualified name.",
	"CI - Packaging - CompilationUnit - Types - Ordinary - Parts - ClassesAndInterfaces": "Top level declarations of classes and interfaces",
	"CI - Packaging - CompilationUnit - Types - Modular": "A modular compilation unit consists of a module declaration, optionally preceded by import declarations",
	"CI - Packaging - CompilationUnit - Types - Modular - Parts - ImportDeclaration": "The import declarations allow classes and interfaces from packages in this module and other modules, as well as static members of classes and interfaces, to be referred to using their simple names within the module declaration",
	"CI - Packaging - CompilationUnit - Types - Modular - Parts - ModuleDeclaration": "A module declaration specifies a new named module.",
	"CI - Packaging - CompilationUnit - Types - Modular - Parts - ModuleDeclaration - Dependencies": "A named module specifies dependences on other modules to define the universe of classes and interfaces available to its own code; and specifies which of its packages are exported or opened in order to populate the universe of classes and interfaces available to other modules which specify a dependence on it.",
	"CI - Packaging - CompilationUnit - Types - Modular - Parts - ModuleDeclaration - Types": "There are two kinds of modules: normal modules and open modules. The kind of a module determines the nature of access to the module's types, and the members of those types, for code outside the module.",
	"CI - Packaging - CompilationUnit - Types - Modular - Parts - ModuleDeclaration - Types - Normal": "A normal module, without the open modifier, grants access at compile time and run time to types in only those packages which are explicitly exported.",
	"CI - Packaging - CompilationUnit - Types - Modular - Parts - ModuleDeclaration - Types - Open": "An open module, with the open modifier, grants access at compile time to types in only those packages which are explicitly exported, but grants access at run time to types in all its packages, as if all packages had been exported.",
	"CI - Packaging - CompilationUnit - Types - Modular - Parts - ModuleDeclaration - ModuleDirective": "The directives of a module declaration specify the module's dependences on other modules (via requires), the packages it makes available to other modules (via exports and opens), the services it consumes (via uses), and the services it provides (via provides).",
	"CI - Packaging - CompilationUnit - Types - Modular - Parts - ModuleDeclaration - ModuleDirective - requires": "The requires directive specifies the name of a module on which the current module has a dependence.",
	"CI - Packaging - CompilationUnit - Types - Modular - Parts - ModuleDeclaration - ModuleDirective - requires - transitive": "The requires keyword may be followed by the modifier transitive. This causes any module which requires the current module to have an implicitly declared dependence on the module specified by the requires transitive directive.",
	"CI - Packaging - CompilationUnit - Types - Modular - Parts - ModuleDeclaration - ModuleDirective - requires - static": "The requires keyword may be followed by the modifier static. This specifies that the dependence, while mandatory at compile time, is optional at run time.",
	"CI - Packaging - CompilationUnit - Types - Modular - Parts - ModuleDeclaration - ModuleDirective - exports": "The exports directive specifies the name of a package to be exported by the current module. For code in other modules, this grants access at compile time and run time to the public and protected types in the package, and the public and protected members of those types. It also grants reflective access to those types and members for code in other modules.",
	"CI - Packaging - CompilationUnit - Types - Modular - Parts - ModuleDeclaration - ModuleDirective - opens": "The opens directive specifies the name of a package to be opened by the current module. For code in other modules, this grants access at run time, but not compile time, to the public and protected types in the package, and the public and protected members of those types. It also grants reflective access to all types in the package, and all their members, for code in other modules.",
	"CI - Packaging - CompilationUnit - Types - Modular - Parts - ModuleDeclaration - ModuleDirective - uses": "The uses directive specifies a service for which code in the current module may discover providers via java.util.ServiceLoader. The service may be declared in the current module or in another module.",
	"CI - Packaging - CompilationUnit - Types - Modular - Parts - ModuleDeclaration - ModuleDirective - provides": "The provides directive specifies a service for which the with clause specifies one or more service providers to java.util.ServiceLoader.",
	"CI - Packaging - CompilationUnit - Types - UnnamedModule": "An observable ordinary compilation unit that the host system does not associate with a named module is associated with an unnamed module.",
	"CI - Packaging - Class - Metadata - ACC_RECORD": "Records are marked with the ACC_RECORD flag in the class file",
	"CI - Packaging - Class - ClassFileAPI - Java22": "The Class-File API is a new standard API introduced in Java 22 (JEP 457) as a preview feature. It provides programmatic access to parsing, generating, and transforming Java class files.",
	"CI - Packaging - Class - ClassFileAPI - ClassFileParser": "Reads class files into a structured representation.",
	"CI - Packaging - Class - ClassFileAPI - ClassFileBuilder": "Generates new class files.",
	"CI - Packaging - Class - ClassFileAPI - ClassFileTransformer": "Modifies existing class files.",
	"CI - Packaging - Jar": "",
	"CI - Packaging - Jar - MRJAR": "Multi-Release JAR (MRJAR) files, introduced in Java 9 and fully supported in Java 11, allow a single JAR file to contain different versions of class files targeting different Java versions. This enables backward compatibility while leveraging newer Java features where available.",
	"CI - Packaging - Jar - MRJAR - JVM": "A single JAR can include version-specific implementations. The JVM automatically selects the right class files based on the runtime version.",
	"CI - Packaging - Jar - MRJAR - MANIFEST.MF": "Multi-Release: true",
	"CI - Packaging - Tools - JPackage": "The packaging tool simplifies distribution of Java applications by providing native installation experiences for end users, eliminating the need for manual Java installation or complex deployment scripts."

}