{
  "Solidity": "SECTION",
  "Solidity - quizz": "https://www.rareskills.io/post/solidity-interview-questions",
  "Solidity - quizz2": "https://coinsbench.com/master-solidity-must-know-interview-questions-for-ethereum-developers-%EF%B8%8F-practical-only-00cc15a9b9bf",
  "Solidity - quizz3": "https://leetcode.com/discuss/interview-question/4610367/Lists-of-LeetCode-Blind-75/",

	"Variables": "SECTION",
	"Variables - DataTypes - Inmutable - constant": "A constant variable is one whose value is assigned at compile time and never changes throughout the lifetime of the contract. These variables are particularly useful for defining fixed values, such as mathematical constants or configuration parameters.",
	"Variables - DataTypes - Inmutable - constant - gas": "Gas efficiency: constant variables do not occupy a storage slot, as their values are embedded directly in the bytecode.",
	"Variables - DataTypes - Inmutable - immutable": "An immutable variable is one that is assigned once during the execution of the constructor and cannot be modified afterward. Unlike constants, their value does not need to be known at compile time but is still set only once.",
	"Variables - DataTypes - Inmutable - immutable - gas": "Like constants, immutable variables are embedded in the bytecode and do not use storage slots.",
	"Variables - DataTypes - Variables": "In Solidity, regular state variables are stored in storage slots, which are the most expensive form of data storage in the Ethereum Virtual Machine (EVM).",
  "Variables - DataTypes - types": "Solidity is a statically typed language, meaning that the types of variables must be defined at compile time.",
  "Variables - DataTypes - types - Value - Literals - Address": "literals that pass the address checksum test, for example 0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF are of address type.",
  "Variables - DataTypes - types - Value - Literals - Rational": "",
  "Variables - DataTypes - types - Value - Literals - Integer": "",
  "Variables - DataTypes - types - Value - Literals - Integer - Arithmetic": "A fixed-point number is an integer that stores only the numerator of a fraction — while the denominator is implied. This type of arithmetic is not necessary in most programming languages because they have floating point numbers. It is necessary in Solidity because Solidity only has integers, and we often need to perform operations with fractional numbers. https://medium.com/rareskills/fixed-point-arithmetic-in-solidity-using-solady-solmate-and-abdk-as-examples-100d972f884f",
  "Variables - DataTypes - types - Value - Literals - String": "",
  "Variables - DataTypes - types - Value - Literals - Unicode": "",
  "Variables - DataTypes - types - Value - Literals - Hexadecimal": "",
  "Variables - DataTypes - types - Value - Variables - Boolean - bool": "",
	"Variables - DataTypes - types - Value - Variables - Integer": "",
  "Variables - DataTypes - types - Value - Variables - Integer - uint1": "",
  "Variables - DataTypes - types - Value - Variables - Integer - uint8": "",
  "Variables - DataTypes - types - Value - Variables - Integer - uint256": "",
  "Variables - DataTypes - types - Value - Variables - Integer - uint": "",
  "Variables - DataTypes - types - Value - Variables - Integer - int1": "",
  "Variables - DataTypes - types - Value - Variables - Integer - int8": "",
  "Variables - DataTypes - types - Value - Variables - Integer - int256": "",
  "Variables - DataTypes - types - Value - Variables - Integer - int": "",
	"Variables - DataTypes - types - Value - Variables - FixedPointNumbers": "",
  "Variables - DataTypes - types - Value - Variables - Bytes - byte": "byte is an alias for bytes1 and therefore stores a single byte.",
  "Variables - DataTypes - types - Value - Variables - Bytes - bytes": "The term bytes in Solidity represents a dynamic array of bytes. It’s a shorthand for byte[].",
  "Variables - DataTypes - types - Value - Variables - Bytes - bytes1": "bytes1 has size of 8 bits (possible values 0x00 to 0xff)",
  "Variables - DataTypes - types - Value - Variables - Bytes - bytes32": "bytes32 is a data type that holds exactly 32 bytes of data, which equals 256 bits",
  "Variables - DataTypes - types - Value - Variables - String - string": "",
	"Variables - DataTypes - types - Value - Variables - Address": "Holds a 20 byte value (size of an Ethereum address).",
  "Variables - DataTypes - types - Value - Variables - Address - balance": "It is possible to query the balance of an address using the property balance.",
  "Variables - DataTypes - types - Value - Variables - Address - transfer": "It is possible to send Ether (in units of wei) to a payable address using the transfer function",
  "Variables - DataTypes - types - Value - Variables - AddressPayable": "The idea behind this distinction is that address payable is an address you can send Ether to. Same as address, but with the additional members transfer and send.",
  "Variables - DataTypes - types - Value - Variables - Enums": "",
  "Variables - DataTypes - types - Value - Variables - Functions": "",
  "Variables - DataTypes - types - Reference": "",
  "Variables - DataTypes - types - Reference - Arrays": "",
  "Variables - DataTypes - types - Reference - Arrays - static": "",
  "Variables - DataTypes - types - Reference - Arrays - dinamic": "Dynamic arrays are only available in storage, not in memory.",
  "Variables - DataTypes - types - Reference - ArraysSlides": "",
  "Variables - DataTypes - types - Reference - Structs": "",
  "Variables - DataTypes - types - Mapping": "https://coinsbench.com/understanding-mappings-in-solidity-a-deep-dive-0a4a59034e72",
  "Variables - DataTypes - types - Mapping - IterableMappings": "https://coinsbench.com/getting-started-with-solidity-mappings-part-2-46bafaeba098",
  "Variables - DataTypes - types - Mapping - Limitations - key - type": "we can't use just any type for the key",
  "Variables - DataTypes - types - Mapping - Limitations - nesting": "We can't write something like mapping(mapping()) — nesting mappings within mappings isn’t allowed. However, we can use mappings as values within a mapping.",
  "Variables - DataTypes - Conversions - uint160 - address": "Explicit conversions to and from address are allowed for uint160",
  "Variables - DataTypes - Conversions - integer - address": "Explicit conversions to and from address are allowed for integer literals",
  "Variables - DataTypes - Conversions - bytes20 - address": "Explicit conversions to and from address are allowed for bytes20",
  "Variables - DataTypes - Conversions - payable - address": "Implicit conversions from address payable to address are allowed",
  "Variables - DataTypes - Conversions - contract - address": "Explicit conversions to and from address are allowed for contract",
  "Variables - DataTypes - Conversions - address - payable": "from address to address payable must be explicit via payable(<address>).",
  "Variables - DataTypes - Conversions - contract - payable": "from address to address payable must be explicit via payable(<contract>). For contract-type, this conversion is only allowed if the contract can receive Ether, i.e., the contract either has a receive or a payable fallback function. Note that payable(0) is valid and is an exception to this rule.",
  "Variables - DataTypes - ArithmeticOperations": "",
  "Variables - DataTypes - ArithmeticOperations - unchecked": "",
  "Variables - DataTypes - ArithmeticOperations - checked": "",
  "Variables - DataTypes - Encoding": "In Solidity programming language, there is some function that can encode data into low-level (bytes)",
	"Variables - DataTypes - Encoding - abi.encode": "abi.encode is used to encode multiple values into a single-byte array.",
	"Variables - DataTypes - Encoding - abi.encodePacked": "abi.encodePacked is similar to encode function, but instead of encoding element values only, it reduced the unnecessary bytes that are not needed.",
	"Variables - DataTypes - Encoding - abi.encodeWithSignature": "abi.encodeWithSignature is used to encode function names and parameters, in order to be called by another contract, or to be called indirectly from the same contract.",
	"Variables - DataTypes - Encoding - abi.encodeWithSelector": "abi.encodeWithSelector is similar to abi.encodeWithSignature. Instead of using a function signature to encode, we will use a function selector to encode our function.",
	"Variables - DataTypes - Encoding - abi.decode": "abi.decode allows you to decode encoded parameters from external contract calls. It unpacks encoded data so your Solidity contract can work with the original values again.",
	"Variables - DataTypes - Storage - SSTORE": "updating a storage slot’s value",
	"Variables - DataTypes - Storage - SSTORE - types - zero to non-zero": "20,000 gas plus 2,100 gas if the slot is cold",
	"Variables - DataTypes - Storage - SSTORE - types - non-zero to non-zero": "5,000 gas",
	"Variables - DataTypes - Storage - SSTORE - types - non-zero to zero": "5,000 gas",
	"Variables - DataTypes - Storage - transient": "https://coinsbench.com/transient-storage-in-solidity-a-closer-look-at-eip-1153-f5db99b3698d",

	"Logic": "SECTION",
	"Logic - Sync - Imperative - ControlFlow - Expressions": "",
	"Logic - Sync - Imperative - ControlFlow - Ternary": "The ternary operator is used in expressions of the form <expression> ? <trueExpression> : <falseExpression>. It evaluates one of the latter two given expressions depending upon the result of the evaluation of the main <expression>. If <expression> evaluates to true, then <trueExpression> will be evaluated, otherwise <falseExpression> is evaluated.",
	"Logic - Sync - Imperative - ControlFlow - if": "",
	"Logic - Sync - Imperative - ControlFlow - else": "",
	"Logic - Sync - Imperative - ControlFlow - Iterators - while": ".",
	"Logic - Sync - Imperative - ControlFlow - Iterators - do": ".",
	"Logic - Sync - Imperative - ControlFlow - Iterators - for": ".",
	"Logic - Sync - Imperative - ControlFlow - Iterators - break": ".",
	"Logic - Sync - Imperative - ControlFlow - Iterators - continue": ".",
	"Logic - Sync - Imperative - ControlFlow - Transfer": "",
	"Logic - Sync - Imperative - ControlFlow - Transfer - transfer()": "",
	"Logic - Sync - Imperative - ControlFlow - Transfer - send()": "",
	"Logic - Sync - Imperative - ControlFlow - Transfer - selfdestruct()": "deprecated. selfdestruct removes the contract from the blockchain, sending any remaining Ether to a specified address.",
	"Logic - Sync - Imperative - ControlFlow - Invocations": "The Ethereum Virtual Machine (EVM) offers four opcodes for making calls between contracts: https://medium.com/rareskills/delegatecall-the-detailed-and-animated-guide-30621d6b2c81",
	"Logic - Sync - Imperative - ControlFlow - Invocations - CALL (F1)": "",
	"Logic - Sync - Imperative - ControlFlow - Invocations - CALL (F1) - return": "The call method returns a tuple with two values. The first value is a boolean indicating the success or failure of the transaction. The second value, of type bytes, holds the return value of the function executed by the call, ABI-encoded, if any.",
	"Logic - Sync - Imperative - ControlFlow - Invocations - CALLCODE (F2)": "CALLCODE opcode has been deprecated since Solidity v5, being replaced by DELEGATECALL.",
	"Logic - Sync - Imperative - ControlFlow - Invocations - STATICCALL (FA)": "",
	"Logic - Sync - Imperative - ControlFlow - Invocations - DELEGATECALL (F4)": "",
	"Logic - Sync - Imperative - ControlFlow - MoneyHandling": "",
	"Logic - Sync - Imperative - ControlFlow - MoneyHandling - receive": "The receive() function is triggered whenever a contract receives ETH and the transaction contains no data (msg.data is empty). It is ideal for situations where ETH is sent directly to the contract via tools like Metamask’s 'Send' button or other low-level interaction",
	"Logic - Sync - Imperative - ControlFlow - MoneyHandling - fallback": "The fallback() function is a more versatile alternative to receive(). It is triggered: When ETH is sent to the contract with data that doesn’t match any function signature. When a non-existent function is called on the contract.",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - require": "ensure that certain conditions are met before a function can proceed. If the condition specified in require is not satisfied, the transaction is reverted, an optional error message can be provided",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - require - gas": "If require fails, the transaction is reverted, and the user receives a gas refund for the unused portion of the transaction's gas limit. However, any gas used before the require statement, including costs for initial operations and data loading, is not refunded.",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - require - gas - message - ": "The error message 'Sender is not the owner' is stored as a string array in the contract's bytecode. Each character in the string takes up space, making error messages surprisingly expensive in terms of gas.",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - revert": "The revert keyword works similarly to require, but without the need for an inline condition. You can use revert directly to abort a transaction or function call anywhere in your code.",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - error - 8.0.4.": "With Solidity 0.8.4 and later, you can define custom errors that are more gas-efficient than traditional require statements. A custom error is defined at the top of your contract and can be used with the revert keyword to handle errors.",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - error - gas - bytecode": "Instead of embedding the entire error message string into the bytecode, only the error’s identifier is stored, which is significantly smaller.",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - trycatch": "try / catch can only catch errors from external function calls and contract creation.",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - overflow - <0.8": "",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - overflow - 0.8+": "Starting with Solidity version 0.8.0, integer overflow and underflow throw an error and revert the transaction by default.",
	"Logic - Sync - Functional - Modifiers": "",

	"CICD - Architecture": "SECTION",
	"CICD - Architecture - Structure - SPDX": "SPDX License Identifier: This line specifies the license under which the code is released. It’s a best practice in Solidity development.",
	"CICD - Architecture - Structure - Pragma": "Pragma Statement: pragma solidity ^0.8.0; specifies the version of Solidity we're using. The ^ means 'any version greater than or equal to 0.8.0 but less than 0.9.0'.",
	"CICD - Architecture - Structure - Interface": "The interface keyword is used to define an interface in Solidity. Interfaces define a set of functions that other contracts must implement.",
	"CICD - Architecture - Structure - Contract": "Contracts in Solidity are similar to classes in object-oriented languages.",
	"CICD - Architecture - Structure - Contract - address": "A contract in Solidity is a collection of code (its functions) and data (its state) that resides at a specific address on the Ethereum blockchain.",
	"CICD - Architecture - Structure - Contract - members": "Each contract can contain declarations of state variables, functions, function modifiers, events, errors, struct types, and enum types. Furthermore, contracts can inherit from other contracts.",
	"CICD - Architecture - Structure - Contract - StateVariable": "Each contract can contain declarations of state variables, functions, function modifiers, events, errors, struct types, and enum types. Furthermore, contracts can inherit from other contracts.",
	"CICD - Architecture - Structure - Contract - constructor": "Constructor: The constructor function is called when the contract is deployed. It initializes our greeting variable with an initial value.",
	"CICD - Architecture - Structure - Contract - Functions": "",
	"CICD - Architecture - Structure - AbstractContract": "",
	"CICD - Architecture - Structure - Inheritance": ".",
	"CICD - Architecture - Structure - ABI": "The Contract Application Binary Interface (ABI) is the standard way to interact with contracts in the Ethereum ecosystem, both from outside the blockchain and for contract-to-contract interaction.",
	"CICD - Architecture - Libraries": "using PriceConverter for uint256;",
	"CICD - Architecture - Patterns": "",
	"CICD - Architecture - Patterns - checks-effects-interactions": "The checks-effects-interactions pattern is used to prevent reentrancy attacks by first checking conditions, then performing state changes, and finally interacting with external contracts.",
	"CICD - Architecture - Patterns - Factory": "https://coinsbench.com/day-12-storage-factory-building-composable-smart-contracts-89ec5bd2448b",
	"CICD - Architecture - Patterns - Proxy": "",
	"CICD - Architecture - Patterns - Proxy - UUPS": "",
	"CICD - Architecture - Patterns - Proxy - TUP": "",

	"CICD - Bundling": "SECTION",
	"CICD - Bundling - Arch - Functions - selector": "https://medium.com/rareskills/understanding-the-function-selector-in-solidity-f8d115372ef9",
	"CICD - Bundling - Arch - Functions - receive": "https://coinsbench.com/understanding-fallback-vs-receive-functions-in-solidity-647986a82af2",

	"CICD - Building": "SECTION",
	"CICD - Building - bytecode": "Solidity performs this function, producing what is known as “bytecode” (or lower-level code).",
	"CICD - Building - solc": "",

	"CICD - Execution": "SECTION",
	"CICD - Execution - EVM": "The EVM is an interpreter that reads bytecode and executes instructions based on it.",
	"CICD - Execution - EVM - codes": "https://www.evm.codes/?fork=cancun#55",
	"CICD - Execution - Scopes - Functions - private": "",
	"CICD - Execution - Scopes - Functions - internal": "default. ",
	"CICD - Execution - Scopes - Functions - public": "This means the function can be called from outside the contract.",
	"CICD - Execution - Scopes - Functions - external": "",
	"CICD - Execution - Scopes - Functions - view": "This indicates that the function doesn't modify the contract's state (it only reads data).",
	"CICD - Execution - Scopes - Functions - pure": "pure functions cannot read from or modify the state.",
	"CICD - Execution - Scopes - Functions - modifiers": "Modifiers in Solidity can be used to apply a condition to a function, such as restricting its execution to the contract owner.",
	"CICD - Execution - Scopes - Functions - onlyOwner": ".",
	"CICD - Execution - Scopes - Functions - fallback": "The fallback function is executed when a contract receives Ether without any data or when a function that doesn't exist is called. It can be used to handle unexpected calls and receive Ether.",
	"CICD - Execution - Scopes - Functions - overloading": "Function overloading means having multiple functions with the same name but different parameter types or numbers of parameters. Solidity decides which version to use based on the arguments passed during a function call.",
	"CICD - Execution - Scopes - functionargs - memory": "",
	"CICD - Execution - Scopes - functionargs - calldata": "",

	"CICD - Audit": "SECTION"


}

