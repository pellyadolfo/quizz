{
  "Solidity": "SECTION",
  "Solidity - quizz": "https://www.rareskills.io/post/solidity-interview-questions",
  "Solidity - quizz2": "https://coinsbench.com/master-solidity-must-know-interview-questions-for-ethereum-developers-%EF%B8%8F-practical-only-00cc15a9b9bf",
  "Solidity - quizz3": "https://leetcode.com/discuss/interview-question/4610367/Lists-of-LeetCode-Blind-75/",

	"Variables": "SECTION",
	"Variables - DataTypes - Inmutable - constant": "A constant variable is one whose value is assigned at compile time and never changes throughout the lifetime of the contract. These variables are particularly useful for defining fixed values, such as mathematical constants or configuration parameters.",
	"Variables - DataTypes - Inmutable - constant - gas": "Gas efficiency: constant variables do not occupy a storage slot, as their values are embedded directly in the bytecode.",
	"Variables - DataTypes - Inmutable - immutable": "An immutable variable is one that is assigned once during the execution of the constructor and cannot be modified afterward. Unlike constants, their value does not need to be known at compile time but is still set only once.",
	"Variables - DataTypes - Inmutable - immutable - gas": "Like constants, immutable variables are embedded in the bytecode and do not use storage slots.",
	"Variables - DataTypes - Variables": "In Solidity, regular state variables are stored in storage slots, which are the most expensive form of data storage in the Ethereum Virtual Machine (EVM).",
  "Variables - DataTypes - types": "Solidity is a statically typed language, meaning that the types of variables must be defined at compile time.",
  "Variables - DataTypes - types - Value": "The following are called value types because their variables will always be passed by value",
  "Variables - DataTypes - types - Value - Literals - Address": "literals that pass the address checksum test, for example 0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF are of address type.",
  "Variables - DataTypes - types - Value - Literals - Rational": "",
  "Variables - DataTypes - types - Value - Literals - Integer": "",
  "Variables - DataTypes - types - Value - Literals - Integer - Arithmetic": "A fixed-point number is an integer that stores only the numerator of a fraction — while the denominator is implied. This type of arithmetic is not necessary in most programming languages because they have floating point numbers. It is necessary in Solidity because Solidity only has integers, and we often need to perform operations with fractional numbers. https://medium.com/rareskills/fixed-point-arithmetic-in-solidity-using-solady-solmate-and-abdk-as-examples-100d972f884f",
  "Variables - DataTypes - types - Value - Literals - String": "",
  "Variables - DataTypes - types - Value - Literals - Unicode": "",
  "Variables - DataTypes - types - Value - Literals - Hexadecimal": "",
  "Variables - DataTypes - types - Value - Variables - Boolean - bool": "",
	"Variables - DataTypes - types - Value - Variables - Numeric - Integer": "",
  "Variables - DataTypes - types - Value - Variables - Numeric - Integer - uint1": "",
  "Variables - DataTypes - types - Value - Variables - Numeric - Integer - uint8": "",
  "Variables - DataTypes - types - Value - Variables - Numeric - Integer - uint256": "",
  "Variables - DataTypes - types - Value - Variables - Numeric - Integer - uint": "",
  "Variables - DataTypes - types - Value - Variables - Numeric - Integer - int1": "",
  "Variables - DataTypes - types - Value - Variables - Numeric - Integer - int8": "",
  "Variables - DataTypes - types - Value - Variables - Numeric - Integer - int256": "",
  "Variables - DataTypes - types - Value - Variables - Numeric - Integer - int": "",
	"Variables - DataTypes - types - Value - Variables - Numeric - FixedPointNumbers": "",
	"Variables - DataTypes - types - Value - Variables - Numeric - Arithmethic - FloatingPoint": "There is no floating point in Solidity. You should keep numbers in whole number format. You can place decimal place in your front-end code.",
	"Variables - DataTypes - types - Value - Variables - Numeric - Arithmethic - <0.8.0": "Before version 0.8.0, integer underflows and overflows were allowed and would not cause an error.",
	"Variables - DataTypes - types - Value - Variables - Numeric - Arithmethic - 0.8.0": "Starting with version 0.8.0, Solidity automatically includes checks for arithmetic underflows and overflows as a built-in feature of the language. Since version 0.8.0, Solidity will revert if an expression causes an integer underflow or overflow.",
	"Variables - DataTypes - types - Value - Variables - Numeric - Arithmethic - Random": "Random number generation on the blockchain is difficult because of its deterministic and public nature. The Ethereum Virtual Machine (EVM) must produce the same output given the same input, and all data on the blockchain is public. Therefore, it is possible to determine the “random number” by copying its generation formula and reading the inputs from the blockchain.",
	"Variables - DataTypes - types - Value - Variables - Numeric - Arithmethic - Random - InsufficientRandomness": "Contracts that attempt to create random numbers on-chain and use them in business logic suffer from Insufficient Randomness. ",
	"Variables - DataTypes - types - Value - Variables - Numeric - Arithmethic - Random - Oracle": "To obtain a more secure and unpredictable random number, it is best practice to use a trusted oracle (Chainlink is a popular choice) that will generate the number off-chain. This helps to protect against attackers being able to predict the number. ",
  "Variables - DataTypes - types - Value - Variables - String - Bytes - byte": "byte is an alias for bytes1 and therefore stores a single byte.",
  "Variables - DataTypes - types - Value - Variables - String - Bytes - bytes": "The term bytes in Solidity represents a dynamic array of bytes. It’s a shorthand for byte[].",
  "Variables - DataTypes - types - Value - Variables - String - Bytes - bytes - encoding": "bytes and string are encoded identically. In general, the encoding is similar to bytes1[], in the sense that there is a slot for the array itself and a data area that is computed using a keccak256 hash of that slot’s position. However, for short values (shorter than 32 bytes) the array elements are stored together with the length in the same slot.",
  "Variables - DataTypes - types - Value - Variables - String - Bytes - bytes1": "bytes1 has size of 8 bits (possible values 0x00 to 0xff)",
  "Variables - DataTypes - types - Value - Variables - String - Bytes - bytes32": "bytes32 is a data type that holds exactly 32 bytes of data, which equals 256 bits",
  "Variables - DataTypes - types - Value - Variables - String - String - string": "",
  "Variables - DataTypes - types - Value - Variables - String - Hashing": "Ethereum uses KECCAK-256. It is an alias to sha3, meaning that keccak256 produces identical results to sha3",
	"Variables - DataTypes - types - Value - Variables - Address": "Holds a 20 byte value (size of an Ethereum address).",
  "Variables - DataTypes - types - Value - Variables - Address - balance": "It is possible to query the balance of an address using the property balance.",
  "Variables - DataTypes - types - Value - Variables - Address - transfer": "It is possible to send Ether (in units of wei) to a payable address using the transfer function",
  "Variables - DataTypes - types - Value - Variables - AddressPayable": "The idea behind this distinction is that address payable is an address you can send Ether to. Same as address, but with the additional members transfer and send.",
  "Variables - DataTypes - types - Value - Variables - Enums": "Enums can be used to create custom types with a finite set of ‘constant values’ ",
	"Variables - DataTypes - types - Value - Variables - Storage": "The Solidity storage is a persistent key-value store that is used to store the state variables of the contract.",
	"Variables - DataTypes - types - Value - Variables - Storage - allocation": "Each key-value pair is stored in a unique storage slot, which is identified by a 256-bit key. The sstore opcode is used to store a 256-bit value in a specific storage slot, identified by its key.",
	"Variables - DataTypes - types - Value - Variables - Storage - slot": "A slot contains 32 bytes.",
	"Variables - DataTypes - types - Value - Variables - Storage - slot - location": "data is stored contiguously item after item starting with the first state variable, which is stored in slot 0.",
	"Variables - DataTypes - types - Value - Variables - Storage - slot - size": "",
	"Variables - DataTypes - types - Value - Variables - Storage - size": "For each variable, a size in bytes is determined according to its type. Value types use only as many bytes as are necessary to store them. If a value type does not fit the remaining part of a storage slot, it is stored in the next storage slot.",
	"Variables - DataTypes - types - Value - Variables - Storage - <23b": "Multiple, contiguous items that need less than 32 bytes are packed into a single storage slot if possible.",
	"Variables - DataTypes - types - Value - Variables - Storage - SSTORE": "In Solidity assembly, the sstore opcode is used to store a value in the contract's storage.",
	"Variables - DataTypes - types - Value - Variables - Storage - SSTORE - gas": "The three types of storage gas costs for writes (SSTORE) involve updating a storage slot’s value from zero to non-zero, non-zero to non-zero and non-zero to zero. As of the latest Ethereum upgrade (Cancun), an initial write to a storage slot (zero to non-zero) costs 20,000 gas (plus 2,100 gas if the slot is cold). Updating a storage slot (non-zero to non-zero or non-zero to zero) costs 5,000 gas.",
	"Variables - DataTypes - types - Value - Variables - Storage - SSTORE - gas - insert": "As of the latest Ethereum upgrade (Cancun), an initial write to a storage slot (zero to non-zero) costs 20,000 gas (plus 2,100 gas if the slot is cold).",
	"Variables - DataTypes - types - Value - Variables - Storage - SSTORE - gas - update": "Updating a storage slot (non-zero to non-zero or non-zero to zero) costs 5,000 gas.",
	"Variables - DataTypes - types - Value - Variables - Storage - SSTORE - gas - size": "When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.",
	"Variables - DataTypes - types - Value - Variables - Storage - access": ".",
	"Variables - DataTypes - types - Value - Variables - Storage - access - ColdRead": "The first read of a storage slot during a transaction is considered is a cold read and costs 2100 gas.",
	"Variables - DataTypes - types - Value - Variables - Storage - access - WarmRead": " Subsequent reads to the same storage slot are considered warm reads and cost 100 gas each.",
	"Variables - DataTypes - types - Reference": "",
  "Variables - DataTypes - types - Reference - Arrays": "",
  "Variables - DataTypes - types - Reference - Arrays - static": "",
  "Variables - DataTypes - types - Reference - Arrays - dinamic": "Dynamic arrays are only available in storage, not in memory.",
	"Variables - DataTypes - types - Reference - Arrays - Storage - location": "Always start a new slot.",
	"Variables - DataTypes - types - Reference - Arrays - Storage - size": "",
	"Variables - DataTypes - types - Reference - ArraysSlides": "",
	"Variables - DataTypes - types - Reference - Structs": "Structs are custom defined types that can group several variables",
	"Variables - DataTypes - types - Reference - Structs - Storage - location": "Always start a new slot.",
	"Variables - DataTypes - types - Reference - Structs - Storage - size": ".",
	"Variables - DataTypes - types - Mapping": "https://coinsbench.com/understanding-mappings-in-solidity-a-deep-dive-0a4a59034e72",
  "Variables - DataTypes - types - Mapping - IterableMappings": "https://coinsbench.com/getting-started-with-solidity-mappings-part-2-46bafaeba098",
  "Variables - DataTypes - types - Mapping - Limitations - key - type": "we can't use just any type for the key",
  "Variables - DataTypes - types - Mapping - Limitations - nesting": "We can't write something like mapping(mapping()) — nesting mappings within mappings isn’t allowed. However, we can use mappings as values within a mapping.",
	"Variables - DataTypes - types - Mapping - Storage - location": ".",
	"Variables - DataTypes - types - Mapping - Storage - size": ".",
  "Variables - DataTypes - Conversions - Implicit": "An implicit type conversion is automatically applied by the compiler in some cases during assignments, when passing arguments to functions and when applying operators. In general, an implicit conversion between value-types is possible if it makes sense semantically and no information is lost.",
  "Variables - DataTypes - Conversions - Explicit": "",
  "Variables - DataTypes - Conversions - Explicit - uint160 - address": "Explicit conversions to and from address are allowed for uint160",
  "Variables - DataTypes - Conversions - Explicit - integer - address": "Explicit conversions to and from address are allowed for integer literals",
  "Variables - DataTypes - Conversions - Explicit - bytes20 - address": "Explicit conversions to and from address are allowed for bytes20",
  "Variables - DataTypes - Conversions - Explicit - payable - address": "Implicit conversions from address payable to address are allowed",
  "Variables - DataTypes - Conversions - Explicit - contract - address": "Explicit conversions to and from address are allowed for contract",
  "Variables - DataTypes - Conversions - Explicit - address - payable": "from address to address payable must be explicit via payable(<address>).",
  "Variables - DataTypes - Conversions - Explicit - contract - payable": "from address to address payable must be explicit via payable(<contract>). For contract-type, this conversion is only allowed if the contract can receive Ether, i.e., the contract either has a receive or a payable fallback function. Note that payable(0) is valid and is an exception to this rule.",
  "Variables - DataTypes - ArithmeticOperations": "",
  "Variables - DataTypes - ArithmeticOperations - unchecked": "",
  "Variables - DataTypes - ArithmeticOperations - checked": "",
  "Variables - DataTypes - Encoding": "In Solidity programming language, there is some function that can encode data into low-level (bytes)",
	"Variables - DataTypes - Encoding - abi.encode": "abi.encode is used to encode multiple values into a single-byte array.",
	"Variables - DataTypes - Encoding - abi.encodePacked": "abi.encodePacked is similar to encode function, but instead of encoding element values only, it reduced the unnecessary bytes that are not needed.",
	"Variables - DataTypes - Encoding - abi.encodePacked - HashCollision": "abi.encodePacked could create a vulnerability if it contains adjacent dynamic types (such as strings or bytes). Since abi.encodePacked concatenates the encoded values without any delimiters or length prefixes, different sets of input values could produce the same encoded output. This could cause hash collisions, in the case where the abi.encodePacked output is hashed, and could allow attackers to bypass security measures like authentication checks or manipulate contract logic that depends on unique hash values.",
	"Variables - DataTypes - Encoding - abi.encodeWithSignature": "abi.encodeWithSignature is used to encode function names and parameters, in order to be called by another contract, or to be called indirectly from the same contract.",
	"Variables - DataTypes - Encoding - abi.encodeWithSelector": "abi.encodeWithSelector is similar to abi.encodeWithSignature. Instead of using a function signature to encode, we will use a function selector to encode our function.",
	"Variables - DataTypes - Encoding - abi.decode": "abi.decode allows you to decode encoded parameters from external contract calls. It unpacks encoded data so your Solidity contract can work with the original values again.",
	"Variables - DataTypes - Storage - SSTORE": "updating a storage slot’s value",
	"Variables - DataTypes - Storage - SSTORE - types - zero to non-zero": "20,000 gas plus 2,100 gas if the slot is cold",
	"Variables - DataTypes - Storage - SSTORE - types - non-zero to non-zero": "5,000 gas",
	"Variables - DataTypes - Storage - SSTORE - types - non-zero to zero": "5,000 gas",
	"Variables - DataTypes - Storage - transient": "https://coinsbench.com/transient-storage-in-solidity-a-closer-look-at-eip-1153-f5db99b3698d",

	"Logic": "SECTION",
	"Logic - Sync - Imperative - ControlFlow - Expressions": "",
	"Logic - Sync - Imperative - ControlFlow - Ternary": "The ternary operator is used in expressions of the form <expression> ? <trueExpression> : <falseExpression>. It evaluates one of the latter two given expressions depending upon the result of the evaluation of the main <expression>. If <expression> evaluates to true, then <trueExpression> will be evaluated, otherwise <falseExpression> is evaluated.",
	"Logic - Sync - Imperative - ControlFlow - if": "",
	"Logic - Sync - Imperative - ControlFlow - else": "",
	"Logic - Sync - Imperative - ControlFlow - Iterators - while": ".",
	"Logic - Sync - Imperative - ControlFlow - Iterators - do": ".",
	"Logic - Sync - Imperative - ControlFlow - Iterators - for": ".",
	"Logic - Sync - Imperative - ControlFlow - Iterators - break": ".",
	"Logic - Sync - Imperative - ControlFlow - Iterators - continue": ".",
	"Logic - Sync - Imperative - ControlFlow - Transfer": "",
	"Logic - Sync - Imperative - ControlFlow - Transfer - transfer()": "",
	"Logic - Sync - Imperative - ControlFlow - Transfer - send()": "",
	"Logic - Sync - Imperative - ControlFlow - Transfer - selfdestruct()": "deprecated. selfdestruct removes the contract from the blockchain, sending any remaining Ether to a specified address.",
	"Logic - Sync - Imperative - ControlFlow - Invocations": "The Ethereum Virtual Machine (EVM) offers four opcodes for making calls between contracts: https://medium.com/rareskills/delegatecall-the-detailed-and-animated-guide-30621d6b2c81",
	"Logic - Sync - Imperative - ControlFlow - Invocations - CALL (F1)": "",
	"Logic - Sync - Imperative - ControlFlow - Invocations - CALL (F1) - return": "The call method returns a tuple with two values. The first value is a boolean indicating the success or failure of the transaction. The second value, of type bytes, holds the return value of the function executed by the call, ABI-encoded, if any.",
	"Logic - Sync - Imperative - ControlFlow - Invocations - CALLCODE (F2)": "CALLCODE opcode has been deprecated since Solidity v5, being replaced by DELEGATECALL.",
	"Logic - Sync - Imperative - ControlFlow - Invocations - STATICCALL (FA)": "",
	"Logic - Sync - Imperative - ControlFlow - Invocations - DELEGATECALL (F4)": "",
	"Logic - Sync - Imperative - ControlFlow - Invocations - tx.origin": "tx.origin is the address of the EOA (externally ownder account) that originated the transaction",
	"Logic - Sync - Imperative - ControlFlow - Invocations - msg.sender": "msg.sender is the address of whatever called the currently executing smart contract (could be an EOA or a smart contract).",
	"Logic - Sync - Imperative - ControlFlow - MoneyHandling": "",
	"Logic - Sync - Imperative - ControlFlow - MoneyHandling - transfer": ".transfer() reverts on failure. In most cases, this should be the preferred method of transferring ether because it automatically reverts in the event of an error",
	"Logic - Sync - Imperative - ControlFlow - MoneyHandling - transfer - gas": "Because it only provides 2300 gas, it protects your contract from re-entry attacks.",
	"Logic - Sync - Imperative - ControlFlow - MoneyHandling - send": ".send() returns a boolean result for success/failure. should be used when the error must be handled in the contract without reverting all state changes.",
	"Logic - Sync - Imperative - ControlFlow - MoneyHandling - send - gas": "It also has a gas limit of 2300",
	"Logic - Sync - Imperative - ControlFlow - MoneyHandling - call": "This low-level method is the recommended way of sending ETH to a smart contract.",
	"Logic - Sync - Imperative - ControlFlow - MoneyHandling - receive": "The receive() function is triggered whenever a contract receives ETH and the transaction contains no data (msg.data is empty). It is ideal for situations where ETH is sent directly to the contract via tools like Metamask’s 'Send' button or other low-level interaction",
	"Logic - Sync - Imperative - ControlFlow - MoneyHandling - payable": "",
	"Logic - Sync - Imperative - ControlFlow - MoneyHandling - payable - gas": "Making a function payable decreases the cost to deploy and call the function. Non-payable functions include additional opcodes to verify that msg. value is zero and revert the transaction if any Ether is sent.",
	"Logic - Sync - Imperative - ControlFlow - MoneyHandling - balance": "",
	"Logic - Sync - Imperative - ControlFlow - MoneyHandling - balance - BALANCE": "opcode 31 BALANCE - The static cost is 0. If the accessed address is warm, the dynamic cost is 100. Otherwise, the dynamic cost is 2600. See section access sets.",
	"Logic - Sync - Imperative - ControlFlow - MoneyHandling - balance - SELFBALANCE": "opcode 47 SELFBALANCE - Semantically equivalent of calling BALANCE with ADDRESS as a parameter, but with a reduced gas cost.Minimum gas - 5.",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - require": "ensure that certain conditions are met before a function can proceed. If the condition specified in require is not satisfied, the transaction is reverted, an optional error message can be provided",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - require - gas": "If require fails, the transaction is reverted, and the user receives a gas refund for the unused portion of the transaction's gas limit. However, any gas used before the require statement, including costs for initial operations and data loading, is not refunded.",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - require - gas - message - ": "The error message 'Sender is not the owner' is stored as a string array in the contract's bytecode. Each character in the string takes up space, making error messages surprisingly expensive in terms of gas.",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - revert": "The revert keyword works similarly to require, but without the need for an inline condition. You can use revert directly to abort a transaction or function call anywhere in your code.",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - error - 8.0.4.": "With Solidity 0.8.4 and later, you can define custom errors that are more gas-efficient than traditional require statements. A custom error is defined at the top of your contract and can be used with the revert keyword to handle errors.",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - error - gas - bytecode": "Instead of embedding the entire error message string into the bytecode, only the error’s identifier is stored, which is significantly smaller.",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - trycatch": "try / catch can only catch errors from external function calls and contract creation.",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - overflow - <0.8": "",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - overflow - 0.8+": "Starting with Solidity version 0.8.0, integer overflow and underflow throw an error and revert the transaction by default.",
	"Logic - Sync - Imperative - Assembly": "The language used for inline assembly in Solidity is called Yul",
	"Logic - Sync - Imperative - Assembly - Yul": "The language used for inline assembly in Solidity is called Yul",
	"Logic - Sync - Functional - Modifiers": "",
	"Logic - Sync - Functional - Events": "",

	"CICD - Architecture": "SECTION",
	"CICD - Architecture - Structure - SPDX": "SPDX License Identifier: This line specifies the license under which the code is released. It’s a best practice in Solidity development.",
	"CICD - Architecture - Structure - Pragma": "Pragma Statement: pragma solidity ^0.8.0; specifies the version of Solidity we're using. The ^ means 'any version greater than or equal to 0.8.0 but less than 0.9.0'.",
	"CICD - Architecture - Structure - Interface": "The interface keyword is used to define an interface in Solidity. Interfaces define a set of functions that other contracts must implement.",
	"CICD - Architecture - Structure - Contract": "Contracts in Solidity are similar to classes in object-oriented languages.",
	"CICD - Architecture - Structure - Contract - size": "The maximum limit of a Solidity smart contract bytecode size is between 24 kb — 25 kb.",
	"CICD - Architecture - Structure - Contract - address": "A contract in Solidity is a collection of code (its functions) and data (its state) that resides at a specific address on the Ethereum blockchain.",
	"CICD - Architecture - Structure - Contract - members": "Each contract can contain declarations of state variables, functions, function modifiers, events, errors, struct types, and enum types. Furthermore, contracts can inherit from other contracts.",
	"CICD - Architecture - Structure - Contract - StateVariable": "Each contract can contain declarations of state variables, functions, function modifiers, events, errors, struct types, and enum types. Furthermore, contracts can inherit from other contracts.",
	"CICD - Architecture - Structure - Contract - constructor": "Constructor: The constructor function is called when the contract is deployed. It initializes our greeting variable with an initial value.",
	"CICD - Architecture - Structure - Contract - Functions": "",
	"CICD - Architecture - Structure - Contract - Functions - Custom": "",
	"CICD - Architecture - Structure - Contract - Functions - BuiltIn - self-destruct": "In Ethereum, a self-destruct operation is a feature that allows a contract to destroy itself and release its storage and funds.",
	"CICD - Architecture - Structure - Contract - Functions - BuiltIn - self-destruct - invokation": "When Contract A attempts to make a delegatecall to Contract B, and Contract B has previously executed a self-destruct, the delegatecall will return a success.",
	"CICD - Architecture - Structure - AbstractContract": "",
	"CICD - Architecture - Structure - Inheritance": ".",
	"CICD - Architecture - Structure - ABI": "The Contract Application Binary Interface (ABI) is the standard way to interact with contracts in the Ethereum ecosystem, both from outside the blockchain and for contract-to-contract interaction.",
	"CICD - Architecture - Libraries": "using PriceConverter for uint256;",
	"CICD - Architecture - Patterns": "",
	"CICD - Architecture - Patterns - Upgradeable": "",
	"CICD - Architecture - Patterns - Upgradeable - constructor": "Upgradeable contracts have no constructors but initializers, therefore they can't handle immutable variables. Since the immutable variable value is stored in the bytecode its value would be shared among all proxies pointing to a given contract instead of each proxy's storage.",
	"CICD - Architecture - Patterns - Factory": "https://coinsbench.com/day-12-storage-factory-building-composable-smart-contracts-89ec5bd2448b",
	"CICD - Architecture - Patterns - Proxy": "",
	"CICD - Architecture - Patterns - Proxy - DELEGATECALL": "DELEGATECALL is required for proxy contracts to work because this type of call will preserve the msg (msg.sender, msg.value, etc…) and run in the context of the calling contract instead of the called contract. This enables the proxy contract to call an implementation contract to modify the proxy contract’s state. By using DELEGATECALL, the implementation contract can be upgraded without the smart contract system losing any information or having to change the address of the proxy.",
	"CICD - Architecture - Patterns - Proxy - StorageCollision": "A storage collision in a proxy contract is the occurrence when the implementation contract reads from or writes to a storage variable that occupies a different slot in the proxy contract than it does in the implementation contract.",
	"CICD - Architecture - Patterns - Proxy - FunctionSelectorClash": "A function selector clash in a proxy is the scenario when the proxy contract’s function selector matches a function selector in the implementation contract. This occurs when the proxy contract and the implementation contract both have defined a function with the same name and parameters, leading to identical function selectors. This could cause the proxy contract to intercept and execute function calls that were meant to be forwarded to the implementation contract.",
	"CICD - Architecture - Patterns - Proxy - Types - UUPS": "",
	"CICD - Architecture - Patterns - Proxy - Types - TUP": "",
	"CICD - Architecture - Patterns - Proxy - CommitReveal": "The commit-reveal scheme is a technique used in blockchain-based applications to ensure the fairness, transparency, and security of various activities such as voting, auctions, lotteries, quizzes, and gift exchanges. The scheme involves two steps: commit and reveal.",
	"CICD - Architecture - Patterns - Proxy - CommitReveal - Commit": "During the commit phase, users submit a commitment that contains the hash of their answer along with a random seed value. The smart contract stores this commitment on the blockchain.",
	"CICD - Architecture - Patterns - Proxy - CommitReveal - Reveal": "Later, during the reveal phase, the user reveals their answer and the seed value. The smart contract then checks that the revealed answer and the hash match, and that the seed value is the same as the one submitted earlier. If everything checks out, the contract accepts the answer as valid and rewards the user accordingly.",
	"CICD - Architecture - Patterns - CEI": "The CHECKS-EFFECTS-INTERACTIONS programming pattern, commonly abbreviated as CEI, offers a structured way of writing contract functions to avoid potential pitfalls. In essence, this pattern suggests the following order of operations inside a function: 1. Checks: Validate all conditions and prerequisites. For example, check if the caller has the necessary permissions or if there's enough ether sent. 2. Effects: Update the state variables. 3. Interactions: Interact with other contracts, send Ether, or conduct external function calls. Following this order can help prevent a known attack vector in Solidity called 'reentrancy attack,' where a malicious actor can exploit the call to an external contract to re-enter and manipulate the calling contract.",
	"CICD - Architecture - Standards - ERC-20": "",
	"CICD - Architecture - Standards - ERC-721": "",
	"CICD - Architecture - Standards - ERC-1555": "",
	"CICD - Architecture - Security - Reentrancy": "A reentrancy attack happens when the contract allows a function to be called again before the previous call finishes.",
	"CICD - Architecture - Security - Reentrancy - checks-effects-interactions": "The checks-effects-interactions pattern is used to prevent reentrancy attacks by first checking conditions, then performing state changes, and finally interacting with external contracts.",
	"CICD - Architecture - Security - SignatureReply": "Replay attacks occur when a signature and the system consuming it have no deduplication mechanism. A cause for replay attack vulnerabilities is when signatures are not properly invalidated or a nonce is absent from the system.",
	"CICD - Architecture - Security - FrontRunning": "",
	"CICD - Architecture - Functionalities - AccessControl - AllowList": "A mapping is better for an address allowlist because it is more gas efficient. With a mapping, it is possible to check if an address is on the allowlist by directly accessing its value. Using an array, verifying an address could be costly because it would require looping through each element.",

	"CICD - Bundling": "SECTION",
	"CICD - Bundling - Arch - Functions - selector": "https://medium.com/rareskills/understanding-the-function-selector-in-solidity-f8d115372ef9",
	"CICD - Bundling - Arch - Functions - receive": "https://coinsbench.com/understanding-fallback-vs-receive-functions-in-solidity-647986a82af2",

	"CICD - Building": "SECTION",
	"CICD - Building - bytecode": "Solidity performs this function, producing what is known as “bytecode” (or lower-level code).",
	"CICD - Building - solc": "",

	"CICD - Deployment": "SECTION",
	"CICD - Deployment - OPCODES - CODESIZE": "CODESIZE opcode which simply puts the size of the current contract's bytecode on top of the stack.",
	"CICD - Deployment - OPCODES - CREATE": "CREATE opcode is used by default when deploying smart contracts. The deployed contract address is calculated like this. keccak256(senderAddress, nonce)",
	"CICD - Deployment - OPCODES - CREATE2": "CREATE2 opcode is introduced later and allows you to predetermine the contract address. Contract address is computed like this. keccak256(0xFF, senderAddress, salt, bytecode). If you are looking for an example you can refer this link, using CREATE2 one project can deploy with same contract address on multiple chains.",

	"CICD - Execution": "SECTION",
	"CICD - Execution - EVM": "The EVM is an interpreter that reads bytecode and executes instructions based on it.",
	"CICD - Execution - EVM - codes": "https://www.evm.codes/?fork=cancun#55",
	"CICD - Execution - Scopes - Functions": "Functions are the executable units of code.",
	"CICD - Execution - Scopes - Functions - organization": "Functions should be organized based on their visibility: They should be ordered as follows: constructor > receive and fallback >, external > public > internal > private functions. View and pure functions should be placed last within each visibility group.",
	"CICD - Execution - Scopes - Functions - access - public": "all can access.",
	"CICD - Execution - Scopes - Functions - access - external": "Cannot be accessed internally, only externally",
	"CICD - Execution - Scopes - Functions - access - internal": "only this contract and contracts deriving from it can access. default. ",
	"CICD - Execution - Scopes - Functions - access - private": "can be accessed only from this contract",
	"CICD - Execution - Scopes - Functions - view": "This indicates that the function doesn't modify the contract's state (it only reads data).",
	"CICD - Execution - Scopes - Functions - pure": "pure functions cannot read from or modify the state.",
	"CICD - Execution - Scopes - Functions - modifiers": "Modifiers in Solidity can be used to apply a condition to a function, such as restricting its execution to the contract owner.",
	"CICD - Execution - Scopes - Functions - onlyOwner": ".",
	"CICD - Execution - Scopes - Functions - fallback": "The fallback function is executed when a contract receives Ether without any data or when a function that doesn't exist is called. It can be used to handle unexpected calls and receive Ether.",
	"CICD - Execution - Scopes - Functions - overloading": "Function overloading means having multiple functions with the same name but different parameter types or numbers of parameters. Solidity decides which version to use based on the arguments passed during a function call.",
	"CICD - Execution - Scopes - functionargs - Storage": "State variables of contracts are stored in storage in a compact way such that multiple values sometimes use the same storage slot.",
	"CICD - Execution - Scopes - functionargs - Memory": "Memory is a temporary data storage location that is used to hold data during the execution of a function. Memory is cleared once the function execution is complete. It is similar to the temporary memory storage used in a computer's RAM. Memory is useful for storing variables that are only needed temporarily during the execution of a function. These variables may include function arguments, local variables, and dynamic arrays that are created during the execution of a function.",
	"CICD - Execution - Scopes - functionargs - CallData": "Calldata is also a temporary data storage location, but it is used to hold function arguments that are passed in from an external caller, such as a user or another contract. Calldata is read-only and cannot be modified by the function. Calldata is useful for passing large amounts of data to a function without having to copy the data into memory, which can be expensive in terms of gas usage. By using calldata, you can avoid the overhead of copying data into memory and reduce the amount of gas needed to execute the function.",
	"CICD - Execution - OPCODES - freememeorypointer": "The free memory pointer is a pointer (i.e. shows where to go) to the next available slot of memory. Meaning that if you need to create a new uint256 for exemple, the free memory pointer will let the EVM know where to create the new uint256.",

	"CICD - Audit": "SECTION"


}

