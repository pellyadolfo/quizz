{
	"consistency": "SECTION",
	"Consistency - Strong consistency": "Strong consistency is a consistency model where all subsequent accesses to a distributed system will always return the updated value after the update.",
	"Consistency - Weak consistency": "It is a consistency model used in distributed computing where subsequent accesses might not always be returning the updated value. There might be inconsistent responses.",
	"Consistency - Eventual consistency": "Eventual consistency is a special type of weak consistency method which informally guarantees that, if no new updates are made to a given data item, eventually all accesses to that item will return the last updated value.",
	
	"SOLID": "SECTION",
	"SOLID Principles": "S.O.L.I.D., the first five principles of object-oriented programming. S.O.L.I.D. stands for: S - Single-responsibility principle, O - Open-closed principle, L - Liskov substitution principle, I - Interface segregation principle, D - Dependency Inversion Principle",
	"SOLID Principles. S - Single-responsibility principle": "Single-responsibility principle. This principle states that an object / class should only have one responsibility and that it should be completely encapsulated by the class. A reason to change",
	"SOLID Principles. O - Open-closed principle": "Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification. You will get loose coupling.",
	"SOLID Principles. L - Liskov substitution principle": "Defined by Barbara Liskov. Objects should be replaceable by instances of their subtypes without affecting the functioning of your system.",
	"SOLID Principles. I - Interface segregation principle": "Classes that implement interfaces, should not be forced to implement methods they do not use.",
	"SOLID Principles. D - Dependency Inversion Principle": "High level modules should not depend on low level modules.",

	"ACID": "SECTION",
	"ACID ": "ACID: Atomicity, Consistency, Isolation, Durability",
	"ACID. Atomicity": "The db must treat each transaction as all or nothing, if any part fails, the whole transaction must be rolled back as if it never happened.",
	"ACID. Consistency": "A catch-all term that means all the rules defined in the database must be followed when committing a transaction. The end state, at the end of the transaction, must be valid. Rules here can mean data constraints, cascades, triggers, etc. Consistency relies on atomicity, in that if there is a violation, we rely on the systems ability to roll back changes.",
	"ACID. Isolation": "result of 2 concurrent operations should be the same as if they occurred sequentially.",
	"ACID. Durability": "Transactions that have committed must survive permanently, even if the system crashes. This is usually assured by writing transactions into a log before acknowledging the commit. The log is on non-volatile storage and can be used to recreate the system state prior to failure (often automatically).",
	"Transaction Isolation. States": "Isolation levels defines the degree to which a transaction must be isolated from the data modifications made by any other transaction in the database system. A transaction isolation level are defined by the following phenomena: Dirty Read, Non Repeatable read, Phantom Read",
	"Transaction Isolation. States. Dirty Read": "A Dirty read is the situation when a transaction reads a data that has not yet been commited.",
	"Transaction Isolation. States. Non Repeatable read": "Non Repeatable read occurs when a transaction reads same row twice, and get a different value each time. For example, suppose transaction T1 reads a data. Due to concurrency, another transaction T2 updates the same data and commit, Now if transaction T1 rereads the same data, it will retrieve a different value.",
	"Transaction Isolation. States. Phantom Read": "Phantom Read occurs when two same queries are executed, but the rows retrieved by the two, are different.",
	"Transaction Isolation. Levels": "The SQL standard defines four isolation levels: Read Uncommitted, Read Committed, Repeatable Read, Serializable",
	"Transaction Isolation. Levels. Read Uncommitted": "Read Uncommitted is the lowest isolation level. In this level, one transaction may read not yet commited changes made by other transaction, thereby allowing dirty reads. In this level, transactions are not isolated from each other.",
	"Transaction Isolation. Levels. Read Committed": "This isolation level guarantees that any data read is committed at the moment it is read. Thus it does not allows dirty read. The transaction hold a read or write lock on the current row, and thus prevent other rows from reading, updating or deleting it.",
	"Transaction Isolation. Levels. Repeatable Read": "This is the most restrictive isolation level. The transaction holds read locks on all rows it references and write locks on all rows it inserts, updates, or deletes. Since other transaction cannot read, update or delete these rows, consequently it avoids non repeatable read.",
	"Transaction Isolation. Levels. Serializable": "This is the Highest isolation level. A serializable execution is defined to be an execution of the operations of concurrently executing SQL-transactions that produces the same effect as some serial execution of those same SQL-transactions. A serial execution is one in which each SQL-transaction executes to completion before the next SQL-transaction begins.",

	"BASE": "SECTION",
	"BASE Consistency Model": "BASE properties are looser than ACID. A BASE datastore values availability and scale, instead of guaranteed consistency. Used by NoSQL stores, including column family, key-value and document stores.",
	"BASE Basic Availability": "The database appears to work most of the time.",
	"BASE Soft-state": "Stores do not have to be write-consistent, nor do different replicas have to be mutually consistent all the time.",
	"BASE Eventual consistency": "Stores exhibit consistency at some later point (e.g., lazily at read time).",

	"CAP Theorem": "SECTION",
	"CAP Theorem ": "In any distributed data store, you can have at most two of these three properties: consistency (C), high availability (A), tolerance to network partitions (P)",
	"CAP Theorem. Consistency (C)": "Consistency (C) equivalent to having a single up-to-date copy of the data. Every read receives the most recent write or an error. Note that this is different definition of C than in ACID, where it's about maintaining the constraints on the data and the model.",
	"CAP Theorem. High Availability (A)": "High Availability (A) of that data (for updates). Every request receives a (non-error) response without guarantee that it contains the most recent write. Note that this is a different definition of A than in ACID, which is about atomicity.",
	"CAP Theorem. Tolerance to Network Partitions (P)": "Tolerance to network partitions (P). The system continues to operate despite an arbitrary number of messages being dropped (or delayed) by the network between nodes. Note that the I in ACID depends on network partitions: Isolation can only be guaranteed inside a single partition.",
	"CAP Theorem - CA - Forfeit Partitions": "The system achieves High Available Consistency. To manage data across multiple resources these systems used methods like 2-Phase Commit. Single-site databases, RDBMS (Oracle, Postgres, MySQL) could be good eamples of CA systems.",
	"CAP Theorem - CP - Best Effort Availity": "The system achieves Strong Consistency with Partition Tolerance. Pessimistic Locking methods used for multi resource data management. DNS, MongoDB, Redis are the example CP systems.",
	"CAP Theorem - AP - Best Effort Consistency": "The system offers Full Availability by relaxing consistency. Optimistic Locking methods used for multi resource data management. CouchBase, Cassandra, Hazelcast are the example CP systems.",

	"DDD": "SECTION",
	"DDD - description": ".",
	"DDD - Entities": "Entities are objects that have a distinct identity that runs through time and different states. The identity is usually represented by an ID.",
	"DDD - ValueObjects": "Value objects are objects that are defined by their attributes. They do not have a distinct identity.",
	"DDD - Repositories": "Repositories are used to retrieve and store entities. They act as a collection of entities.",
	"DDD - Factories": "Factories are used to create complex objects and aggregates.",
	"DDD - Aggregates": "Aggregates are clusters of entities and value objects that are treated as a single unit.",
	"DDD - Services": "Services contain business logic that doesn’t naturally fit within an entity or value object.",
	"DDD - Services - stateless": "1.Stateless: Services are typically stateless. They do not hold any state themselves but operate on the state of entities and value objects.",
	"DDD - Services - Encapsulation": "2.Encapsulation of Business Logic: They encapsulate business logic that spans multiple entities or value objects or that doesn’t fit neatly within a single entity or value object.",
	"DDD - Services - Coordination": "3.Coordination: They often coordinate interactions between multiple entities and value objects.",
	"DDD - DomainEvents": "Domain events are used to communicate changes in the state of the business.",
	"DDD - DomainEvents - published": "Where Domain Events Are Published:",
	"DDD - DomainEvents - published - EventBus": "1.Event Bus: Domain events are often published to an in-memory event bus within the application. This allows other parts of the application to subscribe to and handle these events. Since it is in-memory, the events are ephemeral and will be lost if the application restarts or crashes. It is suitable for scenarios where events need to be processed quickly and do not require persistence, such as inter-component communication within a single application instance.",
	"DDD - DomainEvents - published - EventStore": "2.Event Store: For more complex scenarios, domain events can be published to an event store, such as AWS EventBridge, Kafka, or a custom event store. This allows for durable storage and replay of events.",
	"DDD - DomainEvents - published - MessageBrokers": "3.Message Brokers: Domain events can also be published to message brokers like RabbitMQ or AWS SNS/SQS for asynchronous processing and integration with other systems."

}