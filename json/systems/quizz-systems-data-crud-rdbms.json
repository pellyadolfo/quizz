{
	"RDBMS": "SECTION",
	"RDBMS 0": "https://www.linkedin.com/posts/ajayyadav1996_sql-handwritten-notes-activity-7324313678801985536-SXvy/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"RDBMS 1": "https://www.linkedin.com/posts/ashishps1_the-internal-architecture-of-postgresql-explained-activity-7315224649435385858-iCp3?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"RDBMS 2": "https://www.linkedin.com/posts/sakshiku945_100-sql-commands-activity-7323194415949197312-7wD8?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"RDBMS 3": "https://www.linkedin.com/posts/ajay026_repost-sql-dataengineering-activity-7336743830903238660-cOi9/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"RDBMS 4": "https://levelup.gitconnected.com/i-thought-i-knew-sql-7d3d94a31c2a",
	"RDBMS 5": "https://www.linkedin.com/posts/diwakarsinghbamentor_sql-notes-activity-7334943206368858113-UUCf/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"RDBMS 6": "https://www.linkedin.com/posts/zoranmilosevic_how-does-sql-execution-order-work-and-why-activity-7338867676116615169-QhOZ?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",

	"PL-SQL": "SECTION",

	"Querying - SQL": "SECTION",
	"Querying - SQL - Commands": "",
	"Querying - SQL - TCL": "",
	"Querying - SQL - TCL - COMMIT": "",
	"Querying - SQL - TCL - SET TRANSACTION": "",
	"Querying - SQL - TCL - ROLLBACK": "",
	"Querying - SQL - TCL - SAVEPOINT": "",
	"Querying - SQL - DQL": "",
	"Querying - SQL - DQL - SELECT": "",
	"Querying - SQL - DQL - SELECT - Columns": "",
	"Querying - SQL - DQL - SELECT - Columns - OPERATORS - Arithmetic": "Arithmetic (+, -, *, /, etc.)",
	"Querying - SQL - DQL - SELECT - Columns - OPERATORS - Comparison": "Comparison (>, <, =, >=, etc.)",
	"Querying - SQL - DQL - SELECT - Columns - OPERATORS - Compound": "Compound (+=, -=, *=, /=, etc.)",
	"Querying - SQL - DQL - SELECT - Columns - OPERATORS - Logical": "Logical (AND, OR, NOT, BETWEEN, etc.)",
	"Querying - SQL - DQL - SELECT - Columns - OPERATORS - String": "String (%, _, +, ^, etc.)",
	"Querying - SQL - DQL - SELECT - Columns - OPERATORS - Set": "Set (UNION, UNION ALL, INTERSECT, and MINUS (or EXCEPT))",
	"Querying - SQL - DQL - SELECT - Columns - WindowFunction": "A window function is an SQL function where the input values are taken from a window of one or more rows in the results set of a SELECT statement.",
	"Querying - SQL - DQL - SELECT - Columns - WindowFunction - Aggregate": "",
	"Querying - SQL - DQL - SELECT - Columns - WindowFunction - Aggregate - SUM()": "",
	"Querying - SQL - DQL - SELECT - Columns - WindowFunction - Aggregate - AVG()": "",
	"Querying - SQL - DQL - SELECT - Columns - WindowFunction - Aggregate - COUNT()": "",
	"Querying - SQL - DQL - SELECT - Columns - WindowFunction - Aggregate - MAX()": "",
	"Querying - SQL - DQL - SELECT - Columns - WindowFunction - Aggregate - MIN()": "",
	"Querying - SQL - DQL - SELECT - Columns - WindowFunction - Ranking": "",
	"Querying - SQL - DQL - SELECT - Columns - WindowFunction - Ranking - RANK()": "Assigns ranks to rows, skipping ranks for duplicates. SELECT Name, Department, Salary, RANK() OVER(PARTITION BY Department ORDER BY Salary DESC) AS emp_rank FROM employee;",
	"Querying - SQL - DQL - SELECT - Columns - WindowFunction - Ranking - DENSE_RANK()": "Assigns ranks to rows without skipping rank numbers for duplicates. SELECT Name, Department, Salary, DENSE_RANK() OVER(PARTITION BY Department ORDER BY Salary DESC) AS emp_dense_rank FROM employee;",
	"Querying - SQL - DQL - SELECT - Columns - WindowFunction - Ranking - PERCENT_RANK()": "",
	"Querying - SQL - DQL - SELECT - Columns - WindowFunction - Ranking - ROW_NUMBER()": "Assigns a unique number to each row in the result set. SELECT Name, Department, Salary, ROW_NUMBER() OVER(PARTITION BY Department ORDER BY Salary DESC) AS emp_row_no FROM employee;",
	"Querying - SQL - DQL - SELECT - Columns - WindowFunction - Ranking - NTILE()": "The NTILE() is the last major ranking window function in SQL but it is not very commonly used. In short, it works analogically to the ROW_NUMBER function but instead of assigning consecutive numbers to the next rows, it assigns consecutive numbers to the buckets of rows. The bucket is a collection of several consecutive rows and the number of buckets is set as a parameter of the NTILE() function - for example, NTILE(10) means that the dataset will be divided into 10 buckets.",
	"Querying - SQL - DQL - SELECT - Columns - WindowFunction - Value": "The value window functions in SQL are used to assign to rows values from other rows. Similarly to the ranking window functions and unlike the aggregate functions, the value functions have no obvious equivalents that donâ€™t use windows. However, it is usually possible to replicate the results of these functions using two nested queries, hence, the value window functions are not that commonly used as the ranking functions.",
	"Querying - SQL - DQL - SELECT - Columns - WindowFunction - Value - LAG()": "The LAG() function is by far the most popular out of the value window functions but at the same time is rather simple. What it does is, it assigns to each row a value that normally belongs to the previous row. In other words, it allows to shift any column by one row down and allows to perform queries using this shift of values. Naturally, the ordering of the rows matters also in this case, hence, the window function will most commonly include the ORDER BY clause within its OVER( clause.",
	"Querying - SQL - DQL - SELECT - Columns - WindowFunction - Value - LEAD()": "The LEAD() window function is the exact opposite of the LAG() function because while LAG() returns for each row the value of the previous row, the LEAD() function will return the value of the following row. In other words, as LAG() shifts the values 1 row down, LEAD() shifts them 1 row up. Otherwise, the functions are identical in how they are called or how the order is defined.",
	"Querying - SQL - DQL - SELECT - Columns - WindowFunction - Value - FIRST_VALUE()": "The FIRST_VALUE() function is not that commonly used but is also a rather interesting value window function in SQL. It does exactly what its name suggests - for all the rows, it assigns the first value of the table or the partition to which it is applied, according to some ordering that determines which row comes as a first one. Moreover, the variable from which the first value should be returned needs to be defined as the parameter of the function.",
	"Querying - SQL - DQL - SELECT - Columns - WindowFunction - Value - LAST_VALUE()": "The LAST_VALUE() function is the exact opposite of the FIRST_VALUE() function and, as can be deduced from the name, returns the value from the last row of the dataset or the partition to which it is applied.",
	"Querying - SQL - DQL - SELECT - Columns - WindowFunction - Value - NTH_VALUE()": "Finally, the NTH_VALUE() function is very similar to both the FIRST_VALUE() and the LAST_VALUE(). The difference is that while the other functions output the value of either the first or the last row of a window, the NTH_VALUE() allows the user to define which value from the order should be assigned to other rows. This function takes an additional parameter denoting which value should be returned.",
	"Querying - SQL - DQL - SELECT - Columns - Aliases": "SQL aliases are used to give a table, or a column in a table, a temporary name. Aliases are often used to make column names more readable. An alias only exists for the duration of that query. An alias is created with the AS keyword.",
	"Querying - SQL - DQL - SELECT - Target": "",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE ": "A condition imposed on a SQL query to filter the data to obtain the desired result. Some examples are WHERE, LIMIT, HAVING, LIKE, AND, OR, ORDER BY, etc.",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - FROM": "",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN": "A SQL clause used to combine and retrieve records from two or multiple tables. https://www.naukri.com/code360/library/sql-joins-interview-questions",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN - Tools": "",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN - Tools - LEFT JOIN": "All data from the left table and common data from the right table.",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN - Tools - ANTI LEFT JOIN": "All records from the left table that DON'T have a match in the right table.",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN - Tools - INNER JOIN": "Only common data from both the tables.",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN - Tools - OUTER JOIN": "All the data from both the tables keeping null values with no common keys.",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN - Tools - ANTI OUTER JOIN": "All records from both tables that DON'T have a match in the other table.",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN - Tools - RIGHT JOIN": "All data from right table and common data from the left table.",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN - Tools - ANTI RIGHT JOIN": "All records from the right table that DON'T have a match in the left table",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN - Tools - SELF JOIN": "This technique involves joining a table to itself, employing recursion, a concept widely used in computer programming.",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN - Tools - LOOKUP JOIN": ".",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN - Tools - EQI JOIN": "SQL Equi Join is a simple SQL join that uses the comparison operator equal sign(=) for the condition. It is of two types SQL Inner join and SQL Outer join.",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN - Tools - NON EQI JOIN": "SQL Non-Equi Join is a join that uses a comparison operator other than the equal sign with the condition. It can be >, <, >=, or <=.",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN - Tools - NESTED JOIN": "A Nested Join uses two tables. One joining table is an outer input table, while the other is an inner input table. A Nested Loop Join involves: Retrieving one row from the outside table. Searching for it in the inner table. Repeating this procedure until all the output rows from the outer table are searched for in the inner table.",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN - Tools - NESTED JOIN - NaiveNested": "",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN - Tools - NESTED JOIN - IndexedNested": "",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN - Tools - NESTED JOIN - TemporaryIndexNested": "",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN - Tools - NATURAL JOIN": "Natural Join combines two tables based on similar attribute names and data types, and the resulting table consists of the attributes from both tables by keeping only one copy of each common column. Therefore, two tables are combined on the basis of their similar column names, and the table in output consists of only one instance of the common column.",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN - Tools - CROSS JOIN": "Cartesian product of all records from both tables.",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN - Cases": "ONLY_TABLE_A - INTERSECTION - ONLY_TABLE_B",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN - Cases - (INNER) JOIN": "INNER JOIN is same as JOIN -> INTERSECTION",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN - Cases - LEFT (OUTER) JOIN": "LEFT OUTER JOIN is same as LEFT JOIN. Completes TableA with columns of TableB - > ONLY_TABLE_A + INTERSECTION + matching (ONLY_TABLE_B)",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN - Cases - RIGHT (OUTER) JOIN": "RIGHT OUTER JOIN is same as RIGHT JOIN Completes TableB with columns of TableA -> ONLY_TABLE_A + INTERSECTION + matching (ONLY_TABLE_B)",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - JOIN - Cases - FULL (OUTER) JOIN": "FULL OUTER JOIN is same as FULL JOIN -> matching (ONLY_TABLE_A) + INTERSECTION + ONLY_TABLE_B.",
	"Querying - SQL - DQL - SELECT - Target - CLAUSE - WHERE": "checks each row individually",	"Querying - SQL - DQL - SUBQUERY": "It is a query enclosed within another query. In this, the inner query is known as a subquery. While the outer query is known as the main query. There are two types of subqueries: Nested, Correlated.",
	"Querying - SQL - DQL - SELECT - Results": "",
	"Querying - SQL - DQL - SELECT - Results - CLAUSE - LIMIT": "",
	"Querying - SQL - DQL - SELECT - Results - CLAUSE - ORDER BY": "",
	"Querying - SQL - DQL - SELECT - Results - CLAUSE - GROUP BY": "",
	"Querying - SQL - DQL - SELECT - Results - CLAUSE - HAVING": "works on aggregated data after they are grouped",
	"Querying - SQL - DQL - SELECT - Results - CLAUSE - DISTINCT": "",
	"Querying - SQL - DQL - SUBQUERY - NestedQuery:": "Nested Query: It first executes the inner query, and only once. Then an outer query is executed depending on the results of the inner query. Therefore the inner query is used to execute the outer query.",
	"Querying - SQL - DQL - SUBQUERY - CorrelatedQuery": "Correlated Query: It first executes the outer query. For every outer query row, the inner query is executed. Therefore, values from the outer query are used in the inner query.",
	"Querying - SQL - DQL - VIEW - View": "A view is a virtual table that fetches data dynamically whenever queried.",
	"Querying - SQL - DQL - VIEW - View - MaterializedVIew": "A materialized view is a pre-computed data set derived from a query and stored for later use.",
	"Querying - SQL - DQL - VIEW - View - MaterializedVIew - faster": "Because the data is pre-computed, querying a materialized view is faster than executing a query against the base table of the view.",
	"Querying - SQL - DQL - EXPLAIN ANALYZE": "",

	"DataOptimization": "SECTION",

	"DataModel": "SECTION",
	"DataModel - ForeignKey": "Creates a relationship/link between two tables",
	"DataModel - ForeignKey - Duplicates": "Can contain duplicate values (for one-to-many relationships)",
	"DataModel - ForeignKey - Null": "Can contain NULL values (unless marked as NOT NULL)",
	"DataModel - ForeignKey - Quantity": "Multiple unique constraints per table allowed",
	"DataModel - ForeignKey - Purpose": "Multiple foreign keys can exist in a table",
	"DataModel - ForeignKey - References": "References PK of another table",
	"DataModel - ForeignKey - Indexing": "May or may not be indexed",
	"DataModel - UniqueConstraint": "",
	"DataModel - UniqueConstraint - NoDuplicates": "Must contain unique values (no duplicates)",
	"DataModel - UniqueConstraint - Null": "Can contain NULL values (unless combined with NOT NULL)",
	"DataModel - UniqueConstraint - Quantity": "Multiple unique constraints per table allowed",
	"DataModel - UniqueConstraint - Purpose": "Ensures data integrity for non-primary key columns",
	"DataModel - UniqueConstraint - Relationships": "Not typically used for relationships",
	"DataModel - UniqueConstraint - Indexing": "Creates a unique index on the column(s)",
	"DataModel - PrimaryKey": "Uniquely identifies each record in a table",
	"DataModel - PrimaryKey - NoDuplicates": "Must contain unique values (no duplicates)",
	"DataModel - PrimaryKey - Null": "Cannot contain NULL values",
	"DataModel - PrimaryKey - Quantity": "Only one primary key per table",
	"DataModel - PrimaryKey - Purpose": "Identifies each record uniquely in a table",
	"DataModel - PrimaryKey - Relationships": "Used as foreign keys in other tables",
	"DataModel - PrimaryKey - Clustering": " Often used as the clustering key (physical ordering of data)",
	"DataModel - SQL": "",
	"DataModel - SQL - Objects - Schema": "A collection of database structural elements such as tables, stored procedures, indexes, functions, and triggers. It shows the overall database architecture, specifies the relationships between various objects of a database, and defines different access permissions for them. Read our database schema guide for a deeper understanding.",
	"DataModel - SQL - Objects - Entities": ".",
	"DataModel - SQL - Objects - Table": ".",
	"DataModel - SQL - Objects - View": ".",
	"DataModel - SQL - Objects - MaterializedView": ".",
	"DataModel - SQL - DDL": "",
	"DataModel - SQL - DDL - CREATE": "",
	"DataModel - SQL - DDL - CREATE - CONSTRAINTS": "",
	"DataModel - SQL - DDL - CREATE - CONSTRAINTS ": "A set of conditions defining the type of data that can be input into each column of a table. Constraints ensure data integrity in a table and block undesired actions.",
	"DataModel - SQL - DDL - CREATE - CONSTRAINTS - DEFAULT": "provides a default value for a column.",
	"DataModel - SQL - DDL - CREATE - CONSTRAINTS - UNIQUE": "allows only unique values.",
	"DataModel - SQL - DDL - CREATE - CONSTRAINTS - NOT NULL": "allows only non-null values.",
	"DataModel - SQL - DDL - CREATE - CONSTRAINTS - PRIMARY KEY": "allows only unique and strictly non-null values (NOT NULL and UNIQUE).",
	"DataModel - SQL - DDL - CREATE - CONSTRAINTS - FOREIGN KEY": "provides shared keys between two or more tables.",
	"DataModel - SQL - DDL - ALTERTABLE": "",
	"DataModel - SQL - DDL - PARTITIONOF": "CREATE TABLE orders_202301 PARTITION OF",
	"DataModel - SQL - DDL - DELETE": "",
	"DataModel - SQL - DDL - DROP": "DROP deletes a table from the database completely, including the table structure and all the associated constraints, relationships with other tables, and access privileges. TRUNCATE deletes all rows from a table without affecting the table structure and constraints. DROP works slower than TRUNCATE. Both are irreversible DDL (Data Definition Language) commands.",
	"DataModel - SQL - DDL - TRUNCATE": "",
	"DataModel - SQL - DDL - ADDCOLUMN": "",
	"DataModel - SQL - DML": "",
	"DataModel - SQL - DML - INSERT": "",
	"DataModel - SQL - DML - UPDATE": "",
	"DataModel - SQL - DML - DELETE": "",
	"DataModel - SQL - DCL": "",
	"DataModel - SQL - DCL - GRANT": "",
	"DataModel - SQL - DCL - REVOKE": ""

}