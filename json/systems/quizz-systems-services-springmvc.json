{
	"Spring MVC": "SECTION",
	"Spring MVC - definition": "Spring Web MVC is the original web framework built on the Servlet API and included in the Spring Framework from the very beginning. The formal name 'Spring Web MVC' comes from the name of its source module spring-webmvc but it is more commonly known as 'Spring MVC'. Parallel to Spring Web MVC, Spring Framework 5.0 introduced a reactive stack, web framework whose name Spring WebFlux is also based on its source module spring-webflux. .",

	"Spring MVC - config": "SECTION",
	"Spring MVC - config - web.xml": "Put in web.xml:<br>(1) < listener >< listener-class >org.springframework.web.context.ContextLoaderListener< /listener-class >< /listener > <br>(2) < context-param >< param-name >contextConfigLocation< /param-name >< param-value >/WEB-INF/applicationContext*.xml< /param-value >< /context-param > If you do not specify the contextConfigLocation context parameter, the ContextLoaderListener will look for a file called /WEB-INF/applicationContext.xml to load. <br>(3) Once the context files are loaded, Spring creates a WebApplicationContext object based on the bean definitions and stores it in the ServletContext of the web application. To get access to this ApplicationContext use WebApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext),",
	"Spring MVC - config - web.xml - verify": "WebApplicationContextUtils#getWebApplicationContext() method will return null if ServletContext does not exist under the WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE key. WebApplicationContextUtils#getRequiredWebApplicationContext() throws an exception when the ApplicationContext is missing. Once you have a reference to the WebApplicationContext, you can retrieve beans by their name or type",
	"Spring MVC - config - DelegatingWebMvcConfiguration - Java": "@Configuration public class WebConfig extends DelegatingWebMvcConfiguration { ... }",
	"Spring MVC - config - DelegatingWebMvcConfiguration - Java ": "The MVC namespace does not have an advanced mode. If you need to customize a property on a bean that you can’t change otherwise, you can use the BeanPostProcessor lifecycle hook of the Spring ApplicationContext:",
	"Spring MVC - config - WebMvcConfigurer": "Defines callback methods to customize the Java-based configuration for Spring MVC enabled via @EnableWebMvc",
	"Spring MVC - config - WebMvcConfigurer - WebMvcConfigurerAdapter": "Before Spring5 WebMvcConfigurer was called WebMvcConfigurerAdapter",
	"Spring MVC - config - WebMvcConfigurer - @EnableWebMvc": "In Java config use the @EnableWebMvc annotation: @Configuration @EnableWebMvc public class WebConfig implements WebMvcConfigurer { .... }. In XML < mvc:annotation-driven/ >",
	"Spring MVC - config - WebMvcConfigurer - ContentNegotiation": "You can configure how Spring MVC determines the requested media types from the request, e.g. Accept header, URL path extension, query parameter, etc. By default the URL path extension is checked first, with json, xml, rss, and atom registered as known extensions depending on classpath dependencies, and the 'Accept' header is checked second. Consider changing those defaults to Accept header only and if you must use URL-based content type resolution consider the query parameter strategy over the path extensions. @Override   public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {        configurer.mediaType('json', MediaType.APPLICATION_JSON),        configurer.mediaType('xml', MediaType.APPLICATION_XML),    } In XML < mvc:annotation-driven content-negotiation-manager='contentNegotiationManager'/ >  ",
	"Spring MVC - config - WebMvcConfigurer - DefaultServletHttpRequestHandler": "This allows for mapping the DispatcherServlet to '/' (thus overriding the mapping of the container’s default Servlet), while still allowing static resource requests to be handled by the container’s default Servlet. It configures a DefaultServletHttpRequestHandler with a URL mapping of '/**' and the lowest priority relative to other URL mappings. This handler will forward all requests to the default Servlet. Therefore it is important that it remains last in the order of all other URL HandlerMappings. That will be the case if you use <mvc:annotation-driven> or alternatively if you are setting up your own customized HandlerMapping instance be sure to set its order property to a value lower than that of the DefaultServletHttpRequestHandler, which is Integer.MAX_VALUE. @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {        configurer.enable(),    } iN xml < mvc:default-servlet-handler/ >",

	"Engine - DispatcherServlet": "SECTION",
	"Engine - DispatcherServlet - pattern": "Spring MVC, like many other web frameworks, is designed around the front controller pattern where a central Servlet, the DispatcherServlet.",
	"Engine - DispatcherServlet - Declaration": "The DispatcherServlet, as any Servlet, needs to be declared and mapped according to the Servlet specification using Java configuration or in web.xml..",
	"Engine - DispatcherServlet - Processing": "The DispatcherServlet processes requests as follows:",
	"Engine - DispatcherServlet - Processing - WebApplicationContext": "(1) The WebApplicationContext is searched for and bound in the request as an attribute that the controller and other elements in the process can use. It is bound by default under the key DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE.",
	"Engine - DispatcherServlet - Processing - Locale": "(2) The locale resolver is bound to the request to enable elements in the process to resolve the locale to use when processing the request (rendering the view, preparing data, and so on). If you do not need locale resolving, you do not need it.",
	"Engine - DispatcherServlet - Processing - Theme": "(3) The theme resolver is bound to the request to let elements such as views determine which theme to use. If you do not use themes, you can ignore it.",
	"Engine - DispatcherServlet - Processing - Multipart": "(4) If you specify a multipart file resolver, the request is inspected for multiparts, if multiparts are found, the request is wrapped in a MultipartHttpServletRequest for further processing by other elements in the process. See Multipart resolver for further information about multipart handling. (5) An appropriate handler is searched for. If a handler is found, the execution chain associated with the handler (preprocessors, postprocessors, and controllers) is executed in order to prepare a model or rendering. Or alternatively for annotated controllers, the response may be rendered (within the HandlerAdapter) instead of returning a view. (6) If a model is returned, the view is rendered. If no model is returned, (may be due to a preprocessor or postprocessor intercepting the request, perhaps for security reasons), no view is rendered, because the request could already have been fulfilled..",
	"Engine - DispatcherServlet - Processing - Handler": "(5) An appropriate handler is searched for. If a handler is found, the execution chain associated with the handler (preprocessors, postprocessors, and controllers) is executed in order to prepare a model or rendering. Or alternatively for annotated controllers, the response may be rendered (within the HandlerAdapter) instead of returning a view.",
	"Engine - DispatcherServlet - Processing - View": "(6) If a model is returned, the view is rendered. If no model is returned, (may be due to a preprocessor or postprocessor intercepting the request, perhaps for security reasons), no view is rendered, because the request could already have been fulfilled..",
	"Engine - DispatcherServlet - Configuration": "The DispatcherServlet uses Spring configuration to discover the delegate components it needs for request mapping, view resolution, exception handling, and more..",
	"Engine - DispatcherServlet - Configuration - Delegate to beans": "The DispatcherServlet delegates to special beans to process requests and render the appropriate responses. By 'special beans' we mean Spring-managed, Object instances that implement WebFlux framework contracts. Those usually come with built-in contracts but you can customize their properties, extend or replace them. The table below lists the special beans detected by the DispatcherHandler: HandlerMapping, HandlerAdapter, HandlerExceptionResolver, ViewResolver, LocaleResolver, LocaleContextResolver, ThemeResolver, MultipartResolver, FlashMapManager",
	"Engine - DispatcherServlet - Configuration - web.xml": "Until Spring 3.1, the DispatcherServlet had to be registered with the Servlet container via the standard Web application web.xml file. With the presence of the Servlet 3.0 specification, the web.xml file in a Web application is now optional.  The Servlet 3.0 API brought annotations to the Java Web application world allowing the registration of servlets to be accomplished by annotation.",
	"Engine - DispatcherServlet - Configuration - WebApplicationInitializer": "In a Servlet 3.0+ environment, you have the option of configuring the Servlet container programmatically as an alternative or in combination with a web.xml file. WebApplicationInitializer is an interface provided by Spring MVC that ensures your implementation is detected and automatically used to initialize any Servlet 3 container.",
	"Engine - DispatcherServlet - Configuration - WebApplicationInitializer - onStartup": "void onStartup(ServletContext servletContext) throws ServletException Configure the given ServletContext with any servlets, filters, listeners context-params and attributes necessary for initializing this web application.",
	"Engine - DispatcherServlet - Configuration - WebApplicationInitializer - implementation - AbstractContextLoaderInitializer": "This class included in spring-web module uses abstract createRootApplicationContext() method to create application context, delegates it toContextLoaderListener which then is being registered in the ServletContext instance.",
	"Engine - DispatcherServlet - Configuration - WebApplicationInitializer - implementation - AbstractDispatcherServletInitializer": "An abstract base class implementation of WebApplicationInitializer named AbstractDispatcherServletInitializer. specify the servlet mapping and the location of the DispatcherServlet configuration. It extends previous class and adds two abstract methods: createServletApplicationContext() and getServletMappings()",
	"Engine - DispatcherServlet - Configuration - WebApplicationInitializer - implementation - AbstractAnnotationConfigDispatcherServletInitializer": "Here we can see further step in simplifying Spring initialization - we don't need to manually create contexts but just set appropriate config classes in getRootConfigClasses()and getServletConfigClasses() methods. I hope you are already familiar with those names, because they works exactly like in the former case. Of course due to this class extends AbstractDispatcherServletInitializer we can still override getServletFilters()",
	"Engine - DispatcherServlet - Configuration - WebApplicationContext": "DispatcherServlet expects a WebApplicationContext, an extension of a plain ApplicationContext, for its own configuration. WebApplicationContext has a link to the ServletContext and Servlet it is associated with. It is also bound to the ServletContext such that applications can use static methods on RequestContextUtils to look up the WebApplicationContext if they need access to it. For many applications having a single WebApplicationContext is simple and sufficient. It is also possible to have a context hierarchy where one root WebApplicationContext is shared across multiple DispatcherServlet (or other Servlet) instances, each with its own child WebApplicationContext configuration. The root WebApplicationContext typically contains infrastructure beans such as data repositories and business services that need to be shared across multiple Servlet instances. Those beans are effectively inherited and could be overridden (i.e. re-declared) in the Servlet-specific, child WebApplicationContext which typically contains beans local to the given Servlet.",
	"Engine - DispatcherServlet - Configuration - Init Params": "You can customize individual DispatcherServlet instances by adding Servlet initialization parameters ( init-param elements) to the Servlet declaration in the web.xml file. contextClass, contextConfigLocation, namespace, throwExceptionIfNoHandlerFound",
	"Engine - DispatcherServlet - Configuration - Init Params - contextClass": "Class that implements WebApplicationContext, which instantiates the context used by this Servlet. By default, the XmlWebApplicationContext is used.",
	"Engine - DispatcherServlet - Configuration - Init Params - contextConfigLocation": "String that is passed to the context instance (specified by contextClass) to indicate where context(s) can be found. The string consists potentially of multiple strings (using a comma as a delimiter) to support multiple contexts. In case of multiple context locations with beans that are defined twice, the latest location takes precedence.",
	"Engine - DispatcherServlet - Configuration - Init Params - namespace": "Namespace of the WebApplicationContext. Defaults to [servlet-name]-servlet.",
	"Engine - DispatcherServlet - Configuration - Init Params - throwExceptionIfNoHandlerFound": "Whether to throw a NoHandlerFoundException when no handler was found for a request. The exception can then be caught with a HandlerExceptionResolver, e.g. via an @ExceptionHandler controller method, and handled as any others. By default this is set to 'false', in which case the DispatcherServlet sets the response status to 404 (NOT_FOUND) without raising an exception. Note that if default servlet handling is also configured, then unresolved requests are always forwarded to the default servlet and a 404 would never be raised.",

	"Components - Controllers": "SECTION",
	"Components - Controllers - @Controller": "Is a specialization of Component",
	"Components - Controllers - @RestController": "@RestController @Controller + @ResponseBody annotation and therefore writes directly to the response body vs view resolution and rendering with an HTML template.",
	"Components - Controllers - ViewControllers": "This is a shortcut for defining a ParameterizableViewController that immediately forwards to a view when invoked. Use it in static cases when there is no Java controller logic to execute before the view generates the response. @Override public void addViewControllers(ViewControllerRegistry registry) {        registry.addViewController('/').setViewName('home'),    }. In XML < mvc:view-controller path='/' view-name='home'/ >",
	"Components - Controllers - ViewControllers - PathMatch": "This allows customizing options related to URL matching and treatment of the URL. For details on the individual options check out the PathMatchConfigurer API. @Override public void configurePathMatch(PathMatchConfigurer configurer) { ... } In XML < mvc:annotation-driven > < mvc:path-matching suffix-pattern='true' trailing-slash='false' registered-suffixes-only='true' path-helper='pathHelper' path-matcher='pathMatcher'/ > < /mvc:annotation-driven >",
	"Components - Controllers - @CrossOrigin": "This @CrossOrigin annotation enables cross-origin requests only for this specific method. By default, its allows all origins, all headers, the HTTP methods specified in the @RequestMapping annotation and a maxAge of 30 minutes is used. You can customize this behavior by specifying the value of one of the annotation attributes: origins, methods, allowedHeaders, exposedHeaders, allowCredentials or maxAge. @CrossOrigin is supported at the class level too and inherited by all methods:",
	"Components - Controllers - @RequestMapping": "The @RequestMapping annotation is used to map requests to controllers methods. It has various attributes to match by URL, HTTP method, request parameters, headers, and media types. It can be used at the class-level to express shared mappings or at the method level to narrow down to a specific endpoint mapping. There are also HTTP method specific shortcut variants of @RequestMapping: @GetMapping, @PostMapping, @PutMapping, @DeleteMapping, @PatchMapping.",
	"Components - Controllers - @RequestMapping - Method - @GetMapping": "@RequestMapping(method = RequestMethod.GET)",
	"Components - Controllers - @RequestMapping - Method - @PostMapping": "@RequestMapping(method = RequestMethod.POST)",
	"Components - Controllers - @RequestMapping - Method - @PutMapping": "@RequestMapping(method = RequestMethod.PUT",
	"Components - Controllers - @RequestMapping - Method - @DeleteMapping": "@RequestMapping(method = RequestMethod.DELETE)",
	"Components - Controllers - @RequestMapping - Method - @PatchMapping": "@RequestMapping(method = RequestMethod.PATCH)",
	"Components - Controllers - @RequestMapping - Policy - @CrossOrigin": "Configure cross origin requests processing.",
	"Components - Controllers - @RequestMapping - Arguments": "",
	"Components - Controllers - @RequestMapping - Arguments - WebRequest, NativeWebRequest": "",
	"Components - Controllers - @RequestMapping - Arguments - javax.servlet.ServletRequest, javax.servlet.ServletResponse": "",
	"Components - Controllers - @RequestMapping - Arguments - javax.servlet.http.HttpSession": "",
	"Components - Controllers - @RequestMapping - Arguments - javax.servlet.http.PushBuilder": "",
	"Components - Controllers - @RequestMapping - Arguments - java.security.Principal": "",
	"Components - Controllers - @RequestMapping - Arguments - HttpMethod": "",
	"Components - Controllers - @RequestMapping - Arguments - java.util.Locale": "",
	"Components - Controllers - @RequestMapping - Arguments - java.util.TimeZone + java.time.ZoneId": "",
	"Components - Controllers - @RequestMapping - Arguments - java.io.InputStream, java.io.Reader": "",
	"Components - Controllers - @RequestMapping - Arguments - java.io.OutputStream, java.io.Writer": "",
	"Components - Controllers - @RequestMapping - Arguments - @PathVariable": "read values from the URI, like query parameters",
	"Components - Controllers - @RequestMapping - Arguments - @MatrixVariable": "",
	"Components - Controllers - @RequestMapping - Arguments - @RequestParam": "",
	"Components - Controllers - @RequestMapping - Arguments - @RequestHeader": "",
	"Components - Controllers - @RequestMapping - Arguments - @CookieValue": "",
	"Components - Controllers - @RequestMapping - Arguments - @RequestBody": "",
	"Components - Controllers - @RequestMapping - Arguments - HttpEntity<B>": "",
	"Components - Controllers - @RequestMapping - Arguments - @RequestPart": "",
	"Components - Controllers - @RequestMapping - Arguments - java.util.Map, org.springframework.ui.Model, org.springframework.ui.ModelMap": "",
	"Components - Controllers - @RequestMapping - Arguments - RedirectAttributes": "",
	"Components - Controllers - @RequestMapping - Arguments - @ModelAttribute": "The @ModelAttribute annotation can be used: (1) On a method argument in @RequestMapping methods to create or access an Object from the model, and to bind it to the request through a WebDataBinder. (2) As a method-level annotation in @Controller or @ControllerAdvice classes helping to initialize the model prior to any @RequestMapping method invocation. (3) On a @RequestMapping method to mark its return value is a model attribute.",
	"Components - Controllers - @RequestMapping - Arguments - @ModelAttribute Methods": "@ModelAttribute methods have flexible method signatures. They support many of the same arguments as @RequestMapping methods except for @ModelAttribute itself nor anything related to the request body.",
	"Components - Controllers - @RequestMapping - Arguments - @ModelAttribute - DataBinder": "The WebDataBinder class matches Servlet request parameter names (query parameters and form fields) to field names on the target Object. Matching fields are populated after type conversion is applied where necessary.",
	"Components - Controllers - @RequestMapping - Arguments - @ModelAttribute - DataBinder - @InitBinder": "@Controller or @ControllerAdvice classes can have @InitBinder methods in order to initialize instances of WebDataBinder, and those in turn are used to: (1) Bind request parameters (i.e. form data or query) to a model object. (2) Convert String-based request values such as request parameters, path variables, headers, cookies, and others, to the target type of controller method arguments. (3) Format model object values as String values when rendering HTML forms.",
	"Components - Controllers - @RequestMapping - Arguments - @ModelAttribute - DataBinder - @InitBinder - arguments": "@InitBinder methods support many of the same arguments that a @RequestMapping methods do, except for @ModelAttribute (command object) arguments. Typically they’re are declared with a WebDataBinder argument, for registrations, and a void return value.",
	"Components - Controllers - @RequestMapping - Arguments - Errors, BindingResult": "",
	"Components - Controllers - @RequestMapping - Arguments - SessionStatus + class-level @SessionAttributes": "",
	"Components - Controllers - @RequestMapping - Arguments - UriComponentsBuilder": "",
	"Components - Controllers - @RequestMapping - Arguments - @SessionAttribute": "",
	"Components - Controllers - @RequestMapping - Arguments - @RequestAttribute": "",
	"Components - Controllers - @RequestMapping - Arguments - Any other argument": "",
	"Components - Controllers - @RequestMapping - Responses": "",
	"Components - Controllers - @RequestMapping - Responses - @ResponseBody": "writes directly to the response body",
	"Components - Controllers - @RequestMapping - Responses - HttpEntity<B>, ResponseEntity<B>": "Returning the ResponseEntity gives you more control over how the HTTP Response is generated, especially when it comes to HTTP status codes and other headers.",
	"Components - Controllers - @RequestMapping - Responses - HttpHeaders": "",
	"Components - Controllers - @RequestMapping - Responses - String": "",
	"Components - Controllers - @RequestMapping - Responses - View": "",
	"Components - Controllers - @RequestMapping - Responses - java.util.Map, org.springframework.ui.Model": "",
	"Components - Controllers - @RequestMapping - Responses - @ModelAttribute": "",
	"Components - Controllers - @RequestMapping - Responses - ModelAndView": "",
	"Components - Controllers - @RequestMapping - Responses - void": "",
	"Components - Controllers - @RequestMapping - Responses - Callable<V> (async)": "Returning Callable implies that Spring MVC will invoke the task defined in the Callable in a different thread. Spring will manage this thread by using a TaskExecutor. Before waiting for the long task to finish, the servlet thread will be released.",
	"Components - Controllers - @RequestMapping - Responses - DeferredResult<V> (async)": "DeferredResult provides an alternative to using a Callable for asynchronous request processing. While a Callable is executed concurrently in a thread managed by the application, with a DeferredResult the application can produce the result from a thread of its choice.",
	"Components - Controllers - @RequestMapping - Responses - ListenableFuture<V>, java.util.concurrent.CompletionStage<V>, java.util.concurrent.CompletableFuture<V>": "Per the Future interface contract, which ListenableFuture implements, get() returns the result of the Future, and thusly must block until necessary computations are complete.",
	"Components - Controllers - @RequestMapping - Responses - ResponseBodyEmitter (streaming)": "The ResponseBodyEmitter return value can be used to produce a stream of Objects, where each Object sent is serialized with an HttpMessageConverter and written to the response. ResponseBodyEmitter can also be used as the body in a ResponseEntity allowing you to customize the status and headers of the response.",
	"Components - Controllers - @RequestMapping - Responses - SseEmitter (streaming)": "SseEmitter is a sub-class of ResponseBodyEmitter that provides support for Server-Sent Events where events sent from the server are formatted according to the W3C SSE specification",
	"Components - Controllers - @RequestMapping - Responses - StreamingResponseBody (streaming)": "Sometimes it is useful to bypass message conversion and stream directly to the response OutputStream for example for a file download. Use the of the StreamingResponseBody return value type to do that.",
	"Components - Controllers - @RequestMapping - Responses - Reactive types, Reactor, RxJava, or others via ReactiveAdapterRegistry": "",
	"Components - Controllers - @RequestMapping - Responses - Other": "",
	"Components - Controllers - ExceptionHandling - @ExceptionHandler": "",
	"Components - Controllers - ExceptionHandling - @ControllerAdvice": "On startup, the infrastructure classes for @RequestMapping and @ExceptionHandler methods detect Spring beans of type @ControllerAdvice, and then apply their methods at runtime. Global @ExceptionHandler methods (from an @ControllerAdvice) are applied after local ones (from the @Controller). By contrast global @ModelAttribute and @InitBinder methods are applied before local ones.",
	"Components - Controllers - ExceptionHandling - @RestControllerAdvice": "@ControllerAdvice + @ResponseBody, allowing you to handle exceptions globally in a Spring MVC application and return the response directly in the response body (typically as JSON/XML).",
	"Components - Controllers - ExceptionHandling - @RestControllerAdvice - GlobalExceptionHandling": "It's commonly used for centralized exception handling in RESTful APIs. Catch exceptions thrown by any controller.",
	"Components - Controllers - ExceptionHandling - @RestControllerAdvice - Scope": "Flexible Scope – Can be applied globally or restricted to specific packages/controllers.",
	"Components - Controllers - ExceptionHandling - @RestControllerAdvice - Response": "Response Body Conversion – Automatically serializes responses (thanks to @ResponseBody).",
	"Components - Controllers - ExceptionHandling - @RestControllerAdvice - CustomErrorResponses": "Can be applied globally or restricted to specific packages/controllers.",

	"Beans - Filters + Interceptors + Validators + Mappers + Resolvers": "SECTION",
	"Beans - Filters": "The spring-web module provides some useful filters: HTTP PUT Form, Forwarded Headers, Shallow ETag",
	"Beans - Filters - GenericFilterBean": "Simple base implementation of Filter which treats its config parameters (init-param entries within the filter tag in web.xml) as bean properties.",
	"Beans - Filters - GenericFilterBean - methods": "This filter leaves actual filtering to subclasses, which have to implement the Filter.doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain) method.",
	"Beans - Filters - GenericFilterBean - methods - @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { ... }": "",
	"Beans - Filters - GenericFilterBean - DI": "You cannot use dependency injection inside a filter out of the box. Although you are using GenericFilterBean your Servlet Filter is not managed by spring. We cannot expect spring to inject the service, but we can lazy set it on the first call webApplicationContext.getBean(MyServices.class). ",
	"Beans - Filters - GenericFilterBean - OncePerRequestFilter": "Filter base class that aims to guarantee a single execution per request dispatch, on any servlet container. It provides a doFilterInternal(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, javax.servlet.FilterChain) method with HttpServletRequest and HttpServletResponse arguments.",
	"Beans - Filters - GenericFilterBean - CommonsRequestLoggingFilter": "Simple request logging filter that writes the request URI (and optionally the query string) to the Commons Log.",
	"Beans - Filters - GenericFilterBean - CharacterEncodingFilter": "Servlet Filter that allows one to specify a character encoding for requests. This is useful because current browsers typically do not set a character encoding even if specified in the HTML page or form. This filter can either apply its encoding if the request does not already specify an encoding, or enforce this filter's encoding in any case ('forceEncoding'='true'). In the latter case, the encoding will also be applied as default response encoding (although this will usually be overridden by a full content type set in the view).",
	"Beans - Filters - GenericFilterBean - CompositeFilter": "A generic composite servlet Filter that just delegates its behavior to a chain (list) of user-supplied filters, achieving the functionality of a FilterChain, but conveniently using only Filter instances. This is useful for filters that require dependency injection, and can therefore be set up in a Spring application context. Typically, this composite would be used in conjunction with DelegatingFilterProxy, so that it can be declared in Spring but applied to a servlet context.",
	"Beans - Filters - GenericFilterBean - DelegatingFilterProxy": "Proxy for a standard Servlet Filter, delegating to a Spring-managed bean that implements the Filter interface.",
	"Beans - Filters - GenericFilterBean - HiddenHttpMethodFilter": "Filter that converts posted method parameters into HTTP methods, retrievable via HttpServletRequest.getMethod(). Since browsers currently only support GET and POST, a common technique - used by the Prototype library, for instance - is to use a normal POST with an additional hidden form field (_method) to pass the real HTTP method along. This filter reads that parameter and changes the HttpServletRequestWrapper.getMethod() return value accordingly. Only PUT, DELETE and PATCH HTTP methods are allowed.",
	"Beans - Filters - GenericFilterBean - ServletContextRequestLoggingFilter": "Simple request logging filter that writes the request URI (and optionally the query string) to the ServletContext log.",
	"Beans - Filters - GenericFilterBean - HttpPutFormContentFilter": "Browsers can only submit form data via HTTP GET or HTTP POST but non-browser clients can also use HTTP PUT and PATCH. The Servlet API requires ServletRequest.getParameter*() methods to support form field access only for HTTP POST. The spring-web module provides HttpPutFormContentFilter that intercepts HTTP PUT and PATCH requests with content type application/x-www-form-urlencoded, reads the form data from the body of the request, and wraps the ServletRequest in order to make the form data available through the ServletRequest.getParameter*() family of methods.",
	"Beans - Filters - GenericFilterBean - ForwardedHeaderFilter": "As a request goes through proxies such as load balancers the host, port, and scheme may change presenting a challenge for applications that need to create links to resources since the links should reflect the host, port, and scheme of the original request as seen from a client perspective. RFC 7239 defines the 'Forwarded' HTTP header for proxies to use to provide information about the original request. There are also other non-standard headers in use such as 'X-Forwarded-Host', 'X-Forwarded-Port', and 'X-Forwarded-Proto'. ForwardedHeaderFilter detects, extracts, and uses information from the 'Forwarded' header, or from 'X-Forwarded-Host', 'X-Forwarded-Port', and 'X-Forwarded-Proto'. It wraps the request in order to overlay its host, port, and scheme and also 'hides' the forwarded headers for subsequent processing. Note that there are security considerations when using forwarded headers as explained in Section 8 of RFC 7239. At the application level it is difficult to determine whether forwarded headers can be trusted or not. This is why the network upstream should be configured correctly to filter out untrusted forwarded headers from the outside. Applications that don’t have a proxy and don’t need to use forwarded headers can configure the ForwardedHeaderFilter to remove and ignore such headers.",
	"Beans - Filters - GenericFilterBean - ShallowEtagHeaderFilter": "The ShallowEtagHeaderFilter filter creates a 'shallow' ETag by caching the content written to the response, and computing an MD5 hash from it. The next time a client sends, it does the same, but also compares the computed value against the If-None-Match request header and if the two are equal, it returns a 304 (NOT_MODIFIED). This strategy saves network bandwidth but not CPU, as the full response must be computed for each request. Other strategies at the controller level, described above, can avoid the computation. See HTTP Caching. This filter has a writeWeakETag parameter that configures the filter to write Weak ETags, like this: W/'02a2d595e6ed9a0b24f027f2b63b134d6', as defined in RFC 7232 Section 2.3.",
	"Beans - Filters - GenericFilterBean - CorsFilter": "Spring MVC provides fine-grained support for CORS configuration through annotations on controllers. However when used with Spring Security it is advisable to rely on the built-in CorsFilter that must be ordered ahead of Spring Security’s chain of filters. See the section on CORS and the CORS Filter for more details.",
	"Beans - Interceptors": "Add Spring MVC lifecycle interceptors for pre- and post-processing of controller method invocations.",
	"Beans - Interceptors - programmatically": "@Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor( ... ), } }.",
	"Beans - Interceptors - configuration": "< mvc:interceptors >< bean class='org.springframework.web.servlet.i18n.LocaleChangeInterceptor'/ >< mvc:interceptor > ... < /mvc:interceptor > < /mvc:interceptors >",
	"Beans - Interceptors - HandlerInterceptor": "All HandlerMapping implementations supports handler interceptors that are useful for pre- and post-processing when you want to apply specific functionality to certain requests, (e.g. checking for a principal,  logging, changing globally used parameters in Spring model, etc)",
	"Beans - Interceptors - HandlerInterceptor - methods": "Interceptors must implement HandlerInterceptor from the org.springframework.web.servlet package with three methods that should provide enough flexibility to do all kinds of pre-processing and post-processing: preHandle, postHandle, afterCompletion",
	"Beans - Interceptors - HandlerInterceptor - methods - preHandle": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {... } Called before the actual handler is executed, but the view is not generated yet. Notice the method returns a boolean value – which tells Spring if the request should be further processed by a handler (true) or not (false). (e.g. log information about the requests’ parameters, setting timers to check handling time of the requests, checking if a user is logged in, )",
	"Beans - Interceptors - HandlerInterceptor - methods - postHandle": "public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { ... } This method is called immediately after the request is processed by HandlerAdapter, but before generating a view (e.g. add additional attributes to the ModelAndView as an avatar or to determine the time taken by handler method to process a client’s request).",
	"Beans - Interceptors - HandlerInterceptor - methods - afterCompletion": "public void afterCompletion(HttpServletRequest request,  HttpServletResponse response, Object handler, Exception ex) { ... } Called after the complete request has finished and view was generated (e.g. gather additional statistics, obtain request and response data, as well as information about exceptions)",
	"Beans - Interceptors - Adapters - HandlerAdapter": "Implement the interceptors to help the DispatcherServlet to invoke a handler mapped to a request regardless of how the handler is actually invoked (e.g. invoking an annotated controller requires resolving annotations).",
	"Beans - Interceptors - Adapters - HandlerAdapter - HandlerInterceptorAdapter": "The main difference between HandlerInterceptor and HandlerInterceptorAdapter is that in the first one we need to override all three methods: preHandle(), postHandle() and afterCompletion(), whereas in the second we may implement only required methods.",
	"Beans - Interceptors - Adapters - HandlerAdapter - SimpleControllerHandlerAdapter": "This is the default handler adapter registered by Spring MVC. It deals with classes implementing Controller interface and is used to forward a request to a controller object. If a web application uses only controllers then we don’t need to configure any HandlerAdapter as the framework uses this class as the default adapter for handling a request.",
	"Beans - Interceptors - Adapters - HandlerAdapter - SimpleServletHandlerAdapter": "This handler adapter allows the use of any Servlet to work with DispatcherServlet for handling the request. It forwards the request from DispatcherServlet to the appropriate Servlet class by calling its service() method. The beans which implement the Servlet interface are automatically handled by this adapter. It is not registered by default and we need to register it like any other normal bean in the configuration file of DispatcherServlet:",
	"Beans - Interceptors - Adapters - HandlerAdapter - AnnotationMethodHandlerAdapter": "This adapter class is used to execute the methods that are annotated with @RequestMapping annotation. It is used to map the methods based on HTTP methods and HTTP paths. The mapping class for this adapter is DefaultAnnotationHandlerMapping, which is used to process the @RequestMapping annotation at the type level and AnnotationMethodHandlerAdaptor is used to process at a method level.",
	"Beans - Interceptors - Adapters - HandlerAdapter - RequestMappingHandlerAdapter": "This adapter class was introduced in Spring 3.1, deprecating the AnnotationMethodHandlerAdaptor handler adapter in Spring 3.2. It’s used with RequestMappingHandlerMapping class, which executes methods annotated with @RequestMapping. The RequestMappingHandlerMapping is used to maintain the mapping of the request URI to the handler. Once the handler is obtained, the DispatcherServlet dispatches the request to the appropriate handler adapter, which then invokes the handlerMethod().",
	"Beans - Interceptors - Adapters - HandlerAdapter - HttpRequestHandlerAdapter": "This handler adapter is used for the handlers that process HttpRequests. It implements the HttpRequestHandler interface, which contains a single handleRequest() method for processing the request and generating the response. The return type of this method is void and it doesn’t generate ModelAndView return type as produced by other handler adapters. It’s basically used to generate binary responses and it doesn’t generate a view to render.",
	"Beans - Interceptors vs Filters": "HandlerInterceptor is basically similar to a Servlet Filter, but in contrast to the latter it just allows custom pre-processing with the option of prohibiting the execution of the handler itself, and custom post-processing. Filters are more powerful, for example they allow for exchanging the request and response objects that are handed down the chain. Note that a filter gets configured in web.xml, a HandlerInterceptor in the application context. As a basic guideline, fine-grained handler-related preprocessing tasks are candidates for HandlerInterceptor implementations, especially factored-out common handler code and authorization checks. On the other hand, a Filter is well-suited for request content and view content handling, like multipart forms and GZIP compression. This typically shows when one needs to map the filter to certain content types (e.g. images), or to all requests.",
	"Beans - Validators": "By default if Bean Validation is present on the classpath, e.g. Hibernate Validator, the LocalValidatorFactoryBean is registered as a global Validator for use with @Valid and Validated on controller method arguments. Use A CUSTOM WITH getValidator(). iN xml < mvc:annotation-driven validator='globalValidator'/ >",
	"Beans - Validators - Binder": "@InitBinder protected void initBinder(WebDataBinder binder) {        binder.addValidators(new FooValidator()),    }",
	"Beans - Mappers - HandlerMapping": "Map a request to a handler, so that the DispatcherServlet will be able to invoke it when processing a request.",
	"Beans - Mappers - HandlerMapping - implementation": "The mapping is based on some criteria the details of which vary by HandlerMapping implementation: RequestMappingHandlerMapping, SimpleUrlHandlerMapping, BeanNameUrlHandlerMapping",
	"Beans - Mappers - HandlerMapping - implementation - DefaultAnnotationHandlerMapping (Deprecated in Spring 3.2 in favor of RequestMappingHandlerMapping)": "Implementation of the HandlerMapping interface that maps handlers based on HTTP paths expressed through the RequestMapping annotation at the type or method level.",
	"Beans - Mappers - HandlerMapping - implementation - RequestMappingHandlerMapping": "RequestMappingHandlerMapping which supports @RequestMapping annotated methods",
	"Beans - Mappers - HandlerMapping - implementation - BeanNameUrlHandlerMapping": "maps incoming HTTP requests to names of beans, defined in the web application context",
	"Beans - Mappers - HandlerMapping - implementation - SimpleUrlHandlerMapping": "maintains explicit registrations of URI path patterns to handlers to map from URLs to request handler beans",
	"Beans - Resolvers - MultipartResolver": "Abstraction for parsing a multi-part request (e.g. browser form file upload) with the help of some multipart parsing library.",
	"Beans - Resolvers - ThemeResolver": "Resolve themes your web application can use, for example, to offer personalized layouts.",
	"Beans - Resolvers - ThemeResolver - FixedThemeResolver": "Selects a fixed theme, set using the defaultThemeName property.",
	"Beans - Resolvers - ThemeResolver - SessionThemeResolver": "The theme is maintained in the user's HTTP session. It only needs to be set once for each session, but is not persisted between sessions.",
	"Beans - Resolvers - ThemeResolver - CookieThemeResolver": "The selected theme is stored in a cookie on the user-agent's machine.",
	"Beans - Resolvers - FlashMapManager": "Store and retrieve the 'input' and the 'output' FlashMap that can be used to pass attributes from one request to another, usually across a redirect.",
	"Beans - Resolvers - LocaleResolver": "Resolve the Locale a client is using and possibly their time zone, in order to be able to offer internationalized views.",
	"Beans - Resolvers - LocaleResolver - AcceptHeaderLocaleResolver": "LocaleResolver implementation that simply uses the primary locale specified in the 'accept-language' header of the HTTP request (that is, the locale sent by the client browser, normally that of the client's OS).",
	"Beans - Resolvers - LocaleResolver - LocaleContextResolver": "Extension of LocaleResolver, adding support for a rich locale context (potentially including locale and time zone information).",
	"Beans - Resolvers - LocaleResolver - CookieLocaleResolver": "LocaleResolver implementation that uses a cookie sent back to the user in case of a custom setting, with a fallback to the specified default locale or the request's accept-header locale. This is particularly useful for stateless applications without user sessions. The cookie may optionally contain an associated time zone value as well, alternatively, you may specify a default time zone.",
	"Beans - Resolvers - LocaleResolver - SessionLocaleResolver": "LocaleResolver implementation that uses a locale attribute in the user's session in case of a custom setting, with a fallback to the specified default locale or the request's accept-header locale.",
	"Beans - Resolvers - LocaleResolver - LocaleChangeInterceptor": "It will detect a parameter in the request and change the locale. It calls setLocale() on the LocaleResolver that also exists in the context.",
	"Beans - Resolvers - ViewResolvers": "Resolve logical String-based view names returned from a handler to an actual View to render to the response with. enable you to render models in a browser without tying you to a specific view technology. ViewResolver provides a mapping between view names and actual views. View addresses the preparation of data before handing over to a specific view technology.",
	"Beans - Resolvers - ViewResolvers - Configuration": "Configure view resolvers to translate String-based view names returned from controllers into concrete View implementations to perform rendering with. @Override public void configureViewResolvers(ViewResolverRegistry registry) {         registry.enableContentNegotiation(new MappingJackson2JsonView()),         registry.jsp(),    }. In XML",
	"Beans - Resolvers - ViewResolvers - Contract": "The contract of a ViewResolver specifies that it can return null to indicate the view could not be found. However in the case of JSPs, and InternalResourceViewResolver, the only way to figure out if a JSP exists is to perform a dispatch through RequestDispatcher. Therefore an InternalResourceViewResolver must always be configured to be last in the overall order of view resolvers..",
	"Beans - Resolvers - ViewResolvers - Chain of Resolvers": "You chain view resolvers by declaring more than one resolver beans and, if necessary, by setting the order property to specify ordering. Remember, the higher the order property, the later the view resolver is positioned in the chain.",
	"Beans - Resolvers - ViewResolvers - Forwarding": "It is also possible to use a special forward: prefix for view names that are ultimately resolved by UrlBasedViewResolver and subclasses. This creates an InternalResourceView which does a RequestDispatcher.forward(). Therefore, this prefix is not useful with InternalResourceViewResolver and InternalResourceView (for JSPs) but it can be helpful if using another view technology, but still want to force a forward of a resource to be handled by the Servlet/JSP engine. Note that you may also chain multiple view resolvers, instead.",
	"Beans - Resolvers - ViewResolvers - Redirecting": "The special redirect: prefix in a view name allows you to perform a redirect. The UrlBasedViewResolver (and sub-classes) recognize this as an instruction that a redirect is needed. The rest of the view name is the redirect URL. The net effect is the same as if the controller had returned a RedirectView, but now the controller itself can simply operate in terms of logical view names. A logical view name such as redirect:/myapp/some/resource will redirect relative to the current Servlet context, while a name such as redirect:http://myhost.com/some/arbitrary/path will redirect to an absolute URL. Note that if a controller method is annotated with the @ResponseStatus, the annotation value takes precedence over the response status set by RedirectView.",
	"Beans - Resolvers - ViewResolver": "The table below provides more details on the ViewResolver hierarchy: AbstractCachingViewResolver, XmlViewResolver, ResourceBundleViewResolver, UrlBasedViewResolver, InternalResourceViewResolver, FreeMarkerViewResolver, FreeMarkerViewResolver, ContentNegotiatingViewResolver",
	"Beans - Resolvers - ViewResolver - AbstractCachingViewResolver": "Sub-classes of AbstractCachingViewResolver cache view instances that they resolve. Caching improves performance of certain view technologies. It’s possible to turn off the cache by setting the cache property to false. Furthermore, if you must refresh a certain view at runtime (for example when a FreeMarker template is modified), you can use the removeFromCache(String viewName, Locale loc) method.",
	"Beans - Resolvers - ViewResolver - XmlViewResolver": "Implementation of ViewResolver that accepts a configuration file written in XML with the same DTD as Spring’s XML bean factories. The default configuration file is /WEB-INF/views.xml.",
	"Beans - Resolvers - ViewResolver - ResourceBundleViewResolver": "Implementation of ViewResolver that uses bean definitions in a ResourceBundle, specified by the bundle base name, and for each view it is supposed to resolve, it uses the value of the property [viewname].(class) as the view class and the value of the property [viewname].url as the view url. Examples can be found in the chapter on View Technologies.",
	"Beans - Resolvers - ViewResolver - UrlBasedViewResolver": "Simple implementation of the ViewResolver interface that effects the direct resolution of logical view names to URLs, without an explicit mapping definition. This is appropriate if your logical names match the names of your view resources in a straightforward manner, without the need for arbitrary mappings.",
	"Beans - Resolvers - ViewResolver - InternalResourceViewResolver": "Convenient subclass of UrlBasedViewResolver that supports InternalResourceView (in effect, Servlets and JSPs) and subclasses such as JstlView and TilesView. You can specify the view class for all views generated by this resolver by using setViewClass(..). See the UrlBasedViewResolver javadocs for details.",
	"Beans - Resolvers - ViewResolver - FreeMarkerViewResolver": "Convenient subclass of UrlBasedViewResolver that supports FreeMarkerView and custom subclasses of them.",
	"Beans - Resolvers - ViewResolver - ContentNegotiatingViewResolver": "Implementation of the ViewResolver interface that resolves a view based on the request file name or Accept header. See Content negotiation. ContentNegotiatingViewResolver does not resolve views itself but rather delegates to other view resolvers, and selects the view that resembles the representation requested by the client. The representation can be determined from the Accept header or from a query parameter, e.g. '/path?format=pdf'. The ContentNegotiatingViewResolver selects an appropriate View to handle the request by comparing the request media type(s) with the media type (also known as Content-Type) supported by the View associated with each of its ViewResolvers. The first View in the list that has a compatible Content-Type returns the representation to the client. If a compatible view cannot be supplied by the ViewResolver chain, then the list of views specified through the DefaultViews property will be consulted. This latter option is appropriate for singleton Views that can render an appropriate representation of the current resource regardless of the logical view name. The Accept header may include wild cards, for example text/*, in which case a View whose Content-Type was text/xml is a compatible match.",
	"Beans - Resolvers - ViewResolver - Templates": "",
	"Beans - Resolvers - ViewResolver - Templates - Thymeleaf": "",
	"Beans - Resolvers - ViewResolver - Templates - FreeMarker": "",
	"Beans - Resolvers - ViewResolver - Templates - Groovy Markup": "",
	"Beans - Resolvers - ViewResolver - Templates - Script Views": "",
	"Beans - Resolvers - ViewResolver - Templates - JSP & JSTL": "",
	"Beans - Resolvers - ViewResolver - Templates - Tiles": "",
	"Beans - Resolvers - ViewResolver - Templates - RSS, Atom": "",
	"Beans - Resolvers - ViewResolver - Templates - PDF, Excel": "",
	"Beans - Resolvers - ViewResolver - Templates - Jackson": "",
	"Beans - Resolvers - ViewResolver - Templates - XML": "",
	"Beans - Resolvers - ViewResolver - Templates - XSLT": "",
	"Beans - Resolvers - HandlerExceptionResolver - SimpleMappingExceptionResolver": "A mapping between exception class names and error view names. Useful for rendering error pages in a browser application.",
	"Beans - Resolvers - HandlerExceptionResolver - DefaultHandlerExceptionResolver": "Resolves exceptions raised by Spring MVC and maps them to HTTP status codes. Also see alternative ResponseEntityExceptionHandler and REST API exceptions.",
	"Beans - Resolvers - HandlerExceptionResolver - ResponseStatusExceptionResolver": "Resolves exceptions with the @ResponseStatus annotation and maps them to HTTP status codes based on the value in the annotation.",
	"Beans - Resolvers - HandlerExceptionResolver - ExceptionHandlerExceptionResolver": "Resolves exceptions by invoking an @ExceptionHandler method in an @Controller or an @ControllerAdvice class.",
	"Beans - Resolvers - HandlerExceptionResolver - uncatched": "If an exception remains unresolved by any HandlerExceptionResolver and is therefore left to propagate, or if the response status is set to an error status (i.e. 4xx, 5xx), Servlet containers may render a default error page in HTML. To customize the default error page of the container, you can declare an error page mapping in web.xml: < error-page >< location >/error< /location>< /error-page >",
	"Beans - Formatters Components": "Use addFormatters(FormatterRegistry registry). By default formatters for Number and Date types are installed, including support for the @NumberFormat and @DateTimeFormat Spring Core annotations. In XML < mvc:annotation-driven conversion-service='conversionService'/ > < bean id='conversionService' class='org.springframework.format.support.FormattingConversionServiceFactoryBean' >",
	"Beans - MessageConverters Components": "Customization of HttpMessageConverter can be achieved in Java config by overriding configureMessageConverters() if you want to replace the default converters created by Spring Core, or by overriding extendMessageConverters() if you just want to customize them or add additional converters to the default ones. In XML < mvc:annotation-driven >< mvc:message-converters > ... < /mvc:message-converters >< /mvc:annotation-driven >",
	"Beans - ResourceHandlers": "Add handlers to serve static resources such as images, js, and, css files from specific locations under web application root, the classpath, and others. @Override public void addResourceHandlers(ResourceHandlerRegistry registry) {         registry.addResourceHandler('/resources/**')             .addResourceLocations('/public', 'classpath:/static/')             .setCachePeriod(31556926),     }. Add < mvc:resources mapping='/resources/**' location='/public, classpath:/static/' cache-period='31556926 / >",
	"Beans - HandlerExceptionResolvers Beans": "Configure exception resolvers. Extending or modify the list of exception resolvers configured by default. extendHandlerExceptionResolvers(java.util.List<HandlerExceptionResolver> resolvers)",
	"Beans - HandlerExceptionResolvers Beans ": "Strategy to resolve exceptions possibly mapping them to handlers, or to HTML error views, or other. If an exception occurs during request mapping or is thrown from a request handler such as an @Controller, the DispatcherServlet delegates to a chain of HandlerExceptionResolver beans to resolve the exception and provide alternative handling, which typically is an error response. The table below lists the available HandlerExceptionResolver implementations: SimpleMappingExceptionResolver, DefaultHandlerExceptionResolver, ResponseStatusExceptionResolver, ExceptionHandlerExceptionResolver",
	"Beans - HandlerExceptionResolvers Beans - Contract": "The contract of HandlerExceptionResolver specifies that it can return: (1) ModelAndView that points to an error view. (2) Empty ModelAndView if the exception was handled within the resolver. (3) null if the exception remains unresolved, for subsequent resolvers to try, and if the exception remains at the end, it is allowed to bubble up to the Servlet container.",
	"Beans - HandlerExceptionResolvers Beans - Chain of Resolvers": "You can form an exception resolver chain simply by declaring multiple HandlerExceptionResolver beans in your Spring configuration and setting their order properties as needed. The higher the order property, the later the exception resolver is positioned.",

	"Clients": "SECTION",
	"REST Client - RestTemplate": "RestTemplate is the original Spring REST client that follows a similar approach to other template classes in the Spring Framework (e.g. JdbcTemplate, JmsTemplate, etc.) by providing a list of parameterizable methods to perform HTTP requests. RestTemplate has a synchronous API and relies on blocking I/O. This is okay for client scenarios with low concurrency. In a server environment or when orchestrating a sequence of remote calls, prefer using the WebClient which provides a more efficient execution model including seamless support for streaming.",
	"REST Client - WebClient": "Spring WebFlux includes a reactive, non-blocking WebClient for HTTP requests. The client has a functional, fluent API with reactive types for declarative composition, see Reactive Libraries. WebFlux client and server rely on the same non-blocking codecs to encode and decode request and response content. Internally WebClient delegates to an HTTP client library. By default, it uses Reactor Netty, there is built-in support for the Jetty reactive HtpClient, and others can be plugged in through a ClientHttpConnector. WebClient is a reactive client that provides an alternative to the RestTemplate. It exposes a functional, fluent API and relies on non-blocking I/O which allows it to support high concurrency more efficiently (i.e. using a small number of threads) than the RestTemplate. WebClient is a natural fit for streaming scenarios."
}