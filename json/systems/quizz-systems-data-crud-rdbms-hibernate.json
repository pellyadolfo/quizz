{

	"Hibernate": "SECTION",
	"Hibernate ": "",

	"App": "SECTION",
	"App - Fetching ": "Fetching, essentially, is the process of grabbing data from the database and making it available to the application.",
	"App - Fetching - Strategies - Static": "Static definition of fetching strategies is done in the mappings. The statically-defined fetch strategies is used in the absence of any dynamically defined strategies.",
	"App - Fetching - Strategies - Static - @Fetch": "FetchType",
	"App - Fetching - Strategies - Static - @Fetch - Hibernate - FetchMode": "FetchMode defines how Hibernate will fetch the dat",
	"App - Fetching - Strategies - Static - @Fetch - Hibernate - FetchMode.SELECT": "Performs a separate SQL select to load the data. This is the strategy generally termed N+1.",
	"App - Fetching - Strategies - Static - @Fetch - Hibernate - FetchMode.SELECT - @BatchSize - Hibernate": "Hibernate will try to load the orders collection in batches defined by the size parameter. @BatchSize(size=10)",
	"App - Fetching - Strategies - Static - @Fetch - Hibernate - FetchMode.JOIN": "FetchMode.JOIN loads relations eagerly through the use of an SQL outer join.",
	"App - Fetching - Strategies - Static - @Fetch - Hibernate - FetchMode.BATCH": "Performs a separate SQL select to load a number of related data items using an IN-restriction as part of the SQL WHERE-clause based on a batch size.",
	"App - Fetching - Strategies - Static - @Fetch - Hibernate - FetchMode.SUBSELECT": "Performs a separate SQL select to load associated data based on the SQL restriction used to load the owner.",
	"App - Fetching - Strategies - Static - @Fetch - Hibernate - hibernate.jdbc.fetch_size": "Used to specify number of rows to be fetched in a select query.",
	"App - Fetching - Strategies - Dynamic": "Dynamic definition is really use-case centric. There are multiple ways to define dynamic fetching: fetch profiles, HQL/JPQL, entity graphs",
	"App - Fetching - Strategies - Dynamic - Hibernate - FetchProfile": "FetchProfiles are a powerful feature in Hibernate that allow you to define dynamic fetching strategies that can be activated at runtime, giving you more control over how associated entities and collections are loaded.",
	"App - Fetching - Strategies - Dynamic - Hibernate - FetchProfile - Definition": "Defined in entity mappings or programmatic.",
	"App - Fetching - Strategies - Dynamic - Hibernate - FetchProfile - Definition - mapping": "@FetchProfile(name = 'employee-with-department', ... )",
	"App - Fetching - Strategies - Dynamic - Hibernate - FetchProfile - Definition - programmatic": "FetchProfile profile = new FetchProfile('employee-with-address'); profile.addFetch(Employee.class, 'address');",
	"App - Fetching - Strategies - Dynamic - Hibernate - FetchProfile - Enable": "Can be enabled/disabled on the Session session.enableFetchProfile('employee-with-department');",
	"App - Fetching - Strategies - Dynamic - Querying - QueryGeneration": "",
	"App - Fetching - Strategies - Dynamic - Querying - QueryGeneration - Hibernate - @DynamicUpdate": "Modifies the Update statement to include only the changed columns instead of all fields.",
	"App - Fetching - Strategies - Dynamic - Querying - QueryGeneration - Hibernate - @DynamicInsert": "Modifies the INSERT statement to include only non-null columns instead of all fields.",
	"App - Fetching - Strategies - Dynamic - Querying - QueryGeneration - Hibernate - hibernate.order_inserts": "Modifies the INSERT statement to include only non-null columns instead of all fields.",
	"App - Fetching - Strategies - Dynamic - Querying - QueryGeneration - Hibernate - hibernate.jdbc.batch_size": "Used to specify number of inserts or updates to be carried out in a single database hit..",
	"App - Fetching - Strategies - Dynamic - Querying - QueryGeneration - Hibernate - org.hibernate.dialect": "Hibernate uses SQL dialects (org.hibernate.dialect) to: Adapt SQL syntax for different databases, Handle: Pagination (LIMIT vs ROWNUM vs FETCH), Locking syntax, Function names, Data types. Example dialects: MySQL8Dialect, PostgreSQL10Dialect, Oracle12cDialect",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems": "Hibernate generates SQL queries automatically based on your entity mappings and operations, but provides several ways to customize this behavior.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - Hibernate - SQLQueries": "",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - Hibernate - SQLQueries - @SQLInsert": " ",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - Hibernate - SQLQueries - @SQLUpdate": " ",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - Hibernate - SQLQueries - @SQLDelete": " ",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - Hibernate - HQLQueries": "HQL stands for Hibernate Query Language.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - Hibernate - HCQLQueries": "Hibernate Criteria Query Language (HCQL) lets you build queries using Java code.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - Hibernate - HCQLQueries - deprecated": "Hibernate offers a legacy org.hibernate.Criteria API. Eventually, Hibernate-specific criteria features will be ported as extensions to the JPA javax.persistence.criteria.CriteriaQuery",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - Hibernate - Config - hibernate.show_sql": "Controls whether Hibernate logs the SQL statements it executes.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - Hibernate - Config - hibernate.format_sql": "Formats the logged SQL to be more readable.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - Hibernate - Config - hibernate.use_sql_comments": "Adds informative comments to generated SQL.",
	"App - Caching - L1Cache": "In Hibernate, the first-level cache (L1 cache) is a session-level cache that is enabled by default and exists for the duration of a Hibernate Session.",
	"App - Caching - L1Cache - Features - Mandatory": "Automatic & Mandatory – Enabled by default; cannot be disabled.",
	"App - Caching - L1Cache - Features - NoConfig": "No Configuration Needed – Works out of the box.",
	"App - Caching - L1Cache - Lifecycle - Create": "When an entity is loaded via session.get(), session.load(), or queries, Hibernate stores it in the L1 cache.",
	"App - Caching - L1Cache - Lifecycle - Run": "Session-Scoped – Exists only while the Session is open. Once the session is closed, the cache is destroyed.",
	"App - Caching - L1Cache - Lifecycle - Delete": "Short-Lived – Cleared when session.evict(), session.clear(), or session.close() is called.",
	"App - Caching - L2Cache": "It is possible to configure a JVM-level (SessionFactory-level) or even a cluster cache on a class-by-class and collection-by-collection basis. Be aware that caches are not aware of changes made to the persistent store by other applications. They can, however, be configured to regularly expire cached data.",
	"App - Caching - L2Cache - @Cacheable - Hibernate - deprecated": "Hibernate-specific and now deprecated (replaced by JPA's @Cacheable). Use JPA's @Cacheable. Earlier versions of Hibernate used this before JPA standardized caching.",
	"App - Caching - L2Cache - CacheableObjects - Entity": "Hibernate stores cached entities in a dehydrated form, which is similar to the database representation. Aside from the foreign key column values of the @ManyToOne or @OneToOne child-side associations, entity relationships are not stored in the cache,",
	"App - Caching - L2Cache - CacheableObjects - Collection": "Hibernate can also cache collections, and the @Cache annotation must be on added to the collection property. If the collection is made of value types (basic or embeddables mapped with @ElementCollection), the collection is stored as such. If the collection contains other entities (@OneToMany or @ManyToMany), the collection cache entry will store the entity identifiers only.",
	"App - Caching - L2Cache - CacheableObjects - Query": "Hibernate offers a query cache, useful for frequently executed queries with fixed parameter values. Caching of query results introduces some overhead. Disabled by default.",
	"App - Caching - L2Cache - CacheManagement - Hibernate": "Hibernate defined the CacheMode enumeration: CacheMode.NORMAL, CacheMode.REFRESH, CacheMode.PUT, CacheMode.GET, CacheMode.IGNORE",
	"App - Caching - L2Cache - CacheManagement - Hibernate - CacheMode.NORMAL": "Default. Reads/writes data from/into the cache",
	"App - Caching - L2Cache - CacheManagement - Hibernate - CacheMode.REFRESH": "Doesn’t read from cache, but writes to the cache upon loading from the database",
	"App - Caching - L2Cache - CacheManagement - Hibernate - CacheMode.PUT": "Doesn’t read from cache, but writes to the cache as it reads from the database",
	"App - Caching - L2Cache - CacheManagement - Hibernate - CacheMode.GET": "Read from the cache, but doesn’t write to cache",
	"App - Caching - L2Cache - CacheManagement - Hibernate - CacheMode.IGNORE": "Doesn’t read/write data from/into the cache",
	"App - Caching - L2Cache - CacheConcurrencyStrategy - Hibernate": "The @Cache annotation is used to specify the CacheConcurrencyStrategy of a root entity or a collection. The @Cache annotation define three attributes: usage (Defines the CacheConcurrencyStrategy), region (Defines a cache region where entries will be stored), include (If lazy properties should be included in the second level cache. The default value is all so lazy properties are cacheable. The other possible value is non-lazy so lazy properties are not cacheable).",
	"App - Caching - L2Cache - CacheConcurrencyStrategy - Hibernate - @Cache": "The @Cache annotation is used to specify the CacheConcurrencyStrategy of a root entity or a collection.",
	"App - Caching - L2Cache - CacheConcurrencyStrategy - Hibernate - @Cache - attr - usage": "Defines the CacheConcurrencyStrategy.",
	"App - Caching - L2Cache - CacheConcurrencyStrategy - Hibernate - @Cache - attr - region": "Defines a cache region where entries will be stored.",
	"App - Caching - L2Cache - CacheConcurrencyStrategy - Hibernate - @Cache - attr - include": "If lazy properties should be included in the second level cache.",
	"App - Caching - L2Cache - CacheConcurrencyStrategy - Hibernate - @Cache - values - NONE": "Indicates that no concurrency strategy is specified, and that a default strategy should be used.",
	"App - Caching - L2Cache - CacheConcurrencyStrategy - Hibernate - @Cache - values - NONSTRICT_READ_WRITE": "Read/write access to the shared second-level cache with no locking.",
	"App - Caching - L2Cache - CacheConcurrencyStrategy - Hibernate - @Cache - values - READ_ONLY": "Read-only access to the shared second-level cache.",
	"App - Caching - L2Cache - CacheConcurrencyStrategy - Hibernate - @Cache - values - READ_WRITE": "Read/write access to the shared second-level cache using soft locks.",
	"App - Caching - L2Cache - CacheConcurrencyStrategy - Hibernate - @Cache - values - TRANSACTIONAL": "Transactional access to the shared second-level cache.",
	"App - Caching - L2Cache - Statistics": "If you enable the hibernate.generate_statistics configuration property, Hibernate will expose a number of metrics via SessionFactory.getStatistics(). Hibernate can even be configured to expose these statistics via JMX. This way, you can get access to the Statistics class which comprises all sort of second-level cache metrics.",
	"App - Caching - L2Cache - RegionFactory": "org.hibernate.cache.spi.RegionFactory defines the integration between Hibernate and a pluggable caching provider. hibernate.cache.region.factory_class is used to declare the provider to use.",
	"App - Caching - L2Cache - RegionFactory - hibernate.cache.region.factory_class": "hibernate.cache.region.factory_class is used to declare the provider to use.",
	"App - Caching - L2Cache - RegionFactory - Tools:": "Hibernate comes with built-in support for the Java caching standard JCache and also two popular caching libraries: Ehcache and Infinispan.",
	"App - Caching - L2Cache - RegionFactory - Tools - JCache:": "",
	"App - Caching - L2Cache - RegionFactory - Tools - Ehcache:": "",
	"App - Caching - L2Cache - RegionFactory - Tools - Infinispan:": "",
	"App - Performance": "Tuning how an application does fetching is one of the biggest factors in determining how an application will perform. Fetching too much data, in terms of width (values/columns) and/or depth (results/rows), adds unnecessary overhead in terms of both JDBC communication and ResultSet processing. Fetching too little data might cause additional fetching to be needed. Tuning how an application fetches data presents a great opportunity to influence the application overall performance.",
	"App - Performance - N+1": "The N+1 problem is a common performance issue in Hibernate (and other ORMs) where the framework executes many more SQL queries than necessary to fetch associated entities. (1) Execute 1 query to get N entities (the '1' in N+1) (2) Then Hibernate executes N additional queries (the 'N' in N+1) to fetch associated entities for each of the original N entities",
	"App - Performance - N+1 - Solutions - JOIN FETCH": "Eager Fetching with JOIN FETCH List<Author> authors = session.createQuery('SELECT a FROM Author a JOIN FETCH a.books', Author.class).list(); This generates a single SQL query with a JOIN.",
	"App - Performance - N+1 - Solutions - JOIN FETCH - drawback": "JOIN FETCH can lead to Cartesian product explosions with multiple collections.",
	"App - Performance - N+1 - Solutions - @BatchSize": "Configuring Hibernate to load collections in batches. This fetches associations in batches rather than one-by-one.: @BatchSize(size = 10) private Set<Book> books; ",
	"App - Performance - N+1 - Solutions - @BatchSize - drawback": "Batch fetching still involves multiple queries, albeit fewer than the pure N+1 scenario.",
	"App - Performance - N+1 - Solutions - FetchMode.SUBSELECT": "This executes a second query that fetches all collections at once: @Fetch(FetchMode.SUBSELECT) private Set<Book> books;. FetchMode.SUBSELECT is useful as it solves the N+1 query¹ issue of FetchMode.SELECT. But FetchMode.SUBSELECT leads to increased memory usage.",
	"App - Performance - N+1 - Solutions - DTOProjections": "Instead of fetching entire entity graphs, select only the data you need. Use DTO projections when you only need a subset of data",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - SpringBoot3.5": "This feature intelligently analyzes your application’s data access patterns at runtime and automatically optimizes fetching strategies based on observed behavior.",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - BasedOn - DynamicQueryRewriting": "When Spring Boot 3.5 detects potential N+1 scenarios, it dynamically rewrites subsequent queries into efficient batch queries. This happens transparently without requiring developer intervention. For instance, if your code first loads all orders and then accesses their line items, Spring Boot’s enhanced EntityManager intercepts the individual line item access operations and consolidates them into a single optimized query.",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - BasedOn - PredictiveDataLoading": "@EnablePredictiveEntityLoading Spring Boot 3.5 introduces a learning algorithm that analyzes access patterns across requests. After observing that a particular entity relationship is consistently accessed together, it begins preemptively loading the related entities in an optimal way. With this configuration, Spring Boot automatically adapts to your application’s specific data access needs, optimizing queries based on real usage patterns rather than static configuration.",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - BasedOn - TransparentCachingLayer": "@EnableJpaRepositories(enableRelationshipCache = true) The framework now includes a transparent second-level cache specifically designed to eliminate redundant N+1 queries. This cache is context-aware and understands entity relationships, ensuring that related entities are stored and retrieved together. What makes this solution particularly powerful is how little developer intervention it requires. In many cases, it “just works” without additional configuration.",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - Steps - QueryPlanAnalysis": "The enhanced JPA implementation analyzes SQL query plans before execution. When it detects patterns indicative of N+1 scenarios, it intercepts and optimizes the execution plan.",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - Steps - BytecodeEnhancement": "@EnableEnhancedJpaEntities For maximum performance, Spring Boot now offers enhanced bytecode instrumentation that makes relationship traversal operations more efficient:",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - Steps - AdaptiveRepositoryImplementation": "Spring Data repositories now leverage this enhanced infrastructure automatically. The standard repository methods are implemented with awareness of relationship loading patterns:",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - Adoption": "spring.jpa.properties.hibernate.batch_fetch_style=DYNAMIC - spring.jpa.properties.hibernate.query.optimizer.enabled=true - spring.jpa.properties.hibernate.query.relation_aware_loading=true",

	"Persistence": "SECTION",
	"Persistence - PersistenceContext": "Both the org.hibernate.Session API and javax.persistence.EntityManager API represent a context for dealing with persistent data. This concept is called a persistence context. Persistent data has a state in relation to both a persistence context and the underlying database.",
	"Persistence - PersistenceContext - @PersistenceUnit - JPA": "The @PersistenceUnit annotation is used to specify the EntityManagerFactory that needs to be injected as a dependency.",
	"Persistence - PersistenceContext - @PersistenceUnits - JPA": "The @PersistenceUnits annotation is used to group multiple @PersistenceUnit annotations.",
	"Persistence - PersistenceContext - @PersistenceContext - JPA": "The @PersistenceContext annotation is used to specify the EntityManager that needs to be injected as a dependency.",
	"Persistence - PersistenceContext - @PersistenceContexts - JPA": "The @PersistenceContexts annotation is used to group multiple @PersistenceContext annotations.",
	"Persistence - PersistenceContext - @PersistenceProperty - JPA": "The @PersistenceProperty annotation is used by the @PersistenceContext annotation to declare JPA provider properties that are passed to the underlying container when the EntityManager instance is created.",
	"Persistence - EntityManagement - JPA - EntityManager - EntityManagerFactory": "A thread-safe (and immutable) representation of the mapping of the application domain model to a database. Acts as a factory for org.hibernate.Session instances. The EntityManagerFactory is the JPA equivalent of a SessionFactory and basically those two converge into the same SessionFactory implementation. A SessionFactory is very expensive to create, so, for any given database, the application should have only one associated SessionFactory. The SessionFactory maintains services that Hibernate uses across all Session(s) such as second level caches, connection pools, transaction system integrations, etc.",
	"Persistence - EntityManagement - JPA - EntityManager - EntityManager": "A single-threaded, short-lived object conceptually modeling a Unit of Work PoEAA. In JPA nomenclature, the Session is represented by an EntityManager. Behind the scenes, the Hibernate Session wraps a JDBC java.sql.Connection and acts as a factory for org.hibernate.Transaction instances. It maintains a generally repeatable read persistence context (first level cache) of the application domain model.",
	"Persistence - EntityManagement - JPA - EntityManager - EntityTransaction": "A single-threaded, short-lived object used by the application to demarcate individual physical transaction boundaries. EntityTransaction is the JPA equivalent and both act as an abstraction API to isolate the application from the underlying transaction system in use (JDBC or JTA).",
	"Persistence - EntityManagement - JPA - EntityManager - Clearing": "entityManager.clear(), (JPA)",
	"Persistence - EntityManagement - Hibernate - SessionFactory": "A thread-safe (and immutable) representation of the mapping of the application domain model to a database. Acts as a factory for org.hibernate.Session instances. The EntityManagerFactory is the JPA equivalent of a SessionFactory and basically those two converge into the same SessionFactory implementation. A SessionFactory is very expensive to create, so, for any given database, the application should have only one associated SessionFactory. The SessionFactory maintains services that Hibernate uses across all Session(s) such as second level caches, connection pools, transaction system integrations, etc.",
	"Persistence - EntityManagement - Hibernate - Session": "A single-threaded, short-lived object conceptually modeling a Unit of Work PoEAA. In JPA nomenclature, the Session is represented by an EntityManager. Behind the scenes, the Hibernate Session wraps a JDBC java.sql.Connection and acts as a factory for org.hibernate.Transaction instances. It maintains a generally repeatable read persistence context (first level cache) of the application domain model.",
	"Persistence - EntityManagement - Hibernate - Transaction": "A single-threaded, short-lived object used by the application to demarcate individual physical transaction boundaries. EntityTransaction is the JPA equivalent and both act as an abstraction API to isolate the application from the underlying transaction system in use (JDBC or JTA).",
	"Persistence - EntityManagement - Hibernate - Clearing": "session.clear(), (hibernate)",
	"Persistence - Transactions": "",
	"Persistence - Transactions - Features - Flush": "Hibernate does not automatically flush on rollback",
	"Persistence - Transactions - Features - ThreadSafe": "Transactions are not thread-safe by default",
	"Persistence - Transactions - Features - JTA": "For distributed transactions, use JTA with proper XA datasources",
	"Persistence - Transactions - Features - L2Cache": "Second-level cache updates happen during transaction commit",
	"Persistence - Transactions - lifecycle - Hibernate - start": "Hibernate starts the transactions by calling beginTransaction() (Hibernate's Session)",
	"Persistence - Transactions - lifecycle - Hibernate - instance": "According to used persistence mechanism, a transaction can be an instance of org.hibernate.Transaction (for Hibernate's Session)",
	"Persistence - Transactions - lifecycle - Hibernate - session.beginTransaction()": "",
	"Persistence - Transactions - lifecycle - Hibernate - transaction.rollback()": "",
	"Persistence - Transactions - lifecycle - Hibernate - transaction.commit()": "",
	"Persistence - Transactions - lifecycle - Spring - @Transactional": "When using Spring, transaction management is typically delegated to Spring:",
	"Persistence - Transactions - Isolation": "",
	"Persistence - Transactions - Isolation - Levels - JDBC - Connection.TRANSACTION_NONE": "It is represented by integer value 0 does not support transactions.",
	"Persistence - Transactions - Isolation - Levels - JDBC - Connection.TRANSACTION_READ_UNCOMMITTED": "It is represented by integer value 2 supports transactions allowing Non-Repeatable Reads and, Phantom Reads.",
	"Persistence - Transactions - Isolation - Levels - JDBC - Connection.TRANSACTION_READ_COMMITTED": "It is represented by integer value 1 supports transactions allowing Dirty Reads, Non-Repeatable Reads and, Phantom Reads.",
	"Persistence - Transactions - Isolation - Levels - JDBC - Connection.TRANSACTION_REPEATABLE_READ": "It is represented by integer value 4 supports transactions allowing only Phantom Reads.",
	"Persistence - Transactions - Isolation - Levels - JDBC - Connection.TRANSACTION_SERIALIZABLE": "It is represented by integer value 8 supports transactions without allowing Dirty Reads, Non-Repeatable Reads and, Phantom Reads.",
	"Persistence - Transactions - Isolation - Levels - Spring - Isolation.DEFAULT": "Use the default isolation level of the underlying data store.",
	"Persistence - Transactions - Isolation - Levels - Spring - Isolation.READ_UNCOMMITTED": "A constant indicating that dirty reads, non-repeatable reads, and phantom reads can occur.",
	"Persistence - Transactions - Isolation - Levels - Spring - Isolation.READ_COMMITTED": "A constant indicating that dirty reads are prevented; non-repeatable reads and phantom reads can occur.",
	"Persistence - Transactions - Isolation - Levels - Spring - Isolation.REPEATABLE_READ": "A constant indicating that dirty reads and non-repeatable reads are prevented; phantom reads can occur.",
	"Persistence - Transactions - Isolation - Levels - Spring - Isolation.SERIALIZABLE": "A constant indicating that dirty reads, non-repeatable reads, and phantom reads are prevented.",
	"Persistence - Transactions - Locking": "Locking is a mechanism that prevents concurrent access to data to maintain consistency.",
	"Persistence - Transactions - Locking - Config - LockModeType - JPA": "FORCE, NONE, OPTIMISTIC, OPTIMISTIC_FORCE_INCREMENT, PESSIMISTIC_FORCE_INCREMENT, PESSIMISTIC_READ, PESSIMISTIC_WRITE, READ, UPGRADE, UPGRADE_NOWAIT, UPGRADE_SKIPLOCKED, WRITE",
	"Persistence - Transactions - Locking - Config - LockMode - Hibernate": "FORCE, NONE, OPTIMISTIC, OPTIMISTIC_FORCE_INCREMENT, PESSIMISTIC_FORCE_INCREMENT, PESSIMISTIC_READ, PESSIMISTIC_WRITE, READ, UPGRADE, UPGRADE_NOWAIT, UPGRADE_SKIPLOCKED, WRITE",
	"Persistence - Transactions - Locking - Types": "Your locking strategy can be either optimistic or pessimistic.",
	"Persistence - Transactions - Locking - Types - Optimistic": "Assumes that multiple transactions can complete without affecting each other, and that therefore transactions can proceed without locking the data resources that they affect.",
	"Persistence - Transactions - Locking - Types - Optimistic - Rollback": "Before committing, each transaction verifies that no other transaction has modified its data. If the check reveals conflicting modifications, the committing transaction rolls back.",
	"Persistence - Transactions - Locking - Types - Optimistic - @OptimisticLocking - JPA": "The @OptimisticLock annotation is used to specify if the currently annotated attribute will trigger an entity version increment upon being modified.",
	"Persistence - Transactions - Locking - Types - Optimistic - @OptimisticLocking - Hibernate": "The @OptimisticLocking annotation is used to specify the currently annotated an entity optimistic locking strategy.",
	"Persistence - Transactions - Locking - Types - Optimistic - @OptimisticLocking - Strategies": "NONE, VERSION, ALL, DIRTY",
	"Persistence - Transactions - Locking - Types - Optimistic - @OptimisticLocking - Strategies - NONE": "NONE The implicit optimistic locking mechanism is disabled.",
	"Persistence - Transactions - Locking - Types - Optimistic - @OptimisticLocking - Strategies - VERSION": "VERSION The implicit optimistic locking mechanism is using a dedicated version column.",
	"Persistence - Transactions - Locking - Types - Optimistic - @OptimisticLocking - Strategies - VERSION - @Version": "Uses versioning (a version number or timestamp). Implemented using @Version annotation",
	"Persistence - Transactions - Locking - Types - Optimistic - @OptimisticLocking - Strategies - ALL": "ALL The implicit optimistic locking mechanism is using all attributes as part of an expanded WHERE clause restriction for the Update and Delete SQL statements.",
	"Persistence - Transactions - Locking - Types - Optimistic - @OptimisticLocking - Strategies - DIRTY": "DIRTY The implicit optimistic locking mechanism is using the dirty attributes (the attributes that were modified) as part of an expanded WHERE clause restriction for the Update and Delete SQL statements.",
	"Persistence - Transactions - Locking - Types - Pessimistic": "Pessimistic locking assumes that concurrent transactions will conflict with each other, and requires resources to be locked after they are read and only unlocked after the application has finished using the data.",
	"Persistence - Entity - Hibernate - Locate - Reference": "Obtain an entity reference without initializing its data: book.setAuthor( session.load( Person.class, personId ) ) (hibernate)",
	"Persistence - Entity - Hibernate - Locate - ReferenceBySimpleNaturalId": "session.bySimpleNaturalId( Book.class ).getReference( isbn ) (hibernate)",
	"Persistence - Entity - Hibernate - Locate - ReferenceByNaturalId": "session.byNaturalId( Book.class ).using( 'isbn', isbn ).load( ), (hibernate)",
	"Persistence - Entity - Hibernate - Locate - Find": "session.get( Person.class, personId ) and session.byId( Person.class ).load( personId ) (hibernate)",
	"Persistence - Entity - Hibernate - Locate - Contains": "session.contains( person ) (hibernate)",
	"Persistence - Entity - Hibernate - Persist - Persist": "session.save( person ) (hibernate)",
	"Persistence - Entity - Hibernate - Persist - Merging": "Merging detached data: session.merge( person ) (hibernate)",
	"Persistence - Entity - Hibernate - Persist - Remove": "session.delete( person ) (hibernate)",
	"Persistence - Entity - Hibernate - Persist - Refresh": "Refresh entity state: session.refresh( person ) (hibernate)",
	"Persistence - Entity - Hibernate - Persist - Evicting": "session.evict( person ) (hibernate)",
	"Persistence - Entity - Hibernate - Persist - Reattaching": "session.lock( person, LockMode.NONE ) (hibernate) or session.saveOrUpdate( person ) (hibernate).",
	"Persistence - Entity - Hibernate - Persist - Laziness": "Hibernate.isInitialized( person ) (hibernate)",
	"Persistence - Entity - Hibernate - @OnDelete": "The @OnDelete annotation is a Hibernate-specific feature that allows you to specify the database-level action that should occur when a referenced entity is deleted.",
	"Persistence - Entity - Hibernate - @OnDelete - ON DELETE": "This annotation generates the appropriate ON DELETE clause in the foreign key constraint at the database level.",
	"Persistence - Entity - Hibernate - @OnDelete - OnDeleteAction": "",
	"Persistence - Entity - Hibernate - @OnDelete - OnDeleteAction - CASCADE": "Delete child records when parent is deleted",
	"Persistence - Entity - Hibernate - @OnDelete - OnDeleteAction - NO_ACTION": "Default behavior (throws error if children exist)",
	"Persistence - Entity - Hibernate - @OnDelete - OnDeleteAction - RESTRICT": "Similar to NO_ACTION but checked before attempting deletion",
	"Persistence - Entity - Hibernate - @OnDelete - OnDeleteAction - SET_NULL": "Set foreign key to NULL (requires nullable column)",
	"Persistence - Entity - Hibernate - @OnDelete - OnDeleteAction - SET_DEFAULT": "Set foreign key to its default value",
	"Persistence - States": "Transient, managed or persistent, detached, removed",
	"Persistence - States - Transient": "new or transient. The entity has just been instantiated and is not associated with a persistence context. It has no persistent representation in the database and typically no identifier value has been assigned (unless the assigned generator was used).",
	"Persistence - States - Persistent": "managed or persistent. The entity has an associated identifier and is associated with a persistence context. It may or may not physically exist in the database yet.",
	"Persistence - States - Detached": "The entity has an associated identifier, but is no longer associated with a persistence context (usually because the persistence context was closed or the instance was evicted from the context).",
	"Persistence - States - Removed": "The entity has an associated identifier and is associated with a persistence context, however it is scheduled for removal from the database.",
	"Persistence - States - JPA - Modifying": "person.setName('John Doe'), entityManager.flush(), (JPA)",
	"Persistence - States - Hibernate - Modifying": "person.setName('John Doe'), session.flush(), (hibernate)",
	"Persistence - Flushing": "Flushing is the process of synchronizing the state of the persistence context with the underlying database. The EntityManager and the Hibernate Session expose a set of methods, through which the application developer can change the persistent state of an entity. The persistence context acts as a transactional write-behind cache, queuing any entity state change. Like any write-behind cache, changes are first applied in-memory and synchronized with the database during flush time. The flush operation takes every entity state change and translates it to an INSERT, Update or Delete statement.",
	"Persistence - Flushing - ChangeDetection - Hibernate": "Hibernate's change detection is the core feature that enables automatic synchronization between Java object state and database records.",
	"Persistence - Flushing - ChangeDetection - InitialState": "Initial State Capture: When an entity is loaded, Hibernate takes a 'snapshot' of all its persistent state",
	"Persistence - Flushing - ChangeDetection - DeepComparison": "During flush operations, compares current state with the original snapshot.",
	"Persistence - Flushing - ChangeDetection - GranularTracking": "Works at the individual property level.",
	"Persistence - Flushing - ChangeDetection - DirtyChecking": "Hibernate's dirty checking is the process of detecting which entity properties have changed since they were loaded from the database, so only those changes are persisted.",
	"Persistence - Flushing - ChangeDetection - DirtyChecking - SnapshotMechanism": "When an entity is loaded, Hibernate takes a snapshot of its state. At flush time (before query execution or transaction commit), Hibernate compares",
	"Persistence - Flushing - ChangeDetection - DirtyChecking - BytecodeEnhancement": "For better performance, Hibernate can use bytecode enhancement to: Add tracking at the field level, Replace collections with smart proxies that track modifications",
	"Persistence - Flushing - Strategies - JTA": "JPA defines only two flushing strategies (AUTO and COMMIT)",
	"Persistence - Flushing - Strategies - JTA - AUTO": "",
	"Persistence - Flushing - Strategies - JTA - COMMIT": "",
	"Persistence - Flushing - Strategies - Hibernate": "The flushing strategy is given by the flushMode of the current running Hibernate Session. Although JPA defines only two flushing strategies (AUTO and COMMIT), Hibernate has a much broader spectrum of flush types: ALWAYS, AUTO, COMMIT, MANUAl",
	"Persistence - Flushing - Strategies - Hibernate - NEVER": "The Session is never flushed unless Session.flush() is explicitly called by the application. This mode is very efficient for read only transactions.",
	"Persistence - Flushing - Strategies - Hibernate - COMMIT": "The Session is flushed when Transaction.commit() is called.",
	"Persistence - Flushing - Strategies - Hibernate - AUTO": "The Session is flushed if necessary before query execution in order to ensure that queries never return stale state. This is the default flush mode.",
	"Persistence - Flushing - Strategies - Hibernate - MANUAL": "The Session flushing is delegated to the application, which must call Session.flush() explicitly in order to apply the persistence context changes.",
	"Persistence - Flushing - Strategies - Hibernate - ALWAYS": "The Session is flushed before every query. This is almost always unnecessary and inefficient.",
	"Persistence - Flushing - Process": "When changes are detected.",
	"Persistence - Flushing - Process - 1. IdentifyDirtyEntities": "Compare all managed entities with snapshots.",
	"Persistence - Flushing - Process - 2. Processcollections:": "Apply collection updates first.",
	"Persistence - Flushing - Process - 3. GenerateSQL": "Hibernate generates appropriate SQL: INSERT for new entities, UPDATE for changed entities, DELETE for removed entities",
	"Persistence - Flushing - Process - 4. ExecuteSQL": "Execute SQL in optimal order: Inserts (to generate IDs needed for FKs), Updates, Deletes",
	"Persistence - Flushing - Process - 5. ReferentialIntegrity": "Maintains referential integrity: Handles foreign key updates, Processes cascading operations",
	"Persistence - Flushing - Process - 6. OrderOptimally": "Orders operations optimally: Inserts before updates (to generate IDs), Deletes last",
	"Persistence - Flushing - Process - 7. BatchOperations": "When enabled via hibernate.jdbc.batch_size",
	"Persistence - Events": "Both interceptors and event listeners allow you to hook into Hibernate's lifecycle events, making them powerful tools for implementing auditing functionality.",
	"Persistence - Events - Hibernate - Interceptor": "The org.hibernate.Interceptor interface provides callbacks from the session to the application, allowing the application to inspect and/or manipulate properties of a persistent object before it is saved, Updated, Deleted or loaded.",
	"Persistence - Events - Hibernate - Interceptor - Scope": "An Interceptor can be either Session-scoped or SessionFactory-scoped",
	"Persistence - Events - Hibernate - Interceptor - Scope - Session": "A Session-scoped interceptor is specified when a session is opened.",
	"Persistence - Events - Hibernate - Interceptor - Scope - SessionFactory": "A SessionFactory-scoped interceptor is registered with the Configuration object prior to building the SessionFactory. Unless a session is opened explicitly specifying the interceptor to use, the SessionFactory-scoped interceptor will be applied to all sessions opened from that SessionFactory. SessionFactory-scoped interceptors must be thread safe. Ensure that you do not store session-specific states since multiple sessions will use this interceptor potentially concurrently.",
	"Persistence - Events - Hibernate - NativeEventSystem": "React to particular events in the persistence layer. The full range of defined event types is declared on org.hibernate.event.spi.EventType: AUTO_FLUSH, CLEAR, Delete, DIRTY_CHECK, EVICT, FLUSH, FLUSH_ENTITY, INIT_COLLECTION, LOAD, LOCK, MERGE, PERSIST, PERSIST_ONFLUSH, POST_COLLECTION_RECREATE, POST_COLLECTION_REMOVE, POST_COLLECTION_Update, POST_COMMIT_Delete, POST_COMMIT_INSERT, POST_COMMIT_Update, POST_Delete, POST_INSERT, POST_LOAD, POST_Update, PRE_COLLECTION_RECREATE, PRE_COLLECTION_REMOVE, PRE_COLLECTION_Update, PRE_Delete, PRE_INSERT, PRE_LOAD, PRE_Update, REFRESH, REPLICATE, RESOLVE_NATURAL_ID, SAVE, SAVE_Update, Update ",
	"Persistence - Events - Hibernate - EventListeners": "Event listeners provide a more fine-grained approach to handling persistence events.",
	"Persistence - Events - Hibernate - EventListeners - hibernate.cfg.xml": "< listener type='post-insert' class='com.example.AuditEventListener'/> ",
	"Persistence - Events - Hibernate - EventListeners - PreInsertEvent": ".",
	"Persistence - Events - Hibernate - EventListeners - PostInsertEvent": ".",
	"Persistence - Events - Hibernate - EventListeners - PreUpdateEvent": ".",
	"Persistence - Events - Hibernate - EventListeners - PostUpdateEvent": ".",
	"Persistence - Events - Hibernate - EventListeners - PreDeleteEvent": ".",
	"Persistence - Events - Hibernate - EventListeners - PostDeleteEvent": ".",

	"Types": "SECTION",
	"Types - All - Immutability": "Immutability can be specified for both entities and collections.",			
	"Types - All - Immutability - @Updatable - JPA": "@Updatable(false)",			
	"Types - All - Immutability - @Immutable - Hibernate": "The @Immutable annotation is used to specify that the annotated entity, attribute, or collection is immutable.",			
	"Types - All - Immutability - Entity": "If a specific entity is immutable, it is good practice to mark it with the @Immutable annotation. @Immutable means is till ignore Updates and throw Exceptions for Deletes",
	"Types - All - Immutability - Entity - @Subselect - Hibernate": "@Subselect allows us to map an immutable entity to the SQL query",
	"Types - All - Immutability - Collection": "Just like entities, collections can also be marked with the @Immutable annotation. This means is till throw Exceptions for Updates and Deletes",
	"Types - Entities": "Entities, by nature of their unique identifier, exist independently of other objects whereas values do not. Entities are domain model classes which correlate to rows in a database table, using a unique identifier. Because of the requirement for a unique identifier, entities exist independently and define their own lifecycle. The Contact class itself would be an example of an entity.",
	"Types - Entities - Requirements Hibernate": "Hibernate, however, is not as strict in its requirements.",
	"Types - Entities - Requirements Hibernate - constructor": "(1) The entity class must have a no-argument constructor, which may be public, protected or package visibility. The entity class should have a no-argument constructor. Both Hibernate and JPA require this. JPA requires that this constructor be defined as public or protected. Hibernate, for the most part, does not care about the constructor visibility, as long as the system SecurityManager allows overriding the visibility setting. That said, the constructor should be defined with at least package visibility if you wish to leverage runtime proxy generation.",
	"Types - Entities - Requirements Hibernate - constructors": "(2) It may define additional constructors as well.",
	"Types - Entities - Requirements Hibernate - class": "(3) The entity class need not be a top-level class.",
	"Types - Entities - Requirements Hibernate - final": "(4) Hibernate can persist final classes or classes with final persistent state accessor (getter/setter) methods. However, it is generally not a good idea as doing so will stop Hibernate from being able to generate proxies for lazy-loading the entity. A central feature of Hibernate is the ability to load lazily certain entity instance variables (attributes) via runtime proxies. This feature depends upon the entity class being non-final or else implementing an interface that declares all the attribute getters/setters. You can still persist final classes that do not implement such an interface with Hibernate, but you will not be able to use proxies for fetching lazy associations, therefore limiting your options for performance tuning. For the very same reason, you should also avoid declaring persistent attribute getters and setters as final.",
	"Types - Entities - Requirements Hibernate - variables": "(5) Hibernate does not restrict the application developer from exposing instance variables and reference them from outside the entity class itself.",
	"Types - Entities - Requirements Hibernate - JavaBean": "The JPA specification requires this, otherwise the model would prevent accessing the entity persistent state fields directly from outside the entity itself. Although Hibernate does not require it, it is recommended to follow the JavaBean conventions and define getters and setters for entity persistent attributes. Nevertheless, you can still tell Hibernate to directly access the entity fields. Attributes (whether fields or getters/setters) need not be declared public. Hibernate can deal with attributes declared with public, protected, package or private visibility. Again, if wanting to use runtime proxy generation for lazy loading, the getter/setter should grant access to at least package visibility.",			
	"Types - Entities - Class": ".",
	"Types - Entities - Class - Config - Hibernate - @Where": "Sometimes, you want to filter out entities or collections using custom SQL criteria. This can be achieved using the @Where annotation, which can be applied to entities and collections. @Where( clause = 'active = true' )",
	"Types - Entities - Class - Config - Hibernate - @WhereJoinTable": "Just like @Where annotation, @WhereJoinTable is used to filter out collections using a joined table (e.g. @ManyToMany association).",
	"Types - Entities - Class - Config - Hibernate - @Persister": "The @Persister annotation is used to specify a custom entity or collection persister. For entities, the custom persister must implement the EntityPersister interface. For collections, the custom persister must implement the CollectionPersister interface. @Persister(impl=MyEntityPersister.class)",
	"Types - Entities - Class - Config - Hibernate - @Tuplizer": "It is possible to map your entities as dynamic proxies using the @Tuplizer annotation. The @Tuplizer instructs Hibernate to use the DynamicEntityTuplizer and DynamicEmbeddableTuplizer to handle the associated entity and embeddable object types.",
	"Types - Entities - Class - Config - Hibernate - @Tuplizers": "The @Tuplizers annotation is used to group multiple @Tuplizer annotations.",
	"Types - Entities - Class - Config - Hibernate - @Check": "Adds a SQL CHECK constraint.",
	"Types - Entities - Class - Config - Hibernate - @Index": "@Table(appliesTo = 'customers', indexes = @Index(...)) – Hibernate-style index definition.",
	"Types - Entities - Class - Inheritance": "Although relational database systems don’t provide support for inheritance, Hibernate provides several strategies to leverage this object-oriented trait onto domain model entities: MappedSuperclass, Single table, Joined table, Table per class",
	"Types - Entities - Class - Inheritance - PolymorphicQueries": "Querying across inheritance hierarchies",
	"Types - Entities - Class - Inheritance - PolymorphicQueries - @Inheritance - JPA": "Inheritance Mapping Strategies.",
	"Types - Entities - Class - Inheritance - PolymorphicQueries - @Inheritance - SINGLE_TABLE": "The domain model class hierarchy is materialized into a single table which contains entities belonging to different class types. The single table inheritance strategy maps all subclasses to only one database table. Each subclass declares its own persistent properties. Version and id properties are assumed to be inherited from the root class. When omitting an explicit inheritance strategy (e.g. @Inheritance), JPA will choose the SINGLE_TABLE strategy by default.",
	"Types - Entities - Class - Inheritance - PolymorphicQueries - @Inheritance - JOINED": "The base class and all the subclasses have their own database tables and fetching a subclass entity requires a join with the parent table as well. Each subclass can also be mapped to its own table. This is also called table-per-subclass mapping strategy. An inherited state is Appd by joining with the table of the superclass. A discriminator column is not required for this mapping strategy. Each subclass must, however, declare a table column holding the object identifier. The primary key of this table is also a foreign key to the superclass table and described by the @PrimaryKeyJoinColumns. The table name still defaults to the non-qualified class name. Also, if @PrimaryKeyJoinColumn is not set, the primary key / foreign key columns are assumed to have the same names as the primary key columns of the primary table of the superclass.",
	"Types - Entities - Class - Inheritance - PolymorphicQueries - @Inheritance - TABLE_PER_CLASS": "Each subclass has its own table containing both the subclass and the base class properties. A third option is to map only the concrete classes of an inheritance hierarchy to tables. This is called the table-per-concrete-class strategy. Each table defines all persistent states of the class, including the inherited state. In Hibernate, it is not necessary to explicitly map such inheritance hierarchies. You can map each class as a separate entity root. However, if you wish use polymorphic associations (e.g. an association to the superclass of your hierarchy), you need to use the union subclass mapping.",
	"Types - Entities - Class - Inheritance - PolymorphicQueries - Config - @Any - Hibernate": "(One-to-Any) The @Any annotation is used to define the any-to-one association which can point to one one of several entity types. The @Any mapping defines a polymorphic association to classes from multiple tables. This type of mapping requires more than one column. The first column contains the type of the associated entity. The remaining columns contain the identifier. It is impossible to specify a foreign key constraint for this kind of association. This is not the usual way of mapping polymorphic associations and you should use this only in special cases (e.g. audit logs, user session data, etc). The @Any annotation describes the column holding the metadata information. To link the value of the metadata information and an actual entity type, the @AnyDef and @AnyDefs annotations are used. The metaType attribute allows the application to specify a custom type that maps database column values to persistent classes that have identifier properties of the type specified by idType. You must specify the mapping from values of the metaType to class names.",
	"Types - Entities - Class - Inheritance - PolymorphicQueries - Config - @ManyToAny - Hibernate": "Creates a polymorphic many-to-many association. Requires a join table with type information. Similar triple-column approach as @Any",
	"Types - Entities - Class - Inheritance - PolymorphicQueries - Config - Metadata - @AnyMetaDef - Hibernate": "The @AnyMetaDef annotation is used to provide metadata about an @Any or @ManyToAny mapping.",
	"Types - Entities - Class - Inheritance - PolymorphicQueries - Config - Metadata - @AnyMetaDefs - Hibernate": "The @AnyMetaDefs annotation is used to group multiple @AnyMetaDef annotations.",
	"Types - Entities - Access - Strategies - FieldBasedAccess": "When using field-based access, adding other entity-level methods is much more flexible because Hibernate won’t consider those part of the persistence state. To exclude a field from being part of the entity persistent state, the field must be marked with the @Transient annotation.",
	"Types - Entities - Access - Strategies - PropertyBasedAccess": "get/set. When using property-based access, Hibernate uses the accessors for both reading and writing the entity state. Every other method that will be added to the entity (e.g. helper methods for synchronizing both ends of a bidirectional one-to-many association) will have to be marked with the @Transient annotation.",
	"Types - Entities - Access - Strategies - Overriding": "The default access strategy mechanism can be overridden with the JPA @Access annotation. In the following example, the @Version attribute is accessed by its field and not by its getter, like the rest of entity attributes.",
	"Types - Entities - Access - Strategies - EmbeddableTypes": "Because embeddables are managed by their owning entities, the access strategy is therefore inherited from the entity too. This applies to both simple embeddable types as well as for collection of embeddables. The embeddable types can overrule the default implicit access strategy (inherited from the owning entity). In the following example, the embeddable uses property-based access, no matter what access strategy the owning entity is choosing:",
	"Types - Identifiers": "Identifiers model the primary key of an entity. They are used to uniquely identify each specific entity. Hibernate and JPA both make the following assumptions about the corresponding database column(s): unique, not-null, immutable. Every entity must define an identifier. For entity inheritance hierarchies, the identifier must be defined just on the entity that is the root of the hierarchy. ",
	"Types - Identifiers - Types": "An identifier might be simple (single value) or composite (multiple values).",
	"Types - Identifiers - Types - Unique": "",
	"Types - Identifiers - Types - Unique - Column": "@Column(unique = true) Adds a single-column unique constraint to the database schema.",
	"Types - Identifiers - Types - Unique - Columns": "@Table(uniqueConstraints = ...) Defines multi-column unique constraints at the table level.",
	"Types - Identifiers - Types - Unique - Relationships": "Use @JoinColumn(unique = true) to enforce uniqueness in relationships (e.g., one-to-one).",
	"Types - Identifiers - Types - Simple": "Simple identifiers map to a single basic attribute, and are denoted using the javax.persistence.Id annotation. According to JPA only the following types should be used as identifier attribute types: * any Java primitive type * any primitive wrapper type * java.lang.String * java.util.Date (TemporalType#DATE) * java.sql.Date * java.math.BigDecimal * java.math.BigInteger Any types used for identifier attributes beyond this list will not be portable.",
	"Types - Identifiers - Types - Simple - Hibernate - @GenericGenerator": "@GenericGenerator allows integration of any Hibernate org.hibernate.id.IdentifierGenerator implementation, including any of the specific ones discussed here and any custom ones. To make use of the pooled or pooled-lo optimizers, the entity mapping must use the @GenericGenerator annotation:",
	"Types - Identifiers - Types - Composite": "Composite identifiers correspond to one or more persistent attributes.",
	"Types - Identifiers - Types - Composite - Hibernate": "Hibernate allows defining a composite identifier out of entity associations.",
	"Types - Identifiers - Types - Composite - Hibernate - @RowId": "If you annotate a given entity with the @RowId annotation and the underlying database supports fetching a record by ROWID (e.g. Oracle), then Hibernate can use the ROWID pseudo-column for CRUD operations.",
	"Types - Identifiers - Types - Composite - Hibernate - @ValueGenerationType": "The @ValueGenerationType annotation is used to specify that the current annotation type should be used as a generator annotation type. Lets you implement complex value generation that isn't covered by JPA.",
	"Types - Identifiers - Types - Composite - Hibernate - @ValueGenerationType - AnnotationValueGeneration": "You implement the AnnotationValueGeneration interface.",
	"Types - Identifiers - NaturalIds - Hibernate": "Natural ids represent domain model unique identifiers that have a meaning in the real world too. Even if a natural id does not make a good primary key (surrogate keys being usually preferred), it’s still useful to tell Hibernate about it.",
	"Types - Identifiers - NaturalIds - Hibernate - @NaturalId": "The @NaturalId annotation is used to specify that the currently annotated attribute is part of the natural id of the entity.",
	"Types - Identifiers - NaturalIds - Hibernate - @NaturalId - Usage": "When you need optimized queries for business keys.",
	"Types - Identifiers - NaturalIds - Hibernate - @NaturalId - Mutable": "A natural id may be mutable or immutable. By default the @NaturalId annotation marks an immutable natural id attribute. An immutable natural id is expected to never change its value. If the value(s) of the natural id attribute(s) change, @NaturalId(mutable=true) should be used instead.",
	"Types - Identifiers - NaturalIds - Hibernate - @NaturalIdCache": "The @NaturalIdCache annotation is used to specify that the natural id values associated with the annotated entity should be stored in the second-level cache.",
	"Types - Identifiers - NaturalIds - Hibernate - NaturalIdLoadAccess": "Hibernate provides an API for loading entities by their associate natural id. This is represented by the org.hibernate.NaturalIdLoadAccess contract obtained via Session#byNaturalId.",
	"Types - Identifiers - Generate - JPA - @TableGenerator": "The @TableGenerator annotation is used to specify the database table used by the identity generator of the currently annotated entity.",
	"Types - Identifiers - Generate - JPA - @SequenceGenerator": "The @SequenceGenerator annotation is used to specify the database sequence used by the identifier generator of the currently annotated entity.",
	"Types - Associations": ".",
	"Types - Associations ": "Associations describe how two or more entities form a relationship based on a database joining semantics.",
	"Types - Associations - Hibernate - @JoinColumn": "While @JoinColumn is JPA-standard, Hibernate adds extra attributes ",
	"Types - Associations - Hibernate - @JoinFormula - Hibernate": "The @JoinFormula annotation is used to customize the join between a child Foreign Key and a parent row Primary Key. @JoinFormula( \"REGEXP_REPLACE(phoneNumber, '\\+(\\d+)-.*', '\\1')::int\" )",
	"Types - Associations - Hibernate - @JoinColumnOrFormula - Hibernate": "The @JoinColumnOrFormula annotation is used to specify that the entity association is resolved either through a FOREIGN KEY join (e.g. @JoinColumn) or using the result of a given SQL formula (e.g. @JoinFormula).",
	"Types - Associations - Hibernate - @NotFound": "The @NotFound annotation is used to specify the NotFoundAction strategy for when an element is not found in a given association.",
	"Types - Associations - Hibernate - @NotFound - NotFoundAction": "The NotFoundAction defines with two possibilities: EXCEPTION, IGNORE",
	"Types - Associations - Hibernate - @NotFound - NotFoundAction - EXCEPTION": "An exception is thrown when an element is not found (default and recommended).",
	"Types - Associations - Hibernate - @NotFound - NotFoundAction - IGNORE": "Ignore the element when not found in the database.",
	"Types - Associations - Hibernate - @LazyToOne": "The @LazyToOne annotation is used to specify the laziness options, represented by LazyToOneOption, available for a @OneToOne or @ManyToOne association.",
	"Types - Associations - Hibernate - @LazyToOne - LazyToOneOption": "LazyToOneOption defines the following alternatives: FALSE, NO_PROXY, PROXY",
	"Types - Associations - Hibernate - @LazyToOne - LazyToOneOption - FALSE": "Eagerly load the association. This one is not needed since the JPA FetchType.EAGER offers the same behavior.",
	"Types - Associations - Hibernate - @LazyToOne - LazyToOneOption - NO_PROXY": "This option will fetch the association lazily while returning real entity object.",
	"Types - Associations - Hibernate - @LazyToOne - LazyToOneOption - PROXY": "This option will fetch the association lazily while returning a proxy instead.",
	"Types - Associations - Hibernate - @LazyGroup": "This annotation allows defining different groups of attributes to be initialized together when access one attribute in the group.",
	"Types - Associations - Hibernate - @LazyGroup - default": "By default, all non-collection attributes are loaded in one group named 'DEFAULT'.",
	"Types - Associations - Hibernate - @LazyGroup - BytecodeEnhancement": "To load entity attributes lazily, bytecode enhancement is needed.",
	"Types - EntityCollections": "If value type collections can only form a one-to-many association between an owner entity and multiple basic or embeddable types, entity collections can represent both @OneToMany and @ManyToMany associations.",
	"Types - EntityCollections - Types": "By underlying collection typebags: indexed lists, sets, sorted sets, maps, sorted maps, arrays",
	"Types - EntityCollections - Types - Hibernate - Bag": "Bags are unordered lists and we can have unidirectional bags or bidirectional ones.",
	"Types - EntityCollections - Types - Hibernate - Bag - Unidirectional": "The unidirectional bag is mapped using a single @OneToMany annotation on the parent side of the association. Behind the scenes, Hibernate requires an association table to manage the parent-child relationship",
	"Types - EntityCollections - Types - Hibernate - Bag - Bidirectional": "The bidirectional bag is the most common type of entity collection. The @ManyToOne side is the owning side of the bidirectional bag association, while the @OneToMany is the inverse side, being marked with the mappedBy attribute.",
	"Types - ValueTypes": "A value type is a piece of data that does not define its own lifecycle. It is, in effect, owned by an entity, which defines its lifecycle.",
	"Types - ValueTypes - PersistentAttributes": "All the state of an entity is made up entirely of value types. These state fields or JavaBean properties are termed persistent attributes.",
	"Types - ValueTypes - Config - Hibernate - @TypeDef": "The @TypeDef annotation is used to specify a @Type definition which can later be reused for multiple basic attribute mappings. @TypeDef(name = 'dateNoMs', typeClass = com.gorillalogic.type.DateNoMsType.class })",
	"Types - ValueTypes - Config - Hibernate - @TypeDefs": "The @TypeDefs annotation is used to group multiple @TypeDef annotations: @TypeDefs( { @TypeDef(name = 'dateNoMs', typeClass = com.gorillalogic.type.DateNoMsType.class  }) package com.gorillalogic.type,",
	"Types - ValueTypes - Config - Hibernate - @Type": "The @Type annotation is used to specify the Hibernate @Type used by the currently annotated basic attribute. @Type(type='com.gorillalogic.type.DateNoMsType')    @Column(name = 'PAYMENT_DATE')    private DateNoMs m_paymentDate,",
	"Types - ValueTypes - Types": "Value types are further classified into three sub-categories: Basic types, Embeddable types, Collection types" ,
	"Types - ValueTypes - Types - BasicTypes": "Basic value types usually map a single database column, to a single, non-aggregated Java type. Hibernate provides a number of built-in basic types, which follow the natural mappings recommended by the JDBC specifications. Internally Hibernate uses a registry of basic types when it needs to resolve a specific org.hibernate.type.Type. Strictly speaking, a basic type is denoted by the @Basic annotation. @Basic annotation can be ignored, as it is assumed by default.",
	"Types - ValueTypes - Types - BasicTypes - Hibernate - @ColumnTransformer": "The @ColumnTransformer annotation is used to customize how a given column value is read from or write into the database. @ColumnTransformer(read = 'decrypt(credit_card_num)', write = 'encrypt(?)') ",
	"Types - ValueTypes - Types - BasicTypes - Hibernate - @ColumnTransformers": "The @ColumnTransformers annotation iis used to group multiple @ColumnTransformer annotations.",
	"Types - ValueTypes - Types - BasicTypes - Hibernate - @Filters": "The @Filters annotation is used to group multiple @Filter annotations.",
	"Types - ValueTypes - Types - BasicTypes - Hibernate - @Filter": "The @Filter annotation is another way to filter out entities or collections using custom SQL criteria. Unlike the @Where annotation, @Filter allows you to parameterize the filter clause at runtime. Example: @FilterDef( name='firstAccounts', parameters=@ParamDef( name='maxOrderId', type='int' ) ) @Filter( name='firstAccounts', condition='order_id <= :maxOrderId' ) )",
	"Types - ValueTypes - Types - BasicTypes - Hibernate - @FilterDefs": "The @FilterDefs annotation is used to group multiple @FilterDef annotations.",
	"Types - ValueTypes - Types - BasicTypes - Hibernate - @FilterDef": "The @FilterDef annotation is used to specify a @Filter definition (name, default condition and parameter types, if any).. Example: @FilterDef( name='firstAccounts', parameters=@ParamDef( name='maxOrderId', type='int' ) ) @Filter( name='firstAccounts', condition='order_id < = :maxOrderId' ) )",
	"Types - ValueTypes - Types - BasicTypes - Hibernate - @ParamDef": "The @ParamDef annotation is used in conjunction with @FilterDef so that the Hibernate Filter can be customized with runtime-provided parameter values.",
	"Types - ValueTypes - Types - BasicTypes - Hibernate - @FilterJoinTables": "The @FilterJoinTables annotation is used to group multiple @FilterJoinTable annotations.",
	"Types - ValueTypes - Types - BasicTypes - Hibernate - @FilterJoinTable": "When using the @Filter annotation with collections, the filtering is done against the child entries (entities or embeddables). However, if you have a link table between the parent entity and the child table, then you need to use the @FilterJoinTable to filter child entries according to some column contained in the join table. The @FilterJoinTable annotation can be, therefore, applied to a unidirectional @OneToMany collection",
	"Types - ValueTypes - Types - BasicTypes - Hibernate - @Filter + @SqlFragmentAlias": "When using the @Filter annotation and working with entities that are mapped onto multiple database tables, you will need to use the @SqlFragmentAlias annotation if the @Filter defines a condition that uses predicates across multiple tables. @Filter(name='activeAccount', condition='{a}.active = :active and {ad}.Deleted = false', aliases = { @SqlFragmentAlias( alias = 'a', table= 'account'), @SqlFragmentAlias( alias = 'ad', table= 'account_details'), } )",
	"Types - ValueTypes - Types - BasicTypes - Hibernate - @Formula": "Sometimes, you want the Database to do some computation for you rather than in the JVM, you might also create some kind of virtual column. You can use a SQL fragment (aka formula) instead of mapping a property into a column. This kind of property is read only (its value is calculated by your formula fragment) @Formula(value = 'credit * rate')",
	"Types - ValueTypes - Types - @EmbeddableTypes": "Historically Hibernate called these components. JPA calls them embeddables. Either way the concept is the same: a composition of values. An embeddable type is another form of value type, and its lifecycle is bound to a parent entity type, therefore inheriting the attribute access from its parent (for details on attribute access, see Access strategies). Embeddable types can be made up of basic values as well as associations, with the caveat that, when used as collection elements, they cannot define collections themselves.",
	"Types - ValueTypes - Types - @EmbeddableTypes - Hibernate - @Parent": "The Hibernate-specific @Parent annotation allows you to reference the owner entity from within an embeddable.",
	"Types - ValueTypes - Types - ValueTypeCollections": "The owner of the collection is always an entity, even if the collection is defined by an embeddable type. Collections form one/many-to-many associations between types so there can be: value type collections, embeddable type collections, entity collections",
	"Types - ValueTypes - Types - ValueTypeCollections - Config -  Hibernate - @CollectionId": "The @CollectionId annotation is used to specify an identifier column for an idbag collection.",
	"Types - ValueTypes - Types - ValueTypeCollections - Config -  Hibernate - @CollectionType": "The @CollectionType annotation is used to specify a custom collection type. The collection can also name a @Type, which defines the Hibernate Type of the collection elements.",
	"Types - ValueTypes - Types - ValueTypeCollections - Config -  Hibernate - @LazyCollection": "The @LazyCollection annotation is used to specify the lazy fetching behavior of a given collection. The possible values are given by the LazyCollectionOption enumeration: TRUE Load it when the state is requested. FALS Eagerly load it. EXTRA Prefer extra queries over full collection loading. The TRUE and FALSE values are deprecated since you should be using the JPA FetchType attribute of the @ElementCollection, @OneToMany, or @ManyToMany collection. The EXTRA value has no equivalent in the JPA specification, and it’s used to avoid loading the entire collection even when the collection is accessed for the first time. Each element is fetched individually using a secondary query.",
	"Types - ValueTypes - Types - ValueTypeCollections - Types": "Collections of value type include basic and embeddable types. Collections cannot be nested, and, when used in collections, embeddable types are not allowed to define other collections.",
	"Types - ValueTypes - Types - ValueTypeCollections - Types - ValueTypes": ".",
	"Types - ValueTypes - Types - ValueTypeCollections - Types - ValueTypes - Config - JPA - @ElementCollection": "Defines a collection of instances of a basic type or embeddable class (i.e. not entities). Must be specified if the collection is to be mapped by means of a collection table.",
	"Types - ValueTypes - Types - ValueTypeCollections - Types - ValueTypes - Config - Hibernate - @CollectionOfElements": "Equivalent to JPA @ElementCollection",
	"Types - ValueTypes - Types - ValueTypeCollections - Types - ValueTypes - BasicTypes": ".",
	"Types - ValueTypes - Types - ValueTypeCollections - Types - ValueTypes - EmbeddableTypes": ".",
	"Types - ValueTypes - Types - ValueTypeCollections - CustomCollections": "If you wish to use other collection types than List, Set or Map, like Queue for instance, you have to use a custom collection type. The custom collection type can still be customized as long as the base type is one of the aformentioned persistent types.",
	"Types - ValueTypes - Types - ValueTypeCollections - CustomCollections - Hibernate": "Hibernate only allows the following types: java.util.List, java.util.Set, java.util.Map, java.util.SortedSet, java.util.SortedMap.",
	"Types - ValueTypes - Types - ValueTypeCollections - CustomCollections - Hibernate - UserCollectionType": "Fully custom collection types.",
	"Types - ValueTypes - Types - ValueTypeCollections - CustomCollections - Hibernate - Arrays": "Hibernate does support the mapping of arrays in the Java domain model - conceptually the same as mapping a List.",
	"Types - ValueTypes - Types - ValueTypeCollections - CustomCollections - Hibernate - Arrays - binary": "By default, Hibernate will choose a BINARY type, as supported by the current Dialect",
	"Types - ValueTypes - Types - ValueTypeCollections - CustomCollections - Hibernate - Arrays - noRecommended": "It is important to realize that it is impossible for Hibernate to offer lazy-loading for arrays of entities and, for this reason, it is strongly recommended to map a collection of entities using a List rather than an array.",

	"Schema": "SECTION",
	"Schema - Scenarios - Hibernate - hibernate.hbm2ddl.auto": "Hibernate's behavior regarding table creation is controlled by the hibernate.hbm2ddl.auto property (or spring.jpa.hibernate.ddl-auto in Spring Boot)",
	"Schema - Scenarios - SpringBoot - or spring.jpa.hibernate.ddl-auto": "Hibernate's behavior regarding table creation is controlled by the hibernate.hbm2ddl.auto property (or spring.jpa.hibernate.ddl-auto in Spring Boot)",
	"Schema - Scenarios - create": "Drops existing tables and creates new ones every time the SessionFactory starts",
	"Schema - Scenarios - create-drop": "Same as create, but also drops tables when SessionFactory closes (good for testing)",
	"Schema - Scenarios - Update": "Updates the schema if needed (adds new columns, but won't remove columns or change data types). Performance killer.",
	"Schema - Scenarios - validate": "Validates the schema against your entities but makes no changes",
	"Schema - Scenarios - none": "Does nothing with the schema (uses existing tables)",
	"Schema - Validation - Approach - NewProjects": "For new projects: Define validations in code first (DDD-style), then generate DB schema via Hibernate hbm2ddl.",
	"Schema - Validation - Approach - Legacy": "For legacy DBs: Use Hibernate Tools or JPA Buddy for reverse engineering."

}