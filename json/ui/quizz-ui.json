{

	"Web": "SECTION",
	"Web - Binding based - Pros": "Pros: These frameworks reduce the boilerplate code needed for DOM manipulation, making it easier to create dynamic applications.",
	"Web - Binding based - Cons": "Cons: Mixing the JS logic in HTML goes against the principle of Separation of Concerns, which may also introduce complexity and performance issues in large-scale applications due to excessive DOM updates.",
  "Web - Binding based - KnockoutJS": "KnockoutJS: It uses two-way data binding to connect the UI to the underlying data model. Changes in the model automatically update the UI and vice versa.",
  "Web - Binding based - AngularJS": "AngularJS: This framework also utilizes two-way data binding, making it easy to keep the model and view in sync. It allows automatic synchronization of data between the model (business logic) and view (UI).",
  "Web - Binding based - Backbone": ".",
  "Web - Template based - Pros": "Pros: Simple. These frameworks focus on separating the presentation layer from logic, promoting a clear separation of concerns. They simplify rendering by using templates to bind data to the UI efficiently.",
  "Web - Template based - Cons": "Cons: When projects get bigger, you still need to write a lot of code, and much of the logic is duplicated. There are no reusable components, which can lead to code bloat and difficulty in maintaining a consistent structure across large applications.",
  "Web - Template based - HandlebarsJS": "HandlebarsJS: This is a way to build dynamic HTML pages by embedding expressions in HTML. It allows developers to create reusable templates for rendering content.",
  "Web - Template based - EmberJS": "EmberJS: Uses a templating engine similar to HandlebarsJS to render dynamic content. Emberâ€™s template system automatically updates the DOM when the underlying data changes.",
  "Web - Template based - Eleventy": "",
  "Web - Components based - Pros": "Pros: These frameworks promote reusability and maintainability by encapsulating functionality within self-contained components. This modular approach simplifies the development of complex applications.",
  "Web - Components based - Cons": "Cons: There is a learning curve, especially when integrating advanced features like state management and routing. Additionally, because React and Vue are libraries rather than full frameworks, developers must make more decisions about which additional tools and libraries to use, like redux.",
	"Web - Components based - React": "",
  "Web - Components based - React - CRA": "Create React App (CRA): The Community Favorite. CRA remains a popular choice for React developers, known for its simplicity and ease of use",
  "Web - Components based - React - NextJS": "Next.js, a creation of Vercel, is the trusty all-terrain rover of the JavaScript world, capable of navigating a wide range of terrains, from simple static landing pages to complex, dynamic applications. Its hybrid rendering capabilities (SSR, SSG, ISR) make it a popular choice for projects that require both performance and flexibility.",
  "Web - Components based - React - Docusaurus": "",
  "Web - Components based - React - Remix - SPA": "Remix, built by the same team behind React Router, is laser-focused on making Single Page Applications (SPAs) run faster by leveraging native browser features and minimizing client-side JavaScript.",
  "Web - Components based - React - Gatsby": "",
  "Web - Components based - React - Redwood": "",
  "Web - Components based - Preact - DenoFresh": "",
  "Web - Components based - Astro": "Astro, a rising star in the JavaScript world, is quickly gaining traction for its lightweight design and laser focus on performance. Like a nimble lunar lander, Astro prioritizes speed and efficiency, making it an good choice for content-focused websites, blogs, and documentation sites. Last year Astro stepped in as the successor of Gatsby. While it became mainly known for static websites, its growing popularity pushed Astro to explore web applications and API endpoints too.",
  "Web - Components based - Astro - SSG": "Websites built with Astro are performant by default, because they start with zero JavaScript and move all the expensive rendering to the server. While static site generation (SSG) is the default, you can also opt-in into server-side rendering (SSR).",
  "Web - Components based - VueJS": "",
  "Web - Components based - VueJS - Nuxt": "",
  "Web - Components based - Sveltekit": "",
  "Web - Components based - SolidStart": "",
  "Web - Components based - Alpine": "",
  "Web - Components based - Qwik": "",

	"Desktop": "SECTION",
	"Desktop - Chromium - Electron": "Electron embeds Chromium and Node.js to enable web developers to create desktop applications.",
  "Desktop - Chromium - NWjs": "NW.js is an app runtime based on Chromium and node.js. You can write native apps in HTML and JavaScript with NW.js. It also lets you call Node.js modules directly from the DOM and enables a new way of writing native applications with all Web technologies.",
  "Desktop - Webkit - Tauri": "Tauri uses the native WebView provided by the operating system. Based in Rust",
  "Desktop - Webkit - Neutralino": "",
  "Desktop - Webkit - Wails": "A Wails application is a standard Go application, with a webkit frontend.",
  "Desktop - Qt - NodeGui": "",

	"CI - Packaging": "SECTION",
  "CI - Packaging - Arch - Paradigms - MPA": "A Multi-Page Application (MPA) is the opposite of SPAs. MPAs rely on multiple HTML files and have multiple pages. While some companies, such as Amazon and eBay, still use MPAs, the trend is shifting towards SPAs for better user experience.",
  "CI - Packaging - Arch - Paradigms - SPA": "Single-page applications are web applications that load once with new features just being mere additions to the user interface. It does not load new HTML pages to display the new page's content, instead generated dynamically. This is made possible through JavaScript's ability to manipulate the DOM elements on the existing page itself. A SPA approach is faster, thus providing a seamless user experience.",
  "CI - Packaging - Arch - Paradigms - PWA": "A Progressive Web Application (PWA) is a web app that feels like a mobile app. It uses standard web technologies and service workers to enable features such as offline functionality, push notifications, and automatic updates.",

	"CI - Building": "SECTION",
	"CI - Building - Compilation - Type - ByPlace - CSR": "HTML is generated in the browser using JavaScript.",
	"CI - Building - Compilation - Type - ByPlace - CSR - Features - SEO": "No friendly (HTML is built in-browser)",
	"CI - Building - Compilation - Type - ByPlace - CSR - Time - AOT": "Balance: faster load times, increased size.",
	"CI - Building - Compilation - Type - ByPlace - CSR - Time - JIT": "JIT is commonly used during development for CSR applications",
	"CI - Building - Compilation - Type - ByPlace - CSR - tools - Prerender": "However, there are also such gadgets as Prerender. io and Rendertron that can pre-render your SPA for search engines, giving you the best of both worlds: the comparative ease and practicality of CSR along with the SEO implications of SSR.",
	"CI - Building - Compilation - Type - ByPlace - CSR - tools - Prerender - Prerender.io": ".",
	"CI - Building - Compilation - Type - ByPlace - CSR - tools - Prerender - Rendertron": ".",
	"CI - Building - Compilation - Type - ByPlace - CSR - libs - Remix": ".",
	"CI - Building - Compilation - Type - ByPlace - SSG": "HTML is pre-generated at build time and served as static files.",
	"CI - Building - Compilation - Type - ByPlace - SSG - Features - SEO": "Friendly (HTML is pre-built)",
	"CI - Building - Compilation - Type - ByPlace - SSG - Features - Prerendering": "Prerendering, commonly referred to as Static Site Generation (SSG), represents the method by which pages are rendered to static HTML files during the build process.",
	"CI - Building - Compilation - Type - ByPlace - SSG - Features - performance": "Prerendering maintains the same performance benefits of server-side rendering (SSR) but achieves a reduced Time to First Byte (TTFB), ultimately enhancing user experience. The key distinction lies in its approach that pages are served as static content, and there is no request-based rendering.",
	"CI - Building - Compilation - Type - ByPlace - SSG - libs - NextJS": ".",
	"CI - Building - Compilation - Type - ByPlace - SSG - libs - GatsbyJS": ".",
	"CI - Building - Compilation - Type - ByPlace - SSG - libs - Astro": ".",
	"CI - Building - Compilation - Type - ByPlace - SSR": "HTML is generated on the server for each request.",
	"CI - Building - Compilation - Type - ByPlace - SSR - Features - SEO": "Friendly (HTML is pre-rendered)",
	"CI - Building - Compilation - Type - ByPlace - SSR - Features - Hydration": "Hydration is the process that restores the server-side rendered application on the client associating JavaScript functionality with the DOM elements.",
	"CI - Building - Compilation - Type - ByPlace - SSR - Features - Hydration - Scope - reusing": "reusing the server rendered DOM structures.",
	"CI - Building - Compilation - Type - ByPlace - SSR - Features - Hydration - Scope - state": "persisting the application state.",
	"CI - Building - Compilation - Type - ByPlace - SSR - Features - Hydration - Scope - data": "transferring application data that was retrieved already by the server.",
	"CI - Building - Compilation - Type - ByPlace - SSR - Features - Hydration - Scope - listeners": "attaching event listeners and making a server-rendered HTML page interactive",
	"CI - Building - Compilation - Type - ByPlace - SSR - Features - Hydration - Selective": "",
	"CI - Building - Compilation - Type - ByPlace - SSR - Features - Hydration - Selective - Partial": "Partial Hydration: Instead of hydrating the entire page, selective hydration focuses on hydrating only the components that are immediately necessary for user interaction (e.g., above-the-fold content or interactive elements like buttons).",
	"CI - Building - Compilation - Type - ByPlace - SSR - Features - Hydration - Selective - Lazy": "Lazy Hydration: Non-critical components are hydrated lazily, either when they come into the viewport or when the user interacts with them.",
	"CI - Building - Compilation - Type - ByPlace - SSR - Features - Hydration - Selective - Priority": "Priority-Based Hydration: Components are prioritized based on their importance to the user experience. For example, a search bar or a call-to-action button might be hydrated before a footer or less critical content.",
	"CI - Building - Compilation - Type - ByPlace - SSR - Features - Hydration - Mismatch": "Hydration mismatch occurs in Server-Side Rendering (SSR) when the HTML generated on the server does not match the HTML generated on the client during the initial render. This discrepancy can lead to errors, broken functionality, or unexpected behavior in your React application.",
	"CI - Building - Compilation - Type - ByPlace - SSR - Features - Hydration - Mismatch - Causes - DifferentHTML": "The most common cause is when the server and client generate different HTML for the same component. This can happen due to: Conditional rendering that depends on client-only data (e.g., window or document). Differences in data fetching between server and client. Incorrect handling of dynamic content.",
	"CI - Building - Compilation - Type - ByPlace - SSR - Features - Hydration - Mismatch - Causes - BrowserSpecificAPIs": "Using browser-specific APIs (e.g., window, document, localStorage) during server-side rendering can cause mismatches because these APIs are not available on the server.",
	"CI - Building - Compilation - Type - ByPlace - SSR - Features - Hydration - Mismatch - Causes - TimingIssues": "If data fetching or state initialization behaves differently on the server and client, it can lead to mismatched HTML.",
	"CI - Building - Compilation - Type - ByPlace - SSR - Features - Hydration - Mismatch - Causes - Libs": "Some third-party libraries may behave differently on the server and client, leading to mismatches..",
	"CI - Building - Compilation - Type - ByPlace - SSR - Time - AOT": "AOT is a natural fit for SSR.",
	"CI - Building - Compilation - Type - ByPlace - SSR - Time - JIT": "Balance: increase server load",
	"CI - Building - Compilation - Type - ByPlace - SSR - libs - NextJS": ".",
	"CI - Building - Compilation - Type - ByPlace - SSR - libs - NuxtJS": ".",
	"CI - Building - Compilation - Type - ByPlace - SSR - libs - Remix": ".",
	"CI - Building - Compilation - Type - ByPlace - SSR - libs - SvelteKit": "https://itnext.io/frontend-development-beyond-react-svelte-1-3-f47eda22cba5.",
	"CI - Building - Compilation - Type - ByPlace - SSR - libs - FastHTML": "https://blog.stackademic.com/level-up-your-ssr-game-with-fasthtml-react-vue-and-more-weve-got-you-covered-dc363c19218b",
	"CI - Building - Compilation - Type - ByPlace - SSR vs CSR": "By leveraging modern JavaScript capabilities, static site generation, and third-party services, you can build fast, SEO-friendly applications without the need for server-side rendering."

}