{

	"JackRabbit": "SECTION",

	"Write": "SECTION",
	"Write - ObjectContentMapping": "Jackrabbit OCM is a framework used to persist java objects (pojos) in a JCR repository including association, inheritance, polymorphism, composition, and the Java collections framework. It offers also features like version support, object locking and express queries with Java-based criteria, as well as with JCR query languages.",
	"Write - Import": "",
	"Write - Import - Session.import": "",
	"Write - Import - ImportUUIDBehavior": "",
	"Write - Import - ImportUUIDBehavior - IMPORT_UUID_CREATE_NEW": "Incoming nodes are added in the same way that new node is added with Node.addNode. That is, they are either assigned newly created identifiers upon addition or upon save. In either case, identifier collisions will not occur.",
	"Write - Import - ImportUUIDBehavior - IMPORT_UUID_COLLISION_REMOVE_EXISTING": "If an incoming node has the same identifier as a node already existing in the workspace then the already existing node (and its subgraph) is removed from wherever it may be in the workspace before the incoming node is added. Note that this can result in nodes “disappearing” from locations in the workspace that are remote from the location to which the incoming subgraph is being written. Both the removal and the new addition will be dispatched on save.",
	"Write - Import - ImportUUIDBehavior - IMPORT_UUID_COLLISION_REPLACE_EXISTING": "If an incoming node has the same identifier as a node already existing in the workspace, then the already-existing node is replaced by the incoming node in the same position as the existing node. Note that this may result in the incoming subgraph being disaggregated and “spread around” to different locations in the workspace. In the most extreme case this behavior may result in no node at all being added as child of parentAbsPath. This will occur if the topmost element of the incoming XML has the same identifier as an existing node elsewhere in the workspace. The change will be dispatched on save.",
	"Write - Import - ImportUUIDBehavior - IMPORT_UUID_COLLISION_THROW": "If an incoming node has the same identifier as a node already existing in the workspace then an ItemExistsException is thrown.",

	"Read": "SECTION",
	"Read - Query": "",
	"Read - Search": "",
	"Read - Export": "",
	"Read - Observation": "",
	"Read - Observation - JCRObservationManager": "",
	"Read - Observation - ClusterAwareEventProcessing": "Sometimes events must only be processed by the cluster node where the event originated, or only by cluster nodes where the event didn't originate. Each event contains an 'external' flag that indicated whether the event originated on another cluster node, that means whether the code that manipulated the node ran in another cluster node.",
	"Read - Observation - SynchronousObservationListener": "By default Jackrabbit call observation listeners some time after the event occurs. However, synchronous observation is supported as well. To use it, the observation listener needs to implement the interface org.apache.jackrabbit.core.observation.Synchronous{{`Event}}`Listener. Please note that this interface is not part of the Jackrabbit API, and should only be used if really required.\n\nA synchronous event listener should never write to the repository using the same session that was used to create it.",

	"Connecting": "SECTION",
	"Connecting - Authorizable": "An Authorizable is repository object that is neither associated with nor depending from a particular Session and thus independent of the login mechanisms creating Sessions.",
	"Connecting - Authorizable - Access": "It provides access to the Principals associated with an Authorizable (see below) and allow to access and modify additional properties such as e.g. full name, e-mail or address.",
	"Connecting - Authorizable - Types": "The Authorizable is the common base interface for User and Group.",
	"Connecting - Authorizable - Types - User": "defined to be an Authorizable that can be authenticated (by using Credentials) and impersonated.",
	"Connecting - Authorizable - Types - User - UserManager": "",
	"Connecting - Authorizable - Types - Group": "defined to be a collection of other Authorizables.",
	"Connecting - Credentials": "",
	"Connecting - Credentials - GuestCredentials": "",
	"Connecting - Login": "",
	"Connecting - Login - JAAS": "By default Jackrabbit uses the Java Authentication and Authorization Service (JAAS) to authenticate users who try to access the repository. The appName parameter in the <Security/> element is used as the JAAS application name of the repository.",
	"Connecting - Login - LoginModule": "If JAAS authentication is not available or (as is often the case) too complex to set up, Jackrabbit allows you to specify a repository-specific JAAS LoginModule that is then used for authenticating repository users.",
	"Connecting - Login - LoginModule - SimpleLoginModule": " The default SimpleLoginModule class included in Jackrabbit implements a trivially simple authentication mechanism that accepts any username and any password as valid authentication credentials.",
	"Connecting - AccessManager": "Once a user has been authenticated, Jackrabbit will use the configured AccessManager to control what parts of the repository content the user is allowed to access and modify.",
	"Connecting - AccessManager - SimpleAccessManager": "Once a user has been authenticated, Jackrabbit will use the configured AccessManager to control what parts of the repository content the user is allowed to access and modify. The default [SimpleAccessManager|http://jackrabbit.apache.org/api/1.5/org/apache/jackrabbit/core/security/SimpleAccessManager.html] class included in Jackrabbit implements a trivially simple authorization mechanism that grants full read access to all users and write access to everyone except anonymous users.",
	"Connecting - AccessManager - SimpleJBossAccessManager": "The slightly more advanced SimpleJBossAccessManager class was added in Jackrabbit 1.3 (see JCR-650). This class is designed for use with the JBoss Application Server, where it maps JBoss roles to Jackrabbit permissions.",
	"Connecting - Permissions - Privileges": "",
	"Connecting - Permissions - Privileges - Basic - jcr:read": "The privilege to retrieve a node and get its properties and their values.",
	"Connecting - Permissions - Privileges - Basic - jcr:modifyProperties": "The privilege to create, remove and modify the values of the properties of a node.",
	"Connecting - Permissions - Privileges - Basic - jcr:addChildNodes": "The privilege to create child nodes of a node.",
	"Connecting - Permissions - Privileges - Basic - jcr:removeNode": "The privilege to remove a node.",
	"Connecting - Permissions - Privileges - Basic - jcr:removeChildNodes": "The privilege to remove child nodes of a node.",
	"Connecting - Permissions - Privileges - Basic - jcr:write": "An aggregate privilege that contains: jcr:read, jcr:modifyProperties, jcr:addChildNodes, jcr:removeNode, jcr:removeChildNodes.",
	"Connecting - Permissions - Privileges - Advanced": "",
	"Connecting - Permissions - Privileges - Custom": "",
	"Connecting - Permissions - Privileges - jcr:all": "An aggregate privilege that contains all available permissions, including jcr:read, jcr:write and the advanced permssions.",
	"Connecting - Permissions - Privileges - Privilege": "",
	"Connecting - Permissions - ACLs": "The JCR 2.0 specification is modeled with resource-based access control lists in mind. That means that a resource = node is associated with a list of allow/deny entries for certain principals (users or groups), which naturally maps to store them along the JCR node. A core concept of resource-based ACLs is that they inherit the ACLs from the parent node, thus for each node, all the ACLs of its ancestor come into play as well.\n\nResource-based ACLs are the default access control mechanism in Jackrabbit 2.x.",
	"Connecting - Permissions - ACLs - ResourceBased - Advantages": "fully supported by the JCR API / specification\nvery widely available ACL model (eg. file systems)\nsimple resource inheritance\ndefault mechanism in Jackrabbit, no configuration needed ",
	"Connecting - Permissions - ACLs - ResourceBased - Disadvantages": "cannot assign ACLs to non-existent nodes\ncumbersome when many users need un-groupable ACLs on a few resources (e.g. \"subscriptions\"), lots of ACL entries per resource\npermissions are stored right inside the content (can be cumbersome for backups, etc.) ",
	"Connecting - Permissions - ACLs - ResourceBased - Storage": "Resource-based ACLs are stored per resource/node in a special child node rep:policy. This one will have a list of rep:GrantACE child nodes (usually named allow, allow0,...) for grant access control entries and rep:DenyACE child nodes (usually named deny, deny0,...) for deny access control entries.\n\nEach ACE node has a rep:principalName STRING property pointing to the user or group this ACE belongs to, and a rep:privileges NAME multi-value property, containing all the privileges of this ACE.\n\nNote that you can read/browse these nodes using the JCR API, but cannot modify them. This must always happen through the JCR access control API.",
	"Connecting - Permissions - ACLs - ResourceBased - AccessControlManager": "",
	"Connecting - Permissions - ACLs - ResourceBased - AccessControlPolicy": "",
	"Connecting - Permissions - ACLs - ResourceBased - AccessControlList": "",
	"Connecting - Permissions - ACLs - ResourceBased - AccessControlEntry": "",
	"Connecting - Permissions - ACLs - PrincipalBased": "Principal-based ACLs\n\nA different approach for specifying and storing ACLs is to assign certain principals (users or groups) a list of nodes that they are allowed or denied to work on. The nodes will be referenced by paths, and might even include wildcards.\n\nTo work with principal-based ACLs, a Jackrabbit-propietary extension to the ACL management API is required.",
	"Connecting - Permissions - ACLs - PrincipalBased - Advantages": "permissions can be assigned to non-existent nodes\npermissions are stored separately from the content (good for content replication, backup etc.)\ngood for having many users with un-groupable ACLs (e.g. \"subscriptions\"); resources don't get filled up with ACL entries ",
	"Connecting - Permissions - ACLs - PrincipalBased - Disadvantages": "additional Jackrabbit API has to be used for setting ACLs\nmodeling resource inheritance requires more ACLs than resource-based ",
	"Connecting - Permissions - ACLs - PrincipalBased - Storage": "How Principal-based ACLs are stored\n\nAn access control list (rep:ACL) is stored for each user and group (this is transparent, currently it's mirroring the users's home path at /rep:accesscontrol/<principal-path>/rep:policy/). This consists of entries (rep:ACE), which are either allow (rep:GrantACE) or deny (rep:DenyACE) entries.\n\nThe rep:ACE nodetype (used by both resource- and principal-based ACLs) defines the following two properties for principal-based usage. These exact same names need to be used as restrictions when using the Jackrabbit API (JackrabbitAccessControlList.addEntry()):\n\n    rep:nodePath defines the (base) path of a subtree the ACL applies to (mandatory, PATH property)\n    rep:glob defines a glob pattern to restrict the subtree, both child nodes & properties (only a path matching is done) (optional, STRING property) ",
	"Connecting - Permissions - ACLs - PrincipalBased - Principal": "",
	"Connecting - Permissions - ACLs - PrincipalBased - PrincipalManager": "",
	"Connecting - Permissions - ACLs - PrincipalBased - JackrabbitAccessControlManager": "",
	"Connecting - Permissions - ACLs - PrincipalBased - JackrabbitAccessControlPolicy": "",
	"Connecting - Permissions - ACLs - PrincipalBased - JackrabbitAccessControlList": "",
	"Connecting - Permissions - ACLs - PrincipalBased - JackrabbitAccessControlEntry": "",
	"Connecting - Permissions - ACLs - Custom - AccessControlProvider": "To use a different ACL mechanism, a different AccessControlProvider must be configured. This is a per-workspace config, and must be set in the workspace.xml of each workspace, or the <Workspace/> element of the repository.xml for to-be-created workspaces.",
	"Connecting - Session": "",
	"Connecting - Session - JackrabbitSession": "",
	"Connecting - Access - Locking": "The repository lock mechanism ensures that only one Jackrabbit instance can open the same repository at one time.",
	"Connecting - Access - Locking - Motivation": "Jackrabbit works like a file system or database: to improve performance, Jackrabbit caches frequently used data, and keeps transient changes in memory until they are saved explicitly. Therefore, to avoid inconsistencies and corruption, it must be ensured that the same repository is only accessed by one process at a time.",
	"Connecting - Access - Locking - .lock": "By default, when a repository is started, Jackrabbit tries to create a file named .lock in the repository home directory and protects it using using a native file lock. If the repository is already in use, this will fail",
	"Connecting - Access - Locking - .lock - delete": "Deleting the lock file manually is normally not necessary, even if the repository was not closed before.\n\nThe only case where it may be required to manually delete the repository lock file is when using an NFS share (for some NFS implementations), and the NFS server died and was re-started. Some NFS servers will not release the file lock in this case.",
	"Connecting - Access - Locking - .lock - RepositoryLockMechanism": "Since Jackrabbit 1.6 an alternative repository locking mechanism is available.\n\nSome NFS implementations do not release native locks after a hard reboot. In this case the workaround is to manually delete all .lock files. Older NFS implementation throw the exception \"No locks available\", which means the NFS does not support native file locks.\n\nTo solve this problem, Jackrabbit also supports cooperative file locking. This mechanism is not based on native file locks, but instead uses background threads that periodically update a sentinel file (lock.properties). The algorithm of cooperative file locking is described below. To use cooperative file locking, add this to your repository.xml before the </Repository> tag:\n\n<RepositoryLockMechanism class=\"org.apache.jackrabbit.core.util.CooperativeFileLock\" />\n\n",
	"Connecting - Access - Locking - .lock - RepositoryLockMechanism - algorithm": "The cooperative file locking works as follows:\n\n    If the lock.properties file does not exist, it is created (using the atomic operation File.createNewFile). Then, the process waits a little bit and checks the file again. If the file was changed during this time, the operation is aborted. This protects against a race condition when one process deletes the lock file just after another one create it, and a third process creates the file again. It does not occur if there are only two writers.\n    If the file can be created, a random id is inserted. Afterwards, a watchdog thread is started that checks regularly (every second once by default) if the file was deleted or modified by another (challenger) thread or process. Whenever that occurs, the file is overwritten with the old data. The watchdog thread runs with high priority so that a change to the file does not get through undetected even if the system is very busy. However, the watchdog thread does use very little resources (CPU time), because it waits most of the time. Also, the watchdog only reads from the hard disk and does not write to it.\n    If the file exists and was recently modified, the process waits for some time (up to two seconds). If it was still changed, an exception is thrown. This is done to eliminate race conditions with many concurrent writers. Afterwards, the file is overwritten with a new version (challenge). After that, the thread waits for 2 seconds. If there is a watchdog thread protecting the file, he will overwrite the change and this process will fail to lock the repository. However, if there is no watchdog thread, the file will still be as written by this thread. In this case, the file is deleted and atomically created again. The watchdog thread is started in this case and the file is locked.\n",
	"Connecting - Access - RepositoryServer": "Jackrabbit supports multiple Deployment Models. To access the same repository from multiple computers or processes, use a Repository Server.",
	"Connecting - Access - Clustering": "Clustering in Jackrabbit works as follows: content is shared between all cluster nodes. That means all Jackrabbit cluster nodes need access to the *same* persistent storage (persistence manager, data store, and repository file system).\n\nThe persistence manager must be clusterable (eg. central database that allows for concurrent access, see PersistenceManagerFAQ); any DataStore (file or DB) is clusterable by its very nature, as they store content by unique hash ids.\n\nHowever, each cluster node needs its own (private) repository directory, including repository.xml file, workspace FileSystem and Search index.\n\nEvery change made by one cluster node is reported in a journal, which can be either file based or written to some database.",
	"Connecting - Access - Clustering - limitations": "Session scoped locks currently have no effect on other cluster nodes - see http://issues.apache.org/jira/browse/JCR-1173",
	"Connecting - Access - Clustering - requirements": "In order to use clustering, the following prerequisites must be met:\n\n    Each cluster node must have its own repository configuration.\n    A DataStore must always be shared between nodes, if used.\n    The global FileSystem on the repository level must be shared (only the one that is on the same level as the data store; only in the repository.xml file).\n    Each cluster node needs its own (private) workspace level and version FileSystem (only those within the workspace and versioning configuration; the ones in the repository.xml and workspace.xml file).\n    Each cluster node needs its own (private) Search indexes.\n    Every cluster node must be assigned a unique ID.\n    A journal type must be chosen, either based on files or stored in a database.\n    Each cluster node must use the same (shared) journal.\n    The persistence managers must store their data in the same, globally accessible location (see PersistenceManagerFAQ). ",
	"Connecting - Access - Clustering - UniqueClusterId": "Every cluster node needs a unique ID. This ID can be either specified in the cluster configuration as id attribute or as value of the system property org.apache.jackrabbit.core.cluster.node_id. When copying repository configurations, do not forget to adapt the cluster node IDs if they are hardcoded. See below for some sample cluster configurations. A cluster id can be freely defined, the only requirement is that it has to be different on each cluster node.",
	"Connecting - Access - Clustering - SyncDelay": "By default, cluster nodes read the journal and update their state every 5 seconds (5000 milliseconds). To use a different value, set the attribute syncDelay in the cluster configuration.",
	"Connecting - Access - Clustering - RemovingOldRevisions": "The journal in which cluster nodes write their changes can potentially become very large. By default, old revisions are not removed. This enables one to add a cluster node without much work: the new cluster node just replays the journal to get up to date (of course, if the journal contains data from two years of work then this might take a while...)\n\nAs of Jackrabbit 1.5 there is the possibility to automatically clean the database-based journal. The local revision counter is automatically migrated to a new table in the database called LOCAL_REVISIONS. To support a proper migration the \"revision\" parameter must be present in the configuration. After the migration it can be removed.\n\nThe clean-up task can be configured with three parameters:\n\n    janitorEnabled specifies whether the clean-up task for the journal table is enabled (default = false)\n    janitorSleep specifies the sleep time of the clean-up task in seconds (only useful when the clean-up task is enabled, default is 24 hours)\n    janitorFirstRunHourOfDay specifies the hour at which the clean-up task initiates its first run (default = 3, which means 3:00 at night)\n\nThe current solution has three known caveats:\n\n    If the janitor is enabled then you loose the possibility to easily add cluster nodes. (It is still possible but takes detailed knowledge of Jackrabbit.)\n    You must make sure that all cluster nodes have written their local revision to the database before the clean-up task runs for the first time because otherwise cluster nodes might miss updates (because they have been purged) and their local caches and search-indexes get out of sync.\n    If a cluster node is removed permanently from the cluster, then its entry in the LOCAL_REVISIONS table should be removed manually. Otherwise, the clean-up thread will not be effective. ",
	"Connecting - Access - Clustering - AddNewClusterNodes": "Easily add new cluster nodes\n\n    Shutdown one of your instances\n    Get the current revision number that instance was from your database\n    Copy your whole Jackrabbit repository directory to another server/location\n    Start your original Jackrabbit again\n    Change the copied repository.xml with a new nodename in your clusterconfig\n    Add that nodename to your DB in JOURNAL_LOCAL_REVISIONS with the number from the original instance\n    Start your new Jackrabbit instance (or keep it for backup purposes) ",
	"Connecting - Access - Clustering - JournalType": "The cluster nodes store information identifying items they modified in a journal. This journal must again be globally available to all nodes in the cluster. This can be either a folder in the file system or a database running standalone.",
	"Connecting - Access - Clustering - JournalType - FileJournal": "The file journal is configured through the following properties:\n\n    revision: location of the cluster node's revision file\n    directory: location of the journal folder ",
	"Connecting - Access - Clustering - JournalType - DatabaseJournal": "There are three Journal classes:\n\n    org.apache.jackrabbit.core.journal.DatabaseJournal\n    org.apache.jackrabbit.core.journal.OracleDatabaseJournal\n    org.apache.jackrabbit.core.journal.MSSqlDatabaseJournal\n\nIf you use Oracle, you do need to use the OracleDatabaseJournal. The DatabaseJournal will not work.\n\nThe database journal is configured through the following properties:\n\n    revision: location of the cluster node's revision file\n    driver: JDBC driver class name\n    url: JDBC URL\n    user: user name\n    password: password ",
	"Connecting - JcrUtils": "",

	"Repository": "SECTION",
	"Repository - TransientRepository": "The TransientRepository implementation will automatically initialize the content repository when the first session is started and shut it down when the last session is closed. Thus there is no need for explicit repository shutdown as long as all sessions are properly closed. Note that a Jackrabbit repository directory contains a lock file that prevents it from being accessed simultaneously by multiple processes. You will see repository startup exceptions caused by the lock file if you fail to properly close all sessions or otherwise shut down the repository before leaving the process that accesses a repository. Normally you can just manually remove the lock file in such cases but such cases always present a chance of repository corruption especially if you use a non-transactional persistence manager.",
	"Repository - NamespaceRegistry": "",
	"Repository - Configuration": "Apache Jackrabbit needs two pieces of information to set up a runtime content repository instance: Repository home directory, Repository configuration file. These two configuration parameters are passed either directly to Jackrabbit when creating a repository instance or indirectly through settings for a JNDI object factory or some other component management system.",
	"Repository - Configuration - repository.xml": "The repository configuration file, typically called repository.xml, specifies global options like security, versioning and clustering settings. A default workspace configuration template is also included in the repository configuration file.",
	"Repository - Configuration - HomeDirectory": "The filesystem path of the directory containing the content repository accessed by the runtime instance of Jackrabbit. This directory usually contains all the repository content, search indexes, internal configuration, and other persistent information managed within the content repository. Note that this is not absolutely required and some persistence managers and other Jackrabbit components may well be configured to access files and even other resources (like remote databases) outside the repository home directory. A designated repository home directory is however always needed even if some components choose to not use it. Jackrabbit will automatically fill in the repository home directory with all the required files and subdirectories when the repository is first instantiated.",
	"Repository - Configuration - ConfigurationFile": "The filesystem path of the repository configuration XML file. This file specifies the class names and properties of the various Jackrabbit components used to manage and access the content repository. Jackrabbit parses this configuration file and instantiates the specified components when the runtime content repository instance is created.",
	"Repository - Configuration - ConfigurationElement": "Most of the entries in the configuration file are based on the following generic JavaBean configuration pattern. Such configuration specifies that the repository should use an instance of the specified class with the specified properties for the named functionality.",
	"Repository - Configuration - ConfigurationElement - FileSystem": "The virtual file system used by the repository to store things like registered namespaces and node types.",
	"Repository - Configuration - ConfigurationElement - FileSystem - LocalFileSystem": ".",
	"Repository - Configuration - ConfigurationElement - FileSystem - DatabaseFileSystem": ".",
	"Repository - Configuration - ConfigurationElement - FileSystem - MemoryFileSystem": ".",
	"Repository - Configuration - ConfigurationElement - Security": "The security configuration element is used to specify authentication and authorization settings for the repository.",
	"Repository - Configuration - ConfigurationElement - Security - SecurityManager": ".",
	"Repository - Configuration - ConfigurationElement - Security - AccessManager": ".",
	"Repository - Configuration - ConfigurationElement - Security - LoginModule": ".",
	"Repository - Configuration - ConfigurationElement - Versioning": "Configuration of the repository-wide version store.",
	"Repository - Configuration - ConfigurationElement - Versioning - FileSystem": "The virtual file system passed to the persistence manager.",
	"Repository - Configuration - ConfigurationElement - Versioning - PersistenceManager": "Persistence configuration for the version store.",
	"Repository - Configuration - ConfigurationElement - Versioning - ISMLocking": "Locking configuration for concurrent access to workspace content.",
	"Repository - Configuration - ConfigurationElement - SearchIndex": "Configuration of the search index that covers the repository-wide /jcr:system content tree.",
	"Repository - Configuration - ConfigurationElement - Cluster": "Clustering configuration.",
	"Repository - Configuration - ConfigurationElement - DataStore": "Data store configuration. The data store is optionally used to store large binary values. Normally all node and property data is stored in a persistence manager, but for large binaries such as files special treatment can improve performance and reduce disk usage.\n\nThe main features of the data store are:\n\n    Space saving: only one copy per unique object it kept\n    Fast copy: only the identifier is copied\n    Storing and reading does not block others\n    Multiple repositories can use the same data store\n    Objects in the data store are immutable\n    Garbage collection is used to purge unused objects\n    Hot backup is supported\n    Clustering: all cluster nodes use the same data store ",
	"Repository - Configuration - ConfigurationElement - DataStore - FileDataStore": "The file data store stores each binary in a file. The file name is the hash code of the content. When reading, the data is streamed directly from the file (no local or temporary copy of the file is created). The file data store does not use any local cache, that means content is directly read from the files as needed. New content is first stored in a temporary file, and later renamed / moved to the right place.\n\nBecause the data store is append-only, the FileDataStore is guaranteed to be consistent after a crash (unlike the BundleFsPersistenceManager). It is usually faster than the DbDataStore, and the preferred choice unless you have strict operational reasons to put everything into a database.\n",
	"Repository - Configuration - ConfigurationElement - DataStore - DatabaseDataStore": "The database data store stores data in a relational database. All content is stored in one table, the unique key of the table is the hash code of the content.\n\nWhen reading, the data may be first copied to a temporary file on the server, or streamed directly from the database (depending on the copyWhenReading setting). New content is first stored in the table under a unique temporary identifier, and later the key is updated to the hash of the content.\n\nWhen adding a record, by default the stream is first copied to a temporary file. If you get the exception \"Can not insert new record java.io.IOException: No space left on device\" that means your temporary directory is too small. The reason for the temp file is: most databases need to know the stream size when adding a record, and the JCR API doesn't provide a way to do that. The mechanism used to add a record depends on the property \"storeStream\" in resource org/apache/jackrabbit/core/data/db/<databaseType>.properties. Implemented mechanisms are: \"tempFile\" (default; create a temp file before adding a record), \"-1\" (use the length -1 when adding the record; currently only supported by the H2 database), and \"max\" (use the length Integer.MAX_VALUE).",
	"Repository - Configuration - ConfigurationElement - DataStore - GarbageCollection": "The data store never deletes entries except when running data store garbage collection. Similar to Java heap garbage collection, data store garbage collection will first mark all used entries, and later remove unused items.\n\nData store garbage collection does not delete entries if the identifier is still in the Java heap memory. To delete as many unreferenced entries as possible, call System.gc() a few times before running the data store garbage collection. Please note System.gc() does not guarantee all objects are garbage collected.",
	"Repository - Configuration - ConfigurationElement - DataStore - GarbageCollection - DataStoreGarbageCollector": ".",
	"Repository - Configuration - ConfigurationElement - Workspaces": "The Workspaces element of the repository configuration specifies where and how the workspaces are managed.",
	"Repository - Configuration - ConfigurationElement - Workspaces - attrs - rootPath": "The native file system directory for workspaces. A subdirectory is automatically created for each workspace, and the path of that subdirectory can be used in the workspace configuration as the ${wsp.path} variable.",
	"Repository - Configuration - ConfigurationElement - Workspaces - attrs - defaultWorkspace": "Name of the default workspace. This workspace is automatically created when the repository is first started.",
	"Repository - Configuration - ConfigurationElement - Workspaces - attrs - configRootPath": "By default the configuration of each workspace is stored in a workspace.xml file within the workspace directory within the rootPath directory. If this option is specified, then the workspace configuration files are stored within the specified path in the virtual file system (see above) configured for the repository.",
	"Repository - Configuration - ConfigurationElement - Workspaces - attrs - maxIdleTime": "By default Jackrabbit only releases resources associated with an opened workspace when the entire repository is closed. This option, if specified, sets the maximum number of seconds that a workspace can remain unused before the workspace is automatically closed.",
	"Repository - Configuration - ConfigurationElement - Workspace": "Default workspace configuration template. A Jackrabbit repository contains one or more workspaces.",
	"Repository - Configuration - ConfigurationElement - Workspace - workspace.xml": "The repository configuration also contains a default workspace configuration template that is used to create the workspace.xml file of a new workspace unless more specific configuration is given when the workspace is created.",
	"Repository - Configuration - ConfigurationElement - Workspace - FileSystem": "The virtual file system passed to the persistence manager and search index.",
	"Repository - Configuration - ConfigurationElement - Workspace - PersistenceManager": "Persistence configuration for workspace content.",
	"Repository - Configuration - ConfigurationElement - Workspace - SearchIndex": "Configuration of the workspace search index.",
	"Repository - Configuration - ConfigurationElement - Workspace - ISMLocking": "Locking configuration for concurrent access to workspace content.",
	"Repository - Item": "",
	"Repository - Item - ItemManager": "",
	"Repository - Item - ItemId": "",
	"Repository - Item - ItemImpl": "",
	"Repository - Node": "",
	"Repository - Node - NodeId": "",
	"Repository - Node - NodeImpl": "",
	"Repository - Node - Nodetype": "Each node in a Jackrabbit workspace tree has a node type that defines the child nodes and properties it may (or must) have. Developers can use node types to define a custom content model for their application domain and have Jackrabbit enforce the constraints of that model at the repository level.",
	"Repository - Node - Nodetype - Categories": "There are two categories of node types, primary and mixin.",
	"Repository - Node - Nodetype - Categories - Primary": "The primary node type of a node usually defines node structure (i.e., allowed and required child nodes and properties) related to the problem domain being modeled. For example, a node used in storing content about business contacts might have the primary type myapp:Contact which defines properties such as myapp:givenName, myapp:familyName and so forth.",
	"Repository - Node - Nodetype - Categories - Primary - Inheritance": "Primary node types are arranged in an inheritance hierarchy. Every primary node type must be the subtype of at least one existing node type. The built-in node type nt:base serves as the root of this hierarchy. Jackrabbit supports multiple inheritance of node types so node types can have more than one supertyp",
	"Repository - Node - Nodetype - Categories - Mixin": "Mixin node types usually specify additional properties or child nodes related to a capability being added to the node. These capabilities may include generic repository-level functions as in the case of the built-in mixins mix:versionable and mix:lockable, for example, or domain-level capabilities such as a (hypothetical) myapp:Emailable mixin type that adds the property myapp:emailAddress to a node.",
	"Repository - Node - Nodetype - Attrs": "",
	"Repository - Node - Nodetype - Attrs - Name": "Every node type registered with the repository has a unique name. The naming conventions for node types are the same as for items (i.e., they may have a colon delimited prefix).",
	"Repository - Node - Nodetype - Attrs - Supertypes": "A primary node type (with the exception of nt:base) must extend another node type (and may extend more than one node type). A mixin node type may extend another node type.",
	"Repository - Node - Nodetype - Attrs - MixinStatus": "A node type may be either primary or mixin.",
	"Repository - Node - Nodetype - Attrs - OrderableChildNodesStatus": "A primary node type may specify that child nodes are client-orderable. If this status is set to true, then Node.orderBefore can be used to set the order of child nodes. Only primary node types control a node's status in this regard. This setting on a mixin node type will not have any effect on the node.",
	"Repository - Node - Nodetype - Attrs - PropertyDefinitions": "A node type contains a set of definitions specifying the properties that nodes of this node type are allowed (or required) to have and the characteristics of those properties (see below).",
	"Repository - Node - Nodetype - Attrs - PropertyDefinitions - Params": "",
	"Repository - Node - Nodetype - Attrs - ChildNodeDefinitions": "A node type contains a set of definitions specifying the child nodes that nodes of this node type are allowed (or required) to have and the characteristics of those child nodes (including, in turn, their node types, see below).",
	"Repository - Node - Nodetype - Attrs - ChildNodeDefinitions - Params": "",
	"Repository - Node - Nodetype - Attrs - PrimaryItemName": "A node type may specify one child item (property or node) by name as the primary item. This indicator is used by the method Node.getPrimaryItem().",
	"Repository - Node - Nodetype - NodeTypeNotation": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - All": "node_type_def ::= node_type_name [supertypes] [options] {property_def | child_node_def}",
	"Repository - Node - Nodetype - NodeTypeNotation - NodeType - ns": "Namespace <ns = 'http://namespace.com/ns'>",
	"Repository - Node - Nodetype - NodeTypeNotation - NodeType - [ns:NodeType]": "Node type name.",
	"Repository - Node - Nodetype - NodeTypeNotation - NodeType - Supertypes": "> ns:ParentType1, ns:ParentType2",
	"Repository - Node - Nodetype - NodeTypeNotation - NodeType - mixin": "This is a mixin node type",
	"Repository - Node - Nodetype - NodeTypeNotation - NodeType - Attributes - primary - default": "= ns:defaultType default primary node type of the child node",
	"Repository - Node - Nodetype - NodeTypeNotation - NodeType - Attributes - mandatory": "",
	"Repository - Node - Nodetype - NodeTypeNotation - NodeType - Attributes - autocreated": "",
	"Repository - Node - Nodetype - NodeTypeNotation - NodeType - Attributes - protected": "",
	"Repository - Node - Nodetype - NodeTypeNotation - NodeType - Attributes - multiple": "",
	"Repository - Node - Nodetype - NodeTypeNotation - NodeType - Attributes - Copy": "",
	"Repository - Node - Nodetype - NodeTypeNotation - NodeType - Attributes - Version": "",
	"Repository - Node - Nodetype - NodeTypeNotation - NodeType - Attributes - Initialize": "",
	"Repository - Node - Nodetype - NodeTypeNotation - NodeType - Attributes - Compute": "",
	"Repository - Node - Nodetype - NodeTypeNotation - NodeType - Attributes - Ignore": "",
	"Repository - Node - Nodetype - NodeTypeNotation - NodeType - Attributes - Abort": "",
	"Repository - Node - Nodetype - NodeTypeNotation - Property": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Types": "The property type is indicated by a keyword delimited by parentheses. If the property type declaration is missing a type of STRING is assumed.",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Types - String": "- ex:property (string)",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Types - Binary": "",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Types - Long": "",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Types - Double": "",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Types - Boolean": "",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Types - Date": "",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Types - Name": "",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Types - Path": "",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Types - Reference": "",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Types - Undefined": "",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Value": "The default value or values, in the case of a multi-value property, are indicated by an equal sign followed by either a single value in string form or a comma-delimited list of values. The values may be single-quoted. If the default value definition is missing then no default value is set.",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Value - Default": "= 'default1', 'default2' // The default values for this // (multi-value) property are...",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Constraints": "< 'constraint1', 'constraint2'",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Attributes": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Attributes - primary": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Attributes - autocreated": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Attributes - mandatory": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Attributes - protected": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Attributes - multiple": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Attributes - copy": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Attributes - version": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Attributes - initialize": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Attributes - compute": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Attributes - ignore": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - Property - Attributes - abort": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - Child": "child_node_def ::= '+' node_name [required_types] [default_type] [attributes] A child node definition consists of a plus sign followed by a property name, followed in turn by optional elements defining the required primary node types, the default node type, and the node attributes.",
	"Repository - Node - Nodetype - NodeTypeNotation - Child - Types": "+ ns:node (ns:reqType1, ns:reqType2)",
	"Repository - Node - Nodetype - NodeTypeNotation - Child - Required": "",
	"Repository - Node - Nodetype - NodeTypeNotation - Child - Default": "",
	"Repository - Node - Nodetype - NodeTypeNotation - Child - Attributes": "",
	"Repository - Node - Nodetype - NodeTypeNotation - Child - Attributes - primary": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - Child - Attributes - autocreated": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - Child - Attributes - mandatory": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - Child - Attributes - protected": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - Child - Attributes - multiple": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - Child - Attributes - copy": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - Child - Attributes - version": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - Child - Attributes - initialize": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - Child - Attributes - compute": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - Child - Attributes - ignore": ".",
	"Repository - Node - Nodetype - NodeTypeNotation - Child - Attributes - abort": ".",
	"Repository - Node - NodeIterator": "",
	"Repository - Property": "",
	"Repository - Property - PropertyId": "",
	"Repository - Property - PropertyImpl": "",
	"Repository - Property - PropertyIterator": "",
	"Repository - Value": "",
	"Repository - Value - JackrabbitValue": "",
	"Repository - Version": ""


}
