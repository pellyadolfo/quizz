{
	"Test Context Framework": "SECTION",
	"TestContext Framework": "The Spring TestContext Framework (located in the org.springframework.test.context package) provides generic, annotation-driven unit and integration testing support that is agnostic of the testing framework in use. The TestContext framework also places a great deal of importance on convention over configuration, with reasonable defaults that you can override through annotation-based configuration.",
	"TestContext Framework - TestContextManager": "TestContextManager is the main entry point into the Spring TestContext Framework and is responsible for managing a single TestContext and signaling events to each registered TestExecutionListener at well-defined test execution points: Prior to any 'before class' or 'before all' methods of a particular testing framework. Test instance post-processing. Prior to any 'before' or 'before each' methods of a particular testing framework. Immediately before execution of the test method but after test setup. Immediately after execution of the test method but before test tear down. After any 'after' or 'after each' methods of a particular testing framework. After any 'after class' or 'after all' methods of a particular testing framework.",
	"TestContext Framework - Bootstraping - TestContextBootstrapper": "TestContextBootstrapper defines the SPI for bootstrapping the TestContext framework. A TestContextBootstrapper is used by the TestContextManager to load the TestExecutionListener implementations for the current test and to build the TestContext that it manages.",
	"TestContext Framework - Bootstraping - TestContextBootstrapper - AbstractTestContextBootstrapper": "Since the TestContextBootstrapper SPI is likely to change in the future (to accommodate new requirements), we strongly encourage implementers not to implement this interface directly but rather to extend AbstractTestContextBootstrapper or one of its concrete subclasses instead.",
	"TestContext Framework - Bootstraping - @BootstrapWith": "You can configure a custom bootstrapping strategy for a test class (or test class hierarchy) by using @BootstrapWith, either directly or as a meta-annotation",
	"TestContext Framework - Bootstraping - @BootstrapWith - DefaultTestContextBootstrapper": "If a bootstrapper is not explicitly configured by using @BootstrapWith, either the DefaultTestContextBootstrapper or the WebTestContextBootstrapper is used, depending on the presence of @WebAppConfiguration.",
	"TestContext Framework - Bootstraping - @BootstrapWith - WebTestContextBootstrapper": "If a bootstrapper is not explicitly configured by using @BootstrapWith, either the DefaultTestContextBootstrapper or the WebTestContextBootstrapper is used, depending on the presence of @WebAppConfiguration.",
	"TestContext Framework - TestContext": "TestContext encapsulates the context in which a test is executed (agnostic of the actual testing framework in use) and provides context management and caching support for the test instance for which it is responsible. The TestContext also delegates to a SmartContextLoader to load an ApplicationContext if requested.",
	"TestContext Framework - TestContext - config - @ContextConfiguration - location - default": "By default, if you don�t provide the location or value attribute then the XML file it will look out for loading is {class}-context.xml.",
	"TestContext Framework - TestContext - config - @ContextConfiguration - location - xml": "To load an ApplicationContext for your tests by using XML configuration files, annotate your test class with @ContextConfiguration and configure the locations attribute with an array that contains the resource locations of XML configuration metadata. A plain or relative path (for example, context.xml) is treated as a classpath resource that is relative to the package in which the test class is defined. A path starting with a slash is treated as an absolute classpath location (for example, /org/example/config.xml). A path that represents a resource URL (i.e., a path prefixed with classpath:, file:, http:, etc.) is used as is.",
	"TestContext Framework - TestContext - config - @ContextConfiguration - location - groovy": "To load an ApplicationContext for your tests by using Groovy scripts that use the Groovy Bean Definition DSL, you can annotate your test class with @ContextConfiguration and configure the locations or value attribute with an array that contains the resource locations of Groovy scripts.",
	"TestContext Framework - TestContext - config - @ContextConfiguration - location - Annotated Classe": "To load an ApplicationContext for your tests by using annotated classes (see Java-based container configuration), you can annotate your test class with @ContextConfiguration and configure the classes attribute with an array that contains references to annotated classes.",
	"TestContext Framework - TestContext - config - @ContextConfiguration - location - xml + groovy + Annotated Classe": "It may sometimes be desirable to mix XML configuration files, Groovy scripts, and annotated classes (typically @Configuration classes) to configure an ApplicationContext for your tests. For example, if you use XML configuration in production, you may decide that you want to use @Configuration classes to configure specific Spring-managed components for your tests, or vice versa. Furthermore, some third-party frameworks (such as Spring Boot) provide first-class support for loading an ApplicationContext from different types of resources simultaneously (for example, XML configuration files, Groovy scripts, and @Configuration classes). The Spring Framework, historically, has not supported this for standard deployments. Consequently, most of the SmartContextLoader implementations that the Spring Framework delivers in the spring-test module support only one resource type for each test context. However, this does not mean that you cannot use both. One exception to the general rule is that the GenericGroovyXmlContextLoader and GenericGroovyXmlWebContextLoader support both XML configuration files and Groovy scripts simultaneously. Furthermore, third-party frameworks may choose to support the declaration of both locations and classes through @ContextConfiguration, and, with the standard testing support in the TestContext framework, you have the following options. If you want to use resource locations (for example, XML or Groovy) and @Configuration classes to configure your tests, you must pick one as the entry point, and that one must include or import the other. For example, in XML or Groovy scripts, you can include @Configuration classes by using component scanning or defining them as normal Spring beans, whereas, in a @Configuration class, you can use @ImportResource to import XML configuration files or Groovy scripts. Note that this behavior is semantically equivalent to how you configure your application in production: In production configuration, you define either a set of XML or Groovy resource locations or a set of @Configuration classes from which your production ApplicationContext is loaded, but you still have the freedom to include or import the other type of configuration.",
	"TestContext Framework - TestContext - config - @ContextConfiguration - Context Initializers": "To configure an ApplicationContext for your tests by using context initializers, annotate your test class with @ContextConfiguration and configure the initializers attribute with an array that contains references to classes that implement ApplicationContextInitializer. The declared context initializers are then used to initialize the ConfigurableApplicationContext that is loaded for your tests. Note that the concrete ConfigurableApplicationContext type supported by each declared initializer must be compatible with the type of ApplicationContext created by the SmartContextLoader in use (typically a GenericApplicationContext). Furthermore, the order in which the initializers are invoked depends on whether they implement Spring�s Ordered interface or are annotated with Spring�s @Order annotation or the standard @Priority annotation. ",
	"TestContext Framework - TestContext - config - @ContextConfiguration - Inheritance": "@ContextConfiguration supports boolean inheritLocations and inheritInitializers attributes that denote whether resource locations or annotated classes and context initializers declared by superclasses should be inherited. The default value for both flags is true. This means that a test class inherits the resource locations or annotated classes as well as the context initializers declared by any superclasses. Specifically, the resource locations or annotated classes for a test class are appended to the list of resource locations or annotated classes declared by superclasses. Similarly, the initializers for a given test class are added to the set of initializers defined by test superclasses. Thus, subclasses have the option of extending the resource locations, annotated classes, or context initializers. If the inheritLocations or inheritInitializers attribute in @ContextConfiguration is set to false, the resource locations or annotated classes and the context initializers, respectively, for the test class shadow and effectively replace the configuration defined by superclasses.",
	"TestContext Framework - TestContext - config - @ContextConfiguration - @WebApplicationContext": "Spring 3.2 introduced support for loading a WebApplicationContext in integration tests. To instruct the TestContext framework to load a WebApplicationContext instead of a standard ApplicationContext, you can annotate the respective test class with @WebAppConfiguration. The presence of @WebAppConfiguration on your test class instructs the TestContext framework (TCF) that a WebApplicationContext (WAC) should be loaded for your integration tests. In the background, the TCF makes sure that a MockServletContext is created and supplied to your test�s WAC. By default, the base resource path for your MockServletContext is set to src/main/webapp. This is interpreted as a path relative to the root of your JVM (normally the path to your project). If you are familiar with the directory structure of a web application in a Maven project, you know that src/main/webapp is the default location for the root of your WAR. If you need to override this default, you can provide an alternate path to the @WebAppConfiguration annotation (for example, @WebAppConfiguration('src/test/webapp')). If you wish to reference a base resource path from the classpath instead of the file system, you can use Spring�s classpath: prefix. Note that Spring�s testing support for WebApplicationContext implementations is on par with its support for standard ApplicationContext implementations. When testing with a WebApplicationContext, you are free to declare XML configuration files, Groovy scripts, or @Configuration classes by using @ContextConfiguration. You are also free to use any other test annotations, such as @ActiveProfiles, @TestExecutionListeners, @Sql, @Rollback, and others.",
	"TestContext Framework - TestContext - config - @ContextConfiguration - Caching": "Once the TestContext framework loads an ApplicationContext (or WebApplicationContext) for a test, that context is cached and reused for all subsequent tests that declare the same unique context configuration within the same test suite.",
	"TestContext Framework - TestContext - config - @ContextConfiguration - Caching - unique": "An ApplicationContext can be uniquely identified by the combination of configuration parameters that is used to load it. Consequently, the unique combination of configuration parameters is used to generate a key under which the context is cached.",
	"TestContext Framework - TestContext - config - @ContextConfiguration - Caching - parameters": "The TestContext framework uses the following configuration parameters to build the context cache key: locations (from @ContextConfiguration), classes (from @ContextConfiguration), contextInitializerClasses (from @ContextConfiguration), contextCustomizers (from ContextCustomizerFactory), contextLoader (from @ContextConfiguration), parent (from @ContextHierarchy), activeProfiles (from @ActiveProfiles), propertySourceLocations (from @TestPropertySource), propertySourceProperties (from @TestPropertySource), resourceBasePath (from @WebAppConfiguration)",
	"TestContext Framework - TestContext - config - @ContextConfiguration - Caching - storage": "The Spring TestContext framework stores application contexts in a static cache. This means that the context is literally stored in a static variable. In other words, if tests execute in separate processes, the static cache is cleared between each test execution, which effectively disables the caching mechanism. To benefit from the caching mechanism, all tests must run within the same process or test suite. This can be achieved by executing all tests as a group within an IDE. Similarly, when executing tests with a build framework such as Ant, Maven, or Gradle, it is important to make sure that the build framework does not fork between tests.",
	"TestContext Framework - TestContext - config - @ContextConfiguration - Caching - debug": "Since having a large number of application contexts loaded within a given test suite can cause the suite to take an unnecessarily long time to execute, it is often beneficial to know exactly how many contexts have been loaded and cached. To view the statistics for the underlying context cache, you can set the log level for the org.springframework.test.context.cache logging category to DEBUG.",
	"TestContext Framework - TestContext - config - @ContextConfiguration - Caching - @DirtiesContext": "In the unlikely case that a test corrupts the application context and requires reloading (for example, by modifying a bean definition or the state of an application object), you can annotate your test class or test method with @DirtiesContext (see the discussion of @DirtiesContext in Spring Testing Annotations). This instructs Spring to remove the context from the cache and rebuild the application context before running the next test. Note that support for the @DirtiesContext annotation is provided by the DirtiesContextBeforeModesTestExecutionListener and the DirtiesContextTestExecutionListener, which are enabled by default.",
	"TestContext Framework - TestContext - config - @ContextConfiguration - @ContextHierarchy": "When writing integration tests that rely on a loaded Spring ApplicationContext, it is often sufficient to test against a single context. However, there are times when it is beneficial or even necessary to test against a hierarchy of ApplicationContext instances. For example, if you are developing a Spring MVC web application, you typically have a root WebApplicationContext loaded by Spring�s ContextLoaderListener and a child WebApplicationContext loaded by Spring�s DispatcherServlet. This results in a parent-child context hierarchy where shared components and infrastructure configuration are declared in the root context and consumed in the child context by web-specific components. Another use case can be found in Spring Batch applications, where you often have a parent context that provides configuration for shared batch infrastructure and a child context for the configuration of a specific batch job. Since Spring Framework 3.2.2, you can write integration tests that use context hierarchies by declaring context configuration with the @ContextHierarchy annotation, either on an individual test class or within a test class hierarchy. If a context hierarchy is declared on multiple classes within a test class hierarchy, you can also merge or override the context configuration for a specific, named level in the context hierarchy. When merging configuration for a given level in the hierarchy, the configuration resource type (that is, XML configuration files or annotated classes) must be consistent. Otherwise, it is perfectly acceptable to have different levels in a context hierarchy configured using different resource types.",
	"TestContext Framework - TestContext - config - Environment - MockEnvironment (Spring 3.2+)": "",
	"TestContext Framework - TestContext - config - Environment - Profiles - @ActiveProfiles (Spring 3.1+)": "Spring 3.1 introduced first-class support in the framework for the notion of environments and profiles (AKA �bean definition profiles�), and integration tests can be configured to activate particular bean definition profiles for various testing scenarios. This is achieved by annotating a test class with the @ActiveProfiles annotation and supplying a list of profiles that should be activated when loading the ApplicationContext for the test.",
	"TestContext Framework - TestContext - config - Environment - PropertySource - @TestPropertySource (Spring 3.1+)": "Spring 3.1 introduced first-class support in the framework for the notion of an environment with a hierarchy of property sources. Since Spring 4.1, you can configure integration tests with test-specific property sources. In contrast to the @PropertySource annotation used on @Configuration classes, you can declare the @TestPropertySource annotation on a test class to declare resource locations for test properties files or inlined properties. These test property sources are added to the set of PropertySources in the Environment for the ApplicationContext loaded for the annotated integration test.",
	"TestContext Framework - TestContext - config - Environment - PropertySource - MockPropertySource (Spring 3.2+)": "Simple PropertySource implementation for use in testing. Accepts a user-provided Properties object, or if omitted during construction, the implementation will initialize its own. The setProperty(java.lang.String, java.lang.Object) and withProperty(java.lang.String, java.lang.Object) methods are exposed for convenience, for example: PropertySource< ?> source = new MockPropertySource().withProperty('foo', 'bar'),",
	"TestContext Framework - TestExecutionListener": "TestExecutionListener defines the API for reacting to test-execution events published by the TestContextManager with which the listener is registered.",
	"TestContext Framework - TestExecutionListener - ServletTestExecutionListener": "ServletTestExecutionListener: Configures Servlet API mocks for a WebApplicationContext.",
	"TestContext Framework - TestExecutionListener - DirtiesContextBeforeModesTestExecutionListener": "DirtiesContextBeforeModesTestExecutionListener: Handles the @DirtiesContext annotation for �before� modes.",
	"TestContext Framework - TestExecutionListener - DependencyInjectionTestExecutionListener": "DependencyInjectionTestExecutionListener: Provides dependency injection for the test instance.",
	"TestContext Framework - TestExecutionListener - DirtiesContextTestExecutionListener": "DirtiesContextTestExecutionListener: Handles the @DirtiesContext annotation for �after� modes.",
	"TestContext Framework - TestExecutionListener - TransactionalTestExecutionListener": "TransactionalTestExecutionListener: Provides transactional test execution with default rollback semantics.",
	"TestContext Framework - TestExecutionListener - SqlScriptsTestExecutionListener": "SqlScriptsTestExecutionListener: Runs SQL scripts configured by using the @Sql annotation.",
	"TestContext Framework - TestExecutionListener - custom": "You can register custom TestExecutionListener implementations for a test class and its subclasses by using the @TestExecutionListeners annotation. See annotation support and the javadoc for @TestExecutionListeners for details and examples.",
	"TestContext Framework - TestExecutionListener - discovery": "Registering custom TestExecutionListener implementations by using @TestExecutionListeners is suitable for custom listeners that are used in limited testing scenarios. However, it can become cumbersome if a custom listener needs to be used across a test suite. Since Spring Framework 4.1, this issue is addressed through support for automatic discovery of default TestExecutionListener implementations through the SpringFactoriesLoader mechanism. Specifically, the spring-test module declares all core default TestExecutionListener` implementations under the org.springframework.test.context.TestExecutionListener key in its META-INF/spring.factories properties file. Third-party frameworks and developers can contribute their own TestExecutionListener implementations to the list of default listeners in the same manner through their own META-INF/spring.factories properties file.",
	"TestContext Framework - TestExecutionListener - order": "Ordering TestExecutionListener Implementation. When the TestContext framework discovers default TestExecutionListener implementations through the aforementioned SpringFactoriesLoader mechanism, the instantiated listeners are sorted by using Spring�s AnnotationAwareOrderComparator, which honors Spring�s Ordered interface and @Order annotation for ordering. AbstractTestExecutionListener and all default TestExecutionListener implementations provided by Spring implement Ordered with appropriate values. Third-party frameworks and developers should therefore make sure that their default TestExecutionListener implementations are registered in the proper order by implementing Ordered or declaring @Order. See the javadoc for the getOrder() methods of the core default TestExecutionListener implementations for details on what values are assigned to each core listener.",
	"TestContext Framework - TestExecutionListener - merging": "If a custom TestExecutionListener is registered via @TestExecutionListeners, the default listeners are not registered. In most common testing scenarios, this effectively forces the developer to manually declare all default listeners in addition to any custom listeners. To avoid having to be aware of and re-declare all default listeners, you can set the mergeMode attribute of @TestExecutionListeners to MergeMode.MERGE_WITH_DEFAULTS. MERGE_WITH_DEFAULTS indicates that locally declared listeners should be merged with the default listeners. The merging algorithm ensures that duplicates are removed from the list and that the resulting set of merged listeners is sorted according to the semantics of AnnotationAwareOrderComparator, as described in Ordering TestExecutionListener Implementations. If a listener implements Ordered or is annotated with @Order, it can influence the position in which it is merged with the defaults. Otherwise, locally declared listeners are appended to the list of default listeners when merged.",
	"TestContext Framework - ContextLoader": "ContextLoader is a strategy interface that was introduced in Spring 2.5 for loading an ApplicationContext for an integration test managed by the Spring TestContext Framework.",
	"TestContext Framework - ContextLoader - SmartContextLoader": "You should implement SmartContextLoader instead of this interface to provide support for annotated classes, active bean definition profiles, test property sources, context hierarchies, and WebApplicationContext support. SmartContextLoader is an extension of the ContextLoader interface introduced in Spring 3.1. The SmartContextLoader SPI supersedes the ContextLoader SPI that was introduced in Spring 2.5. Specifically, a SmartContextLoader can choose to process resource locations, annotated classes, or context initializers. Furthermore, a SmartContextLoader can set active bean definition profiles and test property sources in the context that it loads.",
	"TestContext Framework - ContextLoader - SmartContextLoader - DelegatingSmartContextLoader": "DelegatingSmartContextLoader: One of two default loaders, it delegates internally to an AnnotationConfigContextLoader, a GenericXmlContextLoader, or a GenericGroovyXmlContextLoader, depending either on the configuration declared for the test class or on the presence of default locations or default configuration classes. Groovy support is enabled only if Groovy is on the classpath.",
	"TestContext Framework - ContextLoader - SmartContextLoader - WebDelegatingSmartContextLoader": "WebDelegatingSmartContextLoader: One of two default loaders, it delegates internally to an AnnotationConfigWebContextLoader, a GenericXmlWebContextLoader, or a GenericGroovyXmlWebContextLoader, depending either on the configuration declared for the test class or on the presence of default locations or default configuration classes. A web ContextLoader is used only if @WebAppConfiguration is present on the test class. Groovy support is enabled only if Groovy is on the classpath.",
	"TestContext Framework - ContextLoader - SmartContextLoader - AnnotationConfigContextLoader": "AnnotationConfigContextLoader: Loads a standard ApplicationContext from annotated classes.",
	"TestContext Framework - ContextLoader - SmartContextLoader - AnnotationConfigWebContextLoader": "AnnotationConfigWebContextLoader: Loads a WebApplicationContext from annotated classes.",
	"TestContext Framework - ContextLoader - SmartContextLoader - GenericGroovyXmlContextLoader": "GenericGroovyXmlContextLoader: Loads a standard ApplicationContext from resource locations that are either Groovy scripts or XML configuration files.",
	"TestContext Framework - ContextLoader - SmartContextLoader - GenericGroovyXmlWebContextLoader": "GenericGroovyXmlWebContextLoader: Loads a WebApplicationContext from resource locations that are either Groovy scripts or XML configuration files.",
	"TestContext Framework - ContextLoader - SmartContextLoader - GenericXmlContextLoader": "GenericXmlContextLoader: Loads a standard ApplicationContext from XML resource locations.",
	"TestContext Framework - ContextLoader - SmartContextLoader - GenericXmlWebContextLoader": "GenericXmlWebContextLoader: Loads a WebApplicationContext from XML resource locations.",
	"TestContext Framework - ContextLoader - SmartContextLoader - GenericPropertiesContextLoader": "GenericPropertiesContextLoader: Loads a standard ApplicationContext from Java properties files.",

	"Unit Testing": "SECTION",
	"Unit Testing - Mock Objects - Servlet": "The org.springframework.mock.web package contains a comprehensive set of Servlet API mock objects that are useful for testing web contexts, controllers, and filters. These mock objects are targeted at usage with Spring�s Web MVC framework and are generally more convenient to use than dynamic mock objects (such as EasyMock) or alternative Servlet API mock objects (such as MockObjects).",
	"Unit Testing - Mock Objects - Servlet - MockFilterChain": "",
	"Unit Testing - Mock Objects - Servlet - MockServletConfig": "",
	"Unit Testing - Mock Objects - Servlet - MockServletContext": "",
	"Unit Testing - Mock Objects - Servlet - MockHttpServletRequest": "",
	"Unit Testing - Mock Objects - Servlet - MockHttpServletResponse": "",
	"Unit Testing - Mock Objects - Servlet - MockHttpSession": "",
	"Unit Testing - Mock Objects - Reactive": "The org.springframework.mock.http.server.reactive package contains mock implementations of ServerHttpRequest and ServerHttpResponse for use in WebFlux applications.",
	"Unit Testing - Mock Objects - Reactive - MockServerHttpRequest": "",
	"Unit Testing - Mock Objects - Reactive - MockServerHttpResponse": "",
	"Unit Testing - Utils": "The org.springframework.test.util package contains several general purpose utilities for use in unit and integration testing.",
	"Unit Testing - Utils - ReflectionTestUtils": "ReflectionTestUtils is a collection of reflection-based utility methods. You can use these methods in testing scenarios where you need to change the value of a constant, set a non-public field, invoke a non-public setter method, or invoke a non-public configuration or lifecycle callback method when testing application code for use cases such as the following: ORM frameworks (such as JPA and Hibernate) that condone private or protected field access as opposed to public setter methods for properties in a domain entity. Spring�s support for annotations (such as @Autowired, @Inject, and @Resource), that provide dependency injection for private or protected fields, setter methods, and configuration methods. Use of annotations such as @PostConstruct and @PreDestroy for lifecycle callback methods.",
	"Unit Testing - Utils - AopTestUtils": "AopTestUtils is a collection of AOP-related utility methods. You can use these methods to obtain a reference to the underlying target object hidden behind one or more Spring proxies. For example, if you have configured a bean as a dynamic mock by using a library such as EasyMock or Mockito, and the mock is wrapped in a Spring proxy, you may need direct access to the underlying mock to configure expectations on it and perform verifications.",
	"Unit Testing - Utils - ModelAndViewAssert": "The org.springframework.test.web package contains ModelAndViewAssert, which you can use in combination with JUnit, TestNG, or any other testing framework for unit tests that deal with Spring MVC ModelAndView objects.",
	
	"SpringMVC Test": "SECTION",
	"SpringMVC Test ": "The goal of Spring MVC Test is to provide an effective way to TEST CONTROLLERS by performing requests and generating responses through the actual DispatcherServlet.",
	"SpringMVC Test - Servlet API": "Spring MVC Test builds on the familiar �mock� implementations of the Servlet API available in the spring-test module. This allows performing requests and generating responses without the need for running in a Servlet container.",
	"SpringMVC Test - MockMVC": "A framework, also known as MockMvc, for testing annotated controllers through the DispatcherServlet, i.e. supporting annotations and complete with Spring MVC infrastructure, but without an HTTP server.",
	"SpringMVC Test - MockMVC - setup": "You have two main options for creating an instance of MockMvc. No matter which MockMvc builder you use, all MockMvcBuilder implementations provide some common and very useful features.",
	"SpringMVC Test - MockMVC - setup - from webAppContextSetup": "The first is to load Spring MVC configuration through the TestContext framework, which loads the Spring configuration and injects a WebApplicationContext into the test to use to build a MockMvc instance. this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build(), The webAppContextSetup loads your actual Spring MVC configuration, resulting in a more complete integration test. Since the TestContext framework caches the loaded Spring configuration, it helps keep tests running fast, even as you introduce more tests in your test suite. Furthermore, you can inject mock services into controllers through Spring configuration to remain focused on testing the web layer.",
	"SpringMVC Test - MockMVC - setup - from standaloneSetup": "Your second option is to manually create a controller instance without loading Spring configuration. Instead, basic default configuration, roughly comparable to that of the MVC JavaConfig or the MVC namespace, is automatically created. You can customize it to a degree. this.mockMvc = MockMvcBuilders.standaloneSetup(new AccountController()).build(), The standaloneSetup, on the other hand, is a little closer to a unit test. It tests one controller at a time. You can manually inject the controller with mock dependencies, and it does not involve loading Spring configuration. Such tests are more focused on style and make it easier to see which controller is being tested, whether any specific Spring MVC configuration is required to work, and so on. The standaloneSetup is also a very convenient way to write ad-hoc tests to verify specific behavior or to debug an issue.",
	"SpringMVC Test - MockMVC - request": "",
	"SpringMVC Test - MockMVC - request - MockMvcRequestBuilders": "",
	"SpringMVC Test - MockMVC - request - MockMvcRequestBuilders.post(java.net.URI uri)": "",
	"SpringMVC Test - MockMVC - request - MockMvcRequestBuilders.get(java.net.URI uri)": "",
	"SpringMVC Test - MockMVC - request - MockMvcRequestBuilders.get(java.lang.String urlTemplate, java.lang.Object... uriVars)": "",
	"SpringMVC Test - MockMVC - request - MockMvcRequestBuilders.multipart(java.net.URI uri)": "",
	"SpringMVC Test - MockMVC - request - HTMLUnit": "",
	"SpringMVC Test - MockMVC - request - WebDriver": "",
	"SpringMVC Test - MockMVC - request - Geb": "",
	"SpringMVC Test - MockMVC - expect": "",
	"SpringMVC Test - MockMVC - expect - MockMvcResultMatchers": "",
	"SpringMVC Test - MockMVC - expect - MockMvcResultMatchers.status()": "",
	"SpringMVC Test - MockMVC - expect - MockMvcResultMatchers.request()": "",
	"SpringMVC Test - MockMVC - expect - MockMvcResultMatchers.view()": "",
	"SpringMVC Test - MockMVC - expect - MockMvcResultMatchers.xpath(java.lang.String expression, java.lang.Object... args)": "",
	"SpringMVC Test - MockMVC - expect - MockMvcResultMatchers.xpath(java.lang.String expression, java.util.Map<java.lang.String,java.lang.String> namespaces, java.lang.Object... args)": "",
	"SpringMVC Test - MockMVC - filter": "When setting up a MockMvc instance, you can register one or more Servlet Filter instances, as the following example shows: mockMvc = standaloneSetup(new PersonController()).addFilters(new CharacterEncodingFilter()).build(),",
	"SpringMVC Test - MockMVC - filter - MockFilterChain": "Registered filters are invoked through the MockFilterChain from spring-test, and the last filter delegates to the DispatcherServlet.",
	"SpringMVC Test - RestTemplate": "You can use client-side tests to test code that internally uses the RestTemplate. The idea is to declare expected requests and to provide �stub� responses so that you can focus on testing the code in isolation (that is, without running a server).",
	"SpringMVC Test - RestTemplate ": "",
	"SpringMVC Test - RestTemplate  ": "",
	"SpringMVC Test - RestTemplate     ": "",
	"SpringMVC Test - RestTemplate   ": "",
	"SpringMVC Test - RestTemplate    ": "",

	"WebTestClient": "SECTION",
	"WebTestClient ": "WebTestClient is a thin shell around WebClient, using it to perform requests and exposing a dedicated, fluent API for verifying responses. WebTestClient binds to a WebFlux application by using a mock request and response, or it can test any web server over an HTTP connection.",
	
	"JDBC Testing": "SECTION",
	"JDBC Testing - JdbcTestUtils": "The org.springframework.test.jdbc package contains JdbcTestUtils, which is a collection of JDBC-related utility functions intended to simplify standard database testing scenarios.",
	"JDBC Testing - JdbcTestUtils.countRowsInTable(JdbcTemplate jdbcTemplate, java.lang.String tableName)": "Counts the number of rows in the given table.",
	"JDBC Testing - JdbcTestUtils.countRowsInTableWhere(JdbcTemplate jdbcTemplate, java.lang.String tableName, java.lang.String whereClause)": "Counts the number of rows in the given table by using the provided WHERE clause.",
	"JDBC Testing - JdbcTestUtils.deleteFromTables(JdbcTemplate jdbcTemplate, java.lang.String... tableNames)": "Deletes all rows from the specified tables.",
	"JDBC Testing - JdbcTestUtils.deleteFromTableWhere(JdbcTemplate jdbcTemplate, java.lang.String tableName, java.lang.String whereClause, java.lang.Object... args)": "Deletes rows from the given table by using the provided WHERE clause.",
	"JDBC Testing - JdbcTestUtils.dropTables(JdbcTemplate jdbcTemplate, java.lang.String... tableNames)": "Drops the specified tables."
}