{
	"String to Stream": "SECTION",
	"example1 String -> IntStream": "IntStream intStream = 'String'.chars(), - chars() inherited from CharSequence",
	"example2 String -> IntStream": "IntStream intStream = 'String'.codePoints(), - codePoints() inherited from CharSequence",
	"example3 String -> Stream<Character>": "Stream<Character> characterStream = testString.chars().mapToObj(c -> (char) c),",
	"example4 String[] parts ='10,20'.split(','),": "Splits this string around matches of the given regular expression. Use Arrays.stream() after to get Stream<String>",
	"example5 Stream< String > message = Pattern.compile(',').splitAsStream('one,two,three')": "Splits this string around matches of the given regular expression.",
	
	"data conversions": "SECTION",
	"IntStream => Stream< Integer >": "mapToObj(i->i)",
	"IntStream =>  Stream< Integer >": ".boxed()",
	"boundaries 1 a 3 => Stream< Integer >": "Stream.iterate(40, n->n+2).limit(20)",
	"Stream.iterate( T seed, UnaryOperator< T > f)": "The iterate() method takes two arguments: a seed and a function. A seed is the first element of the stream. The second element is generated by applying the function to the first element. The third element is generated by applying the function on the second element. Therefore the elements are: seed, f(seed), f(f(seed)), f(f(f(seed))).... The following code creates a stream of natural numbers: Stream<Long> naturalNumbers = Stream.iterate(1L, n -> n + 1), The limit(long maxSize) operation is an intermediate operation that produces another stream.",
	"Stream.iterate( T seed, Predicate< ? super T> hasNext, UnaryOperator<T> next) (Java 9)": "Returns a sequential ordered Stream produced by iterative application of the given next function to an initial element, conditioned on satisfying the given hasNext predicate.",
	"boundaries 1 a 4 => Stream< Integer >": "Stream.generate(() -> 'element').limit(10)",
	"boundaries 1 a 3 => IntStream": "IntStream.range(1, 3)",
	"boundaries 1 a 4 => IntStream": "IntStream.rangeClosed(1, 3)",
	"List< int[] > => Stream< int[] >": ".stream()",
	"int[:> List< int[] >": "Arrays.asList(...)",
	"int[:> Stream< int[] > ": "Stream.of",
	"int[:> Stream< int[] >": "Stream.ofNullable (Java 9)",
	"int[:> IntStream": "Arrays.stream(...)",
	"IntStream => int[]": ".toArray()",
	"Stream< int[] > => int[][]": ".toArray()",
	"1,2,3 => int[]": "new int[] {1,2,3}",
	"1,2,3 => Stream< Integer >": "Stream.of(1,2,3)",
	"'1','2' => Stream< Integer >": "Stream.< String >Builder().add('1').add('2').build()",
	"'1','2' => IntStream": "IntStream.builder().add('1').add('2').build()",
	"2,3,4 => IntStream": "IntStream.of(1,2,3)",
	"3,4 => Integer[]": "new Integer[] {1,2,3}",
	"3,4,5 => Integer[]": "{1,2,3}",
	"Integer[:> Stream< Integer >": "Stream.of(...)",
	"Integer[:> List< Integer >": "Arrays.asList(...)",
	"List< Integer > => Integer[]": ".toArray(new Integer(result.size()))",
	"List< Integer > => Stream< Integer >": ".stream()",
	"Stream< Integer > => List< Integer >": ".collect(Collectors.toList()",
	"Stream< Integer > => IntStream": ".mapToInt(Integer:valueOf)",
	"String => Stream< String > with String.split(...)": "Stream.of(inputString.split('\n'))",
	"Stream< String > => String": ".collect(Collectors.joining(', ')),",
	"Stream< String > => Stream< Integer >": ".map(n -> n.toString())",
	"Stream< Integer > => Stream< String >": ".mapToObj(Integer::toString)",
	"Stream < Integer > => Stream< String > with Pattern.splitAsStream(...)": "Pattern.compile(System.lineSeparator(), Pattern.LITERAL).splitAsStream(str)",
	"Stream.of (...) implementation": "It is worth noting that Stream.of(...) method simply calls the Arrays.stream(...) method for non-primitive types",
	"Optional is returned by": ".findFirst, .findAny, .min/Collectors.minBy, .max/Collectors.maxBy and .reduce/Collectors.reducing without identity",

	"pipeline": "SECTION",
	"Stream.peek(Consumer< ? super T > action)": "to same type stream. Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element",
	"example Stream.peek(Consumer< ? super T> action)": ".peek(e -> System.out.println('Mapped value: ' + e))",
	"Stream.sorted()": "To same type stream. Returns a stream consisting of the elements of this stream, sorted according to natural order..",
	"Stream.sorted(Comparator< ? super T > comparator)": "To same type stream. Returns a stream consisting of the elements of this stream, sorted according to the provided Comparator.",
	"example1 Stream.sorted(Comparator< ? super T> comparator)": ".sorted((o1, o2) -> o1.getItem().getValue().compareTo(o2.getItem().getValue()))",
	"example2 Stream.sorted(Comparator< ? super T> comparator)": ".sorted(Comparator.reverseOrder())",
	"Stream.limit(long maxSize)": "to same type stream. Returns a stream consisting of the elements of this stream, truncated to be no longer than maxSize in length.",
	"Stream.skip(long n)": "to same type stream. Returns a stream consisting of the remaining elements of this stream after discarding the first n elements of the stream.",
	"Stream.filter(Predicate< ? super T > predicate)": "to same type stream. Returns a stream consisting of the elements of this stream that match the given predicate.",
	"example Stream.filter(Predicate< ? super T > predicate)": ".filter(text -> !'A'.equals(text))",
	"Stream.distinct()": "to same type stream. Returns a stream consisting of the distinct elements (according to Object.equals(Object)) of this stream.",
	"Stream.concat(Stream< ? extends T > a, Stream< ? extends T > b)": "to same type stream. Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream.",
	"example Stream.concat(Stream< ? extends T > a, Stream< ? extends T > b)": ".concat(stream1, stream2)",

	"transform": "SECTION",
	"Stream.map(Function< ? super T,? extends R> mapper)": "to other type stream. Returns a stream consisting of the results of applying the given function to the elements of this stream.",
	"example Stream.map(Function< ? super T,? extends R > mapper) with lambda": ".map(t -> t.toUpperCase())",
	"example Stream.map(Function< ? super T,? extends R > mapper) with method reference": ".map(String::toUpperCase)",
	"Stream.mapToInt(ToIntFunction< ? super T> mapper)": "to other type stream. Returns a IntStream consisting of the results of applying the given function to the elements of this stream.",
	"example Stream.mapToInt(ToIntFunction< ? super T > mapper) with method reference": ".mapToInt(num -> Integer.parseInt(num))",
	"Stream.mapToLong(ToLongFunction< ? super T > mapper)": "to other type stream. Returns a LongStream consisting of the results of applying the given function to the elements of this stream.",
	"Stream.mapToDouble(ToDoubleFunction< ? super T > mapper)": "to other type stream. Returns a DoubleStream consisting of the results of applying the given function to the elements of this stream.",
	"Stream.flatMap(Function< ? super T,? extends Stream< ? extends R > > mapper)": "to other type stream. Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.",
	"Stream.flatMapToInt(Function< ? super T,? extends Inttream> mapper)": "to other type stream. Returns a IntStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.",
	"Stream.flatMapToLong(Function< ? super T,? extends LongStream> mapper)": "to other type stream. Returns a LongStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.",
	"Stream.flatMapToDouble(Function< ? super T,? extends DoubleStream> mapper)": "to other type stream. Returns a DoubleStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.",

	"reduction to collection": "SECTION",
	"resume reduction": "(1) Collectors.toMap(key, value, merge for duplicates, supplier mapFactory) -> map <br/> (2) Collectors.mapping(mapping, downstream) -> what downstrean defines <br/> (3) Collectors.groupingBy(key, mapFactory, downstream) -> map <br/> (4) Collectors.partitioningBy(partition predicate for true/false, downstream) -> map <br/> (5) .collect(supplier container, accumulator, parallel combiner) -> supplier container <br/> (6) .reduce(identity, accumulator, parallel combiner) -> object <br/> (7) Collectors.reducing(identity, accumulator, parallel combiner) -> object ",
	"Stream.toArray()": "reduction to Collection. reduction to Array",
	"Collector - interface Collector<T,A,R> { <br/>Supplier< A > supplier(), <br/>BiConsumer< A,T > acumulator(), <br/>BinaryOperator< A > combiner(), <br/>Function< A,R > finisher(), <br/>Set< Characteristics > characteristics() <br/>}": "supplier() returns a function that creates an instance of accumulator - mutable data structure that we will use to accumulate input elements of type T.<br/> accumulator() returns a function that will take accumulator and one item of type T, mutating accumulator. <br/>combiner() is used to join two accumulators together into one. It is used when collector is executed in parallel, splitting input Stream<T> and collecting parts independently first.<br/> finisher() takes an accumulator A and turns it into a result value, e.g. collection, of type R.",
	"Stream.collect(Supplier<R> supplier, BiConsumer<R,? super T> accumulator, BiConsumer<R,R> combiner)": "reduction to custom .collect(SAC)",
	"example collect to List< String >": "getStringStream().collect(() -> new ArrayList<>(), (c, s) -> c.add(s.toUpperCase()), (c1, c2) -> c1.addAll(c2))",
	"example collect to StringBuilder": "getStringStream().collect(StringBuilder::new, StringBuilder::append, StringBuilder::append)",
	"example collect to List< Integer > with lambda function": "getIntStream().collect(() -> new ArrayList<>(), (l, i) -> l.add(i), (l1, l2) -> l1.addAll(l2))",
	"example collect to List< Integer > with method references": "getIntStream().collect(ArrayList::new, ArrayList::add, ArrayList::addAll)",
	"Collectors.toSet()": "reduction to Set",
	"Collectors.toList()": "reduction to List",
	"Collectors.toMap(key, value, merge if duplicates, supplier container)": "",
	"Collectors.toMap(Function< ? super T,? extends K> keyMapper, Function< ? super T,? extends U> valueMapper)": "reduction to Map",
	"example Collectors.toMap(2args) - Collectors.toMap(Function< ? super T,? extends K> keyMapper, Function< ? super T,? extends U> valueMapper) with lambda function and function identity": "Collectors.toMap(p -> p.getLast(), Function.identity())",
	"example Collectors.toMap(2args) - Collectors.toMap(Function< ? super T,? extends K> keyMapper, Function< ? super T,? extends U> valueMapper) with method reference and function identity": "Collectors.toMap(Person::getLast, Function.identity())",
	"example Collectors.toMap(2args) - Collectors.toMap(Function< ? super T,? extends K> keyMapper, Function< ? super T,? extends U> valueMapper) with method reference and lambda": "Collectors.toMap(Person::getLast, p -> p)",
	"Collectors.toMap(Function< ? super T,? extends K> keyMapper, Function< ? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction)": "reduction to Map. Returns a Collector that accumulates elements into a Map whose keys and values are the result of applying the provided mapping functions to the input elements. If the mapped keys contains duplicates (according to Object.equals(Object)), the value mapping function is applied to each equal element, and the results are merged using the provided merging function.",
	"example Collectors.toMap(3args, merge function) - Collectors.toMap(Function< ? super T,? extends K> keyMapper, Function< ? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction) with merge function": "toMap(Person::getName, Person::getAddress, <b>(s, a) -> s + ', ' + a)</b>",
	"Collectors.toMap(Function< ? super T,? extends K> keyMapper, Function< ? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction, Supplier<M> mapSupplier)": "reduction to Map",
	"example Collectors.toMap(4args, merge function) - Collectors.toMap(Function< ? super T,? extends K> keyMapper, Function< ? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction, Supplier<M> mapSupplier) with merge function": "toMap(Person::getName, Person::getAddress, (s, a) -> s + ', ' + a, TreeMap::new)",
	"Collectors.toConcurrentMap(Function< ? super T,? extends K> keyMapper, Function< ? super T,? extends U> valueMapper)": "reduction to Map. Returns a concurrent Collector that accumulates elements into a ConcurrentMap whose keys and values are the result of applying the provided mapping functions to the input elements. If the mapped keys contains duplicates (according to Object.equals(Object)), an IllegalStateException is thrown when the collection operation is performed. If the mapped keys may have duplicates, use toConcurrentMap(Function, Function, BinaryOperator) instead.",
	"Collectors.toConcurrentMap(Function< ? super T,? extends K> keyMapper, Function< ? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction)": "reduction to Map. Returns a concurrent Collector that accumulates elements into a ConcurrentMap whose keys and values are the result of applying the provided mapping functions to the input elements. If the mapped keys contains duplicates (according to Object.equals(Object)), the value mapping function is applied to each equal element, and the results are merged using the provided merging function.",
	"Collectors.toConcurrentMap(Function< ? super T,? extends K> keyMapper, Function< ? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction, Supplier<M> mapSupplier)": "reduction to Map. Returns a concurrent Collector that accumulates elements into a ConcurrentMap whose keys and values are the result of applying the provided mapping functions to the input elements. If the mapped keys contains duplicates (according to Object.equals(Object)), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The ConcurrentMap is created by a provided supplier function. This is a concurrent and unordered Collector.",
	"Collectors.toUnmodifiableList() (Java 10)": "Returns a Collector that accumulates the input elements into an unmodifiable List in encounter order. Provide users with 'read-only' access to internal lists. Attempts to modify the returned list, whether direct or via its iterator, result in an UnsupportedOperationException.",
	"Collectors.toUnmodifiableSet() (Java 10)": "Returns a Collector that accumulates the input elements into an unmodifiable Set. Provide users with 'read-only' access to internal set. Attempts to modify the returned set, whether direct or via its iterator, result in an UnsupportedOperationException.",
	"Collectors.toUnmodifiableMap(Function< ? super T, ? extends K > keyMapper, Function< ? super T, ? extends U > valueMapper) (Java 10)": "Returns a Collector that accumulates the input elements into an unmodifiable Map, whose keys and values are the result of applying the provided mapping functions to the input elements. Provide users with 'read-only' access to internal map. Attempts to modify the returned map, whether direct or via its iterator, result in an UnsupportedOperationException.",
	"Collectors.toUnmodifiableMap(Function< ? super T, ? extends K > keyMapper, Function< ? super T, ? extends U > valueMapper, BinaryOperator< U > mergeFunction) (Java 10)": "Returns a Collector that accumulates the input elements into an unmodifiable Map, whose keys and values are the result of applying the provided mapping functions to the input elements. Provide users with 'read-only' access to internal set. Attempts to modify the returned set, whether direct or via its iterator, result in an UnsupportedOperationException.",
	"Collectors.groupingBy(Function< ? super T,? extends K> classifier)": "reduction to Map. Returns a Collector implementing a 'group by' operation on input elements of type T, grouping elements according to a classification function, and returning the results in a Map.",
	"example Collectors.groupingBy(Function< ? super T,? extends K > classifier)": "Map< BlogPostType, List<BlogPost > > postsPerType = posts.stream().collect(Collectors.groupingBy(BlogPost::getType)),",
	"Collectors.groupingBy(Function< ? super T,? extends K> classifier, Collector< ? super T,A,D> downstream)": "reduction to Map. Returns a Collector implementing a cascaded 'group by' operation on input elements of type T, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream Collector.",
	"example Collectors.groupingBy(Function< ? super T,? extends K> classifier, Collector< ? super T,A,D> downstream) - Modifying the Returned Map Value Type": "Map< BlogPostType, Set<BlogPost>> postsPerType = posts.stream().collect(Collectors.groupingBy(BlogPost::getType, Collector.toSet())),",
	"example Collectors.groupingBy(Function< ? super T,? extends K> classifier, Collector< ? super T,A,D> downstream) - Providing a Secondary Group By Collector": "Map< String, Map< BlogPostType, List>> map = posts.stream().collect(Collectors.groupingBy(BlogPost::getAuthor, Collectors.groupingBy(BlogPost::getType))),",
	"example Collectors.groupingBy(Function< ? super T,? extends K> classifier, Collector< ? super T,A,D> downstream) - Getting the Average from Grouped Results": "Map< BlogPostType, Double> averageLikesPerType = posts.stream().collect(Collectors.groupingBy(BlogPost::getType, Collectors.averagingInt(BlogPost::getLikes))),",
	"example Collectors.groupingBy(Function< ? super T,? extends K> classifier, Collector< ? super T,A,D> downstream) - Getting the Sum from Grouped Results": "Map< BlogPostType, Integer > likesPerType = posts.stream().collect(Collectors.groupingBy(BlogPost::getType, Collectors.summingInt(BlogPost::getLikes))),",
	"example Collectors.groupingBy(Function< ? super T,? extends K> classifier, Collector< ? super T,A,D> downstream) - Getting the Maximum or Minimum from Grouped Results": "Map< BlogPostType, Optional<BlogPost>> maxLikesPerPostType = posts.stream().collect(Collectors.groupingBy(BlogPost::getType, Collectors.maxBy(comparingInt(BlogPost::getLikes)))),",
	"example Collectors.groupingBy(Function< ? super T,? extends K> classifier, Collector< ? super T,A,D> downstream) - Getting a Summary for an Attribute of Grouped Results": "Map< BlogPostType, IntSummaryStatistics > likeStatisticsPerType = posts.stream().collect(Collectors.groupingBy(BlogPost::getType, Collectors.summarizingInt(BlogPost::getLikes))),",
	"example Collectors.groupingBy(Function< ? super T,? extends K> classifier, Collector< ? super T,A,D> downstream) - Mapping Grouped Results to a Different Type": "Map< BlogPostType, String> postsPerType = posts.stream().collect(Collectors.groupingBy(BlogPost::getType, Collectors.mapping(BlogPost::getTitle, Collectors.joining(", ", 'Post titles: [', ']')))),",
	"Collectors.groupingBy(Function< ? super T,? extends K> classifier, Supplier<M> mapFactory, Collector< ? super T,A,D> downstream)": "reduction to Map",
	"example Collectors.groupingBy(Function< ? super T,? extends K > classifier, Supplier< M > mapFactory, Collector< ? super T,A,D > downstream) - Modifying the Return Map Type": "EnumMap< BlogPostType, List<BlogPost>> postsPerType = posts.stream().collect(groupingBy(BlogPost::getType, () -> new EnumMap< >(BlogPostType.class), toList())),",
	"Collectors.groupingByConcurrent(Function< ? super T,? extends K > classifier)": "reduction to Map",
	"example Collectors.groupingByConcurrent(Function< ? super T,? extends K> classifier)": "ConcurrentMap< BlogPostType, List<BlogPost>> postsPerType = posts.parallelStream().collect(groupingByConcurrent(BlogPost::getType)),",
	"Collectors.groupingByConcurrent(Function< ? super T,? extends K> classifier, Collector< ? super T,A,D> downstream)": "reduction to Map",
	"Collectors.groupingByConcurrent(Function< ? super T,? extends K> classifier, Supplier<M> mapFactory, Collector< ? super T,A,D> downstream)": "reduction to Map",
	"Collectors.partitioningBy(Predicate< ? super T> predicate)": "reduction to Map. Returns a Collector which partitions the input elements according to a Predicate, and organizes them into a Map< Boolean, List<T>>.",
	"example Collectors.partitioningBy(Predicate< ? super T> predicate)": "Collectors.partitioningBy(s -> s.getAge() > 20)",
	"Collectors.partitioningBy(Predicate< ? super T> predicate, Collector< ? super T,A,D> downstream)": "reduction to Map. Returns a Collector which partitions the input elements according to a Predicate, reduces the values in each partition according to another Collector, and organizes them into a Map< Boolean, D> whose values are the result of the downstream reduction.",
	"example Collectors.partitioningBy(Predicate< ? super T> predicate, Collector< ? super T,A,D> downstream)": "Collectors.partitioningBy(x -> Character.isUpperCase(x.charAt(0)), Collectors.counting())",
	"Collector<T,?,C> toCollection(Supplier<C> collectionFactory)": "reduction to Collection. Returns a Collector that accumulates the input elements into a new Collection, in encounter order. The Collection is created by the provided factory.",
	"example Collector<T,?,C> toCollection(Supplier<C> collectionFactory)": "Collectors.toCollection(LinkedList::new)",

	"reduction to value (Streams)": "SECTION",
	"Stream.allMatch(Predicate< ? super T> predicate)": "reduction to boolean",
	"example Stream.allMatch(Predicate< ? super T> predicate)": ".allMatch(e -> e.sal < 10000)",
	"Stream.anyMatch(Predicate< ? super T> predicate)": "reduction to boolean",
	"Stream.noneMatch(Predicate< ? super T> predicate)": "reduction to boolean",
	"Stream.findAny()": "reduction to item",
	"Stream.findFirst()": "reduction to item",

	"reduction to value wih collectors (Collectors)": "SECTION",
	"Collectors.joining()": "reduction to String",
	"Collectors.joining(CharSequence delimiter)": "reduction to String",
	"example Collectors.joining(CharSequence delimiter)": "Collectors.joining(',')",
	"Collectors.joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)": "reduction to String",
	"example Collectors.joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)": "Collectors.joining(',', ''', ''')",
	"Collectors.averageInt(ToIntFunction< ? super T> mapper)": "reduction to Double",
	"example Collectors.averageInt(ToIntFunction< ? super T> mapper)": "Collectors.averagingInt(Article::getWordCount)",
	"Collectors.averageLong(ToLongFunction< ? super T> mapper)": "reduction to Double",
	"Collectors.averageDouble(ToDoubleFunction< ? super T> mapper)": "reduction to Double",
	"Collectors.summingInt(ToIntFunction< ? super T> mapper)": "reduction to Integer",
	"Collectors.summingLong(ToLongFunction< ? super T> mapper)": "reduction to Long",
	"Collectors.summingDouble(ToDoubleFunction< ? super T> mapper)": "reduction to Double",

	"reduction to value (Streams and Collectors)": "SECTION",
	"Stream.count()/Collectors.counting()": "reduction to long/Long",
	"Stream.min(Comparator< ? super T> comparator)/Collectors.minBy(Comparator< ? super T> comparator)": "reduction to Optional",
	"Stream.max(Comparator< ? super T> comparator)/Collectors.maxBy(Comparator< ? super T> comparator)": "reduction to Optional",
	"Stream.reduce(BinaryOperator<T> accumulator)/Collectors.reducing(BinaryOperator<T> op)": "reduction to Optional",
	"example reduce to Optional< String >": "stringStream.reduce((x, y) -> x + y)",
	"example reduce to OptionalInt": "intStream.reduce((x, y) -> x + y),",
	"Stream.reduce(T identity, BinaryOperator<T> accumulator)/Collectors.reducing(T identity, BinaryOperator<T> op)": "reduction to Custom",
	"example reduce to String": "stringStream.reduce('pp', (x, y) -> x + y)",
	"example reduce to int": "intStream.reduce(5, (x, y) -> x + y)",
	"Stream.reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner)/Collectors.reducing(U identity, Function< ? super T,? extends U> mapper, BinaryOperator<U> op)": "reduction to Custom",
	"example reduce to int parallel": "intStream.reduce(0, (x, y) -> x + y.length(), (x, y) -> x + y)",

	"stream iterations": "SECTION",
	"alphabets.forEach(s -> System.out.println(s)),": "forEach() is a terminal operation, which means once calling forEach() method on stream, you cannot call another method. It will result in a runtime exception.",
	"alphabets.forEach(System.out::println),": "When you call forEach() on parallel stream, the order of iteration is not guaranteed, but you can ensure that ordering by calling forEachOrdered() method.",
	"list.forEach(a -> a.stuff()) vs list.stream().forEach(a -> a.stuff())": "Iterable.forEach guarantees processing in iteration order, if it is defined for the Iterable. Stream.forEach does not, one must use Stream.forEachOrdered instead.",
	"Stream.of('AAA','BBB','CCC').parallel().forEachOrdered(s->System.out.println('Output:'+s)),": "will always output Output:AAA Output:BBB Output:CCC whereas forEach the order is not kept.",
	
	"statistics": "SECTION",
	"Collectors.summarizingDouble(ToDoubleFunction< ? super T> mapper)": "applies an double-producing mapping function to each input element, and returns summary statistics for the resulting values",
	"Collectors.summarizingInt(ToIntFunction< ? super T> mapper)": "applies an int-producing mapping function to each input element, and returns summary statistics for the resulting values.",
	"Collectors.summarizingLong(ToLongFunction< ? super T> mapper)": "applies an long-producing mapping function to each input element, and returns summary statistics for the resulting values.",

	"additional operation": "SECTION",
	"Collectors.collectingAndThen(Collector<T,A,R> downstream, Function<R,RR> finisher)": "Adapts a Collector to perform an additional finishing transformation.",
	"Collectors.mapping(Function< ? super T,? extends U > mapper, Collector< ? super U,A,R > downstream)": "Adapts a Collector accepting elements of type U to one accepting elements of type T by applying a mapping function to each input element before accumulation.",
	"Collectors.flatMapping​(Function< ? super T,? extends Stream< ? extends U>> mapper, Collector< ? super U,A,R> downstream) (Java 9)": "Adapts a Collector accepting elements of type U to one accepting elements of type T by applying a flat mapping function to each input element before accumulation.",
	"Collectors.takeWhile​(Predicate< ? super T> predicate) (Java 9)": "Returns, if this stream is ordered, a stream consisting of the longest prefix of elements taken from this stream that match the given predicate.",
	"Collectors.dropWhile​(Predicate< ? super T> predicate) (Java 9)": "Returns, if this stream is ordered, a stream consisting of the remaining elements of this stream after dropping the longest prefix of elements that match the given predicate.",

	"array to string": "SECTION",
	"Array to String - Arrays.toString()": "Arrays.toString(strArray),",
	"Array to String - StringBuilder.reverse()": "reverses string",
	"Array to String - StringBuilder.append()": "StringBuilder stringBuilder = new StringBuilder(), for (int i = 0, i < strArray.length, i++) { stringBuilder.append(strArray[i]), }",
	"Array to String - String.join()": "String joinedString = String.join(' ', strArray),",
	"Array to String - Collectors.joining()": "String joinedString = Arrays.stream(strArray).collect(Collectors.joining()),",
}