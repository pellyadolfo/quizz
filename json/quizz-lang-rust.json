{
	"Rust": "SECTION",
	"Rust 0": "https://medium.com/rustaceans/rusts-ownership-model-is-a-hidden-design-superpower-ca94627d8fed",
	"Rust 1": "https://medium.com/rustaceans/rust-in-2025-the-programming-language-reshaping-the-future-of-software-development-47e93ac59fcf",
	"Rust 2": "https://medium.com/rustaceans/a-plugin-system-for-rust-but-not-only-using-webassembly-26bb3d327c10",
	"Rust 3": "https://medium.com/rustaceans/turbocharge-your-rust-docker-builds-a-journey-to-faster-ci-cd-bf776e484e17",
	"Rust 4": "https://medium.com/rustaceans/rust-powered-apis-with-axum-a-complete-2025-guide-213a28bb44ac",
	"Rust 5": "https://medium.com/rustaceans/mastering-async-rust-conquering-the-hard-mode-for-fearless-concurrent-applications-527b77b67c8a",
	"Rust 6": "",
	"Rust 7": "",
	"Rust - description": "Rust is a systems programming language that focuses on safety, concurrency, and performance. It was developed by Mozilla Research and first appeared in 2010. Rust aims to address common pitfalls in programming, such as memory safety issues, data races, and undefined behavior, often found in languages like C and C++.",

	"Variables": "SECTION",
	"Variables - DataTypes - std": "The Rust Standard Library is the foundation of portable Rust software",
	"Variables - DataTypes - std - Primitives - Scalar": "Despite the value of a unit type being a tuple, it is not considered a compound type because it does not contain multiple values.",
	"Variables - DataTypes - std - Primitives - Scalar - Integers - signed": "Signed integers: i8, i16, i32, i64, i128 and isize (pointer size)",
	"Variables - DataTypes - std - Primitives - Scalar - Integers - unsigned": "Unsigned integers: u8, u16, u32, u64, u128 and usize (pointer size)",
	"Variables - DataTypes - std - Primitives - Scalar - Floating": "Floating point: f32, f64",
	"Variables - DataTypes - std - Primitives - Scalar - char": "char Unicode scalar values like 'a', 'α' and '∞' (4 bytes each)",
	"Variables - DataTypes - std - Primitives - Scalar - String": "The String type is the most common string type in rust and it has ownership over the content of the string. It is heap-allocated, growable, and not null-terminated. A String is stored as a vector of bytes(Vec<u8>), and guaranteed to be a valid UTF-8 sequence.",
	"Variables - DataTypes - std - Primitives - Scalar - str": "str is simply a reference and will most commonly be seen as &str. String literals or str is the most primitive string type. A Rust &str is like a char*. str is an immutable sequence of UTF-8 bytes of dynamic length somewhere in memory. Since the size is unknown, one can only handle it behind a pointer, hence it most commonly appears as &str: a reference to some UTF-8 data, normally called a 'string slice'",
	"Variables - DataTypes - std - Primitives - Scalar - bool": "bool either true or false",
	"Variables - DataTypes - std - Primitives - Scalar - ()": "The unit type (), whose only possible value is an empty tuple: ()",
	"Variables - DataTypes - std - Collections": ".",
	"Variables - DataTypes - std - Collections - Vectors": "let mut numbers = vec![1, 2, 3];",
	"Variables - DataTypes - std - Collections - Arrays": "Arrays like [1, 2, 3].",
	"Variables - DataTypes - std - Collections - Tuples": "Tuples like (1, true).",
	"Variables - DataTypes - std - Collections - Slides": "Slices are references to a section of an array or vector, allowing you to work with subranges of data without owning them. Slices are useful when you need to pass parts of arrays or vectors to functions or need to work with read-only views of data. let slice = &numbers[1..3];",
	"Variables - DataTypes - std - Collections - Hashmap": "A HashMap<K, V> is a key-value store that allows fast lookups by key. This collection is perfect when you need to associate values with unique keys and perform quick retrievals. Rust's HashMap is based on hash tables, ensuring average O(1) time complexity for lookups.",
	"Variables - DataTypes - std - Collections - Hashset": "A HashSet<T> is a collection that ensures all elements are unique. It’s perfect for cases where you want to store distinct items without duplicates, and you don't care about the order of elements.",
	"Variables - DataTypes - std - Collections - LinkedLists": "LinkedList<T> is a doubly linked list, allowing efficient insertions and deletions at both ends. However, it’s typically less common in Rust due to its performance overhead compared to Vec, but it’s useful when frequent insertions or deletions at the front or back of a collection are required.",
	"Variables - DataTypes - std - Collections - BinaryHeap": "A BinaryHeap<T> is a priority queue implemented as a max-heap, where the largest element is always at the top. This collection is useful for scenarios where you need quick access to the largest (or smallest) element.",
	"Variables - DataTypes - std - Operators": "",
	"Variables - DataTypes - std - Operators - Add": "",
	"Variables - DataTypes - std - Operators - Sub": "",
	"Variables - DataTypes - std - Operators - Mul": "",
	"Variables - DataTypes - std - Operators - Overloading": "Implement specific traits like Add, Sub, Mul etc., for operator overloading.",
	"Variables - DataTypes - std - Custom Types": "",
	"Variables - DataTypes - std - Custom Types - struct": "Struct is a user-defined data type that can hold different types of data together. struct the keyword is used to create structure in Rust. struct: define a structure",
	"Variables - DataTypes - std - Custom Types - struct - B256": "Maximum 256-bit byte-array that does not require heap allocation.",
	"Variables - DataTypes - std - Custom Types - enum": "enum: define an enumeration",
	"Variables - DataTypes - std - Collectons - vector": "A vector allows you to store a variable number of values next to each other.",
	"Variables - DataTypes - std - Collectons - string": "A string is a collection of characters. We’ve mentioned the String type previously, but in this chapter we’ll talk about it in depth. The String type, which is provided by Rust’s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type. When Rustaceans refer to “strings” in Rust, they might be referring to either the String or the string slice &str types, not just one of those types. Although this section is largely about String, both types are used heavily in Rust’s standard library, and both String and string slices are UTF-8 encoded.",
	"Variables - DataTypes - std - Collectons - hash map": "A hash map allows you to associate a value with a specific key. It’s a particular implementation of the more general data structure called a map.",
	"Variables - DataTypes - Generics": "Generics is the topic of generalizing types and functionalities to broader cases.",
	"Variables - DataTypes - Generics - types- Functions": "",
	"Variables - DataTypes - Generics - types- Implementations": "",
	"Variables - DataTypes - Generics - types- Traits": "",
	"Variables - DataTypes - Generics - bound": "",
	"Variables - DataTypes - Generics - where": "",
	"Variables - DataTypes - Generics - newtype": "",
	"Variables - DataTypes - Generics - phantom": "",
	"Variables - DataTypes - Operations - Copy": "The Copy trait in Rust defines the ability to implicitly copy an object. The behavior Copy is not overloadable. It is always a simple bitwise copy. This is available for the types that have a fixed size and are stored entirely on the stack.",
	"Variables - DataTypes - Operations - Clone": "The Clone trait defines the ability to explicitly create a deep copy of an object T. When we call Clone for type T, it does all the arbitrarily complicated operations required to create a new T.",
	"Variables - DataTypes - Operations - Casting": "",
	"Variables - DataTypes - Operations - Inference": "",
	"Variables - DataTypes - Operations - Aliasing": "",
	"Variables - DataTypes - Operations - Conversion": "",
	"Variables - DataTypes - Operations - Conversion - From": "std::convert::From. Implement the From trait for a type to define how it can be created from another type.",
	"Variables - DataTypes - Operations - Conversion - Into": "std::convert::Into. A value-to-value conversion that consumes the input value. The opposite of From. One should avoid implementing Into and implement From instead. Implementing From automatically provides one with an implementation of Into thanks to the blanket implementation in the standard library.",
	"Variables - Declaration - Typing - static": "Rust provides type safety via static typing. Variable bindings can be type annotated when declared. However, in most cases, the compiler will be able to infer the type of the variable from the context, heavily reducing the annotation burden.",
	"Variables - Declaration - Typing - let": "Values (like literals) can be bound to variables, using the let binding.  let an_integer = 1u32;",
	"Variables - Declaration - Naming": "",
	"Variables - Declaration - Assignment": "",
	"Variables - Declaration - Assignment - declare first": "It's possible to declare variable bindings first, and initialize them later. However, this form is seldom used, as it may lead to the use of uninitialized variables.",
	"Variables - Declaration - Assignment - uninitialized": "The compiler forbids use of uninitialized variables, as this would lead to undefined behavior.",
	"Variables - Declaration - Mutation": "Variable bindings are immutable by default, but this can be overridden using the mut modifier.",
	"Variables - Declaration - Mutation - mut": "Variable bindings are immutable by default, but this can be overridden using the mut modifier.",
	"Variables - Declaration - Mutation - freezing": "When data is bound by the same name immutably, it also freezes. Frozen data can't be modified until the immutable binding goes out of scope.",
	"Variables - Declaration - EnvVars": "",
	"Variables - Declaration - EnvVars - std::env": "Using the std::env module. Rust provides the std::env module to interact with environment variables. This module can read, set, and remove environment variables.",
	"Variables - Declaration - EnvVars - std::env - set": "You can set an environment variable using the set_var function. std::env::set_var(key, '123');",
	"Variables - Declaration - EnvVars - std::env - remove": "To remove an environment variable, use the remove_var function. env::remove_var(key);",
	"Variables - Declaration - EnvVars - std::env - check": "To check if an environment variable exists, use the env::var function, which returns a Result. match env::var(key) { ... }",
	"Variables - Declaration - EnvVars - command line": "Using the command line (Windows and Linux). You can pass environment variables directly from the command line when running your Rust program",
	"Variables - Declaration - EnvVars - dotenv": "Using the dotenv crate. In addition to the standard library, you can use the dotenv crate to load environment variables from a .env file.",

	"Logic": "SECTION",
	"Logic - Sync - Imperative - ControlFlow": "",
	"Logic - Sync - Imperative - ControlFlow - Statements - Expressions": "",
	"Logic - Sync - Imperative - ControlFlow - Conditions - if/else": "Branching with if-else is similar to other languages. Unlike many of them, the boolean condition doesn't need to be surrounded by parentheses, and each condition is followed by a block. if-else conditionals are expressions, and, all branches must return the same type.",
	"Logic - Sync - Imperative - ControlFlow - Conditions - if/let": "Another benefit is that if let allows us to match non-parameterized enum variants.",
	"Logic - Sync - Imperative - ControlFlow - Conditions - let/else": "With let-else, a refutable pattern can match and bind variables in the surrounding scope like a normal let, or else diverge (e.g. break, return, panic!) when the pattern doesn't match.",
	"Logic - Sync - Imperative - ControlFlow - Conditions - then": "(n > 0).then(|| n)",
	"Logic - Sync - Imperative - ControlFlow - Conditions - Combinators": "Combinators are methods that ease the manipulation of some type T. They favor a functional (method chaining) style of code.",
	"Logic - Sync - Imperative - ControlFlow - Conditions - Combinators - map": "match is a valid method for handling Options. However, you may eventually find heavy usage tedious, especially with operations only valid with an input. In these cases, combinators can be used to manage control flow in a modular fashion.",
	"Logic - Sync - Imperative - ControlFlow - Conditions - Combinators - and_then": "Chaining multiple calls together can then become confusing. That's where another combinator called and_then(), known in some languages as flatmap, comes in.",
	"Logic - Sync - Imperative - ControlFlow - Iterators": "",
	"Logic - Sync - Imperative - ControlFlow - Iterators - loop": "Rust provides a loop keyword to indicate an infinite loop.",
	"Logic - Sync - Imperative - ControlFlow - Iterators - while": "The while keyword can be used to run a loop while a condition is true.",
	"Logic - Sync - Imperative - ControlFlow - Iterators - while/let": ".",
	"Logic - Sync - Imperative - ControlFlow - Iterators - for": "The for in construct can be used to iterate through an Iterator. One of the easiest ways to create an iterator is to use the range notation a..b. This yields values from a (inclusive) to b (exclusive) in steps of one.",
	"Logic - Sync - Imperative - ControlFlow - Iterators - break": "The break statement can be used to exit a loop at anytime.",
	"Logic - Sync - Imperative - ControlFlow - Iterators - continue": "continue statement can be used to skip the rest of the iteration and start a new one.",
	"Logic - Sync - Imperative - ControlFlow - Iterators - Collections": "When dealing with collections, using iterators instead for can lead to more readable and performant code. Iterators in Rust are lazy and can prevent unnecessary memory allocations.",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling": "",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - Recoverable": "Most errors aren’t serious enough to require the program to stop entirely. Sometimes when a function fails it’s for a reason that you can easily interpret and respond to. For example, if you try to open a file and that operation fails because the file doesn’t exist, you might want to create the file instead of terminating the process.",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - Unrecoverable - panic!": "Sometimes bad things happen in your code, and there’s nothing you can do about it. In these cases, Rust has the panic! macro.",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - Unrecoverable - panic! - automatic": "by taking an action that causes our code to panic (such as accessing an array past the end)",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - Unrecoverable - panic! - explicitly": "by explicitly calling the panic! macro",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - Unrecoverable - panic! - message": "By default, these panics will print a failure message, unwind, clean up the stack, and quit. Via an environment variable, you can also have Rust display the call stack when a panic occurs to make it easier to track down the source of the panic.",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - Unrecoverable - Option<T>": "Sometimes it's desirable to catch the failure of some parts of a program instead of calling panic!; this can be accomplished using the Option enum. ",
	"Logic - Sync - Imperative - ControlFlow - ErrorHandling - ?": "The ? operator propagates errors by returning them early if they occur, simplifying error handling by avoiding explicit match statements.",
	"Logic - Sync - Imperative - OOP": "Some people say that Rust is Object-Oriented and others say that it is not. Rust: Implement Inheritance 3 Ways",
	"Logic - Sync - Imperative - OOP - enum": "",
	"Logic - Sync - Imperative - OOP - trait": "",
	"Logic - Sync - Imperative - OOP - struct": "Struct Composition",
	"Logic - Sync - Functional - ControlFlow - PatternMatching": "",
	"Logic - Sync - Functional - ControlFlow - PatternMatching - match": "Rust provides pattern matching via the match keyword, which can be used like a C switch. The first matching arm is evaluated and all possible values must be covered.",
	"Logic - Async - Imperative": "The Rust standard library (std) still lacks native support for asynchronous operations, meaning if you need support for async functionality you must rely on third-party crates like async-std, tokio, monoio, or smol.",
	"Logic - Async - Imperative - Syntax - async/await": "async functions return a Future, which can be awaited to yield the result once it is ready.",
	"Logic - Async - Imperative - Frameworks - Tokio": "https://medium.com/@anon.quant/why-one-should-avoid-using-asynchronous-frameworks-like-tokio-in-real-time-trading-systems-663edbf4e961",
	"Logic - Async - Imperative - Libs - async-std": "Async-std was created to mirror the Rust standard library (std) as closely as possible, but in an async context, offering familiar APIs with the power of async/await.",
	"Logic - Async - Imperative - Libs - async-std - executor": "It provided features like single-allocation task creation, an adaptive lock-free executor, and a threadpool, for high throughput with low latency. However async-std had already been using smol’s executor under the hood for some time.",
	"Logic - Async - Imperative - Libs - async-std - deprecated": "Josh Triplett the maintainer of async-std, shared the news on GitHub, marking the end of an era for the project.",
	"Logic - Async - Imperative - Libs - tokio": "tokio, which is often seen as an opinionated ecosystem",
	"Logic - Async - Imperative - Libs - smol": "The async-std team has recommended that all users and crates built on async-std migrate to smol, a lightweight and efficient alternative that shares a similar API structure. smol is a tiny, unopinionated set of async building blocks. This flexibility allows smol-based systems to run within tokio (but not vice versa), making it a better choice for crate authors.",
	"Logic - Async - Imperative - Libs - monoio": "",
	"Logic - Async - Imperative - Libs - futures_macro": "",
	"Logic - Resources": "",
	"Logic - IO - CommandLine": "",
	"Logic - IO - EnvVars": "",
	"Logic - IO - stdout": "",
	"Logic - IO - stderr": "",
	"Logic - IO - Ethers-rs": "",
	"Logic - IO - Buffered": "Reduce system calls with buffered I/O operations: let mut reader = BufReader::new(file); reader.read_to_string(&mut contents)?;",
	"Logic - IO - Async": "Use Tokio for efficient I/O multiplexing: let mut file = tokio::fs::File::open('data.txt').await?;",
	"Logic - IO - Files": "Memory-Mapped Files. For large files requiring random access: let file = OpenOptions::new().read(true).open('large_data.bin')?; let mapping = unsafe { memmap2::Mmap::map(&file)? };",
	"Logic - IO - Alloy": "alloy-rs/core, a rewrite of the popular ethers-core package and the ethabi crate.",
	"Logic - IO - Alloy - alloy-sol-macro": "This crate provides the sol! procedural macro",
	"Logic - IO - Alloy - alloy-sol-macro - sol!": "parses Solidity syntax to generate types that implement alloy-sol-types traits.",
	"Logic - IO - Alloy - alloy-sol-macro - sol! - #[sol(rpc)]": "The sol macro also codegens JSON RPC bindings via the #[sol(rpc)] attribute.",

	"CI - Architecture": "SECTION",
	"CI - Architecture - Structure - Project": ".",
	"CI - Architecture - Structure - Project - create bin": "cargo new arbitrageur --bin",
	"CI - Architecture - Structure - Project - create lib": "cargo new arbitrageur --lib",
	"CI - Architecture - Structure - Workspace": "A workspace is basically a series of packages that share the same output directory as well as cargo.lock.",
	"CI - Architecture - Structure - Package": "A package is a bundle of one or more crates that provides a set of functionality.",
	"CI - Architecture - Structure - Crate": "A crate is the smallest amount of code that the Rust compiler considers at a time.",
	"CI - Architecture - Structure - Crate - root": "The crate root is a source file that the Rust compiler starts from and makes up the root module of your crate usually src/lib.rs for a library crate or src/main.rs for a binary crate.",
	"CI - Architecture - Structure - Crate - types": "A crate can come in one of two forms: a binary crate or a library crate. A package can contain as many binary crates as you like, but at most only one library crate. A package must contain at least one crate, whether that’s a library or binary crate..",
	"CI - Architecture - Structure - Crate - types - binary": "Binary crates are programs you can compile to an executable that you can run, such as a command-line program or a server. Each must have a function called main that defines what happens when the executable runs. All the crates we’ve created so far have been binary crates.",
	"CI - Architecture - Structure - Crate - types - library": "Library crates don’t have a main function, and they don’t compile to an executable. Instead, they define functionality intended to be shared with multiple projects. Most of the time when Rustaceans say “crate”, they mean library crate, and they use “crate” interchangeably with the general programming concept of a “library“.",
	"CI - Architecture - Structure - Crate - Attributes": "",
	"CI - Architecture - Structure - extern": "Rust code can use functions and statics from foreign code. The type signatures of these foreign items are provided in extern blocks.",
	"CI - Architecture - Structure - extern - Unsafe": "Historically, all items within extern blocks have been unsafe to use, but we didn't have to write unsafe anywhere on the extern block itself. We've decided that it's the responsibility of the person writing the extern block to ensure that all signatures contained within it are correct, and so we now allow writing unsafe extern",
	"CI - Architecture - Structure - Modules": "Crates can contain modules, and the modules may be defined in other files that get compiled with the crate.",
	"CI - Architecture - Structure - Modules - declare": "In the crate root file, you can declare new modules; say you declare a “garden” module with mod garden;. The compiler will look for the module’s code in these places:",
	"CI - Architecture - Structure - Modules - declare - inline": "Inline, within curly brackets that replace the semicolon following mod garden",
	"CI - Architecture - Structure - Modules - declare - src/garden.rs": "Inline, within curly brackets that replace the semicolon following mod garden",
	"CI - Architecture - Structure - Modules - declare - src/garden/mod.rs": "Inline, within curly brackets that replace the semicolon following mod garden",
	"CI - Architecture - Structure - Modules - refer": "Paths to code in modules: Once a module is part of your crate, you can refer to code in that module from anywhere else in that same crate, as long as the privacy rules allow, using the path to the code. For example, an Asparagus type in the garden vegetables module would be found at crate::garden::vegetables::Asparagus.",
	"CI - Architecture - Structure - Submodules": "Crates can contain modules, and the modules may be defined in other files that get compiled with the crate.",
	"CI - Architecture - Structure - Submodules - declare": "Declaring submodules: In any file other than the crate root, you can declare submodules. For example, you might declare mod vegetables; in src/garden.rs. The compiler will look for the submodule’s code within the directory named for the parent module in these places: 1. Inline, directly following mod vegetables, within curly brackets instead of the semicolon 2. In the file src/garden/vegetables.rs 3. In the file src/garden/vegetables/mod.rs",
	"CI - Architecture - Structure - Traits": "Traits are a set of methods that can be defined for particular types. Traits allow you to define shared behavior that can be used by multiple types. A trait method is able to access other methods within that trait.",
	"CI - Architecture - Structure - Traits - impl Trait": "The impl keyword is primarily used to define implementations on types.",
	"CI - Architecture - Structure - Traits - impl Trait - fun": "Functions and consts can both be defined in an implementation. A function defined in an impl block can be standalone, meaning it would be called like Foo::bar().",
	"CI - Architecture - Structure - Traits - impl Trait - fun - self": "If the function takes self, &self, or &mut self as its first argument, it can also be called using method-call syntax, a familiar feature to any object oriented programmer, like foo.bar().",
	"CI - Architecture - Structure - Traits - impl Trait - fun - &self": "If the function takes self, &self, or &mut self as its first argument, it can also be called using method-call syntax, a familiar feature to any object oriented programmer, like foo.bar().",
	"CI - Architecture - Structure - Traits - impl Trait - fun - &mut self": "If the function takes self, &self, or &mut self as its first argument, it can also be called using method-call syntax, a familiar feature to any object oriented programmer, like foo.bar().",
	"CI - Architecture - Structure - Traits - where": "where can be used for constraints with traits.",
	"CI - Architecture - Structure - Traits - #[derive]": "The compiler is capable of providing basic implementations for some traits via the #[derive] attribute. These traits can still be manually implemented if a more complex behavior is required.",
	"CI - Architecture - Structure - Traits - dyn": "The dyn keyword is used to highlight that calls to methods on the associated Trait are dynamically dispatched. To use the trait this way, it must be ‘object safe’.",
	"CI - Architecture - Structure - Traits - Drop": "The Drop trait only has one method: drop, which is called automatically when an object goes out of scope. The main use of the Drop trait is to free the resources that the implementor instance owns. Box, Vec, String, File, and Process are some examples of types that implement the Drop trait to free resources. The Drop trait can also be manually implemented for any custom data type.",
	"CI - Architecture - Structure - Traits - Iterator": "The Iterator trait is used to implement iterators over collections such as arrays. The trait requires only a method to be defined for the next element, which may be manually defined in an impl block or automatically defined (as in arrays and ranges).",
	"CI - Architecture - Structure - Traits - Clone": "When dealing with resources, the default behavior is to transfer them during assignments or function calls. However, sometimes we need to make a copy of the resource as well. The Clone trait helps us do exactly this. Most commonly, we can use the .clone() method defined by the Clone trait.",
	"CI - Architecture - Structure - Traits - supertrait": "Rust doesn't have inheritance, but you can define a trait as being a superset of another trait.",
	"CI - Architecture - Structure - Traits - Objects": "",
	"CI - Architecture - Structure - Traits - Objects - DinamicDispatch": "Trait objects allow for dynamic dispatch, meaning the method to call is determined at runtime. This is achieved using a reference to a trait, which is a type-erased pointer.",
	"CI - Architecture - Structure - Traits - Bounds": "Trait bounds restrict the types that can be used with generics, ensuring they implement specific traits.",
	"CI - Architecture - Structure - Functions": "Functions are like separate little programs that can do stuff.",
	"CI - Architecture - Structure - Functions - format - fn": "Functions are declared using the fn keyword.",
	"CI - Architecture - Structure - Functions - format - arguments": "Its arguments are type annotated, just like variables.",
	"CI - Architecture - Structure - Functions - format - arguments - passing": "In Rust, there are four ways to “pass” or transfer a variable into or out of a function or scope.",
	"CI - Architecture - Structure - Functions - format - arguments - passing - moving": "Moving the variable: Rust by default moves values when you assign them or return them from a function. Moving means you cannot use the variable at the previous location once it has been moved. However, discussing moves in detail would be too much to do within the context of this post.",
	"CI - Architecture - Structure - Functions - format - arguments - passing - lifetime": "Passing an immutable reference: An immutable references is a way to reference a variable from another scope, as long as the reference never outlives the variable it references by measurement of scopes. In Rust, this is called a lifetime. You can have one or more immutable references to a variable.",
	"CI - Architecture - Structure - Functions - format - arguments - passing - mutability": "Passing a mutable reference: A mutable reference is a way to reference a variable from another scope, and the similar rules of lifetime apply. However, you may only ever have one mutable reference at a time to a variable. This means any variable can only be modified from a single reference at any given time.",
	"CI - Architecture - Structure - Functions - format - arguments - passing - copy": "Passing a copy: In Rust, different types may implement the Copy or Clone traits, such that they can be either implicitly or explicitly copied. The main difference between Copy and Clone is the former does a byte by byte, memcpy style copy, where as Clone is an explicitly implemented member by member copy, with the possibility for custom logic.",
	"CI - Architecture - Structure - Functions - format - returndec": "if the function returns a value the return type must be specified after an arrow ->. Functions that don't return a value, actually return the unit type `()`",
	"CI - Architecture - Structure - Functions - format - returndec - Result<T, E>": "Result<T, E> is the type used for returning and propagating errors. It is an enum with the variants, Ok(T), representing success and containing a value, and Err(E), representing error and containing an error value.",
	"CI - Architecture - Structure - Functions - format - returndec - Result<T, E> - Ok(T)": "Ok(T), representing success and containing a value",
	"CI - Architecture - Structure - Functions - format - returndec - Result<T, E> - Err(E)": "Err(E), representing error and containing an error value",
	"CI - Architecture - Structure - Functions - format - returndec - Result<String, Box<dyn Error>>": "Box<dyn Error> allows returning any error type that implements the Error trait.",
	"CI - Architecture - Structure - Functions - format - returndec - Option": "Option is for values that might or might not be present.",
	"CI - Architecture - Structure - Functions - format - return": "The final expression in the function will be used as return value. Alternatively, the return statement can be used to return a value earlier from within the function, even from inside loops or if statements.",
	"CI - Architecture - Structure - Functions - format - return - unwrap_or": "when you have a default value to provide for a return",
	"CI - Architecture - Structure - Functions - format - return - unwrap_or_default": "when the type implements Default",
	"CI - Architecture - Structure - Functions - format - return - unwrap_or_else": "when the default value needs computation",
	"CI - Architecture - Structure - Functions - format - return - RTN": "Return Type Notation will use a new syntax, <T as Trait>::method(..) (or <T>::method(..) if the trait is inferred), to refer to the type returned by the method method on trait Trait for a value of type T. This notation can then be used in bounds and where-clauses. https://medium.com/rustaceans/the-long-awaited-return-type-notation-rfc-is-here-b5cfb8ba6db4",
	"CI - Architecture - Structure - Functions - AssociatedFunctions": "Associated functions are functions that are defined on a type generally",
	"CI - Architecture - Structure - Functions - AssociatedFunctions - example": "struct Point { x: f64, y: f64, } impl Point { fn origin() -> Point { Point { x: 0.0, y: 0.0 } } }",
	"CI - Architecture - Structure - Functions - HOF": "Rust provides Higher Order Functions (HOF). These are functions that take one or more functions and/or produce a more useful function. HOFs and lazy iterators give Rust its functional flavor.",
	"CI - Architecture - Structure - Functions - DivergingFunctions": "Diverging functions never return. They are marked using !, which is an empty type.",
	"CI - Architecture - Structure - Functions - Macros": "Rust provides a powerful macro system that allows metaprogramming. As you've seen in previous chapters, macros look like functions, except that their name ends with a bang !, but instead of generating a function call, macros are expanded into source code that gets compiled with the rest of the program. However, unlike macros in C and other languages, Rust macros are expanded into abstract syntax trees, rather than string preprocessing, so you don't get unexpected precedence bugs.",
	"CI - Architecture - Structure - Functions - Macros - macro_rules!": "Macros are created using the macro_rules! macro.",
	"CI - Architecture - Structure - Functions - Macros - invocation": "macros look like functions, except that their name ends with a bang !, but instead of generating a function call, macros are expanded into source code that gets compiled with the rest of the program.",
	"CI - Architecture - Structure - Functions - Methods": "methods are associated functions that are called on a particular instance of a type.",
	"CI - Architecture - Structure - Functions - Methods - example": "methods are associated functions that are called on a particular instance of a type.",
	"CI - Architecture - Structure - Functions - Closures": "Closures are functions that can capture the enclosing environment. Closures are powerful anonymous functions that capture their own environment and can be saved in a variable and also passed to other functions as arguments.",
	"CI - Architecture - Structure - Functions - HRTBs": "Higher-Ranked Trait Bounds (HRTB) allow for functions that accept generic parameters with lifetimes that are themselves generic.",
	"CI - Architecture - Patterns": "https://medium.com/@vermatanisha666/how-rust-killed-the-gang-of-four-the-hidden-war-between-ownership-and-design-patterns-405220e02026",
	"CI - Architecture - Patterns - SingleFlight": "https://medium.com/rustaceans/singleflight-scenario-implementation-based-on-tokio-notify-b70e7697d6e8",
	"CI - Architecture - OO": "",

	"CI - Applications": "SECTION",
	"CI - Applications - Web - Wasm": "Rust’s compatibility with WebAssembly (Wasm) has opened up new avenues for web development, allowing Rust code to run at near-native speed in web browsers.",
	"CI - Applications - Systems - Linux Kernel": "",
	"CI - Applications - Systems - Blockchain": "",
	"CI - Applications - Systems - Browsers": "At Google, we are driving the adoption of Rust in platforms like Android and Chromium to reduce memory safety vulnerabilities.",
	"CI - Applications - Systems - Android": "Google recently rewrote the protected virtual machine firmware within the Android virtualization framework using the Rust programming language.",
	"CI - Applications - Web - frameworks - Actix-Web": "",
	"CI - Applications - Web - frameworks - Rocket": "",
	"CI - Applications - Web - frameworks - Loco": "",
	"CI - Applications - Web - frameworks - Warp": "",
	"CI - Applications - Web - frameworks - Axum": "",
	"CI - Applications - Web - frameworks - Tide": "",
	"CI - Applications - Web - frameworks - Salvo": "",
	"CI - Applications - Web - frameworks - Gotham": "",
	"CI - Applications - Web - frameworks - Nickel": "",
	"CI - Applications - Web - frameworks - Yew": "",
	"CI - Applications - Web - frameworks - Dioxus": "",

	"CI - Packaging": "SECTION",
	"CI - Packaging - Installer - rustup": "rustup is an installer for the systems programming language Rust",
	"CI - Packaging - PackageManager - Cargo": "Cargo is the Rust package manager. It is a tool that allows Rust packages to declare their various dependencies and ensure that you’ll always get a repeatable build.",
	"CI - Packaging - PackageManager - Cargo - cargo": "Cargo is actually a package that contains the binary crate for the command-line tool you’ve been using to build your code. The Cargo package also contains a library crate that the binary crate depends on. Other projects can depend on the Cargo library crate to use the same logic the Cargo command-line tool uses.",
	"CI - Packaging - PackageManager - Cargo - Cargo.toml": "A package contains a Cargo.toml file that describes how to build those crates. The Cargo.toml file is a manifest file where we can specify metadata such as name, version, etc, project settings, and dependencies(crates) for our project.",
	"CI - Packaging - PackageManager - Cargo - Cargo.lock": "The Cargo.lock file contains exact information about dependencies and Cargo maintains it. If we are building a rust library, then put Cargo.lock in the .gitignore but if we are building end products application then Cargo.lock should be checked into the git repo.",
	"CI - Packaging - PackageManager - Cargo - newExecutable": "Create a new package that builds an executable: cargo new IntmainApp.",
	"CI - Packaging - PackageManager - Cargo - newLib": "Create a new package that builds a library: cargo new --lib IntmainLib.",
	"CI - Packaging - PackageManager - Cargo - tree": "Display a tree of dependencies in the project: cargo tree",
	"CI - Packaging - PackageManager - Cargo - info": "Cargo now has an info subcommand to display information about a package in the registry",
	"CI - Packaging - Interoperability - C": "Rust supports interoperability with C code without introducing any additional overhead.",

	"CI - Building": "SECTION",
	"CI - Building - Crate": "When compiling a crate, the compiler first looks in the crate root file for code to compile.",
	"CI - Building - cargo - build": "Build a package and all its dependencies: cargo build",
	"CI - Building - cargo - build - /target/debug": "Output for cargo build",
	"CI - Building - cargo - run": "build and run",
	"CI - Building - cargo - release": "Build a package with optimization: cargo build -- release",
	"CI - Building - cargo - release - /target/release": "Output for cargo release",
	"CI - Building - rustc": ".",
	"CI - Building - gccrs": "https://blog.rust-lang.org/2024/11/07/gccrs-an-alternative-compiler-for-rust.html",
	"CI - Building - UnsafeOperations - unsafe": "unsafe is used to perform operations that cannot be checked by the Rust compiler, such as dereferencing raw pointers or calling unsafe functions.",
	"CI - Building - UnsafeOperations - PhantomData": "PhantomData is used to indicate that a struct owns data of a type without actually storing that type, which is important for enforcing correct lifetimes and variance.",

	"CI - Integration": "SECTION",
	"CI - Integration - Execution - Scopes": "Rust’s name resolution operates on a global hierarchy of namespaces. Each level in the hierarchy can be thought of as some item. The items are one of those mentioned above, but also include external crates. Declaring or defining a new module can be thought of as inserting a new tree into the hierarchy at the location of the definition. To control whether interfaces can be used across modules, Rust checks each use of an item to see whether it should be allowed or not. This is where privacy warnings are generated, or otherwise “you used a private item of another module and weren’t allowed to.",
	"CI - Integration - Execution - Scopes - default": "By default, everything is private, with two exceptions: Associated items in a pub Trait are public by default; Enum variants in a pub enum are also public by default. If an item is private, it may be accessed by the current module and its descendants.",
	"CI - Integration - Execution - Scopes - pub": "When an item is declared as pub, it can be thought of as being accessible to the outside world. If an item is public, then it can be accessed externally from some module m if you can access all the item’s ancestor modules from m. You can also potentially be able to name the item through re-exports. See below.",
	"CI - Integration - Execution - Scopes - pub (in path)": "pub(in path) makes an item visible within the provided path. path must be an ancestor module of the item whose visibility is being declared. Starting with the 2018 edition, paths for pub(in path) must start with crate, self, or super. The 2015 edition may also use paths starting with :: or modules from the crate root.",
	"CI - Integration - Execution - Scopes - pub (crate)": "pub(crate) makes an item visible within the current crate.",
	"CI - Integration - Execution - Scopes - pub (super)": "pub(super) makes an item visible to the parent module. This is equivalent to pub(in super).",
	"CI - Integration - Execution - Scopes - pub (self)": "pub(self) makes an item visible to the current module. This is equivalent to pub(in self) or not using pub at all.",
	"CI - Integration - Execution - Scopes - pub use": "Rust allows publicly re-exporting items through a pub use directive. Because this is a public directive, this allows the item to be used in the current module through the rules above. It essentially allows public access into the re-exported item.",
	"CI - Integration - Execution - Threads": "",
	"CI - Integration - Execution - Threads - Concurrency": "Rust’s ownership model enforces thread-safe behavior at compile time.",
	"CI - Integration - Execution - Threads - Concurrency - RaceConditions": "Confident, parallel processing without race conditions or deadlocks — without needing runtime guards.",
	"CI - Integration - Execution - Threads - Concurrency - Channels": "Channels allow threads to communicate by sending messages.",
	"CI - Integration - Execution - Threads - Concurrency - Channels - create": "let (tx, rx) = mpsc::channel();",
	"CI - Integration - Execution - Threads - Concurrency - Channels - send": "tx.send(val).unwrap();",
	"CI - Integration - Execution - Threads - Concurrency - Channels - receive": "let received = rx.recv().unwrap();",
	"CI - Integration - Execution - Threads - Parallelism - SIMD": "For data-parallel operations, leverage SIMD capabilities",
	"CI - Integration - Execution - Threads - Parallelism - Rayon": "For CPU-bound tasks, use Rayon to easily parallelize workloads",
	"CI - Integration - Execution - Memory": "",
	"CI - Integration - Execution - Memory - undefined": "Undefined behaviour in Rust refers to actions that the Rust compiler and runtime do not guarantee to behave predictably or correctly. A foundational goal of Rust is to ensure that your programs never have undefined behavior.",
	"CI - Integration - Execution - Memory - Allocation - Heap": "Heap memory is for dynamic memory allocation, suitable for objects that need to persist beyond the scope of a single function call.",
	"CI - Integration - Execution - Memory - Allocation - Heap - variables - size": "The heap is slower and used when the memory allocation size is unknown.",
	"CI - Integration - Execution - Memory - Allocation - Heap - variables - move": "Heap data is automatically moved. Rust automatically frees a box’s heap memory when it deallocates the variable’s stack frame that owns the box.",
	"CI - Integration - Execution - Memory - Allocation - Heap - variables - objects": "Rust data structures like Vec, String, and HashMap use the heap memory by default.",
	"CI - Integration - Execution - Memory - Allocation - Heap - variables - Box<T>": "Rust also provides you the Box construct for putting data on the heap. Values can be boxed (allocated on the heap) by creating a Box<T>. A box is a smart pointer to a heap allocated value of type T. When a box goes out of scope, its destructor is called, the inner object is destroyed, and the memory on the heap is freed.",
	"CI - Integration - Execution - Memory - Allocation - Heap - variables - *": "Boxed values can be dereferenced using the * operator; this removes one layer of indirection. let unboxed_point: Point = *boxed_point;",
	"CI - Integration - Execution - Memory - Allocation - Stack": "Stack memory is for static memory allocation, typically used for variables with a known lifetime and scope. Allocating on the stack is faster than the heap. Whenever possible, use types that live on the stack.",
	"CI - Integration - Execution - Memory - Allocation - Stack - frame": "used to store all of the local variables and function parameters.",
	"CI - Integration - Execution - Memory - Allocation - Stack - frame - lifecycle": "When you call a function in Rust, it allocates a stack frame for it. Once main has exited, the stack frame allocated on entry will be released.",
	"CI - Integration - Execution - Memory - Allocation - Stack - variables": "Variables Live in the Stack. When you call a function in Rust, it allocates a stack frame for it. You can think of a stack frame as a mapping from variables to their values within a single scope, such as a function.",
	"CI - Integration - Execution - Memory - Allocation - Stack - variables - size": "The stack is faster and used for known fixed-size memory allocation.",
	"CI - Integration - Execution - Memory - Allocation - Stack - variables - copy": "When an expression reads a variable (for example is assignments and function calls), the variable’s value is copied from its slot in the stack frame.",
	"CI - Integration - Execution - Memory - Allocation - Stack - vs Heap": "Stack allocation is significantly faster than heap allocation. Use stack for small, fixed-size data with known lifetime. let array_on_stack = [0u8; 4096]; let vector_on_heap = vec![0u8; 4096];",
	"CI - Integration - Execution - Memory - Allocation - Arena": "An arena allocator, also simply known as an arena, is an object you can use to allocate a series of objects that all have relatively short lifetimes.",
	"CI - Integration - Execution - Memory - Pointers": "A pointer is a value that describes a location in memory.",
	"CI - Integration - Execution - Memory - Pointers - target": "A pointer points to some memory address on the heap.",
	"CI - Integration - Execution - Memory - Pointers - Ownership": "Each piece of data in Rust has a single owner, and the data is automatically deallocated when the owner goes out of scope. This prevents memory leaks and dangling pointers.",
	"CI - Integration - Execution - Memory - Pointers - Ownership - noGC": "Rust does not use a garbage collector (Java) nor does it rely on manual memory management (C). Instead, Rust employs a unique memory management system based on ownership with the help of the borrow checker.",
	"CI - Integration - Execution - Memory - Pointers - Ownership - safety": "Ownership model prevents undefined behaviour which thus ensures memory-safety.",
	"CI - Integration - Execution - Memory - Pointers - Ownership - Operations - Stack - copy": "For data in stack, the value gets copied and doesn’t lose it ownership",
	"CI - Integration - Execution - Memory - Pointers - Ownership - Operations - Heap - move": "For data in the heap, the value gets moved and it loses ownership.",
	"CI - Integration - Execution - Memory - Pointers - Ownership - Operations - Heap - clone": "For data in heap and ‘clone()’ is used, then the value gets cloned and it doesn’t lose its ownership.",
	"CI - Integration - Execution - Memory - Pointers - Types - inmutable - addr_of": "macro std::ptr::addr_of! Creates a const raw pointer to a place, without creating an intermediate reference. addr_of!(expr) is equivalent to &raw const expr .",
	"CI - Integration - Execution - Memory - Pointers - Types - mutable - addr_of_mut": "macro std::ptr::addr_of_mut! Creates a mut raw pointer to a place, without creating an intermediate reference. addr_of_mut!(expr) is equivalent to &raw mut expr .",
	"CI - Integration - Execution - Memory - Pointers - Smart": "Smart pointers are data structures that act like a pointer but also have additional metadata and capabilities.",
	"CI - Integration - Execution - Memory - Pointers - Smart - cow": "Cow allows you to work with borrowed data while enabling cloning if mutation is needed.",
	"CI - Integration - Execution - Memory - Pointers - Smart - Box": "Boxes allow you to store data on the heap rather than the stack. ",
	"CI - Integration - Execution - Memory - Pointers - Smart - Rc": "Rc: Used for single-threaded shared ownership.",
	"CI - Integration - Execution - Memory - Pointers - Smart - Arc": "Arc: Used for multi-threaded shared ownership.",
	"CI - Integration - Execution - Memory - Pointers - Smart - Cleanup - Drop": "Trait std::ops::Drop. When a value is no longer needed, Rust will run a “destructor” on that value. The most common way that a value is no longer needed is when it goes out of scope. Destructors may still run in other circumstances, but we’re going to focus on scope for the examples here.",
	"CI - Integration - Execution - Memory - Pointers - Smart - Cleanup - Drop - default": "Rust automatically calls the destructors of all contained fields, you don’t have to implement Drop in most cases. But there are some cases where it is useful, for example for types which directly manage a resource.",
	"CI - Integration - Execution - Memory - Pointers - Smart - Cleanup - Drop - Drop:drop": "A call to Drop::drop for that value, if this special Drop trait is implemented for its type.",
	"CI - Integration - Execution - Memory - Pointers - Smart - Cleanup - Drop - drop glue": "The automatically generated “drop glue” which recursively calls the destructors of all the fields of this value.",
	"CI - Integration - Execution - Memory - Pointers - Pinning": "Pinning marks a value as immovable",
	"CI - Integration - Execution - Memory - Pointers - Pinning - commands - Pin": "Pin<P> Wrapper: This type is a wrapper around pointers like Box, Rc, or &mut, enforcing that the value inside it stays at a fixed memory address.",
	"CI - Integration - Execution - Memory - Pointers - Pinning - commands - Unpin": "Unpin Trait: By default, most types in Rust are Unpin, meaning they can be moved. Types that are sensitive to movement (like self-referential structs and async futures) do not implement Unpin, making them compatible with Pin.",
	"CI - Integration - Execution - Memory - Pointers - Pinning - cases - sef-referential": "Self-referential Types: Data structures that reference themselves, creating a direct link to their own fields.",
	"CI - Integration - Execution - Memory - Pointers - Pinning - cases - async": "Async Programming: Many async tasks in Rust (Futures) rely on pinned data structures to avoid issues during suspension and resumption.",
	"CI - Integration - Execution - Memory - Pointers - Pinning - cases - FFI": "FFI (Foreign Function Interface): When working with C libraries or other external code, values need to remain at fixed addresses to keep pointers valid.",
	"CI - Integration - Execution - Memory - References": "If you want to use a value without dealing with ownership, you can create a reference. A reference points to the memory of another value. A reference means you borrow the value, but you don't own it.",
	"CI - Integration - Execution - Memory - References - target": "A Rust reference can refer to items that are located either on the stack or on the heap.",
	"CI - Integration - Execution - Memory - References - Borrowing": "The variable still lives in the stack but its value is stored in the heap.",
	"CI - Integration - Execution - Memory - References - Borrowing - BorrowChecker": "The borrow checker is an essential feature of the Rust language and part of what makes Rust Rust. It helps you (or forces you) to manage ownership.",
	"CI - Integration - Execution - Memory - References - Types - inmutable - &": "Immutable references are created using the & symbol followed by the value you want to borrow. These are read-only references that allow you to borrow an immutable view of a value. When you have an immutable reference to a value, you cannot mutate the value through that reference. ",
	"CI - Integration - Execution - Memory - References - Types - mutable - &mut": "Mutable references are created using the &mut keyword followed by the value you want to borrow. These are references that allow you to borrow a mutable view of a value. When you have a mutable reference to a value, you can mutate the value through that reference.",
	"CI - Integration - Execution - Memory - References - Types - mutable - Mutex": "Mutex for safe mutable access.",
	"CI - Integration - Execution - Memory - References - Types - mutable - Interior": "Interior mutability is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data",
	"CI - Integration - Execution - Memory - References - Types - mutable - Interior - RefCell": "Struct std::cell::RefCell. RefCell allows for mutable borrowing at runtime, enabling interior mutability even in a context that requires immutability.",
	"CI - Integration - Execution - Memory - References - Types - mutable - Dereferencing - Deref": "Trait std::ops::Deref. Used for immutable dereferencing operations, like *v.",
	"CI - Integration - Execution - Memory - References - Types - mutable - Dereferencing - DerefMut": "Trait std::ops::DerefMut. Used for mutable dereferencing operations, like in *v = 1;.",
	"CI - Integration - Execution - Memory - References - Types - Slice": "Slices in Rust are references to consecutive elements in memory, allowing you to reference parts of a collection without copying the entire data, providing a view into arrays, vectors, or other sequences for focused data manipulation. A Rust slice is a data type used to access portions of data stored in collections like arrays, vectors and strings.",
	"CI - Integration - Execution - cargo - run": "Run a binary of local package: cargo run.  Arguments to the binary are followed by two dashes (--): cargo run -- args",
	"CI - Integration - Execution - cargo - run - examples": "In Cargo’s parlance, an example is nothing else but a Rust source code of a standalone executable1 that typically resides in a single .rs file. All such files should be places in the examples/ directory, at the same level as src/ and the Cargo.toml manifest itself2. argo run --example hello",
	"CI - Integration - Execution - cargo - clean": "Remove generated artifacts from the target directory: cargo clean",
	"CI - Integration - Security": "",
	"CI - Integration - Security - Tools - Clippy": "Clippy is Rust’s official linter tool that helps catch common mistakes and enforces best practices. By integrating Clippy into your workflow, you can identify patterns that may lead to vulnerabilities early in development.",
	"CI - Integration - Security - Tools - CargoAudit": "Cargo Audit scans your project dependencies for known vulnerabilities by querying the RustSec Advisory Database. It’s a critical tool to maintain the integrity of your third-party libraries.",
	"CI - Integration - Security - Tools - RustScan": "RustScan is a lightning-fast port scanner built in Rust. It helps identify network vulnerabilities, allowing developers to proactively secure network-facing components.",
	"CI - Integration - Security - Tools - Tarpaulin": "Tarpaulin provides code coverage for Rust projects, ensuring that your test suites cover critical paths and helping identify untested and potentially vulnerable sections of code.",
	"CI - Integration - Security - Tools - Fuzzing": "Fuzzing is an automated testing technique that feeds random data into your application to uncover unexpected behaviors. cargo-fuzz is the go-to tool for fuzzing Rust applications, identifying edge cases that could lead to vulnerabilities.",
	"CI - Integration - Security - Tools - Bindgen": "When interacting with C libraries, bindgen generates Rust FFI (Foreign Function Interface) bindings, ensuring safer interoperability and reducing the risk of memory corruption issues.",

	"CD - Monitor": "SECTION",
	"CD - Monitor - Testing": "",
	"CD - Monitor - Testing - UnitTesting - #[cfg(test)]": "Most unit tests go into a tests mod with the #[cfg(test)] attribute.",
	"CD - Monitor - Testing - UnitTesting - #[test]": "Test functions are marked with the #[test] attribute.",
	"CD - Monitor - Testing - UnitTesting - #[ignore]": "Tests can be marked with the #[ignore] attribute to exclude some tests.",
	"CD - Monitor - Testing - UnitTesting - fail": "Tests fail when something in the test function panics.",
	"CD - Monitor - Testing - UnitTesting - assert - assert!(expression)": "assert!(expression) - panics if expression evaluates to false.",
	"CD - Monitor - Testing - UnitTesting - assert - assert_eq!(left, right)": "testing left and right expressions for equality.",
	"CD - Monitor - Testing - UnitTesting - assert - assert_ne!(left, right)": "testing left and right expressions for inequality.",
	"CD - Monitor - Testing - UnitTesting - cargo": "Compile and execute unit, integration, and documentation tests: cargo test",
	"CD - Monitor - Testing - UnitTesting - cargo - ignore": "Or to run them with command cargo test -- --ignored",
	"CD - Monitor - Testing - IntegrationTesting": "Integration tests are external to your crate and use only its public interface in the same way any other code would. Their purpose is to test that many parts of your library work correctly together.",
	"CD - Monitor - Testing - IntegrationTesting - test folder": "Cargo looks for integration tests in tests directory next to src.",
	"CD - Monitor - Testing - Profiling - flamegraph": "Use profiling tools to identify slow parts of your code. Tools like cargo-flamegraph and perf can be invaluable."

}