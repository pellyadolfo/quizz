{

	"Systems - Distributed": "SECTION",
	"Systems - Distributed - Principles - Consistency": "In distributed systems, consistency models 𝗱𝗲𝗳𝗶𝗻𝗲 𝗵𝗼𝘄 𝗱𝗮𝘁𝗮 𝘂𝗽𝗱𝗮𝘁𝗲𝘀 𝗮𝗿𝗲 𝘀𝗲𝗲𝗻 𝗮𝗰𝗿𝗼𝘀𝘀 𝗻𝗼𝗱𝗲𝘀. Strong consistency and eventual consistency 𝗿𝗲𝗽𝗿𝗲𝘀𝗲𝗻𝘁 𝗯𝗼𝘁𝗵 𝗲𝗻𝗱𝘀 𝗼𝗳 𝘁𝗵𝗲 𝗰𝗼𝗻𝘀𝗶𝘀𝘁𝗲𝗻𝗰𝘆 𝘀𝗽𝗲𝗰𝘁𝗿𝘂𝗺 (sequential and causal consistency in between).",
	"Systems - Distributed - Principles - Consistency - Strong": "↳ Every read sees the latest write ↳ Higher latency, lower availability, higher integrity ↳ Ideal for real-time correctness",
	"Systems - Distributed - Principles - Consistency - Sequential": ".",
	"Systems - Distributed - Principles - Consistency - Causal": ".",
	"Systems - Distributed - Principles - Consistency - Weak": "It is a consistency model used in distributed computing where subsequent accesses might not always be returning the updated value. There might be inconsistent responses.",
	"Systems - Distributed - Principles - Consistency - Eventual": "↳ Reads may return stale data temporarily ↳ Lower latency, higher availability ↳ Great for scale-first systems .",
	"Systems - Distributed - Principles - HA - Scalability": "",
	"Systems - Distributed - Principles - HA - Scalability - Dimensions": "In their book “The Art of Scalability,” Martin Abbott and Michael Fisher elaborate on the concept of the “scale cube,”. (X) Each service can then be further scaled by cloning (X-axis), (Y) The microservices pattern maps to the Y-axis of the cube, wherein functional decomposition is used to scale the system (Z) sharding (Z-axis).",
	"Systems - Distributed - Principles - HA - Scalability - ScaleCube - X - clone services (horizontal duplication)": "X-axis scaling consists of running multiple copies of an application behind a load balancer. If there are N copies then each copy handles 1/N of the load. This is a simple, commonly used approach of scaling an application. One drawback of this approach is that because each copy potentially accesses all of the data, caches require more memory to be effective. Another problem with this approach is that it does not tackle the problems of increasing development and application complexity.",
	"Systems - Distributed - Principles - HA - Scalability - ScaleCube - y - microservices (functional decomposition)": "Unlike X-axis and Z-axis, which consist of running multiple, identical copies of the application, Y-axis axis scaling splits the application into multiple, different services. Each service is responsible for one or more closely related functions. There are a couple of different ways of decomposing the application into services. One approach is to use verb-based decomposition and define services that implement a single use case such as checkout. The other option is to decompose the application by noun and create services responsible for all operations related to a particular entity such as customer management. An application might use a combination of verb-based and noun-based decomposition.",
	"Systems - Distributed - Principles - HA - Scalability - ScaleCube - z - sharding databases (data partioning)": "When using Z-axis scaling each server runs an identical copy of the code. In this respect, it’s similar to X-axis scaling. The big difference is that each server is responsible for only a subset of the data. Some component of the system is responsible for routing each request to the appropriate server. One commonly used routing criteria is an attribute of the request such as the primary key of the entity being accessed. Another common routing criteria is the customer type. For example, an application might provide paying customers with a higher SLA than free customers by routing their requests to a different set of servers with more capacity.",
	"Systems - Distributed - Theorems - CAP Theorem ": "In any distributed data store, you can have at most two of these three properties: consistency (C), high availability (A), tolerance to network partitions (P)",
	"Systems - Distributed - Theorems - CAP Theorem - Consistency (C)": "Consistency (C) – Every read receives the most recent write or an error.",
	"Systems - Distributed - Theorems - CAP Theorem - Availability (A)": "Availability (A) – Every request (read/write) gets a response, even if it's not the most recent data.",
	"Systems - Distributed - Theorems - CAP Theorem - PartitionTolerance (P)": "Partition Tolerance (P) – The system continues operating despite network failures between nodes.",
	"Systems - Distributed - Theorems - CAP Theorem - Solutions - CA - Forfeit Partitions": "The system achieves High Available Consistency. To manage data across multiple resources these systems used methods like 2-Phase Commit. Single-site databases, RDBMS (Oracle, Postgres, MySQL) could be good eamples of CA systems.",
	"Systems - Distributed - Theorems - CAP Theorem - Solutions - CP - Best Effort Availity": "The system achieves Strong Consistency with Partition Tolerance. Pessimistic Locking methods used for multi resource data management. DNS, MongoDB, HBase, Redis are the example CP systems.",
	"Systems - Distributed - Theorems - CAP Theorem - Solutions - AP - Best Effort Consistency": "The system offers Full Availability by relaxing consistency. Optimistic Locking methods used for multi resource data management. CouchBase, Cassandra, DynamoDB, Hazelcast are the example CP systems.",

	"Systems - Decentralized": "SECTION",
	"Systems - Decentralized - Theorems - DCS Theorem": "",
	"Systems - Decentralized - Theorems - DCS Theorem - Decentralization": "Decentralized means the system has no single point of failure or control (SPoF). Another way to state this is: if any single element is removed from {𝑆}, the system continues to perform its intended behavior, and no single component in {𝑆} has the power to redefine 𝑓𝑆 on its own.",
	"Systems - Decentralized - Theorems - DCS Theorem - Consensus": "Consensus means the system uses a collective decision-making process ('consensus algorithm') to update the system’s state, 𝑠, which is shared by all consensus participants. The result of the consensus algorithm determines the network’s accepted output of 𝑓𝑆 , and whether or not 𝑓𝑆 completes within 𝑆𝜏.",
	"Systems - Decentralized - Theorems - DCS Theorem - Scalability": "Scale means the system is capable of handling the transactional demands of any competing system providing the same service to the same arbitrary set of users across the globe (“at scale”).2"

}