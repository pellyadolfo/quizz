{

	"DataModelling": "SECTION",
	"DataModelling - Decomposition": "",
	"DataModelling - Decomposition - by Capability": "Define services corresponding to business capabilities. A business capability is a concept from business architecture modeling. It is something that a business does in order to generate value. A business capability often corresponds to a business object, e.g. Order Management is responsible for orders Customer Management is responsible for customers Business capabilities are often organized into a multi-level hierarchy. For example, an enterprise application might have top-level categories such as Product/Service development, Product/Service delivery, Demand generation, etc.",
	"DataModelling - Decomposition - by Subdomain": "Define services corresponding to Domain-Driven Design (DDD) subdomains. DDD refers to the application’s problem space - the business - as the domain. A domain is consists of multiple subdomains. Each subdomain corresponds to a different part of the business. Subdomains can be classified as follows: Core - key differentiator for the business and the most valuable part of the application Supporting - related to what the business does but not a differentiator. These can be implemented in-house or outsourced. Generic - not specific to the business and are ideally implemented using off the shelf software",
	"DataModelling - Decomposition - by Subdomain - DDD": ".",
	"DataModelling - Decomposition - by Subdomain - DDD - description": ".",
	"DataModelling - Decomposition - by Subdomain - DDD - components - BoundedContext": "Bounded Contexts are used to represent well-defined logical boundaries around concepts within an application. They represent a distinct area of the application where a specific domain model is used, and where the terminology, rules, and data representations are consistent and cohesive.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - Entities": "Entities are objects that have a distinct identity that runs through time and different states. The identity is usually represented by an ID.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - ValueObjects": "Value objects are objects that are defined by their attributes. They do not have a distinct identity.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - Repositories": "Repositories are used to retrieve and store entities. They act as a collection of entities.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - Factories": "Factories are used to create complex objects and aggregates.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - Aggregates": "Aggregates are clusters of entities and value objects that are treated as a single unit.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - Services": "Services contain business logic that doesn’t naturally fit within an entity or value object.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - Services - stateless": "1.Stateless: Services are typically stateless. They do not hold any state themselves but operate on the state of entities and value objects.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - Services - Encapsulation": "2.Encapsulation of Business Logic: They encapsulate business logic that spans multiple entities or value objects or that doesn’t fit neatly within a single entity or value object.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - Services - Coordination": "3.Coordination: They often coordinate interactions between multiple entities and value objects.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - DomainEvents": "Domain events are used to communicate changes in the state of the business.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - DomainEvents - published": "Where Domain Events Are Published:",
	"DataModelling - Decomposition - by Subdomain - DDD - components - DomainEvents - published - EventBus": "1.Event Bus: Domain events are often published to an in-memory event bus within the application. This allows other parts of the application to subscribe to and handle these events. Since it is in-memory, the events are ephemeral and will be lost if the application restarts or crashes. It is suitable for scenarios where events need to be processed quickly and do not require persistence, such as inter-component communication within a single application instance.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - DomainEvents - published - EventStore": "2.Event Store: For more complex scenarios, domain events can be published to an event store, such as AWS EventBridge, Kafka, or a custom event store. This allows for durable storage and replay of events.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - DomainEvents - published - MessageBrokers": "3.Message Brokers: Domain events can also be published to message brokers like RabbitMQ or AWS SNS/SQS for asynchronous processing and integration with other systems.",
	"DataModelling - Decomposition - by maturity": "",
	"DataModelling - Decomposition - by data-access": "decomposing by data-access pattern (read versus write)",
	"DataModelling - Decomposition - by data source": "decomposition by data source (rather than partitioning a data source per microservice, create a microservice per data source)",
	"DataModelling - Decomposition - by functionality": "aggregation for a derived functionality (create an orchestrating service for a few other services)",
	"DataModelling - Decomposition - by client": "aggregation for client convenience (such as the backend for frontend pattern)",
	"DataModelling - Decomposition - by client - BFF": "At its core, Backend for Frontend is a architecture pattern that provides a dedicated backend layer for each frontend interface. Each frontend (e.g., mobile app, web app, smart device, etc.) may have different performance, data, and interaction needs. Instead of relying on a single monolithic or generalized API, a BFF tailors the backend to the specific needs of a given frontend.",
	"DataModelling - Decomposition - by client - BFF Layer": "BFF Layer: The BFF consolidates data from multiple microservices, performs any transformations or optimizations, and responds with a tailored response.",
	"DataModelling - Decomposition - by performance": "aggregation to aid system performance",
	"DataModelling - Decomposition and Storage - Persisting state (modularization) vs persisting events (aggregates = materialized views)": "by Capability has the problem of 2PC because dependencies (violates encapsulation). We can use Saga but is not ACID but ACD (no isolation). Therefore use DDD aggregates instead modularization. Rules: (1) Refer entitites by primary key. (2) One aggregate to comand per atomic transaction. (3) How to maintain consistency between aggregates?? Events sourcing solves this by persisting events instead state. But has challenge of maintain consistency between aggregates",

	"DataArchitecture": "SECTION",
	"DataArchitecture - Storage": "Main challenge is address the eventual consistency issue: Database per Service - Shared database - Saga - API Composition - CQRS - Event sourcing - Application events",
	"DataArchitecture - Storage - Patttern - Shared database": "Use a (single) database that is shared by multiple services. Each service freely accesses data owned by other services using local ACID transactions.",
	"DataArchitecture - Storage - Patttern - Database per Service": "Keep each microservice’s persistent data private to that service and accessible only via its API. The following diagram shows the structure of this pattern. The service’s database is effectively part of the implementation of that service. It cannot be accessed directly by other services. There are a few different ways to keep a service’s persistent data private. You do not need to provision a database server for each service. For example, if you are using a relational database then the options are: Private-tables-per-service – each service owns a set of tables that must only be accessed by that service Schema-per-service – each service has a database schema that’s private to that service Database-server-per-service – each service has it’s own database server. Private-tables-per-service and schema-per-service have the lowest overhead. Using a schema per service is appealing since it makes ownership clearer. Some high throughput services might need their own database server. It is a good idea to create barriers that enforce this modularity. You could, for example, assign a different database user id to each service and use a database access control mechanism such as grants. Without some kind of barrier to enforce encapsulation, developers will always be tempted to bypass a service’s API and access it’s data directly.",
	"DataArchitecture - Storage - Patttern - 2PC - Not an option": "One attempt to solve this problem in an automated and hassle-free manner is the XA protocol implementing the two-phase commit (2PC) pattern. But in modern high-scale applications (especially in a cloud environment), 2PC doesn’t seem to perform so well. To eliminate the disadvantages of 2PC, we have to trade ACID for BASE and cover consistency concerns ourselves in different ways depending on the requirements.",
	"DataArchitecture - Storage - Patttern - Saga": "A saga is a sequence of local transactions. Each local transaction updates the database and publishes a message or event to trigger the next local transaction in the saga. If a local transaction fails because it violates a business rule then the saga executes a series of compensating transactions that undo the changes that were made by the preceding local transactions.",
	"DataArchitecture - Storage - Patttern - Saga - ACD": "Saga provides ACD but misses I (isolation).",
	"DataArchitecture - Storage - Patttern - Saga - Products ": "Products Tram, AXON framework",
	"DataArchitecture - Storage - Patttern - Saga - Coordination": "There are two ways of coordination sagas: Choreography - each local transaction publishes domain events that trigger local transactions in other services Orchestration - an orchestrator (object) tells the participants what local transactions to execute. Saga provides ACD but misses I (isolation). Products Tram, AXON framework",
	"DataArchitecture - Storage - Patttern - Saga - Coordination - Choreography": "Choreography - each local transaction publishes domain events that trigger local transactions in other services",
	"DataArchitecture - Storage - Patttern - Saga - Coordination - Orchestration": "Orchestration - an orchestrator (object) tells the participants what local transactions to execute.",
	"DataArchitecture - Storage - Patttern - CQRS": "CQRS allows different techniques to be used for writing data (Write Side) and reading data (Read Side).",
	"DataArchitecture - Storage - Patttern - CQRS ": "Split the application into two parts: the command-side and the query-side. The command-side handles create, update, and delete requests and emits events when data changes. The query-side handles queries by executing them against one or more materialized views that are kept up to date by subscribing to the stream of events emitted when data changes.",
	"DataArchitecture - Storage - Patttern - CQRS - Responsibilities": ".",
	"DataArchitecture - Storage - Patttern - CQRS - Responsibilities - Command": ".",
	"DataArchitecture - Storage - Patttern - CQRS - Responsibilities - Command - Operations": "Handles create, update, delete operations.",
	"DataArchitecture - Storage - Patttern - CQRS - Responsibilities - Command - Goal": "Uses domain models and business logic to validate and process commands.",
	"DataArchitecture - Storage - Patttern - CQRS - Responsibilities - Query": ".",
	"DataArchitecture - Storage - Patttern - CQRS - Responsibilities - Query - Operations": "Handles read operations (queries).",
	"DataArchitecture - Storage - Patttern - CQRS - Responsibilities - Query - Goal": "Optimized for fast reads using denormalized data or caching mechanisms.",
	"DataArchitecture - Storage - Patttern - CQRS - Strategies": "",
	"DataArchitecture - Storage - Patttern - CQRS - Strategies - EventSourcing": "command model generates events -> events are published to an event store or message broker -> query model listens to these events and updates its own database",
	"DataArchitecture - Storage - Patttern - CQRS - Strategies - EventSourcing - DomainEvents": "Domain events play a crucial role in CQRS by ensuring event-driven communication between the command and query sides of an application. They capture important state changes in the domain and propagate them to other parts of the system, improving scalability, consistency, and decoupling.",
	"DataArchitecture - Storage - Patttern - CQRS - Strategies - DatabaseReplication": "command database acts as the primary data source -> query database is a replica of the command database, updated using replication mechanisms",
	"DataArchitecture - Storage - Patttern - CQRS - Strategies - ChangeDataCapture": "command database logs changes -> CDC tool (Debezium, AWS DMS) captures these changes and propagates them to the query database",
	"DataArchitecture - Storage - Patttern - CQRS - Strategies - ScheduledBatchProcessing": "command model periodically exports data into the query model at scheduled intervals",
	"DataArchitecture - Storage - Patttern - CQRS - Strategies - DualWrites": "application writes to both the command and query databases in the same transaction.",
	"DataArchitecture - Storage - Patttern - CQRS - Challenges": "",
	"DataArchitecture - Storage - Patttern - CQRS - Challenges - EventualConsistency": "In CQRS (Command Query Responsibility Segregation), the command model (write side) and the query model (read side) are often stored separately. Because of this separation, they may not always be in sync immediately, leading to eventual consistency rather than strong consistency.",
	"DataArchitecture - Storage - Patttern - CQRS - Challenges - EventualConsistency - Strategies - EventDrivenUpdates": "There is a delay between command event and query update.",
	"DataArchitecture - Storage - Patttern - CQRS - Challenges - EventualConsistency - Strategies - ReadModelLagHandling": "Since the read model updates asynchronously, you can: Show stale data with a refresh option. Use real-time notifications (WebSockets, polling, or push updates) to alert users when data is updated. Use a 'read-your-own-writes' strategy (storing pending changes in the session or caching).",
	"DataArchitecture - Storage - Patttern - CQRS - Challenges - EventualConsistency - Strategies - CompensatingActions": "Compensating actions to resolve inconsistencies: Retries (e.g., the query model keeps retrying updates until successful). Conflict Resolution Policies (decide what happens if a query model update fails). Delayed Response Handling (return a pending state until data is available).",
	"DataArchitecture - Storage - Patttern - CQRS - Challenges - EventualConsistency - Strategies - QueryingWriteModel": "Querying the write model when strict consistency is needed.",
	"DataArchitecture - Storage - Patttern - CQRS - Challenges - EventualConsistency - Strategies - Read-ThroughCache": "Caching mechanisms to reduce visible inconsistencies.",
	"DataArchitecture - Storage - Patttern - Event sourcing": "A good solution to this problem is to use event sourcing. Event sourcing persists the state of a business entity such an Order or a Customer as a sequence of state-changing events. Whenever the state of a business entity changes, a new event is appended to the list of events. Since saving an event is a single operation, it is inherently atomic. The application reconstructs an entity’s current state by replaying the events. Applications persist events in an event store, which is a database of events. The store has an API for adding and retrieving an entity’s events. The event store also behaves like a message broker. It provides an API that enables services to subscribe to events. When a service saves an event in the event store, it is delivered to all interested subscribers. Some entities, such as a Customer, can have a large number of events. In order to optimize loading, an application can periodically save a snapshot of an entity’s current state. To reconstruct the current state, the application finds the most recent snapshot and the events that have occurred since that snapshot. As a result, there are fewer events to replay.",
	"DataArchitecture - Storage - Patttern - EventSourcing ": "Form of CQRS. Instead of storing the current state of a model, append-only event stores are used to record the full series of actions taken on a model.",
	"DataArchitecture - Storage - Patttern - EventSourcing - rehydration": "When a new Command occurs, the current state of the Model/Entity is ‘rehydrated’ by replaying all of the events that have ever happened for that instance.",
	"DataPrinciples - EventSourcing": "Form of CQRS. Instead of storing the current state of a model, append-only event stores are used to record the full series of actions taken on a model.",
	"DataPrinciples - EventSourcing - rehydration": "When a new Command occurs, the current state of the Model/Entity is ‘rehydrated’ by replaying all of the events that have ever happened for that instance."

}