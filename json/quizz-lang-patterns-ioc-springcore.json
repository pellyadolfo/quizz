{
	
	"Container": "SECTION",
	"Container ": "A Spring IoC container manages one or more beans. These beans are created with the configuration metadata that you supply to the container, for example, in the form of XML <bean/> definitions.",
	"Container - Responsibility": "Spring IoC container is responsible for instantiating, configuring, and assembling the aforementioned beans.",
	"Container - BeanFactory - BeanFactory.getBean(XXXX)": "Return an instance, which may be shared or independent, of the specified bean.",
	"Container - BeanFactory - BeanFactory.containsBean(java.lang.String name)": "Does this bean factory contain a bean definition or externally registered singleton instance with the given name?",
	"Container - BeanFactory - BeanFactory.isSingleton(java.lang.String name)": "Is this bean a shared singleton? That is, will getBean(java.lang.String) always return the same instance?.",
	"Container - BeanFactory - BeanFactory.isPrototype(java.lang.String name)": "Is this bean a prototype? That is, will getBean(java.lang.String) always return independent instances?",
	"Container - BeanFactory - BeanFactory.getAliases(java.lang.String name)": "Return the aliases for the given bean name, if any.",
	"Container - BeanFactory - BeanFactory.isTypeMatch(java.lang.String name, java.lang.Class< ? > typeToMatch)": "Check whether the bean with the given name matches the specified type.",
	"Container - ApplicationContext": "The interface org.springframework.context.ApplicationContext represents the Spring IoC container (org.springframework.context.ApplicationContext). Central interface to provide configuration for an application. This is read-only while the application is running, but may be reloaded if the implementation supports this. An ApplicationContext provides: (1) Bean factory methods for accessing application components. Inherited from ListableBeanFactory. (2) The ability to load file resources in a generic fashion. Inherited from the ResourceLoader interface. (3) The ability to publish events to registered listeners. Inherited from the ApplicationEventPublisher interface. (4) The ability to resolve messages, supporting internationalization. Inherited from the MessageSource interface. (5) Inheritance from a parent context. Definitions in a descendant context will always take priority. This means, for example, that a single parent context can be used by an entire web application, while each servlet has its own child context that is independent of that of any other servlet. (6) In addition to standard BeanFactory lifecycle capabilities, ApplicationContext implementations detect and invoke ApplicationContextAware beans as well as ResourceLoaderAware, ApplicationEventPublisherAware and MessageSourceAware beans.",
	"Container - ApplicationContext - ClassPathXmlApplicationContext": "Standalone XML application context, taking the context definition files from the class path, interpreting plain paths as class path resource names that include the package path. Useful for test harnesses as well as for application contexts embedded within JARs. The config location defaults can be overridden via AbstractRefreshableConfigApplicationContext.getConfigLocations(), Config locations can either denote concrete files like '/myfiles/context.xml' or Ant-style patterns like '/myfiles/*-context.xml' (see the AntPathMatcher javadoc for pattern details).",
	"Container - ApplicationContext - FileSystemXmlApplicationContext": "Standalone XML application context, taking the context definition files from the file system or from URLs, interpreting plain paths as relative file system locations (e.g. 'mydir/myfile.txt'). Useful for test harnesses as well as for standalone environments. NOTE: Plain paths will always be interpreted as relative to the current VM working directory, even if they start with a slash. (This is consistent with the semantics in a Servlet container.) Use an explicit 'file:' prefix to enforce an absolute file path. The config location defaults can be overridden via AbstractRefreshableConfigApplicationContext.getConfigLocations(), Config locations can either denote concrete files like '/myfiles/context.xml' or Ant-style patterns like '/myfiles/*-context.xml' (see the AntPathMatcher javadoc for pattern details).",
	"Container - ApplicationContext - BeanFactory vs ApplicationContext": "Use an ApplicationContext unless you have a good reason for not doing so. Because the ApplicationContext includes all functionality of the BeanFactory, it is generally recommended over the BeanFactory, except for a few situations such as in embedded applications running on resource-constrained devices where memory consumption might be critical and a few extra kilobytes might make a difference. However, for most typical enterprise applications and systems, the ApplicationContext is what you will want to use.",
	"Container - ApplicationContext - ApplicationContextInitializer": "Callback interface for initializing a Spring ConfigurableApplicationContext prior to being refreshed. Typically used within web applications that require some programmatic initialization of the application context. For example, registering property sources or activating profiles against the context's environment. See ContextLoader and FrameworkServlet support for declaring a 'contextInitializerClasses' context-param and init-param, respectively. ApplicationContextInitializer processors are encouraged to detect whether Spring's Ordered interface has been implemented or if the @Order annotation is present and to sort instances accordingly if so prior to invocation.",
	"Container - Instantiation": "ApplicationContext context = new ClassPathXmlApplicationContext('services.xml', 'daos.xml'), Instantiating a Spring IoC container is straightforward. The location path or paths supplied to an ApplicationContext constructor are actually resource strings that allow the container to load configuration metadata from a variety of external resources such as the local file system, from the Java CLASSPATH, and so on.",
	"Container - Shutdown registerShutdownHook()": "Register a shutdown hook with the JVM runtime, closing this context on JVM shutdown unless it has already been closed at that time. ConfigurableApplicationContext#registerShutdownHook(),",
	"Container - Shutdown close()": "Close this application context, releasing all resources and locks that the implementation might hold. ConfigurableApplicationContext#close(),",

	"Components": "SECTION",
	"Components ": "@Component is a generic stereotype for any Spring-managed component.",
	"Components - Purpose": "Use @Component when creating standalone beans that do not need to define other beans.",
	"Components - Purpose - Class": "Added as Class-level (annotates a class)",
	"Components - Purpose - ComponentScan": "A Component is a Spring-managed bean auto-detected via @ComponentScan.",
	"Components - Purpose - ComponentScan - BeanDefinitions": "Classes found annotated as Components are registered in the Spring BeanDefinitionRegistry as BeanDefinitions.",
	"Components - Purpose - Beans": "Used for simple and generic bean definitions.",
	"Components - Purpose - Beans - Instances": "If you use @Component, the @Bean methods inside it might create new instances every time they are called.",
	"Components - Purpose - Beans - Use": "Use some specialization. @Component is just for autodetection via @ComponentScan.",
	"Components - Declaration - @Named (JSR-330)": "@Named belongs to javax.inject API. It marks class to be autodetected as a bean and requires you to specify a name.",
	"Components - Declaration - @ManagedBean (JSR-250)": "container managed objects that support a small set of basic services such as resource injection, lifecycle callbacks and interceptors.",
	"Components - Declaration - @Component (Spring))": "@Component and @Named and @ManagedBean are annotations that basically do the same thing, but come from different APIs. @Component belongs to Spring API. It marks class to be autodetected as a bean and optionally allows you to specify a name for that bean (@Component('foo')). Without explicit name specification detected bean will get a default name derived from the name of its class. @Named belongs to javax.inject API. It marks class to be autodetected as a bean and requires you to specify a name.",
	"Components - Resolution - Classes - Classes- Scanning - @ComponentScan": "To autodetect things like configurations, controllers, services, and other components we define and register the corresponding beans, you need to add @ComponentScan to your @Configuration class, where the basePackages attribute is a common parent package for the two classes. Alternatively, you can specify a comma- or semicolon- or space-separated list that includes the parent package of each class. @Configuration @ComponentScan(basePackages = 'org.example')",
	"Components - Resolution - Classes - Scanning - < context:component-scan/ >": "",
	"Components - Resolution - Classes - Autowiring - Primary @Autowired (Spring)": "You can apply the @Autowired annotation to constructors, to setter methods, to methods with arbitrary names and/or multiple arguments and to fields as well and even mix it with constructors. By default, the autowiring fails whenever zero candidate beans are available, the default behavior is to treat annotated methods, constructors, and fields as indicating required dependencies. This behavior can be changed @Autowired(required = false). As of Spring Framework 4.3, an @Autowired annotation on such a constructor is no longer necessary if the target bean only defines one constructor to begin with. However, if several constructors are available, at least one must be annotated to teach the container which one to use. you may express the non-required nature of a particular dependency through Java 8’s java.util.Optional. As of Spring Framework 5.0, you may also use an @Nullable annotation (of any kind in any package, e.g. javax.annotation.Nullable from JSR-305). You can also use @Autowired for interfaces that are well-known resolvable dependencies: BeanFactory, ApplicationContext, Environment, ResourceLoader, ApplicationEventPublisher, and MessageSource. These interfaces and their extended interfaces, such as ConfigurableApplicationContext or ResourcePatternResolver, are automatically resolved, with no special setup necessary.",
	"Components - Resolution - Classes - Autowiring - Primary @Inject (JSR-330)": "@Inject is part of a Java CDI (Contexts and Dependency Injection)",
	"Components - Resolution - Classes - Autowiring - Primary @Resource (JSR-250)": "Spring also supports injection by using the JSR-250 @Resource annotation on fields or bean property setter methods. @Resource(name='myMovieFinder') public void setMovieFinder(MovieFinder movieFinder) { ... }",
	"Components - Resolution - Classes - Autowiring - Primary @Autowired vs @Inject (JSR-330)": "@Autowired is Spring's own (legacy) annotation. @Inject is part of a Java CDI ( Contexts and Dependency Injection). In a Spring application, the two annotations works the same way as Spring has decided to support some JSR-299 annotations in addition to their own. @Inject has no 'required' attribute. Can be used with Java 8’s Optional instead..",
	"Components - Resolution - Classes - Autowiring - Primary @Required": "The @Required annotation applies to bean property setter methods. This annotation simply indicates that the affected bean property must be populated at configuration time, through an explicit property value in a bean definition or through autowiring. The container throws an exception if the affected bean property has not been populated, this allows for eager and explicit failure, avoiding NullPointerExceptions or the like later on. It is still recommended that you put assertions into the bean class itself, for example, into an init method. Doing so enforces those required references and values even when you use the class outside of a container. Only one annotated constructor per-class can be marked as required, but multiple non-required constructors can be annotated. In that case, each is considered among the candidates and Spring uses the greediest constructor whose dependencies can be satisfied, that is the constructor that has the largest number of arguments.",
	"Components - Resolution - Classes - Autowiring - Primary @Autowired vs @Required": "The required attribute of @Autowired is recommended over the @Required annotation. The required attribute indicates that the property is not required for autowiring purposes, the property is ignored if it cannot be autowired. @Required, on the other hand, is stronger in that it enforces the property that was set by any means supported by the container. If no value is injected, a corresponding exception is raised.",
	"Components - Resolution - Classes - Autowiring - Primary @Primary": "@Primary indicates that a particular bean should be given preference when multiple beans are candidates to be autowired to a single-valued dependency. If exactly one 'primary' bean exists among the candidates, it will be the autowired value.",
	"Components - Resolution - Classes - Autowiring - Primary @Qualifier": "The @Qualifier annotation in Spring is used to resolve ambiguity when multiple beans of the same type are available in the Spring container. It helps specify which exact bean should be autowired when there are multiple candidates.",
	"Components - Resolution - Classes - Autowiring - Dependencies": "The Spring container can autowire relationships between collaborating beans. You can let Spring resolve collaborators (other beans) automatically for your bean by inspecting the contents of the ApplicationContext.",
	"Components - Resolution - Classes - Autowiring - Dependencies - Advantages": "Autowiring has the following advantages: Autowiring can significantly reduce the need to specify properties or constructor arguments. (Other mechanisms such as a bean template discussed elsewhere in this chapter are also valuable in this regard.) Autowiring can update a configuration as your objects evolve. For example, if you need to add a dependency to a class, that dependency can be satisfied automatically without you needing to modify the configuration. Thus autowiring can be especially useful during development, without negating the option of switching to explicit wiring when the code base becomes more stable.",
	"Components - Resolution - Classes - Autowiring - Dependencies - Resolution Process": "The container performs bean dependency resolution as follows: (1) The ApplicationContext is created and initialized with configuration metadata that describes all the beans. Configuration metadata can be specified via XML, Java code, or annotations. (2) For each bean, its dependencies are expressed in the form of properties, constructor arguments, or arguments to the static-factory method if you are using that instead of a normal constructor. These dependencies are provided to the bean, when the bean is actually created. (3) Each property or constructor argument is an actual definition of the value to set, or a reference to another bean in the container. (4) Each property or constructor argument which is a value is converted from its specified format to the actual type of that property or constructor argument. By default Spring can convert a value supplied in string format to all built-in types, such as int, long, String, boolean, etc.",
	"Components - Resolution - Classes - Autowiring - Dependencies - depends-on": "If a bean is a dependency of another bean, that usually means that one bean is set as a property of another. Typically you accomplish this with the < ref/ > element in XML-based configuration metadata. However, sometimes dependencies between beans are less direct. An example is when a static initializer in a class needs to be triggered, such as for database driver registration. The depends-on attribute can explicitly force one or more beans to be initialized before the bean using this element is initialized. NOTE: The depends-on attribute in the bean definition can specify both an initialization-time dependency and, in the case of singleton beans only, a corresponding destroy-time dependency. Dependent beans that define a depends-on relationship with a given bean are destroyed first, prior to the given bean itself being destroyed. Thus, depends-on can also control shutdown order.",
	"Components - Resolution - Classes - Autowiring - Dependencies - Modes": "",
	"Components - Resolution - Classes - Autowiring - Dependencies - Modes - no": "(Default) No autowiring. Bean references must be defined by ref elements. Changing the default setting is not recommended for larger deployments, because specifying collaborators explicitly gives greater control and clarity. To some extent, it documents the structure of a system.",
	"Components - Resolution - Classes - Autowiring - Dependencies - Modes - byName": "Autowiring by property name. Spring looks for a bean with the same name as the property that needs to be autowired. For example, if a bean definition is set to autowire by name and it contains a master property (that is, it has a setMaster(..) method), Spring looks for a bean definition named master and uses it to set the property.",
	"Components - Resolution - Classes - Autowiring - Dependencies - Modes - byType": "Lets a property be autowired if exactly one bean of the property type exists in the container. If more than one exists, a fatal exception is thrown, which indicates that you may not use byType autowiring for that bean. If there are no matching beans, nothing happens (the property is not set).",
	"Components - Resolution - Classes - Autowiring - Dependencies - Modes - constructor": "Analogous to byType but applies to constructor arguments. If there is not exactly one bean of the constructor argument type in the container, a fatal error is raised.",
	"Components - Specializations ": "specializations: @Repository, @Service, @Controller, @RestController, @Configuration",
	"Components - Specializations - @Configuration": "Defines @Bean methods for Spring IoC container setup.",
	"Components - Specializations - @Configuration - Singleton": "Ensures that the beans defined in this class are created only once (Singleton) by enabling CGLIB proxying.",
	"Components - Specializations - @Configuration - BeanFactory": "Supports bean factory methods, which can return other Spring beans.",
	"Components - Specializations - @Configuration - Purpose": "Use @Configuration when creating a class that defines multiple beans with interdependencies",
	"Components - Specializations - @Controller": "specialization of @Component for any class that fulfills the role or stereotype of presentation layer.",
	"Components - Specializations - @Controller - HTTP": "Handles HTTP requests and returns views (HTML).",
	"Components - Specializations - @RestController": "@Controller + @ResponseBody on every method.",
	"Components - Specializations - @Repository": "specialization of @Component for any class that fulfills the role or stereotype of a repository (also known as Data Access Object or DAO).",
	"Components - Specializations - @Repository - DataAccessException": "Translates database exceptions (e.g., JDBC SQLException) into Spring’s unchecked DataAccessException.",
	"Components - Specializations - @Repository - Transactional": "Enables declarative transaction management (@Transactional).",
	"Components - Specializations - @Service": "specialization of @Component for any class that fulfills the role or stereotype of service layer.",
	"Components - Specializations - @Service - BusinessLogic": "Business logic (transactional methods, orchestration).",

	"Beans": "SECTION",
	"Beans - Bean": "A bean is an object that is instantiated, assembled, and managed by a container.",
	"Beans - Bean - Java": "In the context of Java, a bean is a reusable software component that adheres to specific conventions (e.g., having a no-argument constructor, being serializable, and providing getters and setters).",
	"Beans - Bean - Spring": "In Spring, a bean is any object that is managed by the Spring IoC (Inversion of Control) container.",
	"Beans - Bean - Lifecycle": "Managed by the Spring Framework.",
	"Beans - Annotation": "Method-level (annotates a method)",
	"Beans - BeanDefinition ": "Within the container itself, these bean definitions are represented as BeanDefinition objects. BeanDefinition is essentially a recipe for creating one or more objects",
	"Beans - BeanDefinition - Metadata": "Beans - BeanDefinition objects contain the following metadata: (1) A package-qualified class name: typically, the actual implementation class of the bean being defined. (2) Bean behavioral configuration elements, which state how the bean should behave in the container (scope, lifecycle callbacks, and so forth) (3) References to other beans that are needed for the bean to do its work. These references are also called collaborators or dependencies. (4) Other configuration settings to set in the newly created object — for example, the size limit of the pool or the number of connections to use in a bean that manages a connection pool.",
	"Beans - BeanDefinition - Metadata - Types": "The container gets its instructions on what objects to instantiate, configure, and assemble by reading configuration metadata. The configuration metadata is represented in XML, Java annotations, or Java code. It allows you to express the objects that compose your application and the rich interdependencies between such objects. While XML has been the traditional format for defining configuration metadata you can instruct the container to use Java annotations or code as the metadata format by providing a small amount of XML configuration to declaratively enable support for these additional metadata formats.",
	"Beans - BeanDefinition - Annotation-based": "XML configuration",
	"Beans - BeanDefinition - Annotation-based < bean/ > Property class": "You can use the Class property in one of two ways: (*) Typically, to specify the bean class to be constructed in the case where the container itself directly creates the bean by calling its constructor reflectively, somewhat equivalent to Java code with the new operator. (*) To specify the actual class containing the static factory method that is invoked to create the object, in the less common case where the container invokes a static factory method on a class to create the bean. The object type returned from the invocation of the static factory method may be the same class or another class entirely.",
	"Beans - BeanDefinition - Annotation-based < bean/ > Property class - Instantiation with a Constructor": "When you create a bean by the constructor approach, all normal classes are usable by and compatible with Spring. That is, the class being developed does not need to implement any specific interfaces or to be coded in a specific fashion. Simply specifying the bean class should suffice. However, depending on what type of IoC you use for that specific bean, you may need a default (empty) constructor. The Spring IoC container can manage virtually any class you want it to manage. It is not limited to managing true JavaBeans. Most Spring users prefer actual JavaBeans with only a default (no-argument) constructor and appropriate setters and getters modeled after the properties in the container. You can also have more exotic non-bean-style classes in your container. If, for example, you need to use a legacy connection pool that absolutely does not adhere to the JavaBean specification, Spring can manage it as well.",
	"Beans - BeanDefinition - Annotation-based < bean/ > Property class - Instantiation with a Static Factory Method": "When defining a bean that you create with a static factory method, use the class attribute to specify the class that contains the static factory method and an attribute named factory-method to specify the name of the factory method itself. You should be able to call this method (with optional arguments, as described later) and return a live object, which subsequently is treated as if it had been created through a constructor. One use for such a bean definition is to call static factories in legacy code. The following bean definition specifies that the bean be created by calling a factory method. The definition does not specify the type (class) of the returned object, only the class containing the factory method. In this example, the createInstance() method must be a static method. The following example shows how to specify a factory method:< bean id='clientService' class='examples.ClientService' factory-method='createInstance'/>",
	"Beans - BeanDefinition - Annotation-based < bean/ > Property class - Instantiation by Using an Instance Factory Method": "Similar to instantiation through a static factory method, instantiation with an instance factory method invokes a non-static method of an existing bean from the container to create a new bean. To use this mechanism, leave the class attribute empty and, in the factory-bean attribute, specify the name of a bean in the current (or parent or ancestor) container that contains the instance method that is to be invoked to create the object. Set the name of the factory method itself with the factory-method attribute. <bean id='clientService' factory-bean='serviceLocator' factory-method='createClientServiceInstance'/>",
	"Beans - BeanDefinition - Annotation-based < bean/ > Property name": "By default, configuration classes use a @Bean method’s name as the name of the resulting bean. This functionality can be overridden, however, with the name attribute",
	"Beans - BeanDefinition - Annotation-based < bean/ > Property name - Bean Aliasing": "As discussed in Naming Beans, it is sometimes desirable to give a single bean multiple names, otherwise known as bean aliasing. The name attribute of the @Bean annotation accepts a String array for this purpose. The following example shows how to set a number of aliases for a bean: @Bean(name = { 'dataSource', 'subsystemA-dataSource', 'subsystemB-dataSource' })",
	"Beans - BeanDefinition - Annotation-based < bean/ > Property name - Bean Description": "Sometimes, it is helpful to provide a more detailed textual description of a bean. This can be particularly useful when beans are exposed (perhaps through JMX) for monitoring purposes. To add a description to a @Bean, you can use the @Description annotation",
	"Beans - BeanDefinition - Annotation-based < bean/ > Property scope": "",
	"Beans - BeanDefinition - Annotation-based < bean/ > Property constructor arguments": "",
	"Beans - BeanDefinition - Annotation-based < bean/ > Property properties": "",
	"Beans - BeanDefinition - Annotation-based < bean/ > Property autowiring mode": "",
	"Beans - BeanDefinition - Annotation-based < bean/ > Property lazy-initialization mode": "",
	"Beans - BeanDefinition - Annotation-based < bean/ > Property initialization method": "",
	"Beans - BeanDefinition - Annotation-based < bean/ > Property destruction method - destroyMethod": "With Java configuration, you can use the destroyMethod attribute @Bean(destroyMethod='...')",
	"Beans - BeanDefinition - Annotation-based < bean/ > Property destruction method - destroy-method": "With XML-based configuration metadata, you can use the destroy-method attribute on the < bean destroy-method='...'/ >",
	"Beans - BeanDefinition - Annotation-based < bean/ > Property destruction method - default-destroy-method": "You can configure destroy method callbacks similarly (in XML, that is) by using the default-destroy-method attribute on the top-level <beans/> element.",
	"Beans - BeanDefinition - Annotation-based < property/ >": "The value attribute of the < property/ > element specifies a property or constructor argument as a human-readable string representation. Spring’s conversion service is used to convert these values from a String to the actual type of the property or argument.",
	"Beans - BeanDefinition - Annotation-based < property name='email' value=''/ >": "empty string",
	"Beans - BeanDefinition - Annotation-based < property name='email' >< null/ >< /property >": "The < null/ > element handles null values.",
	"Beans - BeanDefinition - Annotation-based < property/ >< value/ >": "The Spring container converts the text inside the < value/ > element into a java.util.Properties instance by using the JavaBeans PropertyEditor mechanism. This is a nice shortcut, and is one of a few places where the Spring team do favor the use of the nested <value/> element over the value attribute style.",
	"Beans - BeanDefinition - Annotation-based < property/ >< idref/ >": "The idref element is simply an error-proof way to pass the id (a string value - not a reference) of another bean in the container to a < constructor-arg/ > or < property/ > element.",
	"Beans - BeanDefinition - Annotation-based < bean/ >": "A < bean/ > element inside the <property/> or < constructor-arg/ > elements defines an inner bean. An inner bean definition does not require a defined ID or name. If specified, the container does not use such a value as an identifier. The container also ignores the scope flag on creation, because inner beans are always anonymous and are always created with the outer bean. It is not possible to access inner beans independently or to inject them into collaborating beans other than into the enclosing bean. As a corner case, it is possible to receive destruction callbacks from a custom scope — for example, for a request-scoped inner bean contained within a singleton bean. The creation of the inner bean instance is tied to its containing bean, but destruction callbacks let it participate in the request scope’s lifecycle. This is not a common scenario. Inner beans typically simply share their containing bean’s scope.",
	"Beans - BeanDefinition - Annotation-based < list/ >": "set the properties and arguments of the Java Collection types List.",
	"Beans - BeanDefinition - Annotation-based < set/ >": "set the properties and arguments of the Java Collection types Set.",
	"Beans - BeanDefinition - Annotation-based < map/ >": "set the properties and arguments of the Java Collection types Map.",
	"Beans - BeanDefinition - Annotation-based < props/ >": "set the properties and arguments of the Java Collection types Properties.",
	"Beans - BeanDefinition - Annotation-based < ref/ >": "The ref element is the final element inside a < constructor-arg/ > or < property/ > definition element. Here, you set the value of the specified property of a bean to be a reference to another bean (a collaborator) managed by the container. The referenced bean is a dependency of the bean whose property is to be set, and it is initialized on demand as needed before the property is set. (If the collaborator is a singleton bean, it may already be initialized by the container.) All references are ultimately a reference to another object. Scoping and validation depend on whether you specify the ID or name of the other object through the bean, local, or parent attributes. Specifying the target bean through the bean attribute of the <ref/> tag is the most general form and allows creation of a reference to any bean in the same container or parent container, regardless of whether it is in the same XML file. The value of the bean attribute may be the same as the id attribute of the target bean or be the same as one of the values in the name attribute of the target bean.",
	"Beans - BeanDefinition - Annotation-based < ref parent='...'/ >": "Specifying the target bean through the parent attribute creates a reference to a bean that is in a parent container of the current container. The value of the parent attribute may be the same as either the id attribute of the target bean or one of the values in the name attribute of the target bean. The target bean must be in a parent container of the current one. You should use this bean reference variant mainly when you have a hierarchy of containers and you want to wrap an existing bean in a parent container with a proxy that has the same name as the parent bean.",
	"Beans - BeanDefinition - Annotation-based Compound Properties": "< property name='fred.bob.sammy' value='123'/ >",
	"Beans - BeanDefinition - Java-based": "Java configuration",
	"Beans - BeanDefinition - Java-based - @Configuration ": "source of @Bean definitions. This annotation marks a class as a Configuration class for Java-based configuration. This is particularly important if you favor Java-based configuration over XML configuration.",	
	"Beans - BeanDefinition - Java-based - @Configuration - @Import": "Indicates one or more @Configuration classes to import. For import Java code-based configuration. e.g. @Configuration @Import({ DataSourceConfig.class, TransactionConfig.class })",
	"Beans - BeanDefinition - Java-based - @Configuration - @Bean": "@Bean is a method-level annotation and a direct analog of the XML <bean/> element. The annotation supports most of the attributes offered by <bean/>, such as: init-method, destroy-method, autowiring, lazy-init, dependency-check, depends-on and scope. The @Bean annotation is used to indicate that a method instantiates, configures, and initializes a new object to be managed by the Spring IoC container. For those familiar with Spring’s <beans/> XML configuration, the @Bean annotation plays the same role as the <bean/> element. You can use @Bean-annotated methods with any Spring @Component. However, they are most often used with @Configuration beans.",
	"Beans - BeanDefinition - Java-based - @Configuration - @Conditional": "The @Conditional annotation indicates specific org.springframework.context.annotation.Condition implementations that should be consulted before a @Bean is registered. Implementations of the Condition interface provide a matches(…​) method that returns true or false.",
	"Beans - PropertyValues - Resolution - @Value('${property}')": "Property values can be injected directly into your beans by using the @Value annotation, e.g. @Value('${jdbc.url}') private String url, You can write a SpEL expression in @Value",
	"Beans - PropertyValues - Resolution - Resources": "Java’s standard java.net.URL class and standard handlers for various URL prefixes unfortunately are not quite adequate enough for all access to low-level resources. For example, there is no standardized URL implementation that may be used to access a resource that needs to be obtained from the classpath, or relative to a ServletContext. While it is possible to register new handlers for specialized URL prefixes (similar to existing handlers for prefixes such as http:), this is generally quite complicated, and the URL interface still lacks some desirable functionality, such as a method to check for the existence of the resource being pointed to.",
	"Beans - PropertyValues - Resolution - Resources - Resource Interface": "Spring’s Resource interface is meant to be a more capable interface for abstracting access to low-level resources. While the Resource interface is used a lot with Spring and by Spring, it’s actually very useful to use as a general utility class by itself in your own code, for access to resources, even when your code doesn’t know or care about any other parts of Spring. While this couples your code to Spring, it really only couples it to this small set of utility classes, which are serving as a more capable replacement for URL, and can be considered equivalent to any other library you would use for this purpose.",
	"Beans - PropertyValues - Resolution - Resources - @ImportResource": "@ImportResource Indicates one or more resources containing bean definitions to import. For import XML-based configuration or other non-@Configuration bean definition resources. e.g. @Configuration @ImportResource({'classpath:spring-security.xml'})",
	"Beans - PropertyValues - Resolution - Resources Implementations - UrlResource": "The UrlResource wraps a java.net.URL, and may be used to access any object that is normally accessible via a URL, such as files, an HTTP target, an FTP target, etc. All URLs have a standardized String representation, such that appropriate standardized prefixes are used to indicate one URL type from another. This includes file: for accessing filesystem paths, http: for accessing resources via the HTTP protocol, ftp: for accessing resources via FTP, etc. A UrlResource is created by Java code explicitly using the UrlResource constructor, but will often be created implicitly when you call an API method which takes a String argument which is meant to represent a path. For the latter case, a JavaBeans PropertyEditor will ultimately decide which type of Resource to create. If the path string contains a few well-known (to it, that is) prefixes such as classpath:, it will create an appropriate specialized Resource for that prefix. However, if it doesn’t recognize the prefix, it will assume the this is just a standard URL string, and will create a UrlResource.",
	"Beans - PropertyValues - Resolution - Resources Implementations - ClassPathResource": "This class represents a resource which should be obtained from the classpath. This uses either the thread context class loader, a given class loader, or a given class for loading resources. This Resource implementation supports resolution as java.io.File if the class path resource resides in the file system, but not for classpath resources which reside in a jar and have not been expanded (by the servlet engine, or whatever the environment is) to the filesystem. To address this the various Resource implementations always support resolution as a java.net.URL. A ClassPathResource is created by Java code explicitly using the ClassPathResource constructor, but will often be created implicitly when you call an API method which takes a String argument which is meant to represent a path. For the latter case, a JavaBeans PropertyEditor will recognize the special prefix classpath: on the string path, and create a ClassPathResource in that case.",
	"Beans - PropertyValues - Resolution - Resources Implementations - FileSystemResource": "This is a Resource implementation for java.io.File handles. It obviously supports resolution as a File, and as a URL.",
	"Beans - PropertyValues - Resolution - Resources Implementations - ServletContextResource": "This is a Resource implementation for ServletContext resources, interpreting relative paths within the relevant web application’s root directory. This always supports stream access and URL access, but only allows java.io.File access when the web application archive is expanded and the resource is physically on the filesystem. Whether or not it’s expanded and on the filesystem like this, or accessed directly from the JAR or somewhere else like a DB (it’s conceivable) is actually dependent on the Servlet container.",
	"Beans - PropertyValues - Resolution - Resources Implementations - InputStreamResource": "A Resource implementation for a given InputStream. This should only be used if no specific Resource implementation is applicable. In particular, prefer ByteArrayResource or any of the file-based Resource implementations where possible. In contrast to other Resource implementations, this is a descriptor for an already opened resource - therefore returning true from isOpen(). Do not use it if you need to keep the resource descriptor somewhere, or if you need to read a stream multiple times.",
	"Beans - PropertyValues - Resolution - Resources Implementations - ByteArrayResource": "This is a Resource implementation for a given byte array. It creates a ByteArrayInputStream for the given byte array. It’s useful for loading content from any given byte array, without having to resort to a single-use InputStreamResource.",
	"Beans - PropertyValues - Resolution - Resources - ResourceLoader": "The ResourceLoader interface is meant to be implemented by objects that can return (i.e. load) Resource instances.",
	"Beans - PropertyValues - Resolution - Resources - classpath*: prefix": "When constructing an XML-based application context, a location string may use the special classpath*: prefix: ApplicationContext ctx =    new ClassPathXmlApplicationContext('classpath*:conf/appContext.xml'), This special prefix specifies that all classpath resources that match the given name must be obtained (internally, this essentially happens via a ClassLoader.getResources(…​) call), and then merged to form the final application context definition. The wildcard classpath relies on the getResources() method of the underlying classloader. ",
	"Beans - PropertyValues - Resolution - Null-safety": "Although Java does not allow to express null-safety with its type system, Spring Framework now provides following annotations in the org.springframework.lang package to declare nullability of APIs and fields: @NonNull, @Nullable, @NonNullApi, @NonNullFields",
	"Beans - PropertyValues - Resolution - Null-safety - @NonNull": "@NonNull annotation where specific parameter, return value or field cannot be null (not needed on parameter and return value where @NonNullApi and @NonNullFields apply).",
	"Beans - PropertyValues - Resolution - Null-safety - @Nullable": "@Nullable annotation where specific parameter, return value or field can be null..",
	"Beans - PropertyValues - Resolution - Null-safety - @NonNullApi": "@NonNullApi annotation at package level declares non-null as the default behavior for parameters and return values.",
	"Beans - PropertyValues - Resolution - Null-safety - @NonNullFields": "@NonNullFields annotation at package level declares non-null as the default behavior for fields.",
	"Beans - PropertyValues - Resolution - Null-safety - JSR 305 meta-annotations": "Spring annotations are meta-annotated with JSR 305 annotations (a dormant but widely spread JSR). JSR 305 meta-annotations allows tooling vendors like IDEA or Kotlin to provide null-safety support in a generic way, without having to hard-code support for Spring annotations. It is not necessary nor recommended to add JSR 305 dependency in project classpath to take advantage of Spring null-safe API. Only projects like Spring-based libraries using null-safety annotations in their codebase should add com.google.code.findbugs:jsr305:3.0.2 with compileOnly Gradle configuration or Maven provided scope to avoid compile warnings.",
	"Beans - PropertyValues - Resolution - BeanWrapper": "the BeanWrapper interface and its corresponding implementation ( BeanWrapperImpl). As quoted from the javadocs, the BeanWrapper offers functionality to set and get property values (individually or in bulk), get property descriptors, and to query properties to determine if they are readable or writable. Also, the BeanWrapper offers support for nested properties, enabling the setting of properties on sub-properties to an unlimited depth. Then, the BeanWrapper supports the ability to add standard JavaBeans PropertyChangeListeners and VetoableChangeListeners, without the need for supporting code in the target class. Last but not least, the BeanWrapper provides support for the setting of indexed properties. The BeanWrapper usually isn’t used by application code directly, but by the DataBinder and the BeanFactory. The way the BeanWrapper works is partly indicated by its name: it wraps a bean to perform actions on that bean, like setting and retrieving properties.",
	"Beans - PropertyValues - Resolution - PropertyEditor": "Spring uses the concept of PropertyEditors to effect the conversion between an Object and a String. If you think about it, it sometimes might be handy to be able to represent properties in a different way than the object itself. For example, a Date can be represented in a human readable way (as the String '2007-14-09'). This behavior can be achieved by registering custom editors, of type java.beans.PropertyEditor.",
	"Beans - PropertyValues - Resolution - PropertyEditor - ByteArrayPropertyEditor": "Editor for byte arrays. Strings will simply be converted to their corresponding byte representations. Registered by default by BeanWrapperImpl.",
	"Beans - PropertyValues - Resolution - PropertyEditor - ClassEditor": "Parses Strings representing classes to actual classes and the other way around. When a class is not found, an IllegalArgumentException is thrown. Registered by default by BeanWrapperImpl.",
	"Beans - PropertyValues - Resolution - PropertyEditor - CustomBooleanEditor": "Customizable property editor for Boolean properties. Registered by default by BeanWrapperImpl, but, can be overridden by registering custom instance of it as custom editor.",
	"Beans - PropertyValues - Resolution - PropertyEditor - CustomCollectionEditor": "Property editor for Collections, converting any source Collection to a given target Collection type.",
	"Beans - PropertyValues - Resolution - PropertyEditor - CustomDateEditor": "Customizable property editor for java.util.Date, supporting a custom DateFormat. NOT registered by default. Must be user registered as needed with appropriate format.",
	"Beans - PropertyValues - Resolution - PropertyEditor - CustomNumberEditor": "Customizable property editor for any Number subclass like Integer, Long, Float, Double. Registered by default by BeanWrapperImpl, but can be overridden by registering custom instance of it as a custom editor.",
	"Beans - PropertyValues - Resolution - PropertyEditor - FileEditor": "Capable of resolving Strings to java.io.File objects. Registered by default by BeanWrapperImpl.",
	"Beans - PropertyValues - Resolution - PropertyEditor - InputStreamEditor": "One-way property editor, capable of taking a text string and producing (via an intermediate ResourceEditor and Resource) an InputStream, so InputStream properties may be directly set as Strings. Note that the default usage will not close the InputStream for you! Registered by default by BeanWrapperImpl.",
	"Beans - PropertyValues - Resolution - PropertyEditor - LocaleEditor": "Capable of resolving Strings to Locale objects and vice versa (the String format is [country][variant], which is the same thing the toString() method of Locale provides). Registered by default by BeanWrapperImpl.",
	"Beans - PropertyValues - Resolution - PropertyEditor - PatternEditor": "Capable of resolving Strings to java.util.regex.Pattern objects and vice versa.",
	"Beans - PropertyValues - Resolution - PropertyEditor - PropertiesEditor": "Capable of converting Strings (formatted using the format as defined in the javadocs of the java.util.Properties class) to Properties objects. Registered by default by BeanWrapperImpl.",
	"Beans - PropertyValues - Resolution - PropertyEditor - StringTrimmerEditor": "Property editor that trims Strings. Optionally allows transforming an empty string into a null value. NOT registered by default, must be user registered as needed.",
	"Beans - PropertyValues - Resolution - PropertyEditor - URLEditor": "Capable of resolving a String representation of a URL to an actual URL object. Registered by default by BeanWrapperImpl.",
	"Beans - PropertyValues - Resolution - PropertyEditor - custom - ConfigurableBeanFactory#registerCustomEditor()": "",
	"Beans - PropertyValues - Resolution - PropertyEditor - custom - CustomEditorConfigurer": "",
	"Beans - PropertyValues - Resolution - Converters": "Converters are used to convert one Java type to another Java type. For example, from Long to java.util.Date or from Integer to Color or from String to Date",
	"Beans - PropertyValues - Resolution - Converters - Built-in": "org.springframework.core.convert.support (converters for Enum, Integer, String, Number, Character, Currency, Charset, Properties, timeZone...), org.springframework.core.serializer.support (Serializer, Deserializer), org.springframework.format.datetime (converters for Calendar, Date, Long), org.springframework.format.datetime.joda ( convertrers for Calendar, Datetieme, DateMidnight, LocalDate... ), org.springframework.format.datetime.standard (Calendar, Instant,OffsetDate, ZoneDate.. )",
	"Beans - PropertyValues - Resolution - Converter - core.convert": "Spring 3 introduces a core.convert package that provides a general type conversion system. The system defines an SPI to implement type conversion logic, as well as an API to execute type conversions at runtime. Within a Spring container, this system can be used as an alternative to PropertyEditors to convert externalized bean property value strings to required property types",
	"Beans - PropertyValues - Resolution - Converter - Converter": "To create your own converter, simply implement the interface Converter",
	"Beans - PropertyValues - Resolution - Converter - ConverterFactory": "When you need to centralize the conversion logic for an entire class hierarchy, for example, when converting from String to java.lang.Enum objects, implement ConverterFactor",
	"Beans - PropertyValues - Resolution - Converter - GenericConverter": "When you require a sophisticated Converter implementation, consider the GenericConverter interface. With a more flexible but less strongly typed signature, a GenericConverter supports converting between multiple source and target types. In addition, a GenericConverter makes available source and target field context you can use when implementing your conversion logic. Such context allows a type conversion to be driven by a field annotation, or generic information declared on a field signature.",
	"Beans - PropertyValues - Resolution - Converter - ConditionalGenericConverter": "Sometimes you only want a Converter to execute if a specific condition holds true. For example, you might only want to execute a Converter if a specific annotation is present on the target field. Or you might only want to execute a Converter if a specific method, such as a static valueOf method, is defined on the target class. ConditionalGenericConverter is the union of the GenericConverter and ConditionalConverter interfaces that allows you to define such custom matching criteria.",
	"Beans - PropertyValues - Resolution - Converter - ConversionService": "The ConversionService defines a unified API for executing type conversion logic at runtime. Converters are often executed behind this facade interface. A ConversionService is a stateless object designed to be instantiated at application startup, then shared between multiple threads. In a Spring application, you typically configure a ConversionService instance per Spring container (or ApplicationContext). That ConversionService will be picked up by Spring and then used whenever a type conversion needs to be performed by the framework. You may also inject this ConversionService into any of your beans and invoke it directly.",
	"Beans - PropertyValues - Resolution - Formatters": "Formatters are used to convert String to another Java type and back. So, one type must be String.",
	"Beans - PropertyValues - Resolution - Formatters - Built-in": "@DateTimeFormat and @NumberFormat",
	"Beans - PropertyValues - Resolution - Formatter - Formatter SPI": "Spring 3 introduces a convenient Formatter SPI that provides a simple and robust alternative to PropertyEditors for client environments.",
	"Beans - PropertyValues - Resolution - Formatter - Formatter": "To create your own Formatter, simply implement the Formatter interface, as a class or as a @component",
	"Beans - PropertyValues - Resolution - Formatter - Annotation-driven Formatting": "To bind an Annotation to a formatter, implement AnnotationFormatterFactory",
	"Beans - PropertyValues - Resolution - Formatter - FormatterRegistry SPI": "The FormatterRegistry is an SPI for registering formatters and converters. FormattingConversionService is an implementation of FormatterRegistry suitable for most environments. This implementation may be configured programmatically or declaratively as a Spring bean using FormattingConversionServiceFactoryBean. Because this implementation also implements ConversionService, it can be directly configured for use with Spring’s DataBinder and the Spring Expression Language (SpEL).",
	"Beans - PropertyValues - Resolution - Formatter - FormatterRegistrar SPI": "The FormatterRegistrar is an SPI for registering formatters and converters through the FormatterRegistry. A FormatterRegistrar is useful when registering multiple related converters and formatters for a given formatting category, such as Date formatting. It can also be useful where declarative registration is insufficient.",

	"DI": "SECTION",
	"DI - Method": ".",
	"DI - Method - Constructor-based - usage": "should be used for mandatory dependencies. In constructor, we should assign constructor args to final member fields.",
	"DI - Method - Constructor-based - < constructor-arg/ > ": "Constructor-based DI is accomplished by the container invoking a constructor with a number of arguments, each representing a dependency. Calling a static factory method with specific arguments to construct the bean is nearly equivalent, and this discussion treats arguments to a constructor and to a static factory method similarly.",
	"DI - Method - Constructor-based - Constructor Argument Resolution": "Constructor argument resolution matching occurs by using the argument’s type. If no potential ambiguity exists in the constructor arguments of a bean definition, the order in which the constructor arguments are defined in a bean definition is the order in which those arguments are supplied to the appropriate constructor when the bean is being instantiated.",
	"DI - Method - Constructor-based - Constructor argument type matching": "In the preceding scenario, the container can use type matching with simple types if you explicitly specify the type of the constructor argument by using the type attribute. < constructor-arg type='int' value='7500000'/ >",
	"DI - Method - Constructor-based - Constructor argument index": "You can use the index attribute to specify explicitly the index of constructor arguments < constructor-arg index='0' value='7500000'/ >",
	"DI - Method - Constructor-based - Constructor argument name": "You can also use the constructor parameter name for value disambiguation <constructor-arg name='years' value='7500000'/ >",
	"DI - Method - Constructor-based - Circular Dependencies": "If you use predominantly constructor injection, it is possible to create an unresolvable circular dependency scenario. For example: Class A requires an instance of class B through constructor injection, and class B requires an instance of class A through constructor injection. If you configure beans for classes A and B to be injected into each other, the Spring IoC container detects this circular reference at runtime, and throws a BeanCurrentlyInCreationException. One possible solution is to edit the source code of some classes to be configured by setters rather than constructors. Alternatively, avoid constructor injection and use setter injection only. In other words, although it is not recommended, you can configure circular dependencies with setter injection. Unlike the typical case (with no circular dependencies), a circular dependency between bean A and bean B forces one of the beans to be injected into the other prior to being fully initialized itself (a classic chicken/egg scenario).",
	"DI - Method - Setter-based": "Setter-based DI is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or no-argument static factory method to instantiate your bean.",
	"DI - Method - Setter-based - usage": "Should be used for optional dependencies.",
	"DI - Method - Setter-based vs Constructor-based": "Since you can mix constructor-based and setter-based DI, it is a good rule of thumb to use constructors for mandatory dependencies and setter methods or configuration methods for optional dependencies. Note that use of the @Required annotation on a setter method can be used to make the property a required dependency. The Spring team generally advocates constructor injection as it enables one to implement application components as immutable objects and to ensure that required dependencies are not null. Furthermore constructor-injected components are always returned to client (calling) code in a fully initialized state. As a side note, a large number of constructor arguments is a bad code smell, implying that the class likely has too many responsibilities and should be refactored to better address proper separation of concerns. Setter injection should primarily only be used for optional dependencies that can be assigned reasonable default values within the class. Otherwise, not-null checks must be performed everywhere the code uses the dependency. One benefit of setter injection is that setter methods make objects of that class amenable to reconfiguration or re-injection later. Management through JMX MBeans is therefore a compelling use case for setter injection. Use the DI style that makes the most sense for a particular class. Sometimes, when dealing with third-party classes for which you do not have the source, the choice is made for you. For example, if a third-party class does not expose any setter methods, then constructor injection may be the only available form of DI.",
	"DI - Method - Field-based - usage": "Spring discourages the use of this because it would possibly hide mandatory fields from outside which would otherwise be assigned in the constructor. This would take away the advantage of properly initialized POJO, specially if intended to use outside of Spring container. Even though, we are mostly using field based injection in this series of tutorials to simplify the concept we want to deliver, we suggest the developers to always avoid using field-based DI in real project scenarios.",
	"DI - Types": ".",
	"DI - Types - eager - default": "By default, ApplicationContext implementations eagerly create and configure all singleton beans as part of the initialization process. Generally, this pre-instantiation is desirable, because errors in the configuration or surrounding environment are discovered immediately, as opposed to hours or even days later.",
	"DI - Types - lazy-init": "You can prevent pre-instantiation of a singleton bean by marking the bean definition as being lazy-initialized. A lazy-initialized bean tells the IoC container to create a bean instance when it is first requested, rather than at startup.",
	"DI - Scope": ".",
	"DI - Scope - Singleton - default": "Scopes a single bean definition to a single object instance per Spring IoC container.",
	"DI - Scope - Prototype": "Scopes a single bean definition to any number of object instances.",
	"DI - Scope - Request": "Scopes a single bean definition to the lifecycle of a single HTTP request, that is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext.",
	"DI - Scope - Session": "Scopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext.",
	"DI - Scope - Application": "Scopes a single bean definition to the lifecycle of a ServletContext. Only valid in the context of a web-aware Spring ApplicationContext.",
	"DI - Scope - Thread": "As of Spring 3.0, a thread scope is available, but is not registered by default. For more information, see the documentation for SimpleThreadScope. For instructions on how to register this or any other custom scope, see Using a custom scope.",
	"DI - Scope - Websocket": "Scopes a single bean definition to the lifecycle of a WebSocket. Only valid in the context of a web-aware Spring ApplicationContext.",
	"DI - Scope - Custom": "",
	"DI - Lifecycle": "Internally, the Spring Framework uses BeanPostProcessor implementations to process any callback interfaces it can find and call the appropriate methods. If you need custom features or other lifecycle behavior Spring does not offer out-of-the-box, you can implement a BeanPostProcessor yourself.",
	"DI - Lifecycle - Mechanisms": "As of Spring 2.5, you have three options for controlling bean lifecycle behavior: the InitializingBean/DisposableBean callback interfaces, custom init()/destroy() methods, and the @PostConstruct/@PreDestroy annotations. You can combine these mechanisms to control a given bean.",
	"DI - Lifecycle - Mechanisms - Order": "@PostConstruct -> InitializingBean#afterPropertiesSet() -> init() -> ... -> @PreDestroy -> DisposableBean#destroy() -> destroy()",
	"DI - Lifecycle - Mechanisms1 - @PostConstruct/@PreDestroy (JSR-250)": "The JSR-250 @PostConstruct and @PreDestroy annotations are generally considered best practice for receiving lifecycle callbacks in a modern Spring application. Using these annotations means that your beans are not coupled to Spring specific interfaces",
	"DI - Lifecycle - Mechanisms2 - init()/destroy()": "",
	"DI - Lifecycle - Mechanisms3 - InitializingBean (Spring)": "The container BeanFactory calls afterPropertiesSet() after it has set all bean properties and satisfied BeanFactoryAware, ApplicationContextAware etc. This method allows the bean instance to perform validation of its overall configuration and final initialization when all bean properties have been set. It is recommended that you do not use the InitializingBean interface because it unnecessarily couples the code to Spring.",
	"DI - Lifecycle - Mechanisms3 - DisposableBean (Spring)": "Interface to be implemented by beans that want to release resources on destruction. A BeanFactory will invoke the destroy method on individual destruction of a scoped bean. An ApplicationContext is supposed to dispose all of its singletons on shutdown, driven by the application lifecycle. destroy() method is invoked by the containing BeanFactory on destruction of a bean. It is recommended that you do not use the DisposableBean callback interface because it unnecessarily couples the code to Spring.",
	"DI - Hooks - BeanPostProcessors": "BeanPostProcessor beans are a special kind of beans (implement BeanPostProcessor interface) that get created before any other beans and interact with newly created beans. With this construct, Spring gives you means to hook-up to and customize the lifecycle behavior simply by implementing a BeanPostProcessor yourself. BeanPostProcessor interface defines callback methods that you can implement to provide your own nstantiation logic, dependency-resolution logic, and so forth. An ApplicationContext automatically detects any beans that are defined with the implementation of the BeanPostProcessor interface and registers these beans as postprocessors, to be then called appropriately by the container upon bean creation.",
	"DI - Hooks - BeanPostProcessors - BeanPostProcessor interface": "BeanPostProcessors, which implement org.springframework.beans.factory.config.BeanPostProcessor interface, consists of exactly two callback methods. postProcessBeforeInitialization (before injecting dependencies) and postProcessAfterInitialization",
	"DI - Hooks - BeanPostProcessors - Multiplicity": "You can configure multiple BeanPostProcessor instances.",
	"DI - Hooks - BeanPostProcessors - Order": "You can control the order in which these BeanPostProcessors execute by setting the order property. You can set this property only if the BeanPostProcessor implements the Ordered interface",
	"DI - Hooks - BeanPostProcessors - Scope": "BeanPostProcessors are scoped per-container. This is only relevant if you are using container hierarchies. If you define a BeanPostProcessor in one container, it will only post-process the beans in that container. In other words, beans that are defined in one container are not post-processed by a BeanPostProcessor defined in another container, even if both containers are part of the same hierarchy.",
	"DI - Hooks - BeanPostProcessors - registering": "While the recommended approach for BeanPostProcessor registration is through ApplicationContext auto-detection, it is also possible to register them programmatically against a ConfigurableBeanFactory using the addBeanPostProcessor method. This can be useful when needing to evaluate conditional logic before registration, or even for copying bean post processors across contexts in a hierarchy. Note however that BeanPostProcessors added programmatically do not respect the Ordered interface. Here it is the order of registration that dictates the order of execution. Note also that BeanPostProcessors registered programmatically are always processed before those registered through auto-detection, regardless of any explicit ordering.",
	"DI - Hooks - BeanFactoryPostProcessor": "The semantics of this interface are similar to those of the BeanPostProcessor, with one major difference: BeanFactoryPostProcessor operates on the bean configuration metadata, that is, the Spring IoC container allows a BeanFactoryPostProcessor to read the configuration metadata and potentially change it before the container instantiates any beans other than BeanFactoryPostProcessors.",
	"DI - Hooks - BeanFactoryPostProcessor - Multiplicity": "You can configure multiple BeanFactoryPostProcessors",
	"DI - Hooks - BeanFactoryPostProcessor - Order": "you can control the order in which these BeanFactoryPostProcessors execute by setting the order property. However, you can only set this property if the BeanFactoryPostProcessor implements the Ordered interface. If you write your own BeanFactoryPostProcessor, you should consider implementing the Ordered interface too",
	"DI - Hooks - BeanFactoryPostProcessor - Scope": "Also, BeanFactoryPostProcessors are scoped per-container. This is only relevant if you are using container hierarchies. If you define a BeanFactoryPostProcessor in one container, it will only be applied to the bean definitions in that container. Bean definitions in one container will not be post-processed by BeanFactoryPostProcessors in another container, even if both containers are part of the same hierarchy.",
	"DI - Hooks - FactoryBean": "Implement the org.springframework.beans.factory.FactoryBean interface for objects that are themselves factories. The FactoryBean interface is a point of pluggability into the Spring IoC container’s instantiation logic. If you have complex initialization code that is better expressed in Java as opposed to a (potentially) verbose amount of XML, you can create your own FactoryBean, write the complex initialization inside that class, and then plug your custom FactoryBean into the container.",
	"DI - Hooks - FactoryBean - methods": "The FactoryBean interface provides three methods: Object getObject(): returns an instance of the object this factory creates. The instance can possibly be shared, depending on whether this factory returns singletons or prototypes. boolean isSingleton(): returns true if this FactoryBean returns singletons, false otherwise. Class getObjectType(): returns the object type returned by the getObject() method or null if the type is not known in advance.",
	"DI - Hooks - FactoryBean - get": "The FactoryBean concept and interface is used in a number of places within the Spring Framework, more than 50 implementations of the FactoryBean interface ship with Spring itself. When you need to ask a container for an actual FactoryBean instance itself instead of the bean it produces, preface the bean’s id with the ampersand symbol ( &) when calling the getBean() method of the ApplicationContext. So for a given FactoryBean with an id of myBean, invoking getBean('myBean') on the container returns the product of the FactoryBean, whereas, invoking getBean('&myBean') returns the FactoryBean instance itself.",
	"DI - Validation": "Spring supports 2 validation libraries: (1) Spring Framework 4.0 also supports Bean Validation 1.0 (JSR-303) and Bean Validation 1.1 (JSR-349) (2) the validation package.",
	"DI - Validation - JSR 303/349 - Support": "JSR-303 standardizes validation constraint declaration and metadata for the Java platform. Using this API, you annotate domain model properties with declarative validation constraints and the runtime enforces them. There are a number of built-in constraints you can take advantage of. You may also define your own custom constraints.",
	"DI - Validation - JSR 303/349 - ValidatorFactory/Validator": "Spring provides full support for the Bean Validation API. This includes convenient support for bootstrapping a JSR-303/JSR-349 Bean Validation provider as a Spring bean. This allows for a javax.validation.ValidatorFactory or javax.validation.Validator to be injected wherever validation is needed in your application.",
	"DI - Validation - JSR 303/349 - LocalValidatorFactoryBean": "LocalValidatorFactoryBean implements both javax.validation.ValidatorFactory and javax.validation.Validator, as well as Spring’s org.springframework.validation.Validator. You may inject a reference to either of these interfaces into beans that need to invoke validation logic.",
	"DI - Validation - JSR 303/349 - ConstraintValidator": "Each Bean Validation custom constraint consists of two parts. First, a @Constraint annotation that declares the constraint and its configurable properties. Second, an implementation of the javax.validation.ConstraintValidator interface that implements the constraint’s behavior. To associate a declaration with an implementation, each @Constraint annotation references a corresponding ConstraintValidator implementation class. At runtime, a ConstraintValidatorFactory instantiates the referenced implementation when the constraint annotation is encountered in your domain model..",
	"DI - Validation - validation package": "The Validator and the DataBinder make up the validation package",
	"DI - Validation - validation package - Validator": "implementing the following two methods of the org.springframework.validation.Validator interface: supports(Class) - Can this Validator validate instances of the supplied Class? validate(Object, org.springframework.validation.Errors) - validates the given object and in case of validation errors, registers those with the given Errors object",
	"DI - Validation - validation package - Data Binding": "Data binding is useful for allowing user input to be dynamically bound to the domain model of an application (or whatever objects you use to process user input). Spring provides the so-called DataBinder to do exactly that.",
	"DI - AwareInterfaces": "Spring offers a range of Aware interfaces that let beans indicate to the container that they require a certain infrastructure dependency. Bean factory implementations should support the standard bean lifecycle interfaces as far as possible. Usage of these interfaces ties your code to the Spring API and does not follow the Inversion of Control style. As such, they are recommended for infrastructure beans that require programmatic access to the container.",
	"DI - AwareInterfaces - Initialization Order": "The full set of initialization methods and their standard order is: (1) BeanNameAware's setBeanName (2) BeanClassLoaderAware's setBeanClassLoader (3) BeanFactoryAware's setBeanFactory (4) EnvironmentAware's setEnvironment (5) EmbeddedValueResolverAware's setEmbeddedValueResolver (6) ResourceLoaderAware's setResourceLoader (only applicable when running in an application context) (7) ApplicationEventPublisherAware's setApplicationEventPublisher (only applicable when running in an application context) (8) MessageSourceAware's setMessageSource (only applicable when running in an application context) (9) ApplicationContextAware's setApplicationContext (only applicable when running in an application context) (10) ServletContextAware's setServletContext (only applicable when running in a web application context) (11) postProcessBeforeInitialization methods of BeanPostProcessors (12) InitializingBean's afterPropertiesSet (13) a custom init-method definition (14) postProcessAfterInitialization methods of BeanPostProcessors.",
	"DI - AwareInterfaces - Shutdown Order": "Bean factory implementations should support the standard bean lifecycle interfaces as far as possible. On shutdown of a bean factory, the following lifecycle methods apply: (1) postProcessBeforeDestruction methods of DestructionAwareBeanPostProcessors (2) DisposableBean's destroy (3) a custom destroy-method definition",
	"DI - AwareInterfaces - ApplicationContextAware": "When an ApplicationContext creates an object instance that implements the org.springframework.context.ApplicationContextAware interface, the instance is provided with a reference to that ApplicationContext..",
	"DI - AwareInterfaces - ApplicationEventPublisherAware": "",
	"DI - AwareInterfaces - BeanClassLoaderAware": "",
	"DI - AwareInterfaces - BeanFactoryAware": "",
	"DI - AwareInterfaces - BeanNameAware": "When an ApplicationContext creates a class that implements the org.springframework.beans.factory.BeanNameAware interface, the class is provided with a reference to the name defined in its associated object definition.",
	"DI - AwareInterfaces - BootstrapContextAware": "",
	"DI - AwareInterfaces - LoadTimeWeaverAware": "",
	"DI - AwareInterfaces - MessageSourceAware": "",
	"DI - AwareInterfaces - NotificationPublisherAware": "",
	"DI - AwareInterfaces - ResourceLoaderAware": "",
	"DI - AwareInterfaces - ServletConfigAware": "",
	"DI - AwareInterfaces - ServletContextAware": "",
	"DI - BeanSpEL - SpringExpressionLanguage": "The Spring Expression Language (SpEL for short) is a powerful expression language that supports querying and manipulating an object graph at runtime. The language syntax is similar to Unified EL but offers additional features, most notably method invocation and basic string templating functionality. While there are several other Java expression languages available — OGNL, MVEL, and JBoss EL, to name a few — the Spring Expression Language was created to provide the Spring community with a single well supported expression language that can be used across all the products in the Spring portfolio. Its language features are driven by the requirements of the projects in the Spring portfolio, including tooling requirements for code completion support within the Eclipse based Spring Tool Suite. That said, SpEL is based on a technology agnostic API allowing other expression language implementations to be integrated should the need arise. While SpEL serves as the foundation for expression evaluation within the Spring portfolio, it is not directly tied to Spring and can be used independently. In order to be self contained, many of the examples in this chapter use SpEL as if it were an independent expression language. This requires creating a few bootstrapping infrastructure classes such as the parser. Most Spring users will not need to deal with this infrastructure and will instead only author expression strings for evaluation. An example of this typical use is the integration of SpEL into creating XML or annotated based bean definitions as shown in the section Expression support for defining bean definitions.",
	"DI - BeanSpEL - EvaluationContext": "",
	"DI - BeanSpEL - SimpleEvaluationContext ": "",
	"DI - BeanSpEL - StandardEvaluationContext ": "",

	"Environment ": "SECTION",
	"Environment": "The Environment is an abstraction integrated in the container that models two key aspects of the application environment: profiles and properties.",
	"Environment - ConfigurableEnvironment": "Configuration interface to be implemented by most if not all Environment types. Provides facilities for setting active and default profiles and manipulating underlying property sources. Allows clients to set and validate required properties, customize the conversion service and more through the ConfigurablePropertyResolver superinterface.",
	"Environment - ConfigurableEnvironment - StandardEnvironment": "Environment implementation suitable for use in 'standard' (i.e. non-web) applications. In addition to the usual functions of a ConfigurableEnvironment such as property resolution and profile-related operations, this implementation configures two default property sources, to be searched in the following order: system properties system environment variables",
	"Environment - ConfigurableEnvironment - StandardServletEnvironment": "Environment implementation to be used by Servlet-based web applications. All web-related (servlet-based) ApplicationContext classes initialize an instance by default. Contributes ServletConfig, ServletContext, and JNDI-based PropertySource instances.",
	"Environment - ConfigurableEnvironment - MockEnvironment": "Simple ConfigurableEnvironment implementation exposing setProperty(String, String) and withProperty(String, String) methods for testing purposes.",
	"Environment - Profiles": "A profile is a named, logical group of bean definitions to be registered with the container only if the given profile is active. Beans may be assigned to a profile whether defined in XML or via annotations. The role of the Environment object with relation to profiles is in determining which profiles (if any) are currently active, and which profiles (if any) should be active by default.",
	"Environment - Profiles - Configuring": "Registration of spring items with specific profiles.",
	"Environment - Profiles - Configuring - Declarative - @Profile": "The @Profile annotation lets you indicate that a component or method is eligible for registration when one or more specified profiles are active.",
	"Environment - Profiles - Configuring - Declarative - @Profile - class": "If a @Component or @Configuration class is marked with @Profile({'p1', 'p2'}), that class is not registered or processed unless profiles 'p1' or 'p2' have been activated.",
	"Environment - Profiles - Configuring - Declarative - @Profile - method": "@Profile can also be declared at the method level to include only one particular bean of a configuration class.",
	"Environment - Profiles - Configuring - Declarative - <beans profile='dev'/>": "",
	"Environment - Profiles - Activating": "Activating a profile can be done in several ways: (1) programmatically (2) Declaratively",
	"Environment - Profiles - Activating - Declarative - JVM": "Declaratively: -Dspring.profiles.active='profile1,profile2'",
	"Environment - Profiles - Activating - Declarative - Environment Variable": "SPRING_PROFILES_ACTIVE is the environment variable to override/pick Spring profile = export spring_profiles_active=dev",
	"Environment - Profiles - Activating - Declarative - web.xml": "<context-param><param-name>spring.profiles.active</param-name><param-value>dev</param-value></context-param>",
	"Environment - Profiles - Activating - Programmatically - via ApplicationContext": "programmatically against the Environment API which is available through an ApplicationContext ctx.getEnvironment().setActiveProfiles('profile1', 'profile2')",
	"Environment - Profiles - Activating - Programmatically - via WebApplicationInitializer": "@Override  public void onStartup(ServletContext servletContext) throws ServletException {    servletContext.setInitParameter('spring.profiles.active', 'dev'),  }",
	"Environment - Profiles - Activating - Programmatically - via ConfigurableEnvironment": "@Autowired private ConfigurableEnvironment env, env.setActiveProfiles('dev'),",
	"Environment - Profiles - Default": "Any bean that does not specify a profile belongs to 'default' profile.",
	"Environment - Profiles - Default - Declarative - ": "declaratively, by using the spring.profiles.default property.'",
	"Environment - Profiles - Default - Programmatically - ": "You can change the name of the default profile by using setDefaultProfiles() on the Environment'",
	"Environment - Profiles - MetaAnnotation": "@Profile can be used as a meta-annotation for the purpose of creating a custom composed annotation. The following example defines a custom @Production annotation that can be used as a drop-in replacement for @Profile('production'):",
	"Environment - Properties": "Properties play an important role in almost all applications, and may originate from a variety of sources: properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects, Maps, and so on. The role of the Environment object with relation to properties is to provide the user with a convenient service interface for configuring property sources and resolving properties from them..",
	"Environment - Properties - PropertySource": " PropertySource is a simple abstraction over any source of key-value pairs, and Spring’s StandardEnvironment is configured with two PropertySource objects — one representing the set of JVM system properties (a la System.getProperties()) and one representing the set of system environment variables (a la System.getenv()).",
	"Environment - Properties - @PropertySource": "Annotation providing a convenient and declarative mechanism for adding a PropertySource to Spring's Environment. To be used in conjunction with @Configuration classes. @PropertySource('classpath:/com/myco/app.properties')",
	"Environment - Properties - @PropertySource - example": "The @PropertySource annotation provides a convenient and declarative mechanism for adding a PropertySource to Spring’s Environment. Given a file called app.properties that contains the key-value pair testbean.name=myTestBean, the following @Configuration class uses @PropertySource in such a way that a call to testBean.getName() returns myTestBean: @Configuration @PropertySource('classpath:/com/myco/app.properties')",

	"AOP": "SECTION",
	"AOP Concept - Aspect": "Aspect: a modularization of a concern that cuts across multiple classes. Transaction management is a good example of a crosscutting concern in enterprise Java applications. In Spring AOP, aspects are implemented using regular classes (the schema-based approach) or regular classes annotated with the @Aspect annotation (the @AspectJ style).",
	"AOP Concept - Join point": "Join point: a point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution.",
	"AOP Concept - Advice": "Advice: action taken by an aspect at a particular join point. Different types of advice include 'around', 'before' and 'after' advice. (Advice types are discussed below.) Many AOP frameworks, including Spring, model an advice as an interceptor, maintaining a chain of interceptors around the join point.",
	"AOP Concept - Pointcut:": "Pointcut: a predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by the pointcut (for example, the execution of a method with a certain name). The concept of join points as matched by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut expression language by default.",
	"AOP Concept - Introduction": "Introduction: declaring additional methods or fields on behalf of a type. Spring AOP allows you to introduce new interfaces (and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement an IsModified interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.)",
	"AOP Concept - Target object": "Target object: object being advised by one or more aspects. Also referred to as the advised object. Since Spring AOP is implemented using runtime proxies, this object will always be a proxied object.",
	"AOP Concept - AOP proxy": "AOP proxy: an object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). In the Spring Framework, an AOP proxy will be a JDK dynamic proxy or a CGLIB proxy.",
	"AOP Concept - Weaving": "Weaving: linking aspects with other application types or objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime.",
	"AOP Concept - @EnableLoadTimeWeaving ": "Activates a Spring LoadTimeWeaver for this application context, available as a bean with the name 'loadTimeWeaver', similar to the <context:load-time-weaver> element in Spring XML.",
	"AOP Concept - Types of advice - Before advice": "Before advice: Advice that executes before a join point, but which does not have the ability to prevent execution flow proceeding to the join point (unless it throws an exception).",
	"AOP Concept - Types of advice - After returning advice": "After returning advice: Advice to be executed after a join point completes normally: for example, if a method returns without throwing an exception..",
	"AOP Concept - Types of advice - After throwing advice": "After throwing advice: Advice to be executed if a method exits by throwing an exception.",
	"AOP Concept - Types of advice - After (finally) advice": "After (finally) advice: Advice to be executed regardless of the means by which a join point exits (normal or exceptional return).",
	"AOP Concept - Types of advice - Around advice": "Around advice: Advice that surrounds a join point such as a method invocation. This is the most powerful kind of advice. Around advice can perform custom behavior before and after the method invocation. It is also responsible for choosing whether to proceed to the join point or to shortcut the advised method execution by returning its own return value or throwing an exception. Around advice is the most general kind of advice. Since Spring AOP, like AspectJ, provides a full range of advice types, we recommend that you use the least powerful advice type that can implement the required behavior. For example, if you need only to update a cache with the return value of a method, you are better off implementing an after returning advice than an around advice, although an around advice can accomplish the same thing. Using the most specific advice type provides a simpler programming model with less potential for errors. For example, you do not need to invoke the proceed() method on the JoinPoint used for around advice, and hence cannot fail to invoke it."
}