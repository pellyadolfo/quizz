{
  "ReactJS": "SECTION",
  "ReactJS 0": "https://github.com/ishwarrimal/frontend-interview-preparation/tree/main/React",
  "ReactJS 1": "https://medium.com/@firatatalay/how-rendering-works-the-commit-phase-4114680d7057",
  "ReactJS 3": "https://www.linkedin.com/posts/ahmedalibutt_aws-ci-cd-pipeline-deployment-activity-7328739254413537280-dW25?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
  "ReactJS 4": "https://www.linkedin.com/posts/vigneshwaran2636_react-cleanarchitecture-scalableapps-activity-7325942206563782659-OWj5?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
  "ReactJS 5": "https://www.linkedin.com/posts/pothugunta-rakesh-93b8a8352_cl-cd-activity-7328226934562168832-uh4I/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
  "ReactJS - Genesis - Feb2010": "2010 - the genesis for React came from an extension of PHP that Facebook had released as open source software in February 2010, called XHP.",
  "ReactJS - Genesis - 2010 - XHP": "2010 - However, because it was PHP — a server-side language — every time something changed, the page would need to re-render completely.",
  "ReactJS - Genesis - 2010 - FaxJS": "So the Facebook team decided to move a lot of the application logic of XHP into JavaScript. Jordan Walke, a software engineer at Facebook, created an early prototype of React. js called 'FaxJS.'",
  "ReactJS - Genesis - 2011 - FaxJS": "2011 - An early prototype of React. Jordan Walke created FaxJS, the early prototype of React - shipped a search element on Facebook.",
  "ReactJS - Genesis - 2012 - Feeds": "2012 - Something new had started at Facebook. First used within Facebook's News Feed and Instagram.",
  "ReactJS - Features - React0.3.0 - May2013 - OpenSourced": "React was officially open-sourced on May 29, 2013, during JSConf US in Palm Springs, California.",
  "ReactJS - Features - React0.3.0 - May2013 - OpenSourced - JSX": "JSX was included in React's initial open-source launch at JSConf US.",
  "ReactJS - Features - React0.3.0 - May2013 - (1) CreateClass": "First public release with React.createClass()",
  "ReactJS - Features - React0.13 - Mar2015 - (2) React.Component": "Added support for ES6 class components. Introduced class MyComponent extends React.Component.",
  "ReactJS - Features - React0.13 - Mar2015 - CreateClass": "Deprecated React.createClass() (later moved to a separate package)",
  "ReactJS - Features - React0.14 - Oct2015 - (3) FunctionalComponents": "First introduced as stateless components (could only accept props). Syntax: Plain JavaScript functions returning JSX",
  "ReactJS - Features - React15 - Apr2016 - LifecycleMethods": "Stabilized class components with lifecycle methods: componentDidMount, shouldComponentUpdate, componentWillUnmount, etc.",
  "ReactJS - Features - React16 - Sep2017 - FiberArchitecture": "Complete rewrite of React's core algorithm",
  "ReactJS - Features - React16 - Sep2017 - ErrorBoundaries": "componentDidCatch for handling errors",
  "ReactJS - Features - React16 - Sep2017 - LifecycleMethods": "getDerivedStateFromProps, getSnapshotBeforeUpdate",
  "ReactJS - Features - React16.3 - Mar2018 - NewContextAPI": "createContext()",
  "ReactJS - Features - React16.3 - Mar2018 - RefAPI": "React.createRef() and forwardRef",
  "ReactJS - Features - React16.3 - Mar2018 - StrictMode": "Highlight potential problems",
  "ReactJS - Features - React16.3 - Mar2018 - NewLifecycles": "getDerivedStateFromProps replaces componentWillReceiveProps",
  "ReactJS - Features - React16.3 - Mar2018 - DeprecatedLifecycles": "Deprecated unsafe methods (componentWillMount, componentWillReceiveProps, etc.)",
  "ReactJS - Features - React16.8 - Feb2019 - (4) FunctionComponents": "manage state and lifecycle behaviors within functional components, reducing the reliance on class components.",
  "ReactJS - Features - React16.8 - Feb2019 - Hooks": "useState, useEffect, etc",
  "ReactJS - Features - React16.8 - Feb2019 - ConcurrentMode": "",
  "ReactJS - Features - React17 - Oct2020 - NewJSXTransform": "No need to import React in JSX files",
  "ReactJS - Features - React17 - Oct2020 - EventDelegationChanges": "Attaches events to root instead of document",
  "ReactJS - Features - React18 - Mar2022 - ConcurrentFeatures": "startTransition, useTransition, useDeferredValue",
  "ReactJS - Features - React18 - Mar2022 - AutomaticBatching": "Better performance.",
  "ReactJS - Features - React18 - Mar2022 - NewRootAPI": "createRoot()",
  "ReactJS - Features - React18 - Mar2022 - SuspenseForSSR": "renderToPipeableStream",
  "ReactJS - Features - React18 - Mar2022 - ServerComponents": "with frameworks like Next.js",
  "ReactJS - Features - React19 - Dec2024 - Actions": "Simplified data handling (useActionState, useFormStatus)",
  "ReactJS - Features - React19 - Dec2024 - Directives": "use client / use server (framework-dependent)",
  "ReactJS - Features - React19 - Dec2024 - AssetLoading": "Automatic handling of scripts/styles",
  "ReactJS - Features - React19 - Dec2024 - DocumentMetadata": "Built-in support for < title > / < meta > tags",
  "ReactJS - Features - React19 - Dec2024 - ReactCompiler": "Automatic memoization",
  "ReactJS - Features - React19 - Dec2024 - NewHooks": "use, useOptimistic",

  "BuildingBlocks": "SECTION",
  "BuildingBlocks - Components - CreateClass - ES5 - 2013": "Deprecated. Everything started out with React's createClass Components. The createClass method provided developers with a factory method to create React class components without using a JavaScript class. It was the status quo for creating React components prior JavaScript ES6, because in JavaScript ES5 there was no class syntax available. const MyComponent = React.createClass({ render() { return <p>I am a component!</p>; } });",
  "BuildingBlocks - Components - CreateClass - deprecated": "React's createClass method is no longer available in the React core package. If you want to try it, you have to install an additional node package: npm install create-react-class. After all, you should only use React's createClass method, if you have no JavaScript ES6 or beyond available in your project. Otherwise you should avoid using it. ",
  "BuildingBlocks - Components - CreateClass - methods - getInitialState": "the getInitialState() function is used to set an initial state for the React component",
  "BuildingBlocks - Components - CreateClass - methods - render": "the mandatory render() method is there to display the output with JSX",
  "BuildingBlocks - Components - CreateClass - methods - onChange": "Additional methods (e.g. onChange()) are added by passing more functions to the object.",
  "BuildingBlocks - Components - CreateClass - Lifecycle - componentDidUpdate": "Lifecycle methods for side-effects are available as well. For instance, in order to write every time the value from the input field to the browser's local storage, we could make use of the componentDidUpdate() lifecycle method by passing a function to the object with an object key named after a React lifecycle method.",
	"BuildingBlocks - Components - Class - ES6 - 2015": "They have a more feature-rich API, including state and lifecycle methods.- They are used when you need to manage the component’s state or lifecycle events.",
	"BuildingBlocks - Components - Class - deprecated": "Probably never need to use a Class component in React anymore. Even though Function components are preferred, there are no current plans on removing Class components from React",
  "BuildingBlocks - Components - Class - React.Component": "Class components are ES6 classes that extend from `React.Component`.",
  "BuildingBlocks - Components - Class - React.PureComponent": "React.PureComponent is similar to React.Component . The difference between them is that React.Component doesn't implement shouldComponentUpdate(). React.PureComponent is a base component class that checks the fields of state and props to know whether the component should be updated. React.PureComponent optimizes our components by reducing the number of wasted renders.",
  "BuildingBlocks - Components - Class - Structure": "You want to have a clear structure in components so you can navigate through them quickly and have a pattern that is obvious to other engineers: 1- State declarations, 2 - Ref declarations, 3 - Memoized values, 4 - Memoized callbacks, 5 - Custom hooks, 6 - Effects, 7 Event handler, 8- JSX",
  "BuildingBlocks - Components - Class - instances": "They have instances, lifecycle methods, and internal state.",
  "BuildingBlocks - Components - Class - render()": "React treats a component as a class component if it is a function and has a prototype.render method. renders JSX",
	"BuildingBlocks - Components - Class - Lifecycle": "These methods are called in the following order when an instance of a component is being created and inserted into the DOM.",
	"BuildingBlocks - Components - Class - Lifecycle - Mounting": "constructor > getDerivedStateFromProps > render > componentDidMount",
	"BuildingBlocks - Components - Class - Lifecycle - Rerendering": "getDerivedStateFromProps > shouldComponentUpdate > render > getSnapshotBeforeUpdate > componentDidUpdate",
	"BuildingBlocks - Components - Class - Lifecycle - Unmounting": "componentWillUnmount",
	"BuildingBlocks - Components - Class - Lifecycle - ErrorHandling": "getDerivedStateFromError / componentDidCatch",
  "BuildingBlocks - Components - Class - this": "React will not auto-bind your functions within components. However, you may manually achieve the binding. Here are some ways to bind your components and functions: Bind in render, Allow arrow function in render, Bind in constructor, Bind arrow function in the class property [Not in official ECMAscript]",
  "BuildingBlocks - Components - Class - this - state": "this.state",
  "BuildingBlocks - Components - Class - this - props": "this.props",
	"BuildingBlocks - Components - HOC": "A HOC is a function that takes a component and returns an enhanced component.",
	"BuildingBlocks - Components - HOC - Structure - HOF": "Higher-Order Components (HOC) stem from the concept of Higher-Order Functions (HOF) which is called this way whenever it takes a function as argument or returns a function with its return statement.",
	"BuildingBlocks - Components - HOC - Structure - Reusable": "Reusable logic: Encapsulates behavior that can be applied to multiple components.",
	"BuildingBlocks - Components - HOC - Structure - Composable": "Composable: HOCs can be chained together to combine multiple behaviors.",
	"BuildingBlocks - Components - Functional": "Functional components are JavaScript functions that take in props as parameters and return React elements.",
	"BuildingBlocks - Components - Functional - Features - Stateless - React <16.8": "Before React Hooks were introduced (React 16.8 in 2019) They were stateless and could not use lifecycle methods like componentDidMount. ",
	"BuildingBlocks - Components - Functional - Features - Code": "less code",
	"BuildingBlocks - Components - Functional - Features - Performance": "better performance",
	"BuildingBlocks - Components - Functional - Features - Lifecycle": "No unnecessary lifecycle methods running.",
	"BuildingBlocks - Components - Functional - Features - Test": "easier to test",
	"BuildingBlocks - Components - Functional - Features - Dumb": "Since they were purely functions with no state or side effects, they were sometimes called 'dumb' components.",
	"BuildingBlocks - Components - Functional - Lifecycle": "don't have constructor or lifecycle methods like ClassComponents.",
	"BuildingBlocks - Components - Functional - Lifecycle - render": "In React functional components, there isn't an explicit render method like in class components. Instead, the entire function body acts as the render method.",
	"BuildingBlocks - Components - Functional - Arrow Function": "With the introduction of JavaScript ES6, new coding concepts were introduced to JavaScript and therefore to React. For instance, a JavaScript function can be expressed as lambda (arrow function). That's why a Function Component is sometimes called Arrow Function Components (or maybe also Lambda Function Component). const App = () => { ... };",
  "BuildingBlocks - Components - Functional - this": "No existing",
	"BuildingBlocks - Components - Function": "React Hooks rebranded Functional to Function Components.",
	"BuildingBlocks - Components - Function - Features - Preferred": "Function components are now the preferred way to build React apps because they are simpler, easier to read, and work well with Hooks.",
	"BuildingBlocks - Components - Function - Features - Statefull": "React Hooks bring state and side-effects to React Function Components.",
	"BuildingBlocks - Components - Function - Features - Powerfull": "They can use state (useState) and side effects (useEffect), making them just as powerful as class components.",
	"BuildingBlocks - Components - Function - Features - instances": "They do not have instances, lifecycle methods, or internal state (prior to React 16.8, before hooks were introduced).",
	"BuildingBlocks - Components - Function - Features - Cache": "Hooks let you optimize re-renders easily (useMemo, useCallback).",
	"BuildingBlocks - Components - Function - Features - noRender": "React treats a component as a function component if it is a function and does not have a prototype.render method.",
  "BuildingBlocks - Components - Function - Lifecycle - Hooks": "Before React 16.8, Class components were the only way to track state and lifecycle on a React component. With the addition of Hooks, Function components are now almost equivalent to Class components.",
  "BuildingBlocks - Components - Function - Lifecycle - Hooks - order": "React executes hooks in the order they appear in the component's function body.",
	"BuildingBlocks - Components - Function - vs Class - Performance": "Functional components with React hooks are generally more performant, but they require memoization in some cases.",
	"BuildingBlocks - Components - Function - vs Class - Lifecycle": "Hooks replace lifecycle methods with a single, flexible API (useEffect).",
	"BuildingBlocks - Components - Function - vs Class - Calls": "Functional components use useEffect, which is easier to manage. All side effects are in one place. Easy cleanup (e.g., return () => unsubscribe()).",
	"BuildingBlocks - Components - Function - vs Class - ErrorBoundaries": "Functional components cannot be used as error boundaries because hooks cannot catch errors in child components.",
	"BuildingBlocks - Router - ReactRouter": "React Router is the perfect tool to link together the URL and your React app. React Router is the de-facto React routing library, and it's one of the most popular projects built on top of React. We can use ReactRouter with Suspense for LazyLoading.",
	"BuildingBlocks - Router - TanStackRouter": "",
	"BuildingBlocks - Router - Vike": "https://javascript.plainenglish.io/exploring-vike-vites-new-micro-frontend-framework-and-how-it-compares-with-other-major-tools-3acad4fa3fc4",

  "Data": "SECTION",
  "Data - Components - Props": "React components use props to communicate with each other.",
  "Data - Components - Props - Syntax": "React Props are like function arguments in JavaScript and attributes in HTML. Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, and functions.",
  "Data - Components - Props - Syntax - quotes": "You may use quotes to specify string literals as attributes: const element = <a href='https://www.reactjs.org'> link </a>;",
  "Data - Components - Props - Syntax - curly braces": "You may also use curly braces to embed a JavaScript expression in an attribute: const element = <img src={user.avatarUrl}></img>;.",
	"Data - Components - Props - Syntax - spreading": "<div {...props}>{props.text}</div> should avoid spreading properties into a DOM element as it adds unknown HTML attribute, which is unnecessary and a bad practice.",
	"Data - Components - Props - Types - TypeScript - Define - Object - Type": "Props should have a TypeScript interface or type alias.",
	"Data - Components - Props - Types - TypeScript - Define - Object - Interface": "Props should have a TypeScript interface or type alias.",
	"Data - Components - Props - Types - TypeScript - Define - Function": "If a component receives a function as a prop, you must define the function's parameters and return type.",
	"Data - Components - Props - Types - TypeScript - Define - Array": "Use Array<T>.",
	"Data - Components - Props - Types - TypeScript - Define - List": "Use T[].",
	"Data - Components - Props - Types - TypeScript - Define - Generics": "Use generics when prop types are dynamic.",
	"Data - Components - Props - Types - TypeScript - Define - FlexibleTypes": "Using Generics for Flexible Prop Types Generics allow components to accept different data types dynamically.",
	"Data - Components - Props - Types - TypeScript - Define - FlexibleProps": "Defining Union Types for Flexible Props. If a prop can accept multiple types, use a union (|).",
	"Data - Components - Props - Types - TypeScript - Define - Default": "src = 'default.png'",
	"Data - Components - Props - Types - TypeScript - Define - Children": "Defining Props for Components with Children. If a component accepts children, use React.ReactNode.",
	"Data - Components - Props - Types - TypeScript - Define - Optional": "Props can be optional using ?: src?: string;",
	"Data - Components - Props - Types - TypeScript - Define - Nested": "For deeply nested objects, define separate interfaces.",
	"Data - Components - Props - Default - defaultValues": "const Button: React.FC<ButtonProps> = ({ label = 'Click me', color = 'blue' }) => { ... } for Functional components (best approach)",
	"Data - Components - Props - Default - defaultProps": "defaultProps (for class components) static defaultProps: Partial<ButtonProps> = { label: 'Click me', color: 'blue', }; for Class components (legacy)",
	"Data - Components - Props - Default - ??": "?? (nullish coalescing) operator. return <button>{props.label ?? 'Click me'}</button>; Handling defaults inline",
  "Data - Components - Interaction - Unidirectional": "React works on a unidirectional data flow from parent components to child components in a React application through props. This makes data flow predictable and easier to debug.",
	"Data - Components - Interaction - ParentToChild - Props - Process": "The component receives the argument as a props object. Every parent component can pass some information to its child components by giving them props. Passing props from component to component in React doesn't make components interactive, because props are read-only and therefore immutable. Props are the information that you pass to a JSX tag. ",
	"Data - Components - Interaction - ParentToChild - Props - Forwarding": ".",
	"Data - Components - Interaction - ParentToChild - Props - Drilling": "At some point, you are passing a lot of props down your component tree. Depending on the depth of the component tree, it can happen that many props are passed from a top level component to all the leaf components. Every component in between has to pass the props even though it may not be interested in the props. The problem is called prop drilling in React. The solution is Context.",
  "Data - Components - Interaction - ParentToChild - Props - taintObjectReference": "lets you prevent a specific object instance from being passed to a Client Component like a user object.",
  "Data - Components - Interaction - ParentToChild - Props - taintUniqueValue": "lets you prevent unique values from being passed to Client Components like passwords, keys, or tokens.",
	"Data - Components - Interaction - ChildToParent - Callback": "To send data from child to parent, pass a function as a prop. The child calls the function, and the parent gets the data.",
	"Data - Components - Interaction - AnyToAny": "Use State.",
	"Data - State ": "State generally refers to data or properties that need to be tracking in an application. State lets a component “remember” information like user input. If you want interactive React components, you have to introduce stateful values by using React State.",
	"Data - State - Structuring": "In React, when multiple components depend on the same state, React ensures that state updates trigger re-renders only for affected components. However, how efficiently React handles these updates depends on where the state is stored and how it's managed.",
	"Data - State - Structuring - Optimize - Normalize": "Normalize State for Lists & Objects If storing large lists of data, normalize it to avoid deep nesting.",
	"Data - State - Structuring - Optimize - Memoize": "Avoid Unnecessary Re-renders Use Memoization (useMemo, useCallback) If a component re-renders too often due to prop changes, memoize values and functions.",
	"Data - State - Structuring - RaceConditions": "Race conditions occur when multiple asynchronous operations compete to update the state, leading to inconsistent or stale data. This is common in cases like API requests, user interactions, or real-time updates.",
	"Data - State - Structuring - RaceConditions - useEffect": "If a component makes an API request but unmounts before it completes, React may try to update state on an unmounted component, causing errors. Solution: Use AbortController to cancel the fetch request when the component unmounts or when a new request is made.",
	"Data - State - Structuring - RaceConditions - StateVersioning": "If multiple API calls are made, a slower previous response might overwrite a newer one. Solution: Use a version counter (useRef) to track the latest request and ignore outdated ones.",
	"Data - State - Structuring - RaceConditions - ReduxMiddleware": "Best for: Managing complex async flows like debouncing, polling, or cancellation Solution: Redux-Saga (takeLatest) takeLatest ensures that only the latest request is processed—if a new request is made, the previous one is canceled.",
	"Data - State - Structuring - RaceConditions - useTransition": "Use useTransition to mark updates as low-priority, allowing the UI to stay responsive.",
	"Data - State - Tools - Choose - localSmallSingle": "e.g. a value that won’t trigger a re-render. In these cases, using a ref is actually simpler and more efficient.",
	"Data - State - Tools - Choose - localSingle": "If only one component needs the state, keep it local (useState, useReducer).",
	"Data - State - Tools - Choose - localComplex": "Use useReducer for Complex State Logic. For state that involves multiple sub-values or actions, useReducer() is better than useState().",
	"Data - State - Tools - Choose - localMultiple": "If multiple components need the state, lift it up to a common parent.",
	"Data - State - Tools - Choose - globalSmall": "If state is needed globally, consider ReactContextAPI, Redux, or Zustand. Use ReactContextAPI for Global State (But With Caution) Best for: Auth, themes, user preferences. Avoid using for frequently changing state (causes re-renders in all consumers).",
	"Data - State - Tools - Choose - globalLarge": "For complex state that spans multiple components (e.g., shopping cart, user data), Redux or Zustand offers better scalability.",
  "Data - State - Tools - BuiltIn - State - useRef": "For example, imagine a counter that you just need to read and update internally without affecting the UI. A ref is perfect. No need for useState or fancy renders—just a stable box to store a changing value.",
  "Data - State - Tools - BuiltIn - State - useState": "The React useState Hook allows us to track state in a function component.",
  "Data - State - Tools - BuiltIn - State - useState - Types - TypeScript": "Use TypeScript generics to specify the state type. const [user, setUser] = useState<User>({ name: 'Alice', age: 25 });",
  "Data - State - Tools - BuiltIn - State - useState - async": "React's useState hook is asynchronous because React batches state updates for performance optimization. If useState were synchronous, every state change would cause an immediate re-render.",
  "Data - State - Tools - BuiltIn - State - useState - lazy": "In React, the useState hook allows for lazy initialization of state, which is particularly useful when the initial state is expensive to compute.",
  "Data - State - Tools - BuiltIn - State - useState - lazy - function": "Instead of passing the initial state directly, you can pass a function to useState. This function will be called only once during the initial render, and its return value will be used as the initial state. const [value, setValue] = useState(() => calculateExpensiveValue()); ",
	"Data - State - Tools - BuiltIn - State - useSyncState - React19": "React 19 introduces useSyncState, a simplified and intuitive way to manage component state.",
	"Data - State - Tools - BuiltIn - Reducer": "A reducer function takes the current state and an action with payload and computes it to a new state: (state, action) => newState.",
  "Data - State - Tools - BuiltIn - Reducer - useReducer": "The useReducer Hook is similar to the useState Hook. const [state, dispatch] = useReducer(< reducer >, < initialState >). ",
  "Data - State - Tools - BuiltIn - Reducer - useReducer - How - Reducer": "Under the hood, it follows a Redux-like pattern where state transitions are controlled by a reducer function.",
  "Data - State - Tools - BuiltIn - Reducer - useReducer - How - Steps - InitialState": "(1) React initializes state using the provided initialState.",
  "Data - State - Tools - BuiltIn - Reducer - useReducer - How - Steps - Dispatch": "(2) When dispatch(action) is called, React: Calls the reducer(state, action), passing the current state and action. The reducer returns a new state based on the action type.",
  "Data - State - Tools - BuiltIn - Reducer - useReducer - How - Steps - Rerender": "(3) React schedules a re-render if the new state is different from the old state (uses shallow comparison).",
  "Data - State - Tools - BuiltIn - Reducer - useReducer - How - Steps - Update": "(4) During re-renders, the state from useReducer persists, ensuring consistency.",
  "Data - State - Tools - BuiltIn - Reducer - useReducer - Types - State": "Defines the shape of the state. Define an interface for complex state",
  "Data - State - Tools - BuiltIn - Reducer - useReducer - Types - Action": "Specifies what actions the reducer can handle. Use a union type for strict control over actions",
  "Data - State - Tools - BuiltIn - Reducer - useReducer - Types - Reducer": "Accepts state and action and returns a new state. Ensure the return type matches the state",
  "Data - State - Tools - BuiltIn - Reducer - useReducer - useCases - Previous": "next state depends on the previous state.",
  "Data - State - Tools - BuiltIn - Reducer - useReducer - useCases - Complex": "Complex State Logic: When the state transitions involve multiple sub-values or depend on previous state.",
  "Data - State - Tools - BuiltIn - Reducer - useReducer - useCases - Centralized": "Centralized Logic: When you want to encapsulate state update logic in a single place (the reducer function).",
  "Data - State - Tools - BuiltIn - Reducer - useReducer - useCases - Predictable": "Predictable State Updates: When you need to enforce strict patterns for state updates (e.g., Redux-like patterns).",
  "Data - State - Tools - BuiltIn - Reducer - useReducer - useCases - Shared": "Shared State: When multiple components need to interact with the same state logic.",
  "Data - State - Tools - BuiltIn - Reducer - useReducer - vs useState": "This is the key difference between useState and useReducer: with useReducer, state is altered by passing messages rather than calling the updater function.",
	"Data - State - Tools - BuiltIn - ReactContextAPI": "React Context is a way to manage state preventing property drilling.",
	"Data - State - Tools - BuiltIn - ReactContextAPI - BuiltIn - React19": "Built into React, requiring no additional libraries.",
	"Data - State - Tools - BuiltIn - ReactContextAPI - howto - 1.CreateContext": "createContext lets you create a context that components can provide or read. type CartContextValues = { count: number; ... } }; export const CartContext = createContext<CartContextValues | null>(null); - https://medium.com/@samhodev/zustand-how-is-it-better-than-react-context-with-an-example-24dad4c65753",
	"Data - State - Tools - BuiltIn - ReactContextAPI - howto - 2.CreateProvider": "The CartContextProvider is a component that will wrap part of your component tree and provides the context value to all components within that tree. - export const CartContextProvider = ({children}: Props) => { return ( <CartContext.Provider value={{count, setCount, payTotal, subTotal, deliveryCost}}> {children}<CartContext.Provider>); } ",
  "Data - State - Tools - BuiltIn - ReactContextAPI - howto - 3.ApplyProvider": "Wraps our component tree with CartContextProviderto make the context available to child components. - export const ReactContextDemo = () => { return (<> <CartContextProvider>.../CartContextProvider></>);};",
  "Data - State - Tools - BuiltIn - ReactContextAPI - howto - 4.useContext": "To access the context value, use the useContext hook in our child component. It can be used together with the useState Hook to share state between deeply nested components more easily than with useState alone. - const cartContext = useContext(CartContext);",
  "Data - State - Tools - BuiltIn - ReactContextAPI - howto - 4.Consumer": "< MyContext.Consumer >  {value => /* render something based on the context value */} </ MyContext.Consumer >",
  "Data - State - Tools - BuiltIn - ReactContextAPI - Use - Theming": "Theme Management: Managing UI themes across an application.",
  "Data - State - Tools - BuiltIn - ReactContextAPI - Use - Locale": "Locale Management: Handling localization and language settings.",
  "Data - State - Tools - BuiltIn - ReactContextAPI - Use - Authentication": "Authentication State: Providing user authentication status throughout your app.",
  "Data - State - Tools - BuiltIn - ReactContextAPI - Use - Routing": "Routing: Most routing solutions use context internally to hold the current route. This is how every link “knows” whether it’s active or not. If you build your own router, you might want to do it too.",
  "Data - State - Tools - BuiltIn - ReactContextAPI - Use - State": "Managing state: As your app grows, you might end up with a lot of state closer to the top of your app. Many distant components below may want to change it. It is common to use a reducer together with context to manage complex state and pass it down to distant components without too much hassle.",
  "Data - State - Tools - BuiltIn - ReactContextAPI - Pitfalls": "Large Applications with Complex State Management Needs:, High-Frequency State Updates, Cross-Cutting Concerns, Frequent Debugging Issues",
	"Data - State - Tools - BuiltIn - ReactContextAPI - Pitfalls - NoAsync": "Context is for prop drilling avoidance without built-in async handling.",
  "Data - State - Tools - BuiltIn - ReactContextAPI - Pitfalls - Complex": "ReactContextAPI is not inherently designed to handle complex state management tasks such as actions, reducers, or middleware. This limitation becomes apparent as your application grows and your state management needs become more complex.",
  "Data - State - Tools - BuiltIn - ReactContextAPI - Pitfalls - ReRenders": "every consumer of the context re-renders when the context value changes, which can lead to performance problems.",
  "Data - State - Tools - BuiltIn - ReactContextAPI - Pitfalls - ReRenders - Fix - Split": "Split Contexts by Concern (Minimize Unnecessary Re-renders) Instead of one big context, split context by separate concerns so consumers only re-render when needed.",
  "Data - State - Tools - BuiltIn - ReactContextAPI - Pitfalls - ReRenders - Fix - Composition": "Use Composition Instead of Deep Nesting. Instead of deeply nesting contexts, group them into a single wrapper component.",
  "Data - State - Tools - BuiltIn - ReactContextAPI - Pitfalls - CI - Code": "Using ReactContextAPI for state management can introduce a lot of boilerplate code. You need to set up the provider, create context objects, and ensure proper usage throughout the application. Every new context requires similar setup, which can quickly add up and clutter your codebase.",
  "Data - State - Tools - BuiltIn - ReactContextAPI - Pitfalls - CI - Debug": "When state is scattered across various contexts, debugging becomes more complex. Understanding the flow of state and tracking down where and why certain updates occur can be challenging. Example: Imagine having multiple contexts like UserContext, ThemeContext, and SettingsContext. Debugging why a component re-rendered unexpectedly becomes a complex task as you need to check updates across all these contexts.",
  "Data - State - Tools - BuiltIn - ReactContextAPI - Pitfalls - CI - Testing": "Testing components that rely on React Context can be cumbersome. You often need to wrap your components with context providers, adding an extra layer of complexity to your tests.",
	"Data - State - Tools - BuiltIn - ReactContextAPI - Pitfalls - CI - Performance": "ReactContextAPI can lead to performance bottlenecks, especially in large applications. When you update the context, every component that consumes that context will re-render, even if the part of the state they use hasn’t changed. This can significantly impact performance.",
	"Data - State - Tools - Libs - Flux - 2014": "Flux uses a unidirectional data flow pattern to solve state management complexity. Remember it is not a framework – rather it's more of a pattern that targets to solve the state management issue.",
  "Data - State - Tools - Libs - Redux - 2015": "Centralizes state management using a pub/sub pattern internally",
  "Data - State - Tools - Libs - Redux - Features - Performance": "Redux makes React app rerendering and slowing down performance.",
  "Data - State - Tools - Libs - Redux - Features - Immutability": "Redux expects state updates to be immutable (no direct modification).",
  "Data - State - Tools - Libs - Redux - Flow": "Producer → Action → Middleware → Reducer → Store Update → Notify Subscribers → UI Re-render.",
  "Data - State - Tools - Libs - Redux - Parts - Producer": "",
	"Data - State - Tools - Libs - Redux - Parts - Producer - Action": "An action is a plain object that describes an event in the app (e.g., { type: 'ADD_TODO', payload: 'Learn Redux' }).",
  "Data - State - Tools - Libs - Redux - Parts - Producer - Action - dispatch": "Action: An action is dispatched, representing a change or event in the application. store.dispatch({ type: 'ADD_TODO', text: 'Learn Redux' });",
  "Data - State - Tools - Libs - Redux - Parts - Middleware": "Middleware like Redux Thunk or Redux Saga dispatches actions asynchronously (e.g., after API calls) to reducers.",
  "Data - State - Tools - Libs - Redux - Parts - Middleware - Actions - sync": "If the action is synchronous, it passes through as usual.",
  "Data - State - Tools - Libs - Redux - Parts - Middleware - Actions - async": "If the action is asynchronous, the middleware handles it before passing the final result to the reducer.",
  "Data - State - Tools - Libs - Redux - Parts - Middleware - Tools - redux-thunk": "A middleware that allows writing action creators that return functions (for async logic) instead of plain actions.",
  "Data - State - Tools - Libs - Redux - Parts - Middleware - Tools - redux-saga": "Redux Saga uses generator functions for side effects, while Thunk uses plain functions. Saga is better for complex async flows.",
  "Data - State - Tools - Libs - Redux - Parts - Store": "The store holds the entire state tree of the application.",
  "Data - State - Tools - Libs - Redux - Parts - Store - Normalizr": "Structuring state like a database (using ids and references) to avoid duplication (e.g., with normalizr).",
	"Data - State - Tools - Libs - Redux - Parts - Store - Reducer": "Take the previous state and an action, and return the new state.",
	"Data - State - Tools - Libs - Redux - Parts - Store - Reducer - Pure": "Pure functions (no side effects). Same input always produces the same output. Guarantee deterministic state management.",
  "Data - State - Tools - Libs - Redux - Parts - Store - Reducer - Patterns - Combine": "const rootReducer = combineReducers({ user: userReducer, posts: postsReducer });",
  "Data - State - Tools - Libs - Redux - Parts - Store - Reducer - Patterns - Normalizing": "Normalizing State Shape",
  "Data - State - Tools - Libs - Redux - Parts - Store - Reducer - Patterns - Handloading": "Handloading Actions",
  "Data - State - Tools - Libs - Redux - Parts - Store - applyMiddleware": "It enhances the store with middleware (e.g., applyMiddleware(thunk, logger)).",
	"Data - State - Tools - Libs - Redux - Parts - Consumer": "Components subscribe to the store and react to state changes by re-rendering, ensuring the UI reflects the current state.",
  "Data - State - Tools - Libs - Redux - Parts - Consumer - Subscription": "When an action is dispatched and processed by the reducers, the store updates and notifies all components subscribed to it.",
  "Data - State - Tools - Libs - Redux - Parts - Consumer - Subscription - ClassComponents - connect": "",
  "Data - State - Tools - Libs - Redux - Parts - Consumer - Subscription - ClassComponents - connect - mapStateToProps": "",
  "Data - State - Tools - Libs - Redux - Parts - Consumer - Subscription - FunctionalComponents - Selectors": "Functions that extract specific pieces of state from the store.",
  "Data - State - Tools - Libs - Redux - Parts - Consumer - Subscription - FunctionalComponents - Selectors - FunctionalComponents": "for FunctionalComponents",
  "Data - State - Tools - Libs - Redux - Parts - Consumer - Subscription - FunctionalComponents - Selectors - useSelector": "Allows functional components to extract data from the Redux store. const data = useSelector(selectorFunction);",
  "Data - State - Tools - Libs - Redux - Parts - Consumer - Subscription - FunctionalComponents - Selectors - selectorFunction": "selectorFunction takes the entire Redux state and returns the needed part.",
  "Data - State - Tools - Libs - Redux - Parts - Consumer - Subscription - FunctionalComponents - Selectors - Optimize - ==": "By default, useSelector does a shallow comparison (===) of the selected value.",
  "Data - State - Tools - Libs - Redux - Parts - Consumer - Subscription - FunctionalComponents - Selectors - Optimize - ReturnPrimitive": "Return Primitive Values",
  "Data - State - Tools - Libs - Redux - Parts - Consumer - Subscription - FunctionalComponents - Selectors - Comparison - Memoized": "Use Memoized Selectors with reselect",
  "Data - State - Tools - Libs - Redux - Parts - Consumer - Subscription - FunctionalComponents - Selectors - Optimize - Custom": "Custom Equality Comparison. Override the default shallow comparison",
  "Data - State - Tools - Libs - Redux - Parts - Consumer - Unsubscription": "Always unsubscribe to prevent memory leaks: unsubscribe();",
  "Data - State - Tools - Libs - Redux - Tools - RTK": "Redux Toolkit simplifies Redux setup with utilities like createSlice, createAsyncThunk, and configureStore to reduce boilerplate.",
  "Data - State - Tools - Libs - Redux - Tools - RTK - createSlice": "A function that auto-generates action creators and reducers (reducing boilerplate).",
  "Data - State - Tools - Libs - Redux - Tools - RTK - createAsyncThunk": "Handles async logic by dispatching pending/fulfilled/rejected actions automatically.",
  "Data - State - Tools - Libs - Redux - Tools - RTK - configureStore": "A wrapper around createStore that sets up Redux DevTools and middleware by default.",
  "Data - State - Tools - Libs - Redux - Tools - ReduxDevTools": "A browser extension for debugging Redux apps (time-travel debugging, action logging).",
  "Data - State - Tools - Libs - Mobx - 2015": "A library that makes state management simple and scalable through reactive state management.",
  "Data - State - Tools - Libs - Mobx - observable": "Mobx applies concepts from Functional Reactive Programming and Object-Oriented design to automatically track changes to state and propagate updates. Mobx lets you create individual 'store' classes and mark specific fields as 'observable', then mark React components and other logic as 'observers'. You can directly modify those observables fields in your code, and Mox will transparently update any observer code that depends on those fields.",
  "Data - State - Tools - Libs - Mobx - atoms": " Achieving this is pretty simple by using atoms, which is the class that MobX uses internally for all observable data types. Atoms can be used to signal to MobX that some observable data source has been observed or changed, and MobX will let the atom know when it's being used and when it's not.",
	"Data - State - Tools - Libs - EasyPeasy - 2018": "Easy Peasy is an abstraction of Redux, providing a reimagined API that focuses on developer experience. It allows you to quickly and easily manage your state, whilst leveraging the strong architectural guarantees and extensive eco-system that Redux has to offer. https://easy-peasy.vercel.app/",
  "Data - State - Tools - Libs - XState - 2018": "statemachine",
  "Data - State - Tools - Libs - ReactTracked - 2019": "",
  "Data - State - Tools - Libs - Zustand - 2019": "Zustand is a single store similar to Redux. A small, fast, and scalable state management library that provides a simpler API compared to Redux. https://medium.com/@samhodev/zustand-how-is-it-better-than-react-context-with-an-example-24dad4c65753",
	"Data - State - Tools - Libs - Zustand - builtOn": "Zustand uses React's custom hook-based approach to handle Component state distribution.",
  "Data - State - Tools - Libs - Zustand - howto - 1. Create Store.": "A 'store' in Zustand holds your application’s state. We create a store using the create function provided by Zustand, and define the cart state and actions. - interface CountState { ... }; export const useCartStore = create<CountState>((set) => ({ ... }));",
  "Data - State - Tools - Libs - Zustand - howto - 2. Use Store.": "We can use the Zustand store in our components by calling the custom hook we exported from CartStore.tsx. We can also prevent unnecessary re-render using useShallow hook provided by Zustand. The component re-renders only when state.deliveryCost change  const { deliveryCost } = useCartStore( useShallow((state) => ({ deliveryCost: state.deliveryCost })) );",
	"Data - State - Tools - Libs - Zustand - Use - State": "Use Zustand if you need simple, high-performance state management with minimal setup and are dealing with mostly global state",
  "Data - State - Tools - Libs - Zustand - Use - Performance": "While React Context provide a simple native solution of passing states to child components, Zustand can offer better performance in some scenarios, such as the above scenario where components only re-renders to the specific pieces of state they use.",
  "Data - State - Tools - Libs - Zustand - Use - Hooks": "works well with React’s hooks.",
  "Data - State - Tools - Libs - Zustand - Use - SSR": "smooth SSR integration.",
	"Data - State - Tools - Libs - Recoil - 2020": "A state management library from Facebook that offers fine-grained state management with a simpler API.",
  "Data - State - Tools - Libs - Recoil - atoms": "Atoms contain the source of truth for our application state.",
  "Data - State - Tools - Libs - Recoil - builtOn": "Using React's internal Context API, Recoil internally uses this API to propagate state updates to the subscribed Components.",
	"Data - State - Tools - Libs - Jotai - 2020": "Jotai is a minimalistic state management library for React that focuses on atomic state",
	"Data - State - Tools - Libs - Jotai - Features - atoms": "Jotai consists of primitive atoms that can be composed together. It allows you to manage state in small, isolated pieces called atoms.",
	"Data - State - Tools - Libs - Jotai - Features - fine-grained": "When your application benefits from fine-grained control over state and you prefer managing state in small, isolated pieces.",
	"Data - State - Tools - Libs - Jotai - Usage - dynamic": "Use Jotai if you prefer atomic state management, need fine-grained control over state, or are dealing with scoped or dynamic state requirements.",
  "Data - State - Tools - Libs - NanoStores - 2021": " ",
  "Data - State - Tools - Libs - Valtio - 2023": "Valtio is yet another library for global state. Unlike Zustand and Jotai, it's based on the mutating update model. It's primarily for module states like Zustand. It utilizes proxies to get an immutable snapshot, which is required to integrate with React.",
  "Data - State - Tools - Libs - Nuqs - 2024": " ",
  "Data - State - Tools - Libs - Zag": "statemachine",
  "Data - State - Tools - Custom - EventBus": "https://medium.com/@ignatovich.dm/event-driven-react-with-the-observer-pattern-a-clean-alternative-to-prop-drilling-a472aae7a74d",
	"Data - Inputs - Forms": "The built-in browser < form > component lets you create interactive controls for submitting information.",
	"Data - Inputs - Forms - Components - Selection": ".",
	"Data - Inputs - Forms - Components - Selection - NoValidation": "Use FormData when you don’t need real-time validation or dynamic UI updates.",
	"Data - Inputs - Forms - Components - Selection - FileUploads": "Use FormData for file uploads.",
	"Data - Inputs - Forms - Components - Selection - Validation": "Use Controlled Forms (React State) When you need Real-Time Validation & Feedback",
	"Data - Inputs - Forms - Components - Selection - Dynamic": "Use Controlled Forms (React State) When you need Dynamic Form Behavior",
	"Data - Inputs - Forms - Components - Selection - FormLibraries": "Using Form Libraries (React Hook Form, Formik) These libraries rely on controlled components for validation and submission.",
	"Data - Inputs - Forms - Components - Types": ".",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - Fields": "DOM via ref manages the inputRefs State.",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - Fields - Features - re-render": "No re-renders on each stroke.",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - Fields - Inputs - Code - 1. Field": "< input type='text' ref={inputRef} />",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - Fields - Inputs - Code - 2. Changes": "-",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - Fields - Inputs - Code - 3. formRef": "const inputRef = useRef(null);",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - Fields - Inputs - Code - 4. Form": "< form onSubmit={handleSubmit} > ... </ form >",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - Fields - Inputs - Code - 5. Submit": "const handleSubmit = (event) => { event.preventDefault(); const formValues = { name: nameRef.current.value email: emailRef.current.value } }",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - Fields - form": "Using < form > + Optionally FormDataAPI.",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - Fields - Inputs": "The DOM handles the input state instead of React.",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - Fields - Inputs - Reusable": "Create reusable input components to keep code clean.",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - Fields - Inputs - Rerender": "No re-renders on input changes (better performance for some cases).",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - Fields - Inputs - ref": "Use refs to access the form values.",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - Fields - Validation - cumbersome": "More cumbersome since the form data isn't managed within the component's state.",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - Fields - Submission": "When submitting data, follow these best practices: ✅ Prevent default behavior (e.preventDefault()). ✅ Show loading state to indicate the request is in progress. ✅ Use async/await for API calls.",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - FormData": "With FormData, you don't need refs to get the values of uncontrolled forms. Instead, you can just read the form values directly off event.target:",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - FormData - Inputs - Code - 1. Field": "-",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - FormData - Inputs - Code - 2. Change": "-",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - FormData - Inputs - Code - 3. formRef": "-",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - FormData - Inputs - Code - 4. Form": "-",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - FormData - Inputs - Code - 5. Submit": "const handleSubmit = (event) => { event.preventDefault(); const formData = new FormData(event.target) const formValues = { name: formData.get('name') email: formData.get('email) } ) }",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - FormData+Refs": "DOM via ref manages the formRef State.",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - FormData+Refs - Inputs - Code - 1. Field": "-",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - FormData+Refs - Inputs - Code - 2. Change": "-",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - FormData+Refs - Inputs - Code - 3. formRef": "const formRef = useRef(); ",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - FormData+Refs - Inputs - Code - 4. Form": "< form ref={formRef} onSubmit={handleSubmit} > ... </ form >",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - FormData+Refs - Inputs - Code - 5. Submit": "const handleSubmit = (event) => { event.preventDefault(); const formData = new FormData(formRef.current); fetch (... body: formData ... ) }",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - FormData+Refs - Inputs - FormDataAPI - ClientComponents": "Can be used because they run in a browser environment.",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - FormData+Refs - Inputs - FormDataAPI - ServerComponents": "Cannot be used because they run in a browser environment.",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - FormData+Refs - Inputs - FormDataAPI - ServerActions": "Handles form submission securely on the server.",
	"Data - Inputs - Forms - Components - Types - Uncontrolled - FormData+Refs - Reset": "On submit resets by default.",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields": "React Manages the State.",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Benefits - Validation": "Immediate validation of inputs.",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Inputs - Code - 1. Field": "<input type='text' value={value} onChange={handleChange} /> const handleChange = (event) => { setValue(event.target.value); };",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Inputs - Code - 2. Change": "const handleChange = (e) => { setValue(e.target.value); };",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Inputs - Code - 3. useState": "const [value, setValue] = useState('');",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Inputs - Code - 4. Form": "-",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Inputs - Code - 5. Submit": "-",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Usage - boilerplate": "Overcomplicates the code.",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Usage - Validation": "The most obvious cases are when you need more rigorous validation or formatting.",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Usage - formatting": "The most obvious cases are when you need more rigorous validation or formatting.",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Usage - data": "The other obvious reason to control a form is if that data is needed elsewhere in your application.",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Inputs": "Controlled forms store each input’s value in React state, and then set the value of each input on each re-render from that state.",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Inputs - Rerender": "Input changes trigger state updates, causing a re-render.",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Inputs - FormData": "Form values are already stored in React state.",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Validation": "The most obvious cases for controlled forms are when you need more rigorous validation or formatting.",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Validation - Timing": "Validate early.",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Validation - Timing - onChange": ".",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Validation - Timing - onBlur": ".",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Validation - Timing - onSubmit": ".",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Validation - libraries - Zod": ".",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Validation - libraries - Formik": ".",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Validation - libraries - Yup": "form validation.",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Validation - libraries - ReactHookForm": ".",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Submission - useActionState - renamed": "React 19 Canary. useActionState allows updating state based on the result of a form action.",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Submission - useFormState": "React 19. Formerly known as useActionState. This hook provides an easy way to track the status of form submissions.",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Submission - useFormStatus": "React 19. useFormStatus is a Hook that gives you status information of the last form submission.",
	"Data - Inputs - Forms - Components - Types - Controlled - Fields - Submission - useOptimistic": "React 19. Show the final state optimistically while an async request is underway.",
  "Data - Inputs - Forms - Components - Types - Controlled - Fields - Submission - ServerActions": "React 19. You can pass a ServerAction to a Form to automatically submit the form to the server. They can be replacement for (unexisting) events in ServerComponents.",
	"Data - Inputs - Forms - Components - Types - Controlled - FormData": "React Manages the State.",
	"Data - Inputs - Forms - Components - Types - Controlled - FormData - Inputs - Code - 1. Field": "< input type='text' name='username' value={formData.username} onChange={handleChange} />",
	"Data - Inputs - Forms - Components - Types - Controlled - FormData - Inputs - Code - 2. Change": "const handleChange = (e) => { const { name, value, files } = e.target; setFormData(prev => ({ ...prev, [name]: files ? files[0] : value })); };",
	"Data - Inputs - Forms - Components - Types - Controlled - FormData - Inputs - Code - 3. useState": "const [formData, setFormData] = useState({ username: '', email: '', avatar: null });",
	"Data - Inputs - Forms - Components - Types - Controlled - FormData - Inputs - Code - 4. Form": "< form onSubmit={handleSubmit} > ... </ form >",
	"Data - Inputs - Forms - Components - Types - Controlled - FormData - Inputs - Code - 5. Submit": "const handleSubmit = (e) => { e.preventDefault(); build const data = new FormData(); and submit in body }",
	"Data - Inputs - Forms - Components - Types - Controlled - FormData - Usage - multipart": "When you need to submit multipart/form-data (e.g., file uploads with other fields)",
	"Data - Inputs - Forms - Components - Types - Controlled - FormData - Usage - APIs": "When working with APIs that expect FormData",
	"Data - Inputs - DataFetching - ClientComponents - tip - minimize": "Only data to user events should be fetched at ClientComponents.",
	"Data - Inputs - DataFetching - ClientComponents - tip - caching": "Cache data fetched from APIs or expensive computations to prevent unnecessary re-fetching or re-computation.",
  "Data - Inputs - DataFetching - ClientComponents - Suspense": "Suspense for data fetching is a more declarative approach that leverages React's Suspense component to handle loading states and errors. It allows you to 'suspend' rendering until the data is ready.",
	"Data - Inputs - DataFetching - ClientComponents - Hooks - useEffect": "Avoid since useEffect() has pitfalls for DataFetching.",
	"Data - Inputs - DataFetching - ClientComponents - Hooks - useSyncExternalStore - React18": "Lets you subscribe to an external store. const snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)",
	"Data - Inputs - DataFetching - ClientComponents - Hooks - useSyncExternalStore - Subscribe": "subscribe: function to register a callback that is called whenever the store changes.",
	"Data - Inputs - DataFetching - ClientComponents - Hooks - useSyncExternalStore - getSnapshot": "getSnapshot: function that returns the current value of the store.",
	"Data - Inputs - DataFetching - ClientComponents - Hooks - useSyncExternalStore - getServerSnapshot": "getServerSnapshot: function that returns the snapshot used during server rendering.",
	"Data - Inputs - DataFetching - ClientComponents - Hooks - useSyncExternalStore - UseCase": "Integrating with non-React state management (Redux, global variables, etc.).",
	"Data - Inputs - DataFetching - ClientComponents - Hooks - useSyncExternalStore - SSR": "Works with server-side rendering (SSR) if a server snapshot is provided.",
	"Data - Inputs - DataFetching - ClientComponents - Hooks - Libs - useQuery": "from libraries like React Query, Apollo Client, or URQL. We can cache it, invalidate it, and fetch it anew.",
  "Data - Inputs - DataFetching - ClientComponents - Hooks - Libs - useQuery - TanStackQuery": "ReactQuery (TanStack Query).",
  "Data - Inputs - DataFetching - ClientComponents - Hooks - Libs - useQuery - SSR/SSG": "Libraries like React Query support hydration for server-rendered data.",
  "Data - Inputs - DataFetching - ClientComponents - Hooks - Libs - SWR": "React Hooks for data fetching. Standing for “stale-while-revalidate,” SWR is a strategy and library that makes fetching, caching, and updating data in your React applications a breeze. SWR (by Vercel) fetches data once and revalidates only when needed.",
  "Data - Inputs - DataFetching - ClientComponents - libs - axios": ".",
  "Data - Inputs - DataFetching - ClientComponents - libs - Alova": "https://javascript.plainenglish.io/say-goodbye-to-axios-in-2025-04fc0772c01e",
  "Data - Inputs - DataFetching - ClientComponents - libs - tRPC": ".",
  "Data - Inputs - DataFetching - ClientComponents - ServerFunctions": "Client Components can import Server Functions.",
	"Data - Inputs - DataFetching - ServerComponents": "In a React Server Component, data fetching is straightforward. Since these components allow you to execute code on the server, you can directly access the data layer (e.g. database) from the UI: ",
  "Data - Inputs - DataFetching - ServerComponents - preferred": "whenever possible, recommend you to just fetch data in Server Components and to pass it down to Client Components.",
	"Data - Inputs - DataFetching - ServerFunctions - ocassional": "Data fetching with Server Actions comes with drawbacks too: Server Actions perform HTTP POST requests Server Actions run in sequence",
  "Data - Inputs - DataFetching - ServerFunctions - drawbacks": "Using a Server Action for data fetching in a Client Component only happens occasionally",

	"View": "SECTION",
	"View - JSX": "Returned by Components.",
  "View - JSX - elements": "React elements are immutable. Once you create an element, you can’t change its children or attributes.",
  "View - JSX - React.createElement()": "Babel compiles JSX down to React.createElement() calls. A component's render output is normally written in JSX syntax, which is then converted to React.createElement() calls as the JS is compiled and prepared for deployment. createElement returns React elements, which are plain JS objects that describe the intended structure of the UI.",
  "View - JSX - owner": "Component wrapping the JSX",
  "View - JSX - parent": "Nested elements within the JSX.",
	"View - JSX - children": "When you nest content inside a JSX tag, the parent component will receive that content in a prop called children.",
  "View - JSX - expressions": "You can put any valid JavaScript expression inside the curly braces in JSX.",
  "View - JSX - return - type - React.FC<Props>": "Functional component with props",
  "View - JSX - return - type - JSX.Element": "Functional component without props - Inline function returning JSX",
  "View - JSX - return - type - generics": "For HOCs that return a wrapped component, use generics.",
	"View - JSX - Conditional": ".",
	"View - JSX - Conditional - if - short-circuit": "< div >{count && < h1 >Messages: {count}< /h1 >}< /div >.",
	"View - JSX - Conditional - if - ternary": "< div >{count ? < h1 >Messages: {count}< /h1 > : null}< /div >. Preferred",
	"View - JSX - Built-in - Common": "All built-in browser components, such as <div>, support some common props and events. https://beta.reactjs.org/reference/react-dom/components/common",
	"View - JSX - Built-in - < Fragment >": "< Fragment >, often used via < >...< /> syntax, lets you group elements without a wrapper node. This is particularly useful when you need to return multiple elements from a component's render method, but you don't want to introduce unnecessary DOM elements that could affect the layout or styles of your application.",
  "View - JSX - Built-in - < Profiler >": "< Profiler > lets you measure rendering performance of a React tree programmatically.",
  "View - JSX - Built-in - < StrictMode >": "< StrictMode > lets you find common bugs in your components early during development. < StrictMode > < App /> < /StrictMode >",
  "View - JSX - Built-in - < Suspense >": "< Suspense > lets you display a fallback until its children have finished loading. < Suspense fallback={< Loading />}> < SomeComponent /> < /Suspense >",
  "View - JSX - Built-in - < input >": "The built-in browser < input > component lets you render different kinds of form inputs. < input />",
  "View - JSX - Built-in - < option >": "The built-in browser < option > component lets you render an option inside a <select> box. < select >  < option value='someOption' >Some option< /option > < option value='otherOption' >Other option< /option > < /select >",
  "View - JSX - Built-in - < progress >": "The built-in browser < progress > component lets you render a progress indicator. < progress value={0.5} />",
  "View - JSX - Built-in - < select >": "The built-in browser < select > component lets you render a select box with options. < select>  < option value='someOption'>Some option</option> <option value='otherOption' >Other option< /option > < /select >",
  "View - JSX - Built-in - < textarea >": "The built-in browser < textarea > component lets you render a multiline text input. < textarea />",
	"View - JSX - Built-in - lists - keys - unique": "Keys must be unique among siblings. However, it’s okay to use the same keys for JSX nodes in different arrays.",
	"View - JSX - Built-in - lists - keys - id": " Use a stable ID based on the data.",
	"View - JSX - Built-in - lists - keys - index - default": "React will use if you don’t specify a key at all.",
	"View - JSX - Built-in - lists - keys - index - Drawbacks - order": "But the order in which you render items will change over time if an item is inserted, deleted, or if the array gets reordered. Index as a key often leads to subtle and confusing bugs. Re-render all items unnecessarily when the list changes. Cause UI issues, like incorrect animations or state loss in interactive components.",
	"View - JSX - Built-in - lists - keys - index - Drawbacks - bugs": "Index as a key often leads to subtle and confusing bugs. Re-render all items unnecessarily when the list changes. Cause UI issues, like incorrect animations or state loss in interactive components.",
	"View - JSX - Built-in - lists - keys - generated": "Similarly, do not generate keys on the fly, e.g. with key={Math.random()}. This will cause keys to never match up between renders, leading to all your components and DOM being recreated every time. Not only is this slow, but it will also lose any user input inside the list items.",
	"View - JSX - Built-in - lists - filter": ".",
	"View - JSX - Built-in - lists - map": ".",
  "View - JSX - Portals": "A React Portal allows you to render a component outside the normal DOM hierarchy while keeping it in the React tree. Can use Suspense.",
  "View - JSX - Portals - benefits - CSS": "Avoid CSS conflicts (e.g., overflow: hidden, z-index).",
  "View - JSX - Portals - benefits - Escape": "Escape parent styles (like position: relative).",
  "View - JSX - Portals - benefits - Modals": "Great for modals, tooltips, dropdowns, and pop-ups.",
  "View - Styling - className": "",
  "View - Styling - className - conditional": "classNames.push('box-error'); ... <div className={classNames.join(' ')}>",
	"View - Rendering": "",
	"View - Rendering - Initialization - Steps - VirtualDOMs": "A lightweight representation of the entire component tree.",
  "View - Rendering - Initialization - Steps - VirtualDOMs - Goal": "The Virtual DOM allows React to efficiently manage and update the UI. it will become a lot faster.",
  "View - Rendering - Initialization - Steps - VirtualDOMs - 2Instances": "React maintains two versions of the Virtual DOM: Work-In-Progress (WIP) Tree and Current Fiber Tree",
  "View - Rendering - Initialization - Steps - VirtualDOMs - 2Instances - WIP": "Work-In-Progress (WIP) Tree is the new version of the VirtualDOM React is currently building before committing updates.",
  "View - Rendering - Initialization - Steps - VirtualDOMs - 2Instances - Current": "Current Fiber Tree → Represents the last committed UI (what’s currently displayed on the screen).",
	"View - Rendering - Initialization - Steps - VirtualDOMs - Creation": "React creates the Virtual DOM for the first time when a component is initially rendered.",
	"View - Rendering - Initialization - Steps - VirtualDOMs - Creation - createRoot()": "When you call ReactDOM.createRoot().render(<App />), React creates the Virtual DOM",
	"View - Rendering - Initialization - Steps - VirtualDOMs - Creation - responsible": "React is solely responsible for the render phase.",
	"View - Rendering - Initialization - Steps - VirtualDOMs - Features - Interaction": "React itself never interacts with the DOM.",
	"View - Rendering - Initialization - Steps - VirtualDOMs - Features - PlatformAgnostic": "React was designed to be platform-agnostic.",
	"View - Rendering - Initialization - Steps - VirtualDOMs - Features - Hierarchy": "React applications use components that form a hierarchical structure to build applications. Components can be functional or class-based and represent reusable UI elements.",
	"View - Rendering - Initialization - Steps - VirtualDOMs - Features - Hierarchy - Performance": "Separating in components helps performance because re-renders only a component.",
	"View - Rendering - Initialization - Steps - VirtualDOMs - NoVirtualDOM - Libs - Preact": "Preact X is what we always wanted Preact to be: A tiny, fast and feature-packed library. And speaking of size, you'll be happy to hear that all the new features and improved rendering fit into the same size footprint as 8.x!",
	"View - Rendering - Initialization - Steps - VirtualDOMs - NoVirtualDOM - Libs - Preact vs React": "The main difference between Preact and React is that Preact does not implement a synthetic event system for size and performance reasons. Preact uses the browser's standard addEventListener to register event handlers, which means event naming and behavior works the same in Preact as it does in plain JavaScript / DOM.",
	"View - Rendering - Initialization - Steps - Renderer": "React Renderers: react-dom, react-native, react-three-fiber, ink",
	"View - Rendering - Initialization - Steps - Mounting": "Generates the real DOM elements based on this Virtual DOM.",
	"View - Rendering - Initialization - Steps - Mounting - DOMElements": "When a React application is first loaded, React constructs the initial Virtual DOM tree based on the component hierarchy.",
	"View - Rendering - Initialization - Steps - Mounting - DOMElements - Browser": "Commits the actual DOM update by injecting elements into the browser.",
	"View - Rendering - Initialization - Steps - Mounting - Calls": "Rendering in React essentially means invoking the functions of those components.",
  "View - Rendering - Initialization - Steps - Mounting - Calls - ClassComponents - constructor()": "The constructor runs before your class component mounts (gets added to the screen). Typically, a constructor is only used for two purposes in React. It lets you declare state and bind your class methods to the class instance:",
  "View - Rendering - Initialization - Steps - Mounting - Calls - ClassComponents - getDerivedStateFromProps()": "During the mounting phase, getDerivedStateFromProps() is called after the constructor and before render(). This method is called for every render cycle and provides an opportunity to update the component's state based on changes in props before the initial render.",
	"View - Rendering - Initialization - Steps - Mounting - Calls - ClassComponents - render()": "Each component’s render method is called to generate the corresponding Virtual DOM representation.",
  "View - Rendering - Initialization - Steps - Mounting - Calls - ClassComponents - componentWillMount()": "Deprecated. ",
  "View - Rendering - Initialization - Steps - Mounting - Calls - ClassComponents - componentDidMount()": "called once the component has been mounted into the DOM.",
  "View - Rendering - Initialization - Steps - Mounting - Calls - ClassComponents - componentDidMount() - used": "typically used to set up any necessary event listeners or timers, perform any necessary API calls or data fetching, and perform other initialization tasks that require access to the browser's DOM API.",
  "View - Rendering - Initialization - Steps - Mounting - Calls - ClassComponents - componentDidMount() - once": "called only once.",
  "View - Rendering - Initialization - Steps - Mounting - Calls - ClassComponents - componentDidMount() - rerender": "From this method, any state change triggers a re-render of the component.",
	"View - Rendering - Initialization - Steps - Mounting - Calls - FunctionalComponents - hooks": "useState / useReducer / useContext / useMemo / useCallback / useRef / useTransition / useDeferredValue / custom",
	"View - Rendering - Initialization - Steps - Mounting - Calls - FunctionalComponents - hooks - order": "React executes hooks in the order they appear in the component's function body.",
	"View - Rendering - Initialization - Steps - Reconciler": "React Reconciler is renderer-agnostic, enabling React to work on multiple platforms.",
	"View - Rendering - Initialization - Steps - Reconciler - Reconcilers - StackReconciler - <React16": ".",
	"View - Rendering - Initialization - Steps - Reconciler - Reconcilers - FiberReconciler - React16": "Builds the initial fiber tree (React Fiber is the underlying reconciliation engine).",
	"View - Rerendering": "Any screen update in a React app happens in 4 steps: Trigger, Update, Reconciliation, Commit. https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/ ",
	"View - Rerendering - Triggering": "Caching the results of expensive computations or function calls.",
  "View - Rerendering - Triggering - NoTriggers - PureComponents": "For ClassComponents, To skip re-rendering for same props and state, extend PureComponent instead of Component",
  "View - Rerendering - Triggering - NoTriggers - useRef": "No Re-renders: Changing ref.current is invisible to React’s rendering mechanism.",
  "View - Rerendering - Triggering - NoTriggers - useId": ".",
  "View - Rerendering - Triggering - NoTriggers - useEffect": ".",
  "View - Rerendering - Triggering - NoTriggers - useLayoutEffect": ".",
	"View - Rerendering - Triggering - NoTriggers - memoization": "Caching the results of expensive computations or function calls.",
  "View - Rerendering - Triggering - NoTriggers - memoization - commands - React.memo - props": "HOC that memoizes, to prevent re-rendering, entire components until its props change.",
  "View - Rerendering - Triggering - NoTriggers - memoization - commands - React.memo - parent": "By default, React re-renders a component whenever its parent re-renders, even if props haven't changed.",
  "View - Rerendering - Triggering - NoTriggers - memoization - commands - React.memo - Use - ComplexComponents": "Complex Components: Use React.memo for components with expensive rendering logic.",
  "View - Rerendering - Triggering - NoTriggers - memoization - commands - React.memo - Use - StableProps": "Stable Props: Use React.memo when the component's props change infrequently.",
  "View - Rerendering - Triggering - NoTriggers - memoization - commands - React.memo - Use - CallbackProps": "Callback Props: Use React.memo with useCallback to memoize callback functions.",
  "View - Rerendering - Triggering - NoTriggers - memoization - commands - React.memo - noUse - FrequentlyChangingProps": "If a component's props change frequently, React.memo will not prevent re-renders because the component will re-render every time its props change. In this case, the overhead of comparing props (using a shallow comparison or a custom comparison function) can actually make performance worse.",
  "View - Rerendering - Triggering - NoTriggers - memoization - commands - React.memo - noUse - SimpleRenderingLogic": "If a component has very simple rendering logic and re-renders quickly, the cost of re-rendering might be lower than the cost of performing the prop comparison in React.memo.",
  "View - Rerendering - Triggering - NoTriggers - memoization - commands - React.memo - noUse - DeeplyNestedProps": "If a component receives deeply nested props (e.g., objects or arrays), React.memo's default shallow comparison will not detect changes within the nested structures. This can lead to incorrect behavior where the component does not re-render when it should.",
  "View - Rerendering - Triggering - NoTriggers - memoization - commands - React.memo - noUse - CallbackProps": "If a component receives callback functions as props, React.memo will not prevent re-renders unless the callbacks are memoized using useCallback. Without useCallback, the callback functions will be recreated on every render, causing React.memo to fail.",
  "View - Rerendering - Triggering - NoTriggers - memoization - commands - React.memo - noUse - ExpensiveComparison": "If you use a custom comparison function with React.memo, and the comparison function itself is expensive, it can negate the performance benefits of memoization.",
  "View - Rerendering - Triggering - NoTriggers - memoization - commands - React.memo - noUse - Overusing": "Overusing React.memo across an entire application can lead to unnecessary complexity and make the code harder to maintain. It's better to use React.memo selectively, only where it provides a clear performance benefit.",
  "View - Rerendering - Triggering - NoTriggers - memoization - commands - useMemo": "useMemo() caches the result of an expensive computation within a component.",
  "View - Rerendering - Triggering - NoTriggers - memoization - commands - useCallback": "Memoizes functions. Caches a function reference to prevent unnecessary re-creation. When passing a function as a prop to a memoized child component to prevent unwanted re-renders.",
  "View - Rerendering - Triggering - NoTriggers - memoization - commands - useCallback - PersistentServiceReference": "We often see useCallback used to memoize inline arrow functions in event handlers. We do this to make sure that the function reference remains stable and does not trigger unnecessary re-renders when passed as a prop. But as you level up, you’ll find you can use it to maintain stable references to more complex services—like WebSockets, workers, or other persistent resources—so they aren’t re-created unnecessarily on each render.",
  "View - Rerendering - Triggering - NoTriggers - memoization - cons - Memory": "Memory overhead: Memoized values/functions stay in memory until dependencies change.",
  "View - Rerendering - Triggering - NoTriggers - memoization - cons - Performance": "Can slow down performance if overused, especially in simple cases.",
  "View - Rerendering - Triggering - NoTriggers - memoization - cons - Stale": "Might cause stale data issues if dependencies aren't managed correctly.",
	"View - Rerendering - Triggering - Triggers - FirstRender": "First Render.",
	"View - Rerendering - Triggering - Triggers - Changes": "An update can be caused by changes to props or state.",
	"View - Rerendering - Triggering - Triggers - Changes - Props": "",
	"View - Rerendering - Triggering - Triggers - Changes - State": "Setting state requests a re-render from React. This means that for an interface to react to the event, you need to update the state.",
	"View - Rerendering - Triggering - Triggers - Changes - State - onEventHandler": "React batches updates and schedules a re-render. The new state value will be available on the next render. If using the previous state (count), there's a risk of stale state issues in rapid updates.",
	"View - Rerendering - Triggering - Triggers - Changes - State - Value": "Context Value Changes. If the value provided by the Context.Provider changes, all components using useContext(MyContext) will re-render. React compares the new context value with the previous one (shallow comparison for objects)..",
	"View - Rerendering - Triggering - Triggers - Changes - State - useContext": "Component That Calls useContext Always Re-renders. Unlike useState or useMemo, useContext does not allow skipping re-renders based on dependencies..",
	"View - Rerendering - Triggering - Triggers - Changes - State - useEffect": "Risk of infinite loops if the state update re-triggers useEffect.",
	"View - Rerendering - Triggering - Triggers - Scope - UnitOfWork": "A unit of work in React can be a change in props or state or DOM updates, anything that can change the output for the screen. The fiber has a relation of 1 to 1 with something whether a component instance, DOM node, etc. ",
	"View - Rerendering - Triggering - WIPUpdate": "React applies changes to VirtualDOM WIP Tree.",
  "View - Rerendering - Triggering - WIPUpdate - Cascading": "Re-renders in React are cascading. Every time you change state in a React component, you trigger a re-render of that component, every component inside, components inside of those components, etc., until the end of the component tree is reached.",
	"View - Rerendering - Triggering - WIPUpdate - Optimistic": "Optimistic UI updates improve user experience by immediately updating the UI before waiting for the server response, assuming the request will succeed. If the request fails, we roll back the state.",
  "View - Rerendering - Triggering - WIPUpdate - Calls - ClassComponents - getDerivedStateFromProps()": "getDerivedStateFromProps is invoked right before calling the render method, both on the initial mount and on subsequent updates. It should return an object to update the state, or null to update nothing.",
	"View - Rerendering - Triggering - WIPUpdate - Calls - ClassComponents - shouldComponentUpdate()": "The shouldComponentUpdate() method is called before a component is updated. It takes two arguments: nextProps and nextState. This method returns a boolean value that determines whether the component should update or not. If this method returns true, the component will update, and if it returns false, the component will not update.",
  "View - Rerendering - Triggering - WIPUpdate - Calls - ClassComponents - componentWillUpdate() - deprecated": "componentWillUpdate() is a lifecycle method in React that gets called just before a component's update cycle starts.",
	"View - Rerendering - Triggering - WIPUpdate - Calls - ClassComponents - render()": "called every time the component needs to be re-rendered",
	"View - Rerendering - Triggering - WIPUpdate - Calls - ClassComponents - render() - VirtualDOM": "generates the component's virtual DOM representation based on its current props and state.",
	"View - Rerendering - Triggering - WIPUpdate - Calls - ClassComponents - render() - inline": "Using inline functions inside the render method (or JSX) can cause unnecessary re-renders and negatively impact performance. This happens because a new function is created on every render, leading to unnecessary updates in child components. Define Event Handlers Outside JSX.",
	"View - Rerendering - Reconciliation": "React compares Current and WIP VirtualDOMs to determine what changes (diffing) and prepares updates. React updates only the parts of the DOM that have actually changed. The diffing and calculation process is known as 'reconciliation'.",
	"View - Rerendering - Reconciliation - Features - interruptible": ".",
	"View - Rerendering - Reconciliation - UnitOfWork": "",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler": "Reconciliation Engine.",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - StackReconciler": "<React16. React 15 and previous versions of React had a reconciler called StackReconciler.",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - StackReconciler - Features - Animations": "Inefficient Animations – Smooth animations (like 60 FPS rendering) were hard to achieve since updates could not be interrupted.",
  "View - Rerendering - Reconciliation - Reconciling - Reconciler - StackReconciler - Features - ErrorHandling": "errors break the entire component tree.",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - StackReconciler - Features - Structure": "LIFO data structure",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - StackReconciler - Process": "responsible for picking a work and returning the results just like how the JavaScript call stack works.",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - StackReconciler - Drawbacks - Sync": "The main problem was that the StackReconciler was synchronous and sequential meaning there was no chance for it to handle multiple units of work at the same time in parallel or concurrently.",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - StackReconciler - Drawbacks - NoPrioritization": "No Prioritization – All updates were treated equally, whether it was a small button click or an expensive re-render.",
  "View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler": "FiberReconciler is a re-implementation of React’s core algorithm",
  "View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - React16": "In React version 16 and above",
  "View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Features - Async": "render phase is asynchronous, allowing Fiber to prioritize tasks, split work into chunks, and pause or resume certain tasks as needed. parallelized to do multiple works concurrently at the same time",
  "View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Features - ErrorHandling": "Fiber introduces error boundaries, which allow React to gracefully recover from errors without crashing the whole app.",
  "View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Features - Structure": "Fiber replaces the old stack-based reconciliation with a linked list tree structure.",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - ConcurrentMode - React18": "The most important addition in React 18: concurrency.",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - ConcurrentMode - React18 - default": "With React 18+, Concurrent Mode is enabled by default in createRoot.",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - ConcurrentMode - Features - renderer": "Many of the features in React 18 are built on top of our new concurrent renderer, a behind-the-scenes change that unlocks powerful new capabilities. Concurrency is not a feature, per se. It’s a new behind-the-scenes mechanism that enables React to prepare multiple versions of your UI at the same time.",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - ConcurrentMode - Features - optin": "Concurrent React is opt-in — it’s only enabled when you use a concurrent feature — but we think it will have a big impact on the way people build applications.",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - ConcurrentMode - Features - gradual": "Gradually Adopting Concurrent Features. Technically, concurrent rendering is a breaking change. Because concurrent rendering is interruptible, components behave slightly differently when it is enabled.",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - FiberNodes": "The current React Fiber Reconciler consists of many FiberNodes or UnitOfWork",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - FiberNodes - UnitOfWork": "Each component in React is represented by a FiberNode, which contains information about the component, its props, state, and relationships with other components. The fiber has a relation of 1 to 1 with something whether a component instance, DOM node, etc.",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - FiberNodes - Info": "Each FiberNode represents a React element and contains information like: The component type Pending work (updates) Priority level References to parent and child fibers.",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - FiberNodes - Tree": "Fiber nodes form a tree structure, and React processes them incrementally.",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - WorkLoop": "React uses a work loop to process fiber nodes. The loop processes a small number of nodes at a time and then checks if there's time left in the current frame.",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - WorkLoop - requestIdleCallback": "React uses the requestIdleCallback API (or a polyfill) to schedule low-priority work during idle periods in the browser's event loop. This ensures that rendering work doesn't interfere with critical tasks like handling user input or rendering animations..",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - TimeSlicing": "Time slicing is a key feature of React's Concurrent Mode that allows React to break up rendering work into smaller chunks and spread it out over multiple frames.",
  "View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - TimeSlicing - Delay - Urgent": "Urgent updates reflect direct interaction, like typing, clicking, pressing, and so on. Urgent updates like typing, clicking, or pressing, need immediate response to match our intuitions about how physical objects behave. Otherwise they feel “wrong”.",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - TimeSlicing - Delay - useDeferredValue - React18": "useDeferredValue is a React Hook that lets you defer updating a part of the UI. const deferredValue = useDeferredValue(value)",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - TimeSlicing - Interruptible": "React guarantees that the UI will appear consistent even if a render is interrupted. To do this, it waits to perform DOM mutations until the end, once the entire tree has been evaluated. With this capability, React can prepare new screens in the background without blocking the main thread. This means the UI can respond immediately to user input even if it’s in the middle of a large rendering task, creating a fluid user experience.",
  "View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - TimeSlicing - Pause": "Concurrent Mode allows React to pause rendering for low-priority updates and resume later.",
  "View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - TimeSlicing - Cancel": "",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - Transition": "Transition updates transition the UI from one view to another. However, transitions are different because the user doesn’t expect to see every intermediate value on screen.",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - Transition - TransitionAPI": "React's Transition API allow developers to prioritize updates. By marking low-priority updates as transitions, React ensures that the UI remains responsive and smooth, even during heavy or complex updates. This results in a better user experience and perceived performance.",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - Transition - TransitionAPI - useTransition": "Defer rendering for these updates, preventing UI blocking and enhancing overall responsiveness.",  
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - Transition - TransitionAPI - isPending": "A boolean that indicates whether the transition is still pending (i.e., the low-priority update is still being processed).",
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - Transition - TransitionAPI - startTransition - React18": "It allows developers to mark certain state updates as transitions.",  
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - Transition - TransitionAPI - LowPriority": "These marked updates are considered low priority and non-blocking. If there are other higher priority updates (like user input), React will handle these first before restarting the state updates within startTransitions",  
	"View - Rerendering - Reconciliation - Reconciling - Reconciler - FiberReconciler - Process - Trees": "React's Fiber Reconciler (React 16) introduced WIP and Current Trees",
	"View - Rerendering - Reconciliation - Reconciling - Diffing": "React Reconciler performs the diffing algorithm.",
	"View - Rerendering - Reconciliation - Reconciling - Diffing - Process": "compare previous VirtualDOM WIP and Current Trees, and react determines which parts of the actual DOM need to be updated by comparing the differences.",
	"View - Rerendering - Reconciliation - Reconciling - Diffing - Process - children": "Adds children of changed nodes for rerendering.",
	"View - Rerendering - Reconciliation - Reconciling - Diffing - Process - sameTag - hierarchy": "If the elements are of the same type, React only updates the changed attributes and recursively checks their children.",
	"View - Rerendering - Reconciliation - Reconciling - Diffing - Process - noSameTag": "If the root elements of the old and new Virtual DOM trees are different (<div> vs. <span>), React discards the old tree and renders a new one.",
	"View - Rerendering - Reconciliation - Reconciling - Diffing - Process - List": "Key-Based List Reconciliation: When dealing with lists, React uses keys to track elements efficiently and minimize re-renders.",
	"View - Rerendering - Reconciliation - Reconciling - Diffing - Process - Reusable": "Another example is reusable state. Concurrent React can remove sections of the UI from the screen, then add them back later while reusing the previous state. For example, when a user tabs away from a screen and back, React should be able to restore the previous screen in the same state it was in before.",
	"View - Rerendering - Reconciliation - Reconciling - Diffing - libraries - why-did-you-update": "If you are still not satisfied by the output of React performance tools, you can still use “why-did-you-update” library that hooks into React and detects potentially unnecessary component renders. The library once goes in an active stage will shout out into your console anytime a piece of state makes your component update which in reality shouldn’t update at all.",
  "View - Rerendering - Reconciliation - Reconciling - Diffing - libraries - Million": "Million.js was designed to address virtual DOM diffing.",
  "View - Rerendering - Reconciliation - Reconciling - Diffing - libraries - Million - goal": "Million.js performs smart updates, only targeting DOM elements that need to be changed, bypassing the traditional diffing algorithm in many cases.",
  "View - Rerendering - Reconciliation - Reconciling - Diffing - libraries - Million - block()": "A standout feature in Million.js is the block() function, which wraps React components and provides ultra-efficient rendering. This function optimizes components by ensuring they only re-render when necessary, enhancing performance.",
  "View - Rerendering - Reconciliation - Reconciling - Diffing - libraries - Million - memo()": "Component memoization ensures that components only re-render when their props change, a vital strategy for optimizing performance in large applications.",
  "View - Rerendering - Reconciliation - Reconciling - Diffing - libraries - Million - compatibility": "Million.js v3.0.0 has evolved to offer better compatibility with React's core features and modern APIs, such as hooks (useState, useEffect, useMemo, and useCallback).",
	"View - Rerendering - Reconciliation - ScheduleUpdates": "React schedules rendering work based on priority (e.g., urgent UI updates vs. background tasks).",
	"View - Rerendering - Reconciliation - ScheduleUpdates - Scheduler": "React uses a scheduler to process updates in the appropriate order.",
	"View - Rerendering - Reconciliation - ScheduleUpdates - Scheduler - How - check": "The scheduler checks the lanes and prioritizes updates in high-priority lanes over those in low-priority lanes.",
	"View - Rerendering - Reconciliation - ScheduleUpdates - Scheduler - How - process": "React processes updates lane by lane, starting with the highest-priority lane. Once all updates in a lane are processed, React moves on to the next lane.",
	"View - Rerendering - Reconciliation - ScheduleUpdates - Lanes": "Lanes are a concept in React Fiber that represent different priority levels for updates.",
	"View - Rerendering - Reconciliation - ScheduleUpdates - Lanes - bitmasks": "Lanes are represented as bitmasks, allowing React to combine multiple lanes and efficiently manage concurrent updates.",
	"View - Rerendering - Reconciliation - ScheduleUpdates - Lanes - Priority": "High-priority updates (like user interactions) are processed before lower-priority ones (like data fetching).",
	"View - Rerendering - Reconciliation - ScheduleUpdates - Lanes - Priority - Scheduler": "There is a whole package in React that prioritizes tasks called Scheduler.",
	"View - Rerendering - Reconciliation - ScheduleUpdates - Lanes - Priority - priority": "With Fiber, React assigns priority levels to updates. High-priority updates (like user inputs) are processed before low-priority ones (like network requests or background data processing). This ensures that important interactions feel instant and responsive.",
	"View - Rerendering - Reconciliation - ScheduleUpdates - Lanes - Priority - levels": "There are 6 levels of priority. export const NoPriority = 0; export const ImmediatePriority = 1; export const UserBlockingPriority = 2; export const NormalPriority = 3; export const LowPriority = 4; export const IdlePriority = 5;",
	"View - Rerendering - Reconciliation - ScheduleUpdates - Lanes - Priority - levels - High": "High priority → User interactions (e.g., clicking a button, typing).",
	"View - Rerendering - Reconciliation - ScheduleUpdates - Lanes - Priority - levels - Medium": "Medium priority → Updating lists, rendering new UI. Animations, transitions.",
	"View - Rerendering - Reconciliation - ScheduleUpdates - Lanes - Priority - levels - Low": "Low priority → Data fetching, background updates.",
	"View - Rerendering - Reconciliation - ScheduleUpdates - Lanes - Priority - levels - Idle": "Analytics loggings.",
	"View - Rerendering - Reconciliation - ScheduleUpdates - Batches": "React’s virtual DOM improves performance by batching updates and reducing the number of direct manipulations to the actual DOM. Reflow and Repaint are both heavy. The Virtual DOM boosts performance by minimizing browser reflows and repaints. Reflows are particularly expensive because they involve recalculating the layout of the page. Without the Virtual DOM, each of the X DOM operations would trigger a reflow and repaint. However, with the Virtual DOM, holding a 'diff-tree' for the dom-difference, these operations are processed in batches, resulting in only one reflow and repaint.",
	"View - Rerendering - Reconciliation - ScheduleUpdates - Batches - NoCases - setTimeout": "Inside setTimeout or Promise.then (Before React 18) In React 17 and earlier, updates inside setTimeout or Promise.then trigger separate renders.",
	"View - Rerendering - Reconciliation - ScheduleUpdates - Batches - NoCases - NativeEventListeners": "React does not batch updates inside manually attached DOM event listeners (e.g., document.addEventListener).",
	"View - Rerendering - Reconciliation - ScheduleUpdates - Batches - NoCases - flushSync": "You can use ReactDOM.flushSync() to disable batching.",
	"View - Rerendering - Reconciliation - ScheduleUpdates - Batches - NoCases - React<18": "Prior to React 18, state updates in asynchronous code (Outside EventHandlers, e.g., setTimeout, Promises, API calls) were not batched.",
	"View - Rerendering - Reconciliation - ScheduleUpdates - Batches - Cases - React18": "React 18 introduced 'Automatic Batching', meaning even asynchronous state updates (Outside EventHandlers, e.g. setTimeout, Promises, API calls) are batched.",
	"View - Rerendering - Reconciliation - ScheduleUpdates - Batches - Cases - EventHandlers": "When multiple setState calls occur inside a React event handler, React batches them together and triggers only one re-render at the end.",
	"View - Rerendering - Reconciliation - ScheduleUpdates - Batches - Cases - lifecycle": "React automatically batches updates in lifecycle methods.",
	"View - Rerendering - Reconciliation - ScheduleUpdates - Batches - Cases - Hooks": "Updates inside hooks are batched automatically.",
	"View - Rerendering - Reconciliation - calls - FunctionalComponents - Hooks": "useState / useReducer / useContext / useMemo / useCallback / useTransition / useDeferredValue / custom",
	"View - Rerendering - Reconciliation - calls - FunctionalComponents - Hooks - order": "React executes hooks in the order they appear in the component's function body",
	"View - Rerendering - Commit": "DOM Updates. Commit phase is where React actually interacts with the DOM. Separated phase to make it synchronous non-interruptible..",
	"View - Rerendering - Commit - Features - synchronous": "This phase is synchronous (React flushes all updates in one go). ",
	"View - Rerendering - Commit - Features - non-interruptible": "This is the reason to be separated phase.",
	"View - Rerendering - Commit - Renderer": "Rendering is done by one of the React Renderers: react-dom, react-native, react-three-fiber, ink ",
	"View - Rerendering - Commit - Renderer - ReactDOM": "Uses React Reconciler internally to apply updates to the real DOM.",
	"View - Rerendering - Commit - Renderer - ReactDOM - react-dom": "Updates the browser DOM. ReactDOM is the renderer for the web platform. A separate library is responsible for writing to the DOM. ",
	"View - Rerendering - Commit - Renderer - ReactDOM - ReactDOMClient": "These new APIs are now exported from react-dom/client:",
  "View - Rerendering - Commit - Renderer - ReactDOM - ReactDOMClient - createRoot": "createRoot: New method to create a root to render or unmount. Use it instead of ReactDOM.render. New features in React 18 don’t work without it.",
  "View - Rerendering - Commit - Renderer - ReactDOM - ReactDOMClient - hydrateRoot": "hydrateRoot: New method to hydrate a server rendered application. Use it instead of ReactDOM.hydrate in conjunction with the new React DOM Server APIs. New features in React 18 don’t work without it.",
  "View - Rerendering - Commit - Renderer - ReactDOM - ReactDOMServer": "These new APIs are now exported from react-dom/server and have full support for streaming Suspense on the server:",
  "View - Rerendering - Commit - Renderer - ReactDOM - ReactDOMServer - renderToPipeableStream": "renderToPipeableStream: for streaming in Node environments.",
  "View - Rerendering - Commit - Renderer - ReactDOM - ReactDOMServer - renderToReadableStream": "renderToReadableStream: for modern edge runtime environments, such as Deno and Cloudflare workers.",
	"View - Rerendering - Commit - Renderer - react-native": "Updates native mobile UI.",
	"View - Rerendering - Commit - Renderer - react-three-fiber": "Updates 3D WebGL scenes.",
	"View - Rerendering - Commit - Renderer - ink": "Updates command-line UI.",
	"View - Rerendering - Commit - Rendering": ".",
	"View - Rerendering - Commit - Rendering - Swap": "React WIP tree replaces the current tree. This is the point where it inserts, deletes, and updates DOM elements, making the final changes visible in the browser. The WIP tree becomes the new Current Fiber tree.",
	"View - Rerendering - Commit - Rendering - Swap - Flagged": "During the rendering process, React will start at the root of the component tree and loop downwards to find all components that have been flagged as needing updates. For each flagged component, React will call either FunctionComponent(props) (for function components), or classComponentInstance.render() (for class components) , and save the render output for the next steps of the render pass.",
  "View - Rerendering - Commit - Rendering - Swap - routing": "Instead of using the native browser routing and navigation, we keep all of that in the JavaScript memory and use JavaScript to handle pages and routing for us, and as a result, it will become a lot faster.",
	"View - Rerendering - Commit - Rendering - Updating": "These methods are called in the following order when a component is being re-rendered.",
  "View - Rerendering - Commit - Rendering - Updating - calls - ClassComponents - getSnapshotBeforeUpdate()": "The getSnapshotBeforeUpdate() method is called just before the component's UI is updated. It allows the component to capture some information about the current state of the UI, such as the scroll position before it changes. This method returns a value that is passed as the third parameter to the componentDidUpdate() method.",
	"View - Rerendering - Commit - Rendering - Updating - calls - ClassComponents - componentWillUnmount()": "React will call it before your component is removed (unmounted) from the screen on nodes tagged with the Deletion effect.",
  "View - Rerendering - Commit - Rendering - Updating - calls - ClassComponents - componentDidMount()": "It then synchronously runs the componentDidMount and componentDidUpdate class lifecycle methods.",
  "View - Rerendering - Commit - Rendering - Updating - calls - ClassComponents - componentDidUpdate()": "The componentDidUpdate() method is a lifecycle method in React that is called after a component has been updated and re-rendered.",
	"View - Rerendering - Commit - Rendering - Updating - calls - FunctionalComponents - Hooks": "useInsertionEffect / useLayoutEffect / useEffect",
	"View - Rerendering - Commit - Rendering - Updating - calls - FunctionalComponents - Hooks - useInsertionEffect": "Runs before DOM mutations (for CSS-in-JS libraries).",
	"View - Rerendering - Commit - Rendering - Updating - calls - FunctionalComponents - Hooks - useLayoutEffect": "Run after DOM mutations but before paint in commit phase",
	"View - Rerendering - Commit - Rendering - Updating - calls - FunctionalComponents - Hooks - useEffect": "After paint in commit phase.",

  "Logic": "SECTION",
	"Logic - Client - ClientComponents - ": "The 'standard' React components we know and love have been rebranded as Client Components. It's a new name for an old thing.",
	"Logic - Client - ClientComponents - Structure - import": "React team added a rule: Client Components can only import other Client Components.",
	"Logic - Client - ClientComponents - Structure - use client": "In this new “React Server Components” paradigm, all components are assumed to be Server Components by default. We have to “opt in” for Client Components. That standalone string at the top, 'use client', is how we signal to React that the component(s) in this file are Client Components, that they should be included in our JS bundles so that they can re-render on the client.. Server Components are not sent to the browser, so they cannot use interactive APIs like useState. To add interactivity to Server Components, you can compose them with Client Component using the 'use client' directive. ",
	"Logic - Client - ClientComponents - Structure - use client - boundaries": "When we add the 'use client' directive to a component, we create a “client boundary”. All of the components within this boundary are implicitly converted to Client Components. Even though components don't have the 'use client' directive, they'll still hydrate/render on the client in this particular situation. Can retry.*",
  "Logic - Client - ClientComponents - Identification - Files": "CSR Components. File extensions: .client.js, .client.jsx, .client.ts, or .client.tsx. These components are rendered on the client, and their JavaScript code is included in the client-side bundle. Convention added with RSC.",
	"Logic - Client - ClientComponents - Rendering - rerender": "The name 'Client Component' implies that these components only render on the client, but that's not actually true. Client Components render on both the client and the server.",
	"Logic - Client - ClientComponents - Rendering - rerender - count": "console.count('render')",
	"Logic - Client - ClientComponents - UserInteraction - EventDelegationModel": "React does not attach event listeners directly to individual DOM elements. Instead, it uses React’s Event Delegation Model by attaching a single event listener to the root of the DOM tree (usually document or a container like #root).",
	"Logic - Client - ClientComponents - UserInteraction - EventDelegationModel - Listener": "React uses a single event listener at the document level (document.addEventListener).",
	"Logic - Client - ClientComponents - UserInteraction - EventDelegationModel - EventHandlers": "Defining Event Handlers in TypeScript.",
	"Logic - Client - ClientComponents - UserInteraction - EventDelegationModel - EventBubbling": "When an event occurs on a child component, it bubbles up to React’s root event handler.",
	"Logic - Client - ClientComponents - UserInteraction - EventDelegationModel - EventBubbling - onClick": "Most events are delegated (e.g., onClick, onChange). Even though we write onClick in JSX, React internally manages a single event listener at the document level.",
	"Logic - Client - ClientComponents - UserInteraction - EventDelegationModel - NoEventBubbling": "Some events do not bubble naturally (e.g., onBlur, onFocus, scroll) and React attaches those directly to elements.",
	"Logic - Client - ClientComponents - UserInteraction - EventDelegationModel - Benefits - Memory": "Better Performance & Less Memory Usage. Instead of attaching multiple event listeners to each individual element, React uses just one, reducing memory usage.",
	"Logic - Client - ClientComponents - UserInteraction - EventDelegationModel - Benefits - Dynamic": "Efficient Handling of Dynamic Elements. If elements are added/removed dynamically, React can still capture their events without needing to re-attach listeners.",
	"Logic - Client - ClientComponents - UserInteraction - EventDelegationModel - Benefits - Compatibility": "Consistent Synthetic Event System. React wraps native events inside Synthetic Events, ensuring cross-browser compatibility and making event handling consistent.",
	"Logic - Client - ClientComponents - UserInteraction - EventDelegationModel - Benefits - Batching": "Event Batching for Optimization. React batches multiple event updates in one go, reducing unnecessary re-renders.",
	"Logic - Client - ClientComponents - UserInteraction - SyntheticEvents": "React determines which component should handle the event using synthetic events.",
	"Logic - Client - ClientComponents - UserInteraction - SyntheticEvents - Features - encapsulate": "React synthetic events encapsulate native browser events, providing a unified API interface so that developers can handle events in the same way regardless of the browser environment.",
	"Logic - Client - ClientComponents - UserInteraction - SyntheticEvents - Features - CrossBrowser": "React normalizes events across browsers using SyntheticEvent, which wraps the native event to provide consistent behavior. The main purpose of this approach is to ensure cross-browser consistency and integrate with React’s declarative programming model and lifecycle. React synthetic events handle all browser compatibility issues, providing developers with a clean, consistent interface for event handling.",
	"Logic - Client - ClientComponents - UserInteraction - SyntheticEvents - Features - ClientComponents": "Only ClientComponents.",
	"Logic - Client - ClientComponents - UserInteraction - SyntheticEvents - Operation - pool": "React SyntheticEvent use an event pool to improve performance, i.e., reusing event objects. This means that after the event callback function is executed, all properties of the event object are cleared and recycled for reuse, reducing the pressure on garbage collection and memory usage.",
	"Logic - Client - ClientComponents - UserInteraction - SyntheticEvents - Operation - Throttling": "Throttling in React is a technique used to limit the number of times a function or an event handler is invoked by postponing the execution of a function. It ensures that the function is called at a specified interval, preventing it from being executed too frequently. Throttling allows you to control the rate at which the function is called by setting up a minimum time interval between each function invocation. If the function is called multiple times within that interval, only the first invocation is executed, and subsequent invocations are ignored until the interval elapses.",
	"Logic - Client - ClientComponents - UserInteraction - SyntheticEvents - Operation - Debouncing": "Debouncing, as opposed to throttling, is a method to stop the event trigger from firing too frequently. Debouncing, on the other hand, is also used to limit the number of times a function or an event handler is invoked. It ensures that the function is called only after a certain period of inactivity. Debouncing allows you to postpone the function call until the user has finished typing or a specific time has elapsed since the last event..",
	"Logic - Client - ClientComponents - SideEffects": "Side effects in React are operations that affect something outside the component. Run in the commmit phase.",
	"Logic - Client - ClientComponents - SideEffects - Mixins - 2014": "A React Mixin got introduced as React's first advanced pattern for reusable component logic. With a Mixin, it's possible to extract logic from a React component as standalone object. When using a Mixin in a component, all features from the Mixin are introduced to the component:",
  "Logic - Client - ClientComponents - SideEffects - Mixins - drawbacks": "However, Mixins are not used anymore in modern React applications, because they come with several drawbacks.",
  "Logic - Client - ClientComponents - SideEffects - Mixins - drawbacks - dependencies": "Often, mixins come to depend on other mixins, and removing one of them breaks the other. In these situations it is very tricky to tell how the data flows in and out of mixins, and what their dependency graph looks like. Unlike components, mixins don’t form a hierarchy: they are flattened and operate in the same namespace. If you have a name conflict with a mixin from a third party package, you can’t just rename a method on it. Instead, you have to use awkward method names on your component to avoid clashes.",
  "Logic - Client - ClientComponents - SideEffects - Mixins - drawbacks - clashes": "There is no guarantee that two particular mixins can be used together. For example, if FluxListenerMixin defines handleChange() and WindowSizeMixin defines handleChange(), you can’t use them together. You also can’t define a method with this name on your own component.",
  "Logic - Client - ClientComponents - SideEffects - Mixins - drawbacks - complexity": "Even when mixins start out simple, they tend to become complex over time.",
	"Logic - Client - ClientComponents - SideEffects - HOCs": "React Higher-Order Components (HOCs), a popular advanced React pattern, are an alternative for React Mixins to deploy reusable logic across React components. The shortest explanation for a Higher-Order Component is that it is a component which takes a component as input and returns the component as output but with extended functionalities.",
	"Logic - Client - ClientComponents - SideEffects - Render Props": "Another popular advanced React pattern are React Render Prop Components, which are often used as alternative to React Higher-Order Components.",
	"Logic - Client - ClientComponents - SideEffects - Hooks - effect": "Effects let a component connect to and synchronize with external systems. This includes dealing with network, browser DOM, animations, widgets written using a different UI library, and other non-React code.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useInsertionEffect - React18": "",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useInsertionEffect - Features - lifecycle": "useInsertionEffect is a version of useEffect that fires before any DOM mutations.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useInsertionEffect - Syntax": "useInsertionEffect(setup, dependencies?)",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useInsertionEffect - Usage": "Pitfall. useInsertionEffect is aimed at CSS-in-JS library authors. Unless you are working on a CSS-in-JS library and need a place to inject the styles, you probably want useEffect or useLayoutEffect instead.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect": "Layout Efects. bring side-effects to Function Components to manipulate the real DOM (not the VirtualDOM). The primary purpose is to avoid visual inconsistencies that might arise if the effect was delayed until after the paint, as would be the case with useEffect. Good for layout-related updates.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Features - lifecycle": "runs  after all DOM mutations to make DOM manipulations BEFORE the Browser Paints the Screen.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Features - blocking": "BLOCKS rendering until the effect is complete.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Features - sync": "The useLayoutEffect hook runs synchronously.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Syntax": "useLayoutEffect(() => { /* Your effect logic here */ return () => { /* Optional cleanup logic here */ };},[dependencies]);",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Syntax - Function": "Effect Function: you can read from the DOM, manipulate it, and make changes that need to be visible immediately.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Syntax - FunctionReturn": "Cleanup Function (optional): This is returned from the main effect function. It will be called before the effect runs the next time, or when the component unmounts. This is useful for cleaning up any side effects (e.g., removing event listeners, cancelling timers).",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Syntax - Dependencies": "Dependencies: This is an array of values that the effect depends on. The effect will only re-run if one of these dependencies changes. If you pass an empty array, the effect will only run on mount and unmount.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Usages": "scenarios where you need to perform side effects that require direct interaction with the real DOM, or when you need to ensure that your updates are visible to the user without any flickering or delay. This is useful when you need to make measurements or changes to the DOM that should be applied before the screen is updated.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Usages - measure": "Measuring Layouts: For example, if you need to measure the position or size of a DOM element immediately after a render but before the browser has painted the screen.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Usages - styles": "apply styles or transformations immediately after rendering.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Usages - syncing": "Synchronizing State with the DOM: When you need to ensure that your component’s state is perfectly synchronized with the DOM in a way that affects the layout or style.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Usages - FOUC": "Avoiding Flash of Unstyled Content (FOUC): Ensuring that CSS changes are applied before the browser repaints can prevent users from seeing unstyled content.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Gotchas - performance": "Performance Impact: useLayoutEffect is synchronous, meaning it will block the browser from painting until the effect has finished executing. This can introduce performance issues, especially if the effect involves complex computations or multiple DOM manipulations. Always be mindful of the performance cost when deciding to use useLayoutEffect over useEffect.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Gotchas - UIJank": "UI Jank: If useLayoutEffect takes too long to execute, it can cause UI jank, where the interface feels sluggish or unresponsive. This is especially critical on lower-end devices or under heavy load, where the blocking behavior can become more noticeable.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Gotchas - render": "Blocking Render Cycles: Since useLayoutEffect runs before the browser has a chance to repaint, it can block the render cycle, leading to delays in visual updates.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect": "Passive Effects. bring side-effects to Function Components.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Features - lifecycle": "Runs AFTER the Browser Paints the Screen.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Features - blocking": "Does NOT BLOCK rendering.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Features - async": "useEffect() is asynchronous.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Features - SSR": "The useEffect doesn’t get executed in SSR as there is no DOM in the server and there is no commit happening in SSR.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Syntax": "useEffect(<function>, <dependency>).",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Syntax - Function": ".",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Syntax - FunctionReturn - cleanup": "The behavior of the useEffect cleanup function is designed to ensure proper resource management and avoid side effects like memory leaks or stale data. The cleanup function runs before the next effect to clean up the previous effect's resources, but it also runs before the component unmounts to clean up the last effect's resources.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Syntax - FunctionReturn - cleanup - syntax": "useEffect(() => { console.log('Effect ran'); return () => { console.log('Cleanup ran'); }; }, [dependency]);",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Syntax - FunctionReturn - cleanup - BeforeNextEffect": ".",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Syntax - FunctionReturn - cleanup - BeforeNextEffect - RunCleanup": "React first runs the cleanup function from the previous effect to clean up any resources (e.g., subscriptions, timers, or event listeners) that were created during the previous render. This ensures that the previous effect's resources are properly disposed of before setting up new ones.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Syntax - FunctionReturn - cleanup - BeforeNextEffect - RunEffect": "After the cleanup, React runs the new effect with the updated dependencies.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Syntax - FunctionReturn - cleanup - BeforeUnmount": "When a component unmounts, React runs the cleanup function from the last effect to ensure that any resources created during the component's lifecycle are properly cleaned up.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Syntax - Dependencies": "optional",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Syntax - Dependencies - mount/unmount/update": "React.useEffect(() => { console.log('I run on every render: mount + update.'); }); This is the most straightforward usage of useEffect where we only pass one argument -- a function. The effect runs after every render -- meaning it runs on the first render of the component (also called on mount or mounting of the component) and on every re-render of the component (also called on update or updating of the component).",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Syntax - Dependencies - mount/unmount": "React.useEffect(() => { console.log('I run only on the first render: mount.'); }, []); If you want to run React's useEffect Hook only on the first render of a component (also called only on mount), then you can pass in a second argument to useEffect: https://medium.com/@sassenthusiast/i-thought-i-knew-useeffect-but-i-was-wrong-useeffect-misconceptions-dcc2781010a9 . It behaves like componentDidMount in class components.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Syntax - Dependencies - update": "React.useEffect(() => { console.log('I run only if toggle changes (and on mount).'); }, [toggle]); Now the side-effect function for this React component runs only when the variable in the dependency array changes. ",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Syntax - Dependencies - update any": "React.useEffect(() => { console.log('I run if toggle or title change (and on mount).'); }, [toggle, title]); if we provide the new variable in the dependency array, the side-effect function will run for both updates:",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Async": "async callbacks cannot be utilised within the useEffect hook. Calling async functions inside useEffect can lead to memory leaks, stale state, race conditions, unhandled errors, and infinite loops. ",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Async - problems": "Calling async functions inside useEffect can lead to several potential problems if not handled correctly.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Async - problems - MemoryLeaks": "If the component unmounts or the effect is re-run before the async function completes, the function may still try to update the component's state, leading to a memory leak or warnings about updating an unmounted component.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Async - problems - StaleState": "If the async function depends on state or props, it may capture stale values if the state or props change before the function completes.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Async - problems - RaceConditions": "If the async function is triggered multiple times (e.g., due to frequent state or prop changes), the results may arrive out of order, causing a race condition.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Async - problems - ErrorHandling": "If the async function throws an error, it may go unhandled, causing the application to break or behave unexpectedly.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Async - problems - InfiniteLoops": "If the async function updates state or props that are dependencies of the useEffect, it may cause an infinite loop of re-renders.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Async - patch": "create a new function that is declared inside the useEffect() hook and that contains the async function, and then we can call this new function inside the useEffect() hook.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Pitfalls - UnnecesaryExecution - StrictMode": "React 18+ in Strict Mode intentionally runs effects twice in development to detect side effect bugs. Solution: Ignore.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Pitfalls - UnnecesaryExecution - Dependencies": "If you pass an object, array, or function in the dependency array, useEffect may run more often than expected because these values create new references on each render. Solution: Use useMemo or useCallback",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Pitfalls - UnnecesaryExecution - State": "State Updates Triggering New Renders. If a state update inside useEffect modifies the state that is in its own dependency array, it can cause an infinite loop. Solution: Use a conditional check inside useEffect.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Pitfalls - UnnecesaryExecution - Functions": "If a function is defined inside a component and included in the dependency array, useEffect will run on every render because functions get re-created on each render. Solution: Use useCallback to memoize functions",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Pitfalls - Leaks": "If a component unmounts before the fetch completes, the state update may still try to execute, leading to memory leaks.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Pitfalls - Infinite": "If a state update inside useEffect() triggers a re-render, useEffect() runs again, updating the state again, leading to an infinite loop.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Pitfalls - HandleErrors": "useEffect() Doesn’t Handle Errors Well. You have to manually catch errors and manage loading states.",
	"Logic - Client - ClientComponents - SideEffects - Hooks - useId": "useId is a React Hook for generating unique IDs.",
	"Logic - Client - ClientComponents - SideEffects - Hooks - useId - stable": "Stable Across Re-renders: The same ID is returned for the same component instance.",
	"Logic - Client - ClientComponents - SideEffects - Hooks - useId - SSR": "Works consistently in server-side rendering (SSR) and client-side hydration.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - custom": "https://javascript.plainenglish.io/collection-of-custom-hooks-for-your-nextjs-react-project-1779379e6f4a",
	"Logic - Client - ClientComponents - DOMInteraction": "",
	"Logic - Client - ClientComponents - DOMInteraction - ref": "Refs let a component hold some information that isn’t used for rendering, like a DOM node or a timeout ID.",
  "Logic - Client - ClientComponents - DOMInteraction - ref - Create - React.createRef": "React.createRef (for class components).",
  "Logic - Client - ClientComponents - DOMInteraction - ref - Create - useRef": "useRef (for functional components). useRef manipulates the real DOM, not the Virtual DOM.",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Create - useRef - current": "The useRef Hook returns an object with a single property called current. Initially, myRef.current will be null.",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Create - useRef - Object": "ref is an object with a single property called current. Initially, myRef.current will be null.",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Create - useRef - Object - current": "ref is an object with a single property called current. When React creates a DOM node for this <div>, React will put a reference to this node into myRef.current.",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Create - useRef - Object - initial": "Initially, myRef.current will be null.",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Update": "After React has updated the DOM in the commit phase, it updates all refs accordingly to point to the requested DOM nodes and component instances.",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Types - TypeScript - Define": "When working with refs in React and TypeScript, you need to specify the correct type for the ref object, whether it’s a DOM element, a custom component, or a forwarded ref.",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Types - TypeScript - Define - DOMElement": "For standard HTML elements, use useRef<HTMLTagElement>(null).",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Types - TypeScript - Define - input": "useRef<HTMLInputElement>(null)",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Types - TypeScript - Define - CustomComponent": "When using useRef with a custom React component, specify the component instance type. ",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Types - TypeScript - Define - Mutable": "Using useRef with useState for Mutable Values. If using useRef for storing mutable values (not DOM refs), define the correct type.",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Usage": "Unlike with state, updating a ref does not re-render your component. Refs are an “escape hatch” from the React paradigm. ",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Usage - DOM": "It can be used to access a DOM element directly (focus, scroll, bypassing React’s Virtual DOM (VDOM) diffing process.",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Usage - DOM - Focus": "A React Ref should only be used in rare cases such as accessing/manipulating the DOM manually (e.g. focus element), animations, and integrating third-party DOM libraries. ref directly references a DOM element",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Usage - DOM - Animations": "A React Ref should only be used in rare cases such as accessing/manipulating the DOM manually (e.g. focus element), animations, and integrating third-party DOM libraries. ref directly references a DOM element",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Usage - DOM - BrowserAPIs": "They are useful when you need to work with non-React systems, such as the built-in browser APIs.",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Usage - Applications - Counter": "It can be used to store a mutable value that does not cause a re-render when updated.",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Usage - Applications - PreviousValue": "Use useRef to store the previous value of a prop or state.",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Usage - Applications - ExpensiveCalculations": "store the result of expensive calculations or side effects that do not need to trigger re-renders.",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Usage - Applications - noFunction": "do not work with function components",
	"Logic - Client - ClientComponents - DOMInteraction - useImperativeHandle": "expose component methods (e.g., focus(), reset()) so that a parent can call them. useImperativeHandle(ref, createHandle, dependencies?)",
  "Logic - Client - ClientComponents - DOMInteraction - forwardRef": "Passes ref from parent to child function components",
	"Logic - Client - ClientComponents - DOMInteraction - forwardRef - motivation": "Normally, refs cannot be passed as props because they are not part of the standard prop system. Use forwardRef",
	"Logic - Client - ClientComponents - DOMInteraction - forwardRef - Usage - function": "works with function components",
	"Logic - Client - ClientComponents - ErrorHandling": "These methods are called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component.",
  "Logic - Client - ClientComponents - ErrorHandling - getDerivedStateFromError()": "Update state so the next render will show the fallback UI..",
  "Logic - Client - ClientComponents - ErrorHandling - componentDidCatch()": "handle errors, such as logging error information, displaying error information to the user, sending error reports, etc.",
	"Logic - Client - ClientComponents - ErrorHandling - ErrorBoundary": "React gives us what is known as 'Error Boundaries': a special API that turns a regular component into a try/catch statement in a way, only for React declarative code. ",
	"Logic - Client - ClientComponents - ErrorHandling - ErrorBoundary - onRecoverableError": "onRecoverableError, to provide better clarity on why the error is happening.",
	"Logic - Client - ClientComponents - ErrorHandling - ErrorBoundary - onCaughtError": "React 19. onCaughtError triggers when React catches an error in an Error Boundary.",
	"Logic - Client - ClientComponents - ErrorHandling - ErrorBoundary - onUncaughtError": "React 19. onUncaughtError triggers when an error is thrown and not caught by an Error Boundary.",
	"Logic - Client - ClientComponents - ErrorHandling - StrictMode": "< React.StrictMode ><App /></React.StrictMode>,. Use StrictMode to enable additional development behaviors and warnings for the component tree inside: Strict Mode enables the following development-only behaviors: Your components will re-render an extra time to find bugs caused by impure rendering. Your components will re-run Effects an extra time to find bugs caused by missing Effect cleanup. Your components will be checked for usage of deprecated APIs.",
	"Logic - Client - Functions - Hooks - React16.8": "React Hooks are functions that let you use state and lifecycle features in function components.",
	"Logic - Client - Functions - Hooks - List - InitPhase - Ref - useRef": "Creates a mutable ref object with current: initialValue.",
	"Logic - Client - Functions - Hooks - List - InitAndReconciliationPhase - State - useState": "",
	"Logic - Client - Functions - Hooks - List - InitAndReconciliationPhase - State - useReducer": "",
	"Logic - Client - Functions - Hooks - List - InitAndReconciliationPhase - State - useContext": "",
	"Logic - Client - Functions - Hooks - List - InitAndReconciliationPhase - State - useSelector": "Redux",
	"Logic - Client - Functions - Hooks - List - InitAndReconciliationPhase - Rendering - useMemo": "",
	"Logic - Client - Functions - Hooks - List - InitAndReconciliationPhase - Rendering - useCallback": "",
	"Logic - Client - Functions - Hooks - List - InitAndReconciliationPhase - Rendering - useTransition": "",
	"Logic - Client - Functions - Hooks - List - InitAndReconciliationPhase - Rendering - useDeferredValue": "",
	"Logic - Client - Functions - Hooks - List - InitAndReconciliationPhase - Ref - useId": "Generates a unique, stable ID each time the component renders.",
	"Logic - Client - Functions - Hooks - List - InitAndReconciliationPhase - Custom - functions": "They are JavaScript functions.",
	"Logic - Client - Functions - Hooks - List - InitAndReconciliationPhase - Custom - stateful": "allow you to extract and reuse stateful logic across multiple components.",
	"Logic - Client - Functions - Hooks - List - InitAndReconciliationPhase - Custom - use": "follow the naming convention of starting with use (e.g., useFetch, useLocalStorage)",
	"Logic - Client - Functions - Hooks - List - InitAndReconciliationPhase - Custom - built-in": "can call other Hooks like useState, useEffect, etc.",
	"Logic - Client - Functions - Hooks - List - InitAndReconciliationPhase - Custom - encapsulate": "Custom Hooks enable you to encapsulate logic, making your components cleaner and more focused on rendering.",	
	"Logic - Client - Functions - Hooks - List - InitAndReconciliationAndCommitPhase - Calls - useSyncExternalStore": "Integrating with non-React state management (Redux, global variables, etc.).",	
	"Logic - Client - Functions - Hooks - List - InitAndReconciliationAndCommitPhase - Calls - useQuery (libs)": "from libraries like React Query, Apollo Client, or URQL.",
	"Logic - Client - Functions - Hooks - List - CommitPhase": "These hooks require DOM existence.",
	"Logic - Client - Functions - Hooks - List - CommitPhase - SideEffects - useInsertionEffect": "Runs Before DOM mutations, e.g. Injecting styles (CSS-in-JS)",
	"Logic - Client - Functions - Hooks - List - CommitPhase - SideEffects - useLayoutEffect": "After DOM mutations, before paint, e.g. DOM measurements/sync updates",
	"Logic - Client - Functions - Hooks - List - CommitPhase - SideEffects - useEffect": "After paint, e.g. Side effects (data fetching, etc.)",
	"Logic - Client - Functions - Hooks - List - CommitPhase - Ref - useImperativeHandle": "Customizes the ref value exposed to parents.",
	"Logic - Client - Functions - Hooks - List - OnEvents - Forms - useActionState - deprecated": "",
	"Logic - Client - Functions - Hooks - List - OnEvents - Forms - useFormState": "The useFormState hook (formerly known as useActionState in earlier experimental versions) is designed specifically for managing state in React forms, particularly with server actions.",
	"Logic - Client - Functions - Hooks - List - OnEvents - Forms - useFormStatus": "",
	"Logic - Client - Functions - Hooks - List - OnEvents - Forms - useOptimistic": "",
	"Logic - Client - Functions - Hooks - RulesOfHooks": "React explicitly enforces the Rules of Hooks, which state that Hooks must be called at the top level of a component and not inside loops, conditionals, or nested functions. Violating these rules will cause React to throw an error.",
	"Logic - Client - Functions - Hooks - RulesOfHooks - useTop": "Name as useXXX",
	"Logic - Client - Functions - Hooks - RulesOfHooks - Top": "always call Hooks at the top level of your component",
	"Logic - Client - Functions - Hooks - RulesOfHooks - Order": "React expects Hooks to be called in the same order on every render.",
	"Logic - Client - Functions - Hooks - RulesOfHooks - Order - Conditional": "If you conditionally call a Hook inside a loop or conditional, the order of Hooks might change between renders, leading to bugs and unexpected behavior.",
	"Logic - Client - Functions - Hooks - RulesOfHooks - Order - Loops": "Conditionally calling Hooks inside loops can lead to unnecessary re-renders or re-initializations of Hooks, which can degrade performance.",
	"Logic - Client - Functions - Hooks - RulesOfHooks - CleanupSideEffects": "If your hook creates subscriptions, timers, or event listeners, clean them up in the useEffect return function",
	"Logic - Client - Functions - Hooks - RulesOfHooks - ReturnValues": "Custom hooks can return: A single value (e.g., return state;). An array (like useState: return [state, setState];). An object (e.g., return { isLoading, data, error };).",
	"Logic - Client - Functions - Hooks - Pitfalls - MemoryLeaks": "Memory leaks in React Hooks often occur due to: Unclosed subscriptions. Unresolved async operations. Unremoved event listeners. Unreleased timers or intervals. Stale closures or large state objects.",
	"Logic - Client - Functions - Hooks - Pitfalls - MemoryLeaks - Unclosed": "Unclosed subscriptions",
	"Logic - Client - Functions - Hooks - Pitfalls - MemoryLeaks - Async": "Unresolved async operations",
	"Logic - Client - Functions - Hooks - Pitfalls - MemoryLeaks - EventListeners": "Unremoved event listeners",
	"Logic - Client - Functions - Hooks - Pitfalls - MemoryLeaks - Timers": "Unreleased timers or intervals",
	"Logic - Client - Functions - Hooks - Pitfalls - MemoryLeaks - LargeObjects": "large state objects.",
	"Logic - Client - Functions - Hooks - Pitfalls - MemoryLeaks - StaleClosures": "Stale closures.",
	"Logic - Client - Functions - Hooks - Pitfalls - Closures": "Closures capture and retain the values of variables at the time the closure was created.",
	"Logic - Client - Functions - Hooks - Pitfalls - Closures - stale": "Closures can cause issues in React hooks, particularly with useEffect and useState, can lead to stale closures, where the closure holds onto outdated values, even after the state or props have changed. This is a common source of bugs in React applications.",	
	"Logic - Client - Functions - Hooks - Pitfalls - Closures - stale - useState": "Use a Functional Update in useState: When updating state based on the previous state, use the functional form of setState to ensure you're working with the latest state.",	
	"Logic - Client - Functions - Hooks - Pitfalls - Closures - stale - useCallback": "Use useCallback for Stable Callbacks: If you need to pass a callback to a child component or an event handler, use useCallback to memoize the callback and ensure it only updates when its dependencies change.",	
	"Logic - Client - Functions - Hooks - Pitfalls - Closures - stale - useRef": "Use a Ref to Access the Latest State: If you need to access the latest state value in a callback without re-creating the callback every time, you can use a useRef to store the current state and update it whenever the state changes.",	
	"Logic - Client - Functions - Hooks - Pitfalls - Closures - stale - useEffect": "Use the Dependency Array in useEffect: Ensure that all dependencies (state, props, or other variables) used inside useEffect are included in the dependency array. This ensures the effect is re-run whenever the dependencies change.",	
	"Logic - Client - Functions - Hooks - Pitfalls - Closures - stale - avoid": "Avoid Unnecessary Closures: If possible, structure your code to avoid creating closures that capture stale values. For example, move state-dependent logic directly into the component or hook where it belongs..",	
	"Logic - Client - ServerFunctions": "Client Components can import Server Functions",
	"Logic - Server - RSC - React19": "ReactServerComponents run exclusively on the server.",
	"Logic - Server - RSC - default": "As a general rule, if a component can be a Server Component, it should be a Server Component.",
  "Logic - Server - RSC - Operation - Identification - Imports": "React also allows you to explicitly specify whether a component should be treated as a Server Component or a Client Component using import statements.",
  "Logic - Server - RSC - Operation - Invocation - caching": "Component-Level Caching: Cache the output of individual components.",
  "Logic - Server - RSC - Operation - Invocation - State - Passing": "Data flows only from RSCs to CCs, meaning Client Components cannot directly modify or pass state back to Server Components.",
  "Logic - Server - RSC - Operation - Invocation - State - Persist": "State Cannot Persist Across Server Renders. If an RSC needs updated state from a Client Component, the client must trigger a full re-fetch (e.g., via an API call or React’s useEffect).",
	"Logic - Server - RSC - Operation - Render": "RSC render at build time or for each request, reducing the workload on the client side and enhancing performance.",
  "Logic - Server - RSC - Operation - Render - stateless": "RSCs are stateless between requests.",
	"Logic - Server - RSC - Operation - Render - resources": "This allows us to do things like write database queries right inside our React components!.",
	"Logic - Server - RSC - Operation - Render - Types - server": "RSC can also run on a web server during a request for a page, letting you access your data layer without having to build an API. They are rendered before your application is bundled, and can pass data and JSX as props to Client Components.",
	"Logic - Server - RSC - Operation - Render - Types - no server": "RSC can run at build time to read from the filesystem or fetch static content, so a web server is not required. For example, you may want to read static data from a content management system.",
  "Logic - Server - RSC - Operation - Render - Identify - Files": "File extensions: .server.js, .server.jsx, .server.ts, or .server.tsx.",
  "Logic - Server - RSC - Operation - Render - Identify - Imports": "React also allows you to explicitly specify whether a component should be treated as a Server Component or a Client Component using import statements.",
	"Logic - Server - RSC - Operation - Render - async": "You can mark an RSC as async and use await to fetch data before rendering the component. When you await in an async component, React will suspend and wait for the promise to resolve before resuming rendering. This works across server/client boundaries with streaming support for Suspense.",
  "Logic - Server - RSC - Operation - Render - caching": "Data-Level Caching: Cache the results of data fetches (e.g., API responses or database queries).",
  "Logic - Server - RSC - Operation - Render - caching - stale": "Preventing Stale Data: Use cache invalidation (time-based or event-based). Implement versioning and manual cache clearing. Use revalidation strategies (e.g., stale-while-revalidate). Leverage framework-specific caching mechanisms.",
	"Logic - Server - RSC - Operation - Render - Rerender": "RSCs leverage React's reconciliation algorithm to determine which parts of the component tree need to be re-rendered. Only the components that depend on the changed data are re-rendered on the server.",
	"Logic - Server - RSC - Operation - Render - Dependencies": "If a React Server Component (RSC) tries to render a third-party library that expects a browser environment, it will likely cause errors or unexpected behavior. This is because RSCs are rendered on the server, where browser-specific APIs (e.g., window, document, localStorage) and features (e.g., DOM manipulation) are not available.",
	"Logic - Server - RSC - Operation - Streaming": "RSC supports streaming, allowing the server to send parts of the UI to the client as they are rendered, improving time-to-interactive (TTI).",
	"Logic - Server - RSC - Operation - Streaming - renderToPipeableStream": "These utilities serialize the rendered output and send it to the client in chunks.",
	"Logic - Server - RSC - Operation - Streaming - HTTP": "The server uses HTTP/1.1 chunked transfer encoding or HTTP/2 streaming to send the rendered chunks to the client.",
	"Logic - Server - RSC - Operation - Streaming - serialized": "The rendered output of RSCs is serialized into a lightweight format (e.g., JSON or a custom format) that can be efficiently sent over the network.",
	"Logic - Server - RSC - Operation - Streaming - serialized - props": "Props passed from an RSC to a Client Component are serialized and sent to the client. The Client Component receives these props during hydration.",
	"Logic - Server - RSC - Operation - Streaming - chuncked": "The rendered output is split into chunks and sent to the client over the network using HTTP streaming. Each chunk is a piece of the rendered HTML or serialized component data.",
	"Logic - Server - RSC - Operation - Streaming - partial": "RSC enables partial rendering of components, meaning only the necessary parts of the UI are sent to the client.",
  "Logic - Server - RSC - Operation - Hidration": "Hydration is the process of attaching event listeners and making a server-rendered HTML page interactive.",
  "Logic - Server - RSC - Operation - Hidration - hidrateRoot": "The client uses hydrateRoot to hydrate the streamed components, attaching event listeners and making them interactive.",
  "Logic - Server - RSC - Operation - Hidration - bundle": "Zero Bundle Size: JavaScript code is not sent to the client, reducing the bundle size.",
  "Logic - Server - RSC - Operation - Hidration - static": "RSC don't rehydrate to the client. They don't send their component javascript code to the client at all.",
  "Logic - Server - RSC - Operation - Hidration - noInteractive": "The results of a server component (HTML and other meta data) sit on the client statically without your component code being there in the client.",
  "Logic - Server - RSC - Operation - Hidration - stateless": "Therefore they can't have state or JavaScript events.",
  "Logic - Server - RSC - Operation - Hidration - incremental": "Hydration is incremental, meaning only the updated parts of the UI are hydrated.",
  "Logic - Server - RSC - Operation - Hidration - Benefits - Performance": "By re-rendering only the affected components, RSCs reduce unnecessary work and improve performance.",
  "Logic - Server - RSC - Operation - Hidration - Benefits - UserExperience": "Incremental updates make the application feel more responsive, as only the necessary parts of the UI are updated.",
  "Logic - Server - RSC - Operation - Hidration - Benefits - Resources": "Streaming and selective re-rendering ensure that server and client resources are used efficiently.",
  "Logic - Server - RSC - Operation - Hidration - Benefits - Security": ".",
  "Logic - Server - RSC - Operation - Hidration - Benefits - TTL": "This reduces the time-to-interactive (TTI) and improves the perceived performance of the application.",
	"Logic - Server - RSC - Operation - Integration": "RSC can work alongside client-side components, enabling a hybrid approach where some parts of the UI are rendered on the server and others on the client.",
	"Logic - Server - RSC - Operation - Integration - javascript": "Only the JavaScript for Client Components is sent to the client, while the JavaScript for RSCs remains on the server.",
	"Logic - Server - RSC - Operation - Integration - interactive": "Client Components are responsible for handling interactivity and client-side logic, while RSCs handle static or server-rendered content.",
	"Logic - Server - RSC - Operation - Integration - interactive -  EventListeners": "Client Components can include event listeners (e.g., onClick, onChange) that are attached during hydration.",
	"Logic - Server - RSC - Operation - Integration - APIcalls": "Since the data is fetched on the server, Client Components do not need to make their own API calls. The fetched data is passed to Client Components as props, making them purely presentational.",
	"Logic - Server - Functions - ServerFunctions": "Server Functions are asynchronous functions that are executed on the server. They can be used in Server and Client Components to handle form submissions",
  "Logic - Server - Functions - ServerFunctions - ServerActions": "Until September 2024, we referred to all Server Functions as “Server Actions”.",
	"Logic - Server - Functions - ServerFunctions - howto - xyzAction.ts": "Name by default.",
  "Logic - Server - Functions - ServerFunctions - howto - _actions": "By convention defined inside _actions folder inside /app.",
  "Logic - Server - Functions - ServerFunctions - howto - use server": "The 'use server' directive is used to mark ServerFunctions.",
  "Logic - Server - Functions - ServerFunctions - howto - async": "Name by default.",
  "Logic - Server - Functions - ServerFunctions - Usage": "",
  "Logic - Server - Functions - ServerFunctions - Usage - attaching - props": "Server Actions can be created in Server Components and passed as props to Client Components. Server Components can define Server Actions with the 'use server' directive",
  "Logic - Server - Functions - ServerFunctions - Usage - useEffect - direct": "You cannot directly call a ServerFunctions inside useEffect. Since ServerFunctions run on the server, calling them inside useEffect (which runs in the browser) will cause an error if directly used. You must wrap the Server Function in a Client Component and call it via fetch().",
  "Logic - Server - Functions - ServerFunctions - Usage - useEffect - fetch": "Works inside useEffect because it now calls an API endpoint instead of a ServerFunctions directly.",
  "Logic - Server - Functions - ServerFunctions - Usage - EventHandler - direct": "You can call a ServerFunctions inside an event handler.",
  "Logic - Server - Functions - ServerFunctions - Usage - EventHandler - useTransition": "use useTransition for React's Server Actions",
  "Logic - Server - Functions - ServerFunctions - Usage - Forms - ServerActions": "ServerActions",
  "Logic - Server - Functions - ServerFunctions - Usage - FullStack": "React, with its addition of Server Components and Server Actions, is evolving into a full-stack framework. Once the most popular frontend framework, it has now successfully bridged the gap between frontend and backend to reign over both sides of the chasm.",
	"Logic - Server - Functions - ServerFunctions - call": "This means that it isn’t just a function call: there is actually an HTTP request made to the API to call the function.",
  "Logic - Server - Functions - ServerFunctions - call - serializable": "Server actions are an abstraction that hides the complexity of the network calls and the data serialization/parsing.",
  "Logic - Server - Functions - ServerFunctions - call - developer": "As a developer I just write a function that I can call on the server and I can write tests for it, but React does a lot of heavy lifting to create the illusion that I’m “just calling a function” from the client to be executed on the server.",
  "Logic - Server - Functions - ServerFunctions - call - RPC": "Server actions offer a remote procedure call (RPC) pattern for Next.js applications.",
  "Logic - Server - Functions - ServerActions": "Used for Forms",
  "Logic - Server - Functions - ServerActions - ServerFunction": "They are ServerFunctions.",
  "Logic - Server - Functions - ServerActions - Usage": "passed to a form action prop or called from inside a form action or from useActionState",
  "Logic - Server - Functions - ServerActions - Usage - formAction": "You can pass a ServerActions to a Form to automatically submit the form to the server: import {updateName} from './actions'; const submitAction = async () => { startTransition(async () => { const {error} = await updateName(name); ... } < form action={submitAction} > ... < form >",
  "Logic - Server - Functions - ServerActions - Usage - fromFormAction": "ServerActions can be called from form Actions on the client: import {updateName} from './actions'; < form action={updateName} > ... < form > ",
  "Logic - Server - Functions - ServerActions - Usage - fromFormAction - Composing": "Server Actions can be composed with Actions on the client.",
  "Logic - Server - Functions - ServerActions - Usage - useActionState": "You can call Server Functions with useActionState for the common case where you just need access to the action pending state and last returned response: import {updateName} from './actions'; < form action={submitAction} > ... < form >     const [, submitAction] = useActionState(updateName, null, `/name/update`);",
	"Logic - Async": "",
	"Logic - Async - Actions": "React 19. Actions streamline the process of handling form submissions and other async tasks, making your code cleaner and more maintainable.",
	"Logic - Async - use": "React 19. React's use API is still in experimental mode. It allows you to pass a Promise from a Server Component to a Client Component and resolve it in the Client Component.",
	"Logic - Async - useAsyncScript": "React 19. You can now render async scripts within any component, with React handling deduplication. This ensures that scripts are loaded efficiently without redundancy.",

  "CI - Packaging": "SECTION",
	"CI - Packaging - Arch - Patterns - Base UI Component": "",
  "CI - Packaging - Arch - Patterns - Base UI Component - BaseUI": "https://baseweb.design/",
  "CI - Packaging - Arch - Patterns - Inheritance": "No use",
  "CI - Packaging - Arch - Patterns - Composition": "",
  "CI - Packaging - Arch - Patterns - Compound": "The Compound Components pattern isn’t just a coding technique; it’s a design paradigm that promotes collaboration between components while maintaining loose coupling. Recognizing its value involves understanding the use of static properties, which resemble dot notation for accessing nested components within a parent component. https://medium.com/@khushi1399gupta/mastering-reacts-compound-components-a-guide-for-experienced-developers-8a35c1468acb",
	"CI - Packaging - Arch - Patterns - Layout": ".",
	"CI - Packaging - Arch - Patterns - Layout - Layout pattern": "The main idea behind the Layout component pattern is that components should not know where they are being displayed, and Layout components should only be concerned with displaying the component.",
  "CI - Packaging - Arch - Patterns - Adapter": "The Adapter Pattern allows incompatible interfaces to work together. It converts the interface of a class into another interface clients expect. This pattern is often used to make existing classes work with others without modifying their source code.",
  "CI - Packaging - Arch - Patterns - Repository": "The Repository Pattern abstracts the data layer, providing a collection-like interface for accessing domain objects. It mediates between the domain and data mapping layers, acting like an in-memory domain object collection.",
	"CI - Packaging - Arch - Patterns - ContainerPresenter": "The Container-Presenter Pattern (also known as Smart and Dumb Components) is a fundamental pattern that helps you separate concerns in your React components. The basic idea is to split components into two categories: containers (which handle data fetching, state management, and logic) and presenters (which focus solely on rendering the UI).",
	"CI - Packaging - Arch - Patterns - Higher-Order Components": "A Higher-Order Component (HOC) is a pattern where you take a component and return a new component with added functionality. HOCs are useful for reusing component logic, such as handling authentication, logging, or theming, without modifying the original component’s behavior.",
	"CI - Packaging - Arch - Patterns - RenderProps": "The Render Props pattern is a technique where a component takes a function as a prop and uses it to render JSX. This pattern allows for better flexibility and reuse of logic within components. It’s particularly useful for cases where you need to share behavior between components but don’t want to use an HOC.",
	"CI - Packaging - Arch - Patterns - CustomHooks": "With the rise of hooks, Custom Hooks have become a go-to pattern for reusing stateful logic. Custom hooks allow you to encapsulate stateful behavior and reuse it across different components without duplicating code. If you find yourself repeating logic across components, it’s often a sign that you can extract it into a custom hook.",
	"CI - Packaging - Optimization - CodeReduction - Resources - Lists": "Virtualize Large Lists with react-window or react-virtualized. Rendering thousands of DOM elements at once slows down performance. Virtualization only renders visible items.",
	"CI - Packaging - Optimization - CodeReduction - Resources - Lists - windowing": "List visualization, or windowing, involves rendering only the items currently visible on the screen. When dealing with a large number of items in a list, rendering all the items at once can lead to slow performance and consume a significant amount of memory. List virtualization tackles this issue by rendering only a subset of the list items currently visible within the view, which conserves resources as the users scroll through the list.",
  "CI - Packaging - Optimization - CodeReduction - Resources - Lists - windowing - virtualization": "The virtualization technique dynamically replaces rendered items with new ones, keeping the visible portion of the list updated and responsive. It efficiently allows you to render large lists or tabular data by only rendering the visible portion, recycling components as needed, and optimizing scroll performance. There are different approaches to implementing list visualization in React, and one is using a popular library called React Virtualized.",
  "CI - Packaging - Optimization - CodeReduction - Resources - Lists - windowing - UniqueKeys": "When rendering lists, always provide unique keys to help React identify which items have changed, added, or removed. This can prevent unnecessary re-renders and improve overall performance.",
  "CI - Packaging - Optimization - CodeReduction - Resources - Lists - windowing - BatchUpdates": "Utilize React's batched updates mechanism to minimize the number of re-renders when updating lists. By batching multiple updates into a single render pass, you can optimize performance and ensure a smoother user experience.",
  "CI - Packaging - Optimization - CodeReduction - Resources - Lists - windowing - Libs - react-window": "Lightweight virtualization for large lists (best for fixed-size items).",
  "CI - Packaging - Optimization - CodeReduction - Resources - Lists - windowing - Libs - react-virtualized": "More advanced virtualization (supports variable-sized items, grids, etc.).",
  "CI - Packaging - Optimization - CodeReduction - Resources - Lists - Pagination": "Instead of rendering thousands of items at once, pagination loads items in smaller chunks. Infinite scrolling loads more data as the user scrolls. Helps reduce the initial load time..",
  "CI - Packaging - Optimization - CodeReduction - Resources - Lists - Pagination - Libs - react-query": "Fetching and caching data efficiently (great for pagination & infinite scroll).",
  "CI - Packaging - Optimization - CodeReduction - Resources - Lists - Memoization": "If list items are re-rendering unnecessarily, use: React.memo() or useMemo()",
  "CI - Packaging - Optimization - CodeReduction - Resources - Lists - Memoization - Libs - reselect": "Optimizes Redux selectors to prevent unnecessary computations.",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - React.lazy": "",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - React.lazy - components": "React.lazy is a feature that allows you to lazily load components, meaning they are loaded only when needed. const lazyComponent = React.lazy(() => import('./HeavyCoponent));",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - React.lazy - modules": "For larger applications, you can lazy load entire feature modules (e.g., a dashboard, settings, or admin panel). This involves dynamically importing not just a single component but an entire set of components, services, and utilities related to a feature.",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - React.lazy - routes": "For applications with multiple routes, you can lazy load entire routes using React.lazy and React Router.",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - Suspense - React16.6.0": "It suspends rendering while waiting for data to load, and shows a fallback UI (like a loading spinner) instead of blocking the entire app.",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - Suspense - fallback": "Suspense is a component that can be used to define a fallback UI while the lazily loaded component is being loaded.",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - Suspense - datasources": "The Suspense documentation insists that the only way of using Suspense is via 'Suspense-enabled frameworks'.",
	"CI - Packaging - Optimization - CodeSplitting - Loading - Lazy - Imports - Dynamic - ServerComponents": "React Server Components (RSCs) are designed to work seamlessly with dynamic imports, allowing you to load components or libraries asynchronously. Can use Suspense.",
	"CI - Packaging - Optimization - CodeFetching - PreLoading": "React v19 allows developers to preload resources using various strategies like prefetchDNS, preconnect, preload, and preinit. This ensures that critical resources are loaded quickly, improving performance.",
	"CI - Packaging - Optimization - CodeFetching - PreLoading - prefetchDNS": "React 19. ",
	"CI - Packaging - Optimization - CodeFetching - PreLoading - preconnect": "React 19. ",
	"CI - Packaging - Optimization - CodeFetching - PreLoading - preload": "React 19. ",
	"CI - Packaging - Optimization - CodeFetching - PreLoading - preinit": "React 19. ",

  "CI - Building": "SECTION",
	"CI - Building - Compilation - Type - ByPlace - SSR": "With Streaming SSR, React can send parts of the UI to the client as they’re ready, instead of waiting for the whole page to finish rendering. This helps reduce load times and gives a faster Time-to-Interactive.",
	"CI - Building - Compilation - Type - ByPlace - SSR - Steps - ClientComponents": "On SSR, Client Components are rendered at servier side to static HTML (no interactivity).",
	"CI - Building - Compilation - Type - ByPlace - SSR - Steps - ServerComponents": "Server Components fully executed on server.",
	"CI - Building - Compilation - Type - ByPlace - SSR - Steps - Hydration": "On the client, React 'revives' the component (attaches event handlers, state, etc.). Hydration is required to make them interactive.",
	"CI - Building - Compilation - Type - ByPlace - SSR - Steps - Post-Hydration": "The component runs fully on the client (useState, useEffect, etc., work as usual).",
	"CI - Building - Compilation - Type - ByPlace - SSR - Limitations - NoBrowserAPIs": "window, document, or localStorage will error during SSR.",
	"CI - Building - Compilation - Type - ByPlace - SSR - Limitations - NoInteractiveHooks": "useState, useEffect, etc., are ignored in SSR output (but hydrate later).",
	"CI - Building - Compilation - Type - ByPlace - SSR - RSC": "React Server Components (RSCs) are the true SSR-only components (no client JavaScript).",
  "CI - Building - FastRefresh - React19": "React 19 has turbocharged the development process with an even faster refresh. Your changes appear instantly without losing the component state.",
  "CI - Building - production": "Make sure to test any performance issues you may be seeing with your React apps using the production build's minified version.",
  "CI - Building - Tools - JSX - transpilation": "JSX allows you to write HTML-like code in your JavaScript. It gets transpiled by a tool like Babel to JavaScript before being rendered in the browser..",
  "CI - Building - Tools - JSX - transpilation - Babel": "Browsers don’t understand JSX out of the box, so most React users rely on a compiler like Babel or TypeScript to transform JSX code into regular JavaScript.",
	"CI - Building - Tools - ReactForget": "React 19 and the ReactCompiler, previously known as ReactForget",
	"CI - Building - Tools - ReactCompiler": "",
  "CI - Building - Tools - ReactCompiler - plugAndPlay": "The Compiler is plug-and-play: you install it, and it Just Works; there is no need to rewrite existing code.",
  "CI - Building - Tools - ReactCompiler - ReactCompilerConfig": "https://jherr2020.medium.com/react-compiler-with-react-18-1e39f60ae71a",
  "CI - Building - Tools - ReactCompiler - memoization - automemoization - React19": "One of the standout features of React 19 is its ability to handle memoization automatically. Previously, developers had to use useMemo and useCallback to manually optimize component re-renders. With React 19, these concerns are handled under the hood, reducing the need for manual intervention.",
  "CI - Building - Tools - ReactCompiler - memoization - manual": "While the compiler may provide impressive optimizations, there are still situations where manual memoization might be necessary.",
	"CI - Building - Tools - Bit": "Bit is a next-generation building system that develops composable software. https://bit.dev/",

  "CI - Integration": "SECTION",
	"CI - Integration - Execution - Scopes - Block": "Block scope: The context inside of a pair of curly braces (only applies to variables created with const and let).",
	"CI - Integration - Execution - Scopes - Function": "Function scope: The context within a JS-function.",
	"CI - Integration - Execution - Scopes - Component": "Component scope: The context inside a functional or class component.",
	"CI - Integration - Execution - Scopes - Module": "Module scope: The context for code running inside a JavaScript (JS), JSX, TypeScript (TS), or TSX file.",
	"CI - Integration - Security - XSS - JSX": "By default, React DOM escapes any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that’s not explicitly written in your application. Everything is converted to a string before being rendered. This helps prevent XSS (cross-site-scripting) attacks.",
	"CI - Integration - Security - XSS - dangerouslySetInnerHTML": "Using dangerouslySetInnerHTML bypasses React’s built-in protections and can introduce XSS vulnerabilities. If you must use dangerouslySetInnerHTML (e.g., rendering HTML from a CMS), always sanitize the input before rendering.",
	"CI - Integration - Security - XSS - EventHandlers": "React does not automatically sanitize event handler values, so avoid inserting untrusted user input into JavaScript code.",
	"CI - Integration - Security - XSS - URL-Based": "When using URLs in attributes like href, ensure user input doesn’t allow JavaScript execution.",
	"CI - Integration - Security - XSS - CSP": "Even if React escapes content, a misconfigured app may still be vulnerable. Use Content Security Policy (CSP) headers to block inline scripts.",

  "CI - Testing": "SECTION",
	"CI - Testing - Jest": ".",
	"CI - Testing - ReactTestingLibrary": "React Testing Library is not an alternative to Jest, because they need each other and every one of them has a clear task.",

  "CD - Monitor": "SECTION",
	"CD - Monitor - Profiling - ReactDevTools": "React Developer Tools. Use React Developer Tools to inspect React components, edit props and state, and identify performance problems.",
  "CD - Monitor - Profiling - ReactDevTools - useDebugValue": "useDebugValue is a React Hook that lets you add a label to a custom Hook in ReactDevTools. useDebugValue(value, format?)",
  "CD - Monitor - Profiling - ReactDevTools - ReactProfiler": "The React Profiler is a tool that comes with the React Developer Tools extension. It allows you to measure and analyze the rendering performance of your components. The React Profiler lets you identify components that take longer to render and detect potential performance bottlenecks."

}