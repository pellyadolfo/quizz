{
  "ReactJS": "SECTION",
  "ReactJS - Feb2010": "2010 - the genesis for React came from an extension of PHP that Facebook had released as open source software in February 2010, called XHP.",
  "ReactJS - 2010": "2010 - However, because it was PHP — a server-side language — every time something changed, the page would need to re-render completely. So the Facebook team decided to move a lot of the application logic of XHP into JavaScript. Jordan Walke, a software engineer at Facebook, created an early prototype of React. js called 'FaxJS.'",
  "ReactJS - 2011": "2011 - An early prototype of React. Jordan Walke created FaxJS, the early prototype of React - shipped a search element on Facebook.",
  "ReactJS - 2012": "2012 - Something new had started at Facebook",
  "ReactJS - 2013": "2013 - The year of the Big Launch",
  "ReactJS - 2014": "2014 - The year of Expansion",
  "ReactJS - 2015": "2015 - React is Stable",
  "ReactJS - 2016": "2016 - React gets mainstream",
  "ReactJS - 2017": "2017 - The year of further improvements",
  "ReactJS - 2018": "",
  "ReactJS - 2019": "",
  "ReactJS - 2020": "",
  "ReactJS - 2021": "",
  "ReactJS - 2022": "",
  "ReactJS - 2023": "",
  "ReactJS - 2024": "",

  "BuildingBlocks": "SECTION",
  "BuildingBlocks - Components - CreateClass - ES5 - 2013": "Deprecated. Everything started out with React's createClass Components. The createClass method provided developers with a factory method to create React class components without using a JavaScript class. It was the status quo for creating React components prior JavaScript ES6, because in JavaScript ES5 there was no class syntax available. const MyComponent = React.createClass({ render() { return <p>I am a component!</p>; } });",
  "BuildingBlocks - Components - CreateClass - deprecated": "React's createClass method is no longer available in the React core package. If you want to try it, you have to install an additional node package: npm install create-react-class. After all, you should only use React's createClass method, if you have no JavaScript ES6 or beyond available in your project. Otherwise you should avoid using it. ",
  "BuildingBlocks - Components - CreateClass - methods - getInitialState": "the getInitialState() function is used to set an initial state for the React component",
  "BuildingBlocks - Components - CreateClass - methods - render": "the mandatory render() method is there to display the output with JSX",
  "BuildingBlocks - Components - CreateClass - methods - onChange": "Additional methods (e.g. onChange()) are added by passing more functions to the object.",
  "BuildingBlocks - Components - CreateClass - Lifecycle - componentDidUpdate": "Lifecycle methods for side-effects are available as well. For instance, in order to write every time the value from the input field to the browser's local storage, we could make use of the componentDidUpdate() lifecycle method by passing a function to the object with an object key named after a React lifecycle method.",
	"BuildingBlocks - Components - Class - ES6 - 2015": "They have a more feature-rich API, including state and lifecycle methods.- They are used when you need to manage the component’s state or lifecycle events.",
	"BuildingBlocks - Components - Class - deprecated": "Probably never need to use a Class component in React anymore. Even though Function components are preferred, there are no current plans on removing Class components from React",
  "BuildingBlocks - Components - Class - React.Component": "Class components are ES6 classes that extend from `React.Component`.",
  "BuildingBlocks - Components - Class - React.PureComponent": "React.PureComponent is similar to React.Component . The difference between them is that React.Component doesn't implement shouldComponentUpdate(). React.PureComponent is a base component class that checks the fields of state and props to know whether the component should be updated. React.PureComponent optimizes our components by reducing the number of wasted renders.",
  "BuildingBlocks - Components - Class - Structure": "You want to have a clear structure in components so you can navigate through them quickly and have a pattern that is obvious to other engineers: 1- State declarations, 2 - Ref declarations, 3 - Memoized values, 4 - Memoized callbacks, 5 - Custom hooks, 6 - Effects, 7 Event handler, 8- JSX",
  "BuildingBlocks - Components - Class - this": "React will not auto-bind your functions within components. However, you may manually achieve the binding. Here are some ways to bind your components and functions: Bind in render, Allow arrow function in render, Bind in constructor, Bind arrow function in the class property [Not in official ECMAscript]",
  "BuildingBlocks - Components - Class - render()": "renders JSX",
	"BuildingBlocks - Components - Class - Lifecycle - ": "These methods are called in the following order when an instance of a component is being created and inserted into the DOM.",
	"BuildingBlocks - Components - HOC": "A HOC is a function that takes a component and returns an enhanced component.",
	"BuildingBlocks - Components - HOC - Structure - HOF": "Higher-Order Components (HOC) stem from the concept of Higher-Order Functions (HOF) which is called this way whenever it takes a function as argument or returns a function with its return statement.",
	"BuildingBlocks - Components - HOC - Structure - Composition": "Higher-Order Components is that they are just functions which allow you to split functionality into multiple functions.",
	"BuildingBlocks - Components - Functional": "Functional components are JavaScript functions that take in props as parameters and return React elements.",
	"BuildingBlocks - Components - Functional - Features - Stateless - React <16.8": "Before React Hooks were introduced (React 16.8 in 2019) They were stateless and could not use lifecycle methods like componentDidMount. ",
	"BuildingBlocks - Components - Functional - Features - Code": "less code",
	"BuildingBlocks - Components - Functional - Features - Performance": "better performance",
	"BuildingBlocks - Components - Functional - Features - Lifecycle": "No unnecessary lifecycle methods running.",
	"BuildingBlocks - Components - Functional - Features - Test": "easier to test",
	"BuildingBlocks - Components - Functional - Features - Dumb": "Since they were purely functions with no state or side effects, they were sometimes called 'dumb' components.",
	"BuildingBlocks - Components - Functional - Lifecycle - No Constructor": "First of all, you have no constructor in a Function Component. Usually the constructor would have been used in a React Class Component to allocate initial state. As you have seen, you don't need it in a Function Component, because you allocate initial state with the useState hook and set up functions within the Function Component for further business logic",
	"BuildingBlocks - Components - Functional - Lifecycle - Simulate Mount": "there is the mounting lifecycle for React components when they are rendered for the first time. If you want to execute something when a React Function Component did mount, you can use the useEffect hook: https://www.robinwieruch.de/react-function-component/#react-arrow-function-component",
	"BuildingBlocks - Components - Functional - Lifecycle - Update": "Every time incoming props or state of the component change, the component triggers a rerender to display the latest status quo which is often derived from the props and state. A render executes everything within the Function Component's body.",
	"BuildingBlocks - Components - Functional - Lifecycle - Rerender": "React memo -- which is one of React's top level APIs -- can be used for React Function Components to prevent a rerender when the incoming props of this component haven't changed:",
	"BuildingBlocks - Components - Functional - Lifecycle - ref": "React Function Components cannot be given refs! If you try the following, the ref will be assigned to the component instance but not to the actual DOM node.",
	"BuildingBlocks - Components - Functional - Arrow Function": "With the introduction of JavaScript ES6, new coding concepts were introduced to JavaScript and therefore to React. For instance, a JavaScript function can be expressed as lambda (arrow function). That's why a Function Component is sometimes called Arrow Function Components (or maybe also Lambda Function Component). const App = () => { ... };",
	"BuildingBlocks - Components - Function": "React Hooks rebranded Functional to Function Components.",
	"BuildingBlocks - Components - Function - Features - Preferred": "Function components are now the preferred way to build React apps because they are simpler, easier to read, and work well with Hooks.",
	"BuildingBlocks - Components - Function - Features - Statefull": "React Hooks bring state and side-effects to React Function Components.",
	"BuildingBlocks - Components - Function - Features - Powerfull": "They can use state (useState) and side effects (useEffect), making them just as powerful as class components..",
	"BuildingBlocks - Components - Function - Features - Cache": "Hooks let you optimize re-renders easily (useMemo, useCallback).",
  "BuildingBlocks - Components - Function - Lifecycle - Hooks": "Before React 16.8, Class components were the only way to track state and lifecycle on a React component. With the addition of Hooks, Function components are now almost equivalent to Class components.",
	"BuildingBlocks - Components - Function - vs Class - Performance": "Functional components with React hooks are generally more performant, but they require memoization in some cases.",
	"BuildingBlocks - Components - Function - vs Class - Lifecycle": "Hooks replace lifecycle methods with a single, flexible API (useEffect).",
	"BuildingBlocks - Components - Function - vs Class - Calls": "Functional components use useEffect, which is easier to manage. All side effects are in one place. Easy cleanup (e.g., return () => unsubscribe()).",
	"BuildingBlocks - Components - Function - vs Class - ErrorBoundaries": "Functional components cannot be used as error boundaries because hooks cannot catch errors in child components.",
	"BuildingBlocks - Router - ReactRouter": "React Router is the perfect tool to link together the URL and your React app. React Router is the de-facto React routing library, and it's one of the most popular projects built on top of React. We can use ReactRouter with Suspense for LazyLoading.",
	"BuildingBlocks - Router - TanStackRouter": "",
	"BuildingBlocks - Router - Vike": "https://javascript.plainenglish.io/exploring-vike-vites-new-micro-frontend-framework-and-how-it-compares-with-other-major-tools-3acad4fa3fc4",

  "Data": "SECTION",
  "Data - Components - Props": "React components use props to communicate with each other.",
  "Data - Components - Props - Syntax": "React Props are like function arguments in JavaScript and attributes in HTML. Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, and functions.",
  "Data - Components - Props - Syntax - quotes": "You may use quotes to specify string literals as attributes: const element = <a href='https://www.reactjs.org'> link </a>;",
  "Data - Components - Props - Syntax - curly braces": "You may also use curly braces to embed a JavaScript expression in an attribute: const element = <img src={user.avatarUrl}></img>;.",
	"Data - Components - Props - Syntax - spreading": "<div {...props}>{props.text}</div> should avoid spreading properties into a DOM element as it adds unknown HTML attribute, which is unnecessary and a bad practice.",
	"Data - Components - Props - Types - TypeScript - Define - Object - Type": "Props should have a TypeScript interface or type alias.",
	"Data - Components - Props - Types - TypeScript - Define - Object - Interface": "Props should have a TypeScript interface or type alias.",
	"Data - Components - Props - Types - TypeScript - Define - Function": "If a component receives a function as a prop, you must define the function's parameters and return type.",
	"Data - Components - Props - Types - TypeScript - Define - Array": "Use Array<T>.",
	"Data - Components - Props - Types - TypeScript - Define - List": "Use T[].",
	"Data - Components - Props - Types - TypeScript - Define - FlexibleTypes": "Using Generics for Flexible Prop Types Generics allow components to accept different data types dynamically.",
	"Data - Components - Props - Types - TypeScript - Define - FlexibleProps": "Defining Union Types for Flexible Props. If a prop can accept multiple types, use a union (|).",
	"Data - Components - Props - Types - TypeScript - Define - Default": "src = 'default.png'",
	"Data - Components - Props - Types - TypeScript - Define - Optional": "Props can be optional using ?: src?: string;",
	"Data - Components - Props - Types - TypeScript - Define - Children": "Defining Props for Components with Children. If a component accepts children, use React.ReactNode.",
	"Data - Components - Props - Types - TypeScript - Define - Generics": "Use generics when prop types are dynamic.",
	"Data - Components - Props - Types - TypeScript - Define - Nested": "For deeply nested objects, define separate interfaces.",
	"Data - Components - Props - Default - defaultValues": "const Button: React.FC<ButtonProps> = ({ label = 'Click me', color = 'blue' }) => { ... } for Functional components (best approach)",
	"Data - Components - Props - Default - defaultProps": "defaultProps (for class components) static defaultProps: Partial<ButtonProps> = { label: 'Click me', color: 'blue', }; for Class components (legacy)",
	"Data - Components - Props - Default - ??": "?? (nullish coalescing) operator. return <button>{props.label ?? 'Click me'}</button>; Handling defaults inline",
	"Data - Components - Interaction - ParentToChild - Props - Process": "The component receives the argument as a props object. Every parent component can pass some information to its child components by giving them props. Passing props from component to component in React doesn't make components interactive, because props are read-only and therefore immutable. Props are the information that you pass to a JSX tag. ",
	"Data - Components - Interaction - ParentToChild - Props - Forwarding": ".",
	"Data - Components - Interaction - ParentToChild - Props - Drilling": "At some point, you are passing a lot of props down your component tree. Depending on the depth of the component tree, it can happen that many props are passed from a top level component to all the leaf components. Every component in between has to pass the props even though it may not be interested in the props. The problem is called prop drilling in React. The solution is Context.",
  "Data - Components - Interaction - ParentToChild - Props - taintObjectReference": "lets you prevent a specific object instance from being passed to a Client Component like a user object.",
  "Data - Components - Interaction - ParentToChild - Props - taintUniqueValue": "lets you prevent unique values from being passed to Client Components like passwords, keys, or tokens.",
	"Data - Components - Interaction - ChildToParent - Callback": "To send data from child to parent, pass a function as a prop. The child calls the function, and the parent gets the data.",
	"Data - Components - Interaction - AnyToAny": "Use State.",
	"Data - State ": "State generally refers to data or properties that need to be tracking in an application. State lets a component “remember” information like user input. If you want interactive React components, you have to introduce stateful values by using React State.",
	"Data - State - Structuring": "In React, when multiple components depend on the same state, React ensures that state updates trigger re-renders only for affected components. However, how efficiently React handles these updates depends on where the state is stored and how it's managed.",
	"Data - State - Structuring - cases - normalize": "Normalize State for Lists & Objects If storing large lists of data, normalize it to avoid deep nesting.",
	"Data - State - Structuring - cases - rerenders": "Avoid Unnecessary Re-renders Use Memoization (useMemo, useCallback) If a component re-renders too often due to prop changes, memoize values and functions.",
	"Data - State - Structuring - cases - single": "If only one component needs the state, keep it local (useState, useReducer).",
	"Data - State - Structuring - cases - complex": "Use useReducer for Complex State Logic. For state that involves multiple sub-values or actions, useReducer() is better than useState().",
	"Data - State - Structuring - cases - multiple": "If multiple components need the state, lift it up to a common parent.",
	"Data - State - Structuring - cases - globalSmall": "If state is needed globally, consider Context API, Redux, or Zustand. Use Context API for Global State (But With Caution) Best for: Auth, themes, user preferences. Avoid using for frequently changing state (causes re-renders in all consumers).",
	"Data - State - Structuring - cases - globalLarge": "For complex state that spans multiple components (e.g., shopping cart, user data), Redux or Zustand offers better scalability.",
	"Data - State - Threads - RaceConditions": "Race conditions occur when multiple asynchronous operations compete to update the state, leading to inconsistent or stale data. This is common in cases like API requests, user interactions, or real-time updates.",
	"Data - State - Threads - RaceConditions - useEffect": "If a component makes an API request but unmounts before it completes, React may try to update state on an unmounted component, causing errors. Solution: Use AbortController to cancel the fetch request when the component unmounts or when a new request is made.",
	"Data - State - Threads - RaceConditions - StateVersioning": "If multiple API calls are made, a slower previous response might overwrite a newer one. Solution: Use a version counter (useRef) to track the latest request and ignore outdated ones.",
	"Data - State - Threads - RaceConditions - ReduxMiddleware": "Best for: Managing complex async flows like debouncing, polling, or cancellation Solution: Redux-Saga (takeLatest) takeLatest ensures that only the latest request is processed—if a new request is made, the previous one is canceled.",
	"Data - State - Threads - RaceConditions - useTransition": "When users trigger multiple state updates quickly (e.g., searching), React may block UI updates while waiting for slow async calls. Solution: Use useTransition to mark updates as low-priority, allowing the UI to stay responsive.",
	"Data - State - Approaches": "",
  "Data - State - Approaches - BuiltIn - State - useState": "The React useState Hook allows us to track state in a function component.",
  "Data - State - Approaches - BuiltIn - State - useState - Types - TypeScript": "Use TypeScript generics to specify the state type. const [user, setUser] = useState<User>({ name: 'Alice', age: 25 });",
  "Data - State - Approaches - BuiltIn - State - useState - async": "React's useState hook is asynchronous because React batches state updates for performance optimization. If useState were synchronous, every state change would cause an immediate re-render.",
  "Data - State - Approaches - BuiltIn - State - SetState": "We recommend using a function and not an object in the setState function. React setState method is asynchronous. This means that rather than immediately mutating this.state, setState() creates a pending state transition. If you access this.state after calling this method, it would potentially return the existing value. To prevent this, use the callback function of setState to run code after the call is completed.",
	"Data - State - Approaches - BuiltIn - State - useSyncState - React19": "React 19 introduces useSyncState, a simplified and intuitive way to manage component state.",
	"Data - State - Approaches - BuiltIn - Reducer": "A reducer function takes the current state and an action with payload and computes it to a new state: (state, action) => newState.",
  "Data - State - Approaches - BuiltIn - Reducer - useReducer": "The useReducer Hook is similar to the useState Hook. useReducer(<reducer>, <initialState>). ",
  "Data - State - Approaches - BuiltIn - Reducer - useReducer - Types - State": "Defines the shape of the state. Define an interface for complex state",
  "Data - State - Approaches - BuiltIn - Reducer - useReducer - Types - Action": "Specifies what actions the reducer can handle. Use a union type for strict control over actions",
  "Data - State - Approaches - BuiltIn - Reducer - useReducer - Types - Reducer": "Accepts state and action and returns a new state. Ensure the return type matches the state",
  "Data - State - Approaches - BuiltIn - Reducer - useReducer - use - Complex": "Complex State Logic: When the state transitions involve multiple sub-values or depend on previous state.",
  "Data - State - Approaches - BuiltIn - Reducer - useReducer - use - Centralized": "Centralized Logic: When you want to encapsulate state update logic in a single place (the reducer function).",
  "Data - State - Approaches - BuiltIn - Reducer - useReducer - use - Predictable": "Predictable State Updates: When you need to enforce strict patterns for state updates (e.g., Redux-like patterns).",
  "Data - State - Approaches - BuiltIn - Reducer - useReducer - use - Shared": "Shared State: When multiple components need to interact with the same state logic.",
  "Data - State - Approaches - BuiltIn - Reducer - useReducer - vs useState": "This is the key difference between useState and useReducer: with useReducer, state is altered by passing messages rather than calling the updater function.",
	"Data - State - Approaches - BuiltIn - ReactContext": "React Context is a way to manage state globally. Context is designed to share data that can be considered 'global' for a tree of React components, such as the current authenticated user, theme, or preferred language. Context is not a good solution for state management in most cases. Built into React, requiring no additional libraries. Context lets a component receive information from distant parents without passing it as props.",
	"Data - State - Approaches - BuiltIn - ReactContext - howto - 1.createContext": "createContext lets you create a context that components can provide or read. type CartContextValues = { count: number; ... } }; export const CartContext = createContext<CartContextValues | null>(null); - https://medium.com/@samhodev/zustand-how-is-it-better-than-react-context-with-an-example-24dad4c65753",
	"Data - State - Approaches - BuiltIn - ReactContext - howto - 2.CreateProvider": "The CartContextProvider is a component that will wrap part of your component tree and provides the context value to all components within that tree. - export const CartContextProvider = ({children}: Props) => { return ( <CartContext.Provider value={{count, setCount, payTotal, subTotal, deliveryCost}}> {children}<CartContext.Provider>); } ",
  "Data - State - Approaches - BuiltIn - ReactContext - howto - 3.ApplyProvider": "Wraps our component tree with CartContextProviderto make the context available to child components. - export const ReactContextDemo = () => { return (<> <CartContextProvider>.../CartContextProvider></>);};",
  "Data - State - Approaches - BuiltIn - ReactContext - howto - 4.useContext": "To access the context value, use the useContext hook in our child component. It can be used together with the useState Hook to share state between deeply nested components more easily than with useState alone. - const cartContext = useContext(CartContext);",
	"Data - State - Approaches - BuiltIn - ReactContext - Use - React19": "React Context is still a valuable tool when used correctly. It’s well-suited for:",
  "Data - State - Approaches - BuiltIn - ReactContext - Use - Theming": "Theme Management: Managing UI themes across an application.",
  "Data - State - Approaches - BuiltIn - ReactContext - Use - Locale": "Locale Management: Handling localization and language settings.",
  "Data - State - Approaches - BuiltIn - ReactContext - Use - Authentication": "Authentication State: Providing user authentication status throughout your app.",
  "Data - State - Approaches - BuiltIn - ReactContext - Use - Routing": "Routing: Most routing solutions use context internally to hold the current route. This is how every link “knows” whether it’s active or not. If you build your own router, you might want to do it too.",
  "Data - State - Approaches - BuiltIn - ReactContext - Use - State": "Managing state: As your app grows, you might end up with a lot of state closer to the top of your app. Many distant components below may want to change it. It is common to use a reducer together with context to manage complex state and pass it down to distant components without too much hassle.",
  "Data - State - Approaches - BuiltIn - ReactContext - NoUse": "Large Applications with Complex State Management Needs:, High-Frequency State Updates, Cross-Cutting Concerns, Frequent Debugging Issues",
	"Data - State - Approaches - BuiltIn - ReactContext - NoUse - Renders": "There are unnecessary re-renders on the delivery component.",
	"Data - State - Approaches - BuiltIn - ReactContext - NoUse - Performance": "ReactContext can lead to performance bottlenecks, especially in large applications. When you update the context, every component that consumes that context will re-render, even if the part of the state they use hasn’t changed. This can significantly impact performance.",
  "Data - State - Approaches - BuiltIn - ReactContext - NoUse - Debug": "When state is scattered across various contexts, debugging becomes more complex. Understanding the flow of state and tracking down where and why certain updates occur can be challenging. Example: Imagine having multiple contexts like UserContext, ThemeContext, and SettingsContext. Debugging why a component re-rendered unexpectedly becomes a complex task as you need to check updates across all these contexts.",
  "Data - State - Approaches - BuiltIn - ReactContext - NoUse - Code": "Using ReactContext for state management can introduce a lot of boilerplate code. You need to set up the provider, create context objects, and ensure proper usage throughout the application. Every new context requires similar setup, which can quickly add up and clutter your codebase.",
  "Data - State - Approaches - BuiltIn - ReactContext - NoUse - Complex": "ReactContext is not inherently designed to handle complex state management tasks such as actions, reducers, or middleware. This limitation becomes apparent as your application grows and your state management needs become more complex.",
  "Data - State - Approaches - BuiltIn - ReactContext - NoUse - Testing": "Testing components that rely on React Context can be cumbersome. You often need to wrap your components with context providers, adding an extra layer of complexity to your tests.",
  "Data - State - Approaches - BuiltIn - ReactContext - Fix": "",
  "Data - State - Approaches - BuiltIn - ReactContext - Fix - Split": "Split Contexts by Concern (Minimize Unnecessary Re-renders) Instead of one big context, split context by separate concerns so consumers only re-render when needed.",
  "Data - State - Approaches - BuiltIn - ReactContext - Fix - Composition": "Use Composition Instead of Deep Nesting. Instead of deeply nesting contexts, group them into a single wrapper component.",
  "Data - State - Approaches - Libs - ReactTracked": "",
  "Data - State - Approaches - Libs - Zustand": "<b>Zustand is a single store similar to Redux</b>. A small, fast, and scalable state management library that provides a simpler API compared to Redux. https://medium.com/@samhodev/zustand-how-is-it-better-than-react-context-with-an-example-24dad4c65753",
	"Data - State - Approaches - Libs - Zustand - builtOn": "Zustand uses React's custom hook-based approach to handle Component state distribution.",
  "Data - State - Approaches - Libs - Zustand - howto - 1. Create Store.": "A 'store' in Zustand holds your application’s state. We create a store using the create function provided by Zustand, and define the cart state and actions. - interface CountState { ... }; export const useCartStore = create<CountState>((set) => ({ ... }));",
  "Data - State - Approaches - Libs - Zustand - howto - 2. Use Store.": "We can use the Zustand store in our components by calling the custom hook we exported from CartStore.tsx. We can also prevent unnecessary re-render using useShallow hook provided by Zustand. The component re-renders only when state.deliveryCost change  const { deliveryCost } = useCartStore( useShallow((state) => ({ deliveryCost: state.deliveryCost })) );",
	"Data - State - Approaches - Libs - Zustand - Use - State": "Use Zustand if you need simple, high-performance state management with minimal setup and are dealing with mostly global state",
  "Data - State - Approaches - Libs - Zustand - Use - Performance": "While React Context provide a simple native solution of passing states to child components, Zustand can offer better performance in some scenarios, such as the above scenario where components only re-renders to the specific pieces of state they use.",
  "Data - State - Approaches - Libs - Zustand - Use - Hooks": "works well with React’s hooks.",
  "Data - State - Approaches - Libs - Zustand - Use - SSR": "smooth SSR integration.",
  "Data - State - Approaches - Libs - Valtio": "Valtio is yet another library for global state. Unlike Zustand and Jotai, it's based on the mutating update model. It's primarily for module states like Zustand. It utilizes proxies to get an immutable snapshot, which is required to integrate with React.",
	"Data - State - Approaches - Libs - Flux": "Flux uses a unidirectional data flow pattern to solve state management complexity. Remember it is not a framework – rather it's more of a pattern that targets to solve the state management issue.",
  "Data - State - Approaches - Libs - Redux": "Centralizes state management using an event store, allowing easy tracking of all state changes, every change is immutable which serves as a single source of truth. Redux: Enforces One-way data flow. The flow starts from an action, dispatches changes to the store, and updates subscribed components.",
  "Data - State - Approaches - Libs - Redux - performance": "A well-known flaw faced by Yahoo is a classic example to consider when React apps are built with Redux. Indeed the combination is deadly and enables complex situations to structurize, but when you use Redux, your React app rerenders and slows down your performance.",
  "Data - State - Approaches - Libs - Redux - parts - Action": "Action: An action is dispatched, representing a change or event in the application.",
  "Data - State - Approaches - Libs - Redux - parts - Reducer": "Reducer: The reducer function takes the current state and the action, processes the update, and returns a new state. The state is immutable, so a new state object is created rather than modifying the existing state.",
  "Data - State - Approaches - Libs - Redux - parts - Store": "Store: The store holds the entire state tree of the application. When an action is dispatched and processed by the reducers, the store updates and notifies all components subscribed to it.",
  "Data - State - Approaches - Libs - Redux - parts - Component": "Component: Components subscribe to the store and react to state changes by re-rendering, ensuring the UI reflects the current state.",
  "Data - State - Approaches - Libs - Redux - useSelector": "Redux uses a centralized store and provides selectors (useSelector()) to subscribe only to specific slices of the state. It ensures only components using the updated part of the state will re-render.",
  "Data - State - Approaches - Libs - Redux - Middleware": "Redux middleware like redux-thunk and redux-saga helps manage asynchronous operations (like API calls) in a Redux application. Since Redux’s reducers must be pure functions (i.e., they can't perform side effects like fetching data), middleware acts as an interceptor between dispatching an action and reaching the reducer.",
  "Data - State - Approaches - Libs - Redux - Middleware - how": "A middleware function sits between the action dispatch and the reducer. When an action is dispatched, the middleware intercepts it. If the action is synchronous, it passes through as usual. If the action is asynchronous, the middleware handles it before passing the final result to the reducer.",
  "Data - State - Approaches - Libs - Redux - Middleware - redux-thunk": "",
  "Data - State - Approaches - Libs - Redux - Middleware - redux-saga": "",
  "Data - State - Approaches - Libs - EasyPeasy": "Easy Peasy is an abstraction of Redux, providing a reimagined API that focuses on developer experience. It allows you to quickly and easily manage your state, whilst leveraging the strong architectural guarantees and extensive eco-system that Redux has to offer. https://easy-peasy.vercel.app/",
  "Data - State - Approaches - Libs - Recoil": "A state management library from Facebook that offers fine-grained state management with a simpler API.",
  "Data - State - Approaches - Libs - Recoil - atoms": "Atoms contain the source of truth for our application state.",
  "Data - State - Approaches - Libs - Recoil - builtOn": "Using React's internal Context API, Recoil internally uses this API to propagate state updates to the subscribed Components.",
	"Data - State - Approaches - Libs - Jotai": "Jotai is a minimalistic state management library for React that focuses on atomic state",
	"Data - State - Approaches - Libs - Jotai - atoms": "<b>Jotai consists of primitive atoms that can be composed together</b>. It allows you to manage state in small, isolated pieces called atoms. When your application benefits from fine-grained control over state and you prefer managing state in small, isolated pieces. Use Jotai if you prefer atomic state management, need fine-grained control over state, or are dealing with scoped or dynamic state requirements.",
  "Data - State - Approaches - Libs - Mobx": "A library that makes state management simple and scalable through reactive state management.",
  "Data - State - Approaches - Libs - Mobx - observable": "Mobx applies concepts from Functional Reactive Programming and Object-Oriented design to automatically track changes to state and propagate updates. Mobx lets you create individual 'store' classes and mark specific fields as 'observable', then mark React components and other logic as 'observers'. You can directly modify those observables fields in your code, and Mox will transparently update any observer code that depends on those fields.",
  "Data - State - Approaches - Libs - Mobx - atoms": " Achieving this is pretty simple by using atoms, which is the class that MobX uses internally for all observable data types. Atoms can be used to signal to MobX that some observable data source has been observed or changed, and MobX will let the atom know when it's being used and when it's not.",
  "Data - State - Approaches - Libs - Nuqs": " ",
  "Data - State - Approaches - Libs - NanoStores": " ",
  "Data - State - Approaches - Libs - statemachine - XState": " ",
  "Data - State - Approaches - Libs - statemachine - Zag": " ",
	"Data - Inputs - Forms - < form >": "The built-in browser <form> component lets you create interactive controls for submitting information.",
	"Data - Inputs - Forms - < form > - Components - Types - Uncontrolled": "DOM (ref) Manages the State. Uncontrolled forms use the native, built-in <form> functionalities of vanilla HTML and JavaScript to manage data.",
	"Data - Inputs - Forms - < form > - Components - Types - Uncontrolled - how - input": "The DOM handles the input state instead of React.",
	"Data - Inputs - Forms - < form > - Components - Types - Uncontrolled - how - useRef": "Uses useRef to access the value when needed.",
	"Data - Inputs - Forms - < form > - Components - Types - Uncontrolled - Features - Rerender": "No re-renders on input changes (better performance for some cases).",
	"Data - Inputs - Forms - < form > - Components - Types - Controlled": "React Manages the State. Controlled forms store each input’s value in React state, and then set the value of each input on each re-render from that state.",
	"Data - Inputs - Forms - < form > - Components - Types - Controlled - how - input": "React fully controls the input value.",
	"Data - Inputs - Forms - < form > - Components - Types - Controlled - how - Hooks - useActionState": "React 19. Declare form state and degrade gracefully if JS hasn’t executed yet.",
	"Data - Inputs - Forms - < form > - Components - Types - Controlled - how - Hooks - useFormState": "React 19. This hook provides an easy way to track the status of form submissions.",
	"Data - Inputs - Forms - < form > - Components - Types - Controlled - how - Hooks - useFormStatus": "React 19. useFormStatus is a Hook that gives you status information of the last form submission.",
	"Data - Inputs - Forms - < form > - Components - Types - Controlled - how - Hooks - useOptimistic": "React 19. Show the final state optimistically while an async request is underway.",
	"Data - Inputs - Forms - < form > - Components - Types - Controlled - how - reset": "On submit resets by default.",
	"Data - Inputs - Forms - < form > - Components - Types - Controlled - Features - Rerender": "Input changes trigger state updates, causing a re-render.",
	"Data - Inputs - Forms - < form > - FormData": "FormData objects are used to capture HTML form and submit it using fetch or another network method.",
	"Data - Inputs - Forms - < form > - FormData - location": "placed in server or ServerAction",
	"Data - Inputs - Forms - < form > - FormData - content": "contains all params of the form as title: formData.get('title')",
	"Data - Inputs - Forms - < form > - FormData - destructuring": "const { title, amount } = Object.fromEntries(formData);",
	"Data - Inputs - Forms - < form > - FormData - noreset": "return formData as default value to prevent reset",
	"Data - Inputs - Forms - < form > - Recommendations - reusable": "Create reusable input components to keep code clean.",
	"Data - Inputs - Forms - < form > - Recommendations - submission": "When submitting data, follow these best practices: ✅ Prevent default behavior (e.preventDefault()). ✅ Show loading state to indicate the request is in progress. ✅ Use async/await for API calls.",
	"Data - Inputs - Forms - < form > - Recommendations - validation": "Form validation improves UX and prevents bad data submission.",
	"Data - Inputs - Forms - < form > - Recommendations - validation - libraries - Formik": ".",
	"Data - Inputs - Forms - < form > - Recommendations - validation - libraries - Yup": "form validation.",
	"Data - Inputs - Forms - form - libraries - react-hook-form": ".",
	"Data - Inputs - Forms - form - libraries - zod": ".",
	"Data - Inputs - DataFetching - ClientComponents - tip - minimize": "Only data to user events should be fetched at ClientComponents.",
	"Data - Inputs - DataFetching - ClientComponents - tip - caching": "Cache data fetched from APIs or expensive computations to prevent unnecessary re-fetching or re-computation.",
  "Data - Inputs - DataFetching - ClientComponents - libs - axios": ".",
  "Data - Inputs - DataFetching - ClientComponents - libs - tRPC": ".",
	"Data - Inputs - DataFetching - ClientComponents - Hooks": "React Hooks are not be intended for data fetching in React.",
  "Data - Inputs - DataFetching - ClientComponents - Hooks - useQuery": "ReactQuery. We can cache it, invalidate it, and fetch it anew.",
	"Data - Inputs - DataFetching - ClientComponents - Hooks - useSyncExternalStore": "useSyncExternalStore is a React 18 hook that lets you subscribe to an external store. const snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)",
	"Data - Inputs - DataFetching - ClientComponents - Hooks - useSyncExternalStore - subscribe": "subscribe: function to register a callback that is called whenever the store changes.",
	"Data - Inputs - DataFetching - ClientComponents - Hooks - useSyncExternalStore - getSnapshot": "getSnapshot: function that returns the current value of the store.",
	"Data - Inputs - DataFetching - ClientComponents - Hooks - useSyncExternalStore - getServerSnapshot": "getServerSnapshot: function that returns the snapshot used during server rendering.",
  "Data - Inputs - DataFetching - ClientComponents - Hooks - SWR": "React Hooks for data fetching. Standing for “stale-while-revalidate,” SWR is a strategy and library that makes fetching, caching, and updating data in your React applications a breeze.",
	"Data - Inputs - DataFetching - ServerComponents": "In a React Server Component, data fetching is straightforward. Since these components allow you to execute code on the server, you can directly access the data layer (e.g. database) from the UI: ",
  "Data - Inputs - DataFetching - ServerComponents - preferred": "whenever possible, recommend you to just fetch data in Server Components and to pass it down to Client Components.",
	"Data - Inputs - DataFetching - ServerFunctions - ocassional": "Data fetching with Server Actions comes with drawbacks too: Server Actions perform HTTP POST requests Server Actions run in sequence",
  "Data - Inputs - DataFetching - ServerFunctions - drawbacks": "Using a Server Action for data fetching in a Client Component only happens occasionally",

	"View": "SECTION",
	"View - JSX": "Returned by Components.",
  "View - JSX - elements": "React elements are immutable. Once you create an element, you can’t change its children or attributes.",
  "View - JSX - React.createElement()": "Babel compiles JSX down to React.createElement() calls. A component's render output is normally written in JSX syntax, which is then converted to React.createElement() calls as the JS is compiled and prepared for deployment. createElement returns React elements, which are plain JS objects that describe the intended structure of the UI.",
  "View - JSX - owner": "Component wrapping the JSX",
	"View - JSX - nesting": "When you nest content inside a JSX tag, the parent component will receive that content in a prop called children.",
  "View - JSX - parent": "Nested elements within the JSX.",
  "View - JSX - expressions": "You can put any valid JavaScript expression inside the curly braces in JSX.",
  "View - JSX - return - type - React.FC<Props>": "Functional component with props",
  "View - JSX - return - type - JSX.Element": "Functional component without props - Inline function returning JSX",
  "View - JSX - return - type - generics": "For HOCs that return a wrapped component, use generics.",
	"View - JSX - Conditional": ".",
	"View - JSX - Conditional - if - short-circuit": "< div >{count && < h1 >Messages: {count}< /h1 >}< /div >.",
	"View - JSX - Conditional - if - ternary": "< div >{count ? < h1 >Messages: {count}< /h1 > : null}< /div >. Preferred",
	"View - JSX - Built-in - Common": "All built-in browser components, such as <div>, support some common props and events. https://beta.reactjs.org/reference/react-dom/components/common",
	"View - JSX - Built-in - < Fragment >": "< Fragment >, often used via < >...< /> syntax, lets you group elements without a wrapper node. This is particularly useful when you need to return multiple elements from a component's render method, but you don't want to introduce unnecessary DOM elements that could affect the layout or styles of your application.",
  "View - JSX - Built-in - < Profiler >": "< Profiler > lets you measure rendering performance of a React tree programmatically.",
  "View - JSX - Built-in - < StrictMode >": "< StrictMode > lets you find common bugs in your components early during development. < StrictMode > < App /> < /StrictMode >",
  "View - JSX - Built-in - < Suspense >": "< Suspense > lets you display a fallback until its children have finished loading. < Suspense fallback={< Loading />}> < SomeComponent /> < /Suspense >",
  "View - JSX - Built-in - < input >": "The built-in browser < input > component lets you render different kinds of form inputs. < input />",
  "View - JSX - Built-in - < option >": "The built-in browser < option > component lets you render an option inside a <select> box. < select >  < option value='someOption' >Some option< /option > < option value='otherOption' >Other option< /option > < /select >",
  "View - JSX - Built-in - < progress >": "The built-in browser < progress > component lets you render a progress indicator. < progress value={0.5} />",
  "View - JSX - Built-in - < select >": "The built-in browser < select > component lets you render a select box with options. < select>  < option value='someOption'>Some option</option> <option value='otherOption' >Other option< /option > < /select >",
  "View - JSX - Built-in - < textarea >": "The built-in browser < textarea > component lets you render a multiline text input. < textarea />",
	"View - JSX - Built-in - lists - keys - unique": "Keys must be unique among siblings. However, it’s okay to use the same keys for JSX nodes in different arrays.",
	"View - JSX - Built-in - lists - keys - index - default": "React will use if you don’t specify a key at all.",
	"View - JSX - Built-in - lists - keys - index - Drawbacks": "But the order in which you render items will change over time if an item is inserted, deleted, or if the array gets reordered. Index as a key often leads to subtle and confusing bugs. Re-render all items unnecessarily when the list changes. Cause UI issues, like incorrect animations or state loss in interactive components.",
	"View - JSX - Built-in - lists - keys - generated": "Similarly, do not generate keys on the fly, e.g. with key={Math.random()}. This will cause keys to never match up between renders, leading to all your components and DOM being recreated every time. Not only is this slow, but it will also lose any user input inside the list items. Instead, use a stable ID based on the data.",
	"View - JSX - Built-in - lists - filter": ".",
	"View - JSX - Built-in - lists - map": ".",
  "View - JSX - Portals": "A React Portal allows you to render a component outside the normal DOM hierarchy while keeping it in the React tree.",
  "View - JSX - Portals - benefits - CSS": "Avoid CSS conflicts (e.g., overflow: hidden, z-index).",
  "View - JSX - Portals - benefits - Escape": "Escape parent styles (like position: relative).",
  "View - JSX - Portals - benefits - Modals": "Great for modals, tooltips, dropdowns, and pop-ups.",
  "View - Styling - className": "",
  "View - Styling - className - conditional": "classNames.push('box-error'); ... <div className={classNames.join(' ')}>",
	"View - Rendering": "",
	"View - Rendering - Initialization - Steps - VirtualDOM": "A lightweight representation of the entire component tree.",
  "View - Rendering - Initialization - Steps - VirtualDOM - Structure - Goal": "The Virtual DOM allows React to efficiently manage and update the UI. it will become a lot faster.",
  "View - Rendering - Initialization - Steps - VirtualDOM - Structure - Trees": "React maintains two versions of the Virtual DOM: Work-In-Progress (WIP) Tree and Current Fiber Tree",
  "View - Rendering - Initialization - Steps - VirtualDOM - Structure - Trees - WIP": "Work-In-Progress (WIP) Tree is the new version of the VirtualDOM React is currently building before committing updates.",
  "View - Rendering - Initialization - Steps - VirtualDOM - Structure - Trees - Current": "Current Fiber Tree → Represents the last committed UI (what’s currently displayed on the screen).",
	"View - Rendering - Initialization - Steps - VirtualDOM - Creation": "React creates the Virtual DOM for the first time when a component is initially rendered.",
	"View - Rendering - Initialization - Steps - VirtualDOM - Creation - createRoot()": "When you call ReactDOM.createRoot().render(<App />), React creates the Virtual DOM",
	"View - Rendering - Initialization - Steps - VirtualDOM - Creation - responsible": "React is solely responsible for the render phase.",
	"View - Rendering - Initialization - Steps - VirtualDOM - Features - Interaction": "React itself never interacts with the DOM.",
	"View - Rendering - Initialization - Steps - VirtualDOM - Features - PlatformAgnostic": "React was designed to be platform-agnostic.",
	"View - Rendering - Initialization - Steps - VirtualDOM - Features - Hierarchy": "React applications use components that form a hierarchical structure to build applications. Components can be functional or class-based and represent reusable UI elements.",
	"View - Rendering - Initialization - Steps - VirtualDOM - Features - SyntheticEvents": ".",
	"View - Rendering - Initialization - Steps - VirtualDOM - NoVirtualDOM - Libs - Preact": "Preact X is what we always wanted Preact to be: A tiny, fast and feature-packed library. And speaking of size, you'll be happy to hear that all the new features and improved rendering fit into the same size footprint as 8.x!",
	"View - Rendering - Initialization - Steps - VirtualDOM - NoVirtualDOM - Libs - Preact vs React": "The main difference between Preact and React is that Preact does not implement a synthetic event system for size and performance reasons. Preact uses the browser's standard addEventListener to register event handlers, which means event naming and behavior works the same in Preact as it does in plain JavaScript / DOM.",
	"View - Rendering - Initialization - Steps - Reconciler": "React Reconciler is renderer-agnostic, enabling React to work on multiple platforms.",
	"View - Rendering - Initialization - Steps - Reconciler - Reconcilers - StackReconciler - <React16": ".",
	"View - Rendering - Initialization - Steps - Reconciler - Reconcilers - FiberReconciler - React16": "Builds the initial fiber tree (React Fiber is the underlying reconciliation engine).",
	"View - Rendering - Initialization - Steps - Renderer": "React Renderers: react-dom, react-native, react-three-fiber, ink ",
	"View - Rendering - Initialization - Steps - DOMElements": "Generates the real DOM elements based on this Virtual DOM.",
	"View - Rendering - Initialization - Steps - DOMElements - Mounting": "When a React application is first loaded, React constructs the initial Virtual DOM tree based on the component hierarchy. Each component’s render method is called to generate the corresponding Virtual DOM representation.",
	"View - Rendering - Initialization - Steps - DOMElements - Mounting - Functions": "Rendering in React essentially means invoking the functions of those components.",
  "View - Rendering - Initialization - Steps - DOMElements - Mounting - constructor()": "The constructor runs before your class component mounts (gets added to the screen). Typically, a constructor is only used for two purposes in React. It lets you declare state and bind your class methods to the class instance:",
  "View - Rendering - Initialization - Steps - DOMElements - Mounting - getDerivedStateFromProps()": "During the mounting phase, getDerivedStateFromProps() is called after the constructor and before render(). This method is called for every render cycle and provides an opportunity to update the component's state based on changes in props before the initial render.",
	"View - Rendering - Initialization - Steps - DOMElements - Mounting - render()": "called on Mounting too",
  "View - Rendering - Initialization - Steps - DOMElements - Mounting - componentWillMount()": "Deprecated. ",
  "View - Rendering - Initialization - Steps - DOMElements - Mounting - componentDidMount()": "called once the component has been mounted into the DOM.",
  "View - Rendering - Initialization - Steps - DOMElements - Mounting - componentDidMount() - used": "typically used to set up any necessary event listeners or timers, perform any necessary API calls or data fetching, and perform other initialization tasks that require access to the browser's DOM API.",
  "View - Rendering - Initialization - Steps - DOMElements - Mounting - componentDidMount() - once": "called only once.",
  "View - Rendering - Initialization - Steps - DOMElements - Mounting - componentDidMount() - rerender": "From this method, any state change triggers a re-render of the component.",
	"View - Rendering - Initialization - Steps - Browser": "Commits the actual DOM update by injecting elements into the browser..",
	"View - Rerendering": "Any screen update in a React app happens in three steps: Trigger, Render, Commit. https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/ ",
	"View - Rerendering - Triggering": "Caching the results of expensive computations or function calls.",
  "View - Rerendering - Triggering - NoTriggers - PureComponents": "React skips re-rendering components if their props and state haven’t changed.",
	"View - Rerendering - Triggering - NoTriggers - memoization": "Caching the results of expensive computations or function calls.",
  "View - Rerendering - Triggering - NoTriggers - memoization - commands - React.memo": "Memoizes entire components until its props change. To prevent re-rendering of a component when props haven't changed.",
  "View - Rerendering - Triggering - NoTriggers - memoization - commands - React.memo - parent": "By default, React re-renders a component whenever its parent re-renders, even if props haven't changed.",
  "View - Rerendering - Triggering - NoTriggers - memoization - commands - useMemo": "Memoizes computed values. To optimize expensive calculations and avoid unnecessary recomputation.",
  "View - Rerendering - Triggering - NoTriggers - memoization - commands - useCallback": "Memoizes functions. Caches a function reference to prevent unnecessary re-creation. When passing a function as a prop to a memoized child component to prevent unwanted re-renders.",
  "View - Rerendering - Triggering - NoTriggers - memoization - cons - Memory": "Memory overhead: Memoized values/functions stay in memory until dependencies change.",
  "View - Rerendering - Triggering - NoTriggers - memoization - cons - Performance": "Can slow down performance if overused, especially in simple cases.",
  "View - Rerendering - Triggering - NoTriggers - memoization - cons - Stale": "Might cause stale data issues if dependencies aren't managed correctly.",
	"View - Rerendering - Triggering - Triggers - FirstRender": "First Render.",
	"View - Rerendering - Triggering - Triggers - Changes": "An update can be caused by changes to props or state.",
	"View - Rerendering - Triggering - Triggers - Changes - Props": "",
	"View - Rerendering - Triggering - Triggers - Changes - State": "Setting state requests a re-render from React. This means that for an interface to react to the event, you need to update the state.",
	"View - Rerendering - Triggering - Triggers - Changes - State - onEventHandler": "React batches updates and schedules a re-render. The new state value will be available on the next render. If using the previous state (count), there's a risk of stale state issues in rapid updates.",
	"View - Rerendering - Triggering - Triggers - Changes - State - Value": "Context Value Changes. If the value provided by the Context.Provider changes, all components using useContext(MyContext) will re-render. React compares the new context value with the previous one (shallow comparison for objects)..",
	"View - Rerendering - Triggering - Triggers - Changes - State - useContext": "Component That Calls useContext Always Re-renders. Unlike useState or useMemo, useContext does not allow skipping re-renders based on dependencies..",
	"View - Rerendering - Triggering - Triggers - Changes - State - useEffect": "Risk of infinite loops if the state update re-triggers useEffect.",
	"View - Rerendering - Triggering - Triggers - Scope - UnitOfWork": "A unit of work in React can be a change in props or state or DOM updates, anything that can change the output for the screen. The fiber has a relation of 1 to 1 with something whether a component instance, DOM node, etc. ",
	"View - Rerendering - Triggering - Update - WIP": "React applies changes to VirtualDOM WIP Tree.",
  "View - Rerendering - Triggering - Update - Cascading": "Re-renders in React are cascading. Every time you change state in a React component, you trigger a re-render of that component, every component inside, components inside of those components, etc., until the end of the component tree is reached.",
	"View - Rerendering - Triggering - Update - Optimistic": "Optimistic UI updates improve user experience by immediately updating the UI before waiting for the server response. This makes the app feel faster and more responsive. Instead of waiting for an API response to update the UI, the UI updates immediately, assuming the request will succeed. If the request fails, we roll back the state.",
  "View - Rerendering - Triggering - Update - methods - getDerivedStateFromProps()": "getDerivedStateFromProps is invoked right before calling the render method, both on the initial mount and on subsequent updates. It should return an object to update the state, or null to update nothing.",
	"View - Rerendering - Triggering - Update - methods - shouldComponentUpdate()": "The shouldComponentUpdate() method is called before a component is updated. It takes two arguments: nextProps and nextState. This method returns a boolean value that determines whether the component should update or not. If this method returns true, the component will update, and if it returns false, the component will not update.",
  "View - Rerendering - Triggering - Update - methods - componentWillUpdate() - deprecated": "componentWillUpdate() is a lifecycle method in React that gets called just before a component's update cycle starts.",
	"View - Rerendering - Triggering - Update - methods - render()": "called every time the component needs to be re-rendered",
	"View - Rerendering - Triggering - Update - methods - render() - VirtualDOM": "generates the component's virtual DOM representation based on its current props and state.",
	"View - Rerendering - Triggering - Update - methods - render() - inline": "Using inline functions inside the render method (or JSX) can cause unnecessary re-renders and negatively impact performance. This happens because a new function is created on every render, leading to unnecessary updates in child components. Define Event Handlers Outside JSX.",
	"View - Rerendering - Reconciliation": "React compares Current and WIP VirtualDOMs to determine what changes (diffing) and prepares updates. React updates only the parts of the DOM that have actually changed. The diffing and calculation process is known as 'reconciliation'.",
	"View - Rerendering - Reconciliation - Features - interruptible": ".",
	"View - Rerendering - Reconciliation - Reconciler": "Reconciliation Engine.",
	"View - Rerendering - Reconciliation - Reconciler - StackReconciler": "<React16. React 15 and previous versions of React had a reconciler called StackReconciler.",
	"View - Rerendering - Reconciliation - Reconciler - StackReconciler - Structure": "LIFO data structure",
	"View - Rerendering - Reconciliation - Reconciler - StackReconciler - Features - Sync": "The main problem was that the StackReconciler was synchronous and sequential meaning there was no chance for it to handle multiple units of work at the same time in parallel or concurrently.",
	"View - Rerendering - Reconciliation - Reconciler - StackReconciler - Features - NoPrioritization": "No Prioritization – All updates were treated equally, whether it was a small button click or an expensive re-render.",
	"View - Rerendering - Reconciliation - Reconciler - StackReconciler - Features - Animations": "Inefficient Animations – Smooth animations (like 60 FPS rendering) were hard to achieve since updates could not be interrupted.",
  "View - Rerendering - Reconciliation - Reconciler - StackReconciler - Features - ErrorHandling": "errors break the entire component tree.",
	"View - Rerendering - Reconciliation - Reconciler - StackReconciler - Process": "responsible for picking a work and returning the results just like how the JavaScript call stack works.",
  "View - Rerendering - Reconciliation - Reconciler - FiberReconciler": "React16. In React version 16 and above, introduced a new way of handling the units of work and virtual DOM tree using the new meta called Fiber Reconciler to tackle two main challenges: 1- Synchronous way of processing the units of work 2- Prioritizing and concurrency of the units of work.",
  "View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Structure": "Fiber replaces the old stack-based reconciliation with a linked list tree structure.",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Structure - UnitOfWork": "The fiber has a relation of 1 to 1 with something whether a component instance, DOM node, etc. ",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Structure - UnitOfWork - Info": "Each node (fiber) represents a React element and contains information like: The component type Pending work (updates) Priority level References to parent and child fibers ",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Structure - UnitOfWork - Incremental": "Fiber breaks the rendering work into small units of work (called “fibers”) instead of processing the entire tree at once.",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Structure - UnitOfWork - fibers": "The current React Fiber Reconciler consists of many fiber nodes or Unis of Work",
  "View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Structure - UnitOfWork - WIP": "React's Fiber Reconciler (React 16) introduced WIP and Current Trees",
  "View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Features - Async": "render phase is asynchronous, allowing Fiber to prioritize tasks, split work into chunks, and pause or resume certain tasks as needed. parallelized to do multiple works concurrently at the same time",
  "View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Features - ErrorHandling": "Fiber introduces error boundaries, which allow React to gracefully recover from errors without crashing the whole app.",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - React18": "The most important addition in React 18: concurrency.",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - React18 - default": "With React 18+, Concurrent Mode is enabled by default in createRoot.",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Features - renderer": "Many of the features in React 18 are built on top of our new concurrent renderer, a behind-the-scenes change that unlocks powerful new capabilities. Concurrency is not a feature, per se. It’s a new behind-the-scenes mechanism that enables React to prepare multiple versions of your UI at the same time.",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Features - optin": "Concurrent React is opt-in — it’s only enabled when you use a concurrent feature — but we think it will have a big impact on the way people build applications.",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Features - gradual": "Gradually Adopting Concurrent Features. Technically, concurrent rendering is a breaking change. Because concurrent rendering is interruptible, components behave slightly differently when it is enabled.",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Operations - Reusable": "Another example is reusable state. Concurrent React can remove sections of the UI from the screen, then add them back later while reusing the previous state. For example, when a user tabs away from a screen and back, React should be able to restore the previous screen in the same state it was in before.",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Operations - Batches": "React’s virtual DOM improves performance by batching updates and reducing the number of direct manipulations to the actual DOM. Reflow and Repaint are both heavy. The Virtual DOM boosts performance by minimizing browser reflows and repaints. Reflows are particularly expensive because they involve recalculating the layout of the page. Without the Virtual DOM, each of the X DOM operations would trigger a reflow and repaint. However, with the Virtual DOM, holding a 'diff-tree' for the dom-difference, these operations are processed in batches, resulting in only one reflow and repaint.",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Operations - Batches - NoCases - setTimeout": "Inside setTimeout or Promise.then (Before React 18) In React 17 and earlier, updates inside setTimeout or Promise.then trigger separate renders.",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Operations - Batches - NoCases - NativeEventListeners": "React does not batch updates inside manually attached DOM event listeners (e.g., document.addEventListener).",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Operations - Batches - NoCases - flushSync": "If you need state updates to take effect immediately, you can force React to process them separately using flushSync().",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Operations - Batches - NoCases - ConcurrentMode - React<=17": "React 17 and Earlier - Updates in Asynchronous Code (Outside Event Handlers) are not batched.",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Operations - Batches - NoCases - ConcurrentMode - React<18": "Prior to React 18, state updates in asynchronous code (e.g., setTimeout, Promises, API calls) were not batched.",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Operations - Batches - Cases - ConcurrentMode - React18": "React 18 introduced 'Automatic Batching', meaning even asynchronous state updates (inside setTimeout, Promises, API calls) are batched.",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Operations - Batches - Cases - lifecycle": "React automatically batches updates in lifecycle methods.",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Operations - Batches - Cases - EventHandlers": "When multiple setState calls occur inside a React event handler, React batches them together and triggers only one re-render at the end.",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Operations - Batches - Cases - Hooks": "Updates inside hooks like useEffect, useMemo, useCallback are batched automatically.",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Operations - Prioritize": "High-priority updates (like user interactions) are processed before lower-priority ones (like data fetching).",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Operations - Prioritize - Scheduler": "There is a whole package in React that prioritizes tasks called Scheduler.",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Operations - Prioritize - levels": "There are 6 levels of priority. export const NoPriority = 0; export const ImmediatePriority = 1; export const UserBlockingPriority = 2; export const NormalPriority = 3; export const LowPriority = 4; export const IdlePriority = 5;",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Operations - Prioritize - priority": "With Fiber, React assigns priority levels to updates. High-priority updates (like user inputs) are processed before low-priority ones (like network requests or background data processing). This ensures that important interactions feel instant and responsive.",
  "View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Operations - Delay - Urgent": "Urgent updates reflect direct interaction, like typing, clicking, pressing, and so on. Urgent updates like typing, clicking, or pressing, need immediate response to match our intuitions about how physical objects behave. Otherwise they feel “wrong”.",
  "View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Operations - Delay - Transition": "Transition updates transition the UI from one view to another. However, transitions are different because the user doesn’t expect to see every intermediate value on screen.",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Operations - Delay - Transition - useTransition": "update the state without blocking the UI. const [isPending, startTransition] = useTransition(). The useTransition hook in React plays a pivotal role in improving the performance of applications by allowing the marking of state updates as non-blocking transitions. This capability enables React to defer rendering for these updates, preventing UI blocking and enhancing overall responsiveness.",  
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Operations - Delay - Transition - startTransition - React18": "It allows developers to mark certain state updates as transitions.",  
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Operations - Delay - Transition - LowPriority": "These marked updates are considered low priority and non-blocking. If there are other higher priority updates (like user input), React will handle these first before restarting the state updates within startTransitions",  
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Operations - Delay - useDeferredValue - React18": "useDeferredValue is a React Hook that lets you defer updating a part of the UI. const deferredValue = useDeferredValue(value)",
	"View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Operations - Interruptible": "React guarantees that the UI will appear consistent even if a render is interrupted. To do this, it waits to perform DOM mutations until the end, once the entire tree has been evaluated. With this capability, React can prepare new screens in the background without blocking the main thread. This means the UI can respond immediately to user input even if it’s in the middle of a large rendering task, creating a fluid user experience.",
  "View - Rerendering - Reconciliation - Reconciler - FiberReconciler - Process - ConcurrentMode - Operations - Cancel": "",
	"View - Rerendering - Reconciliation - Reconciling - Diffing": "React Reconciler performs the diffing algorithm.",
	"View - Rerendering - Reconciliation - Reconciling - Diffing - Process": "compare previous VirtualDOM WIP and Current Trees, and react determines which parts of the actual DOM need to be updated by comparing the differences.",
	"View - Rerendering - Reconciliation - Reconciling - Diffing - Process - sameTag - hierarchy": "If the elements are of the same type, React only updates the changed attributes and recursively checks their children.",
	"View - Rerendering - Reconciliation - Reconciling - Diffing - Process - noSameTag": "If the root elements of the old and new Virtual DOM trees are different (<div> vs. <span>), React discards the old tree and renders a new one.",
	"View - Rerendering - Reconciliation - Reconciling - Diffing - libraries - why-did-you-update": "If you are still not satisfied by the output of React performance tools, you can still use “why-did-you-update” library that hooks into React and detects potentially unnecessary component renders. The library once goes in an active stage will shout out into your console anytime a piece of state makes your component update which in reality shouldn’t update at all.",
  "View - Rerendering - Reconciliation - Reconciling - Diffing - libraries - Million": "Million.js was designed to address virtual DOM diffing.",
  "View - Rerendering - Reconciliation - Reconciling - Diffing - libraries - Million - goal": "Million.js performs smart updates, only targeting DOM elements that need to be changed, bypassing the traditional diffing algorithm in many cases.",
  "View - Rerendering - Reconciliation - Reconciling - Diffing - libraries - Million - block()": "A standout feature in Million.js is the block() function, which wraps React components and provides ultra-efficient rendering. This function optimizes components by ensuring they only re-render when necessary, enhancing performance.",
  "View - Rerendering - Reconciliation - Reconciling - Diffing - libraries - Million - memo()": "Component memoization ensures that components only re-render when their props change, a vital strategy for optimizing performance in large applications.",
  "View - Rerendering - Reconciliation - Reconciling - Diffing - libraries - Million - compatibility": "Million.js v3.0.0 has evolved to offer better compatibility with React's core features and modern APIs, such as hooks (useState, useEffect, useMemo, and useCallback).",
	"View - Rerendering - Reconciliation - Reconciling - ScheduleUpdates": "React schedules rendering work based on priority (e.g., urgent UI updates vs. background tasks).",
	"View - Rerendering - Reconciliation - Reconciling - ScheduleUpdates - Priority - High": "High priority → User interactions (e.g., clicking a button, typing).",
	"View - Rerendering - Reconciliation - Reconciling - ScheduleUpdates - Priority - Medium": "Medium priority → Updating lists, rendering new UI. Animations, transitions.",
	"View - Rerendering - Reconciliation - Reconciling - ScheduleUpdates - Priority - Low": "Low priority → Data fetching, background updates.",
	"View - Rerendering - Committing": "Commit phase is where React actually interacts with the DOM.",
	"View - Rerendering - Committing - Features - synchronous": ".",
	"View - Rerendering - Committing - Features - non-interruptible": ".",
	"View - Rerendering - Committing - Renderer": "Rendering is done by one of the React Renderers: react-dom, react-native, react-three-fiber, ink ",
	"View - Rerendering - Committing - Renderer - ReactDOM": "Uses React Reconciler internally to apply updates to the real DOM.",
	"View - Rerendering - Committing - Renderer - ReactDOM - react-dom": "Updates the browser DOM. ReactDOM is the renderer for the web platform. A separate library is responsible for writing to the DOM. ",
	"View - Rerendering - Committing - Renderer - ReactDOM - ReactDOMClient": "These new APIs are now exported from react-dom/client:",
  "View - Rerendering - Committing - Renderer - ReactDOM - ReactDOMClient - createRoot": "createRoot: New method to create a root to render or unmount. Use it instead of ReactDOM.render. New features in React 18 don’t work without it.",
  "View - Rerendering - Committing - Renderer - ReactDOM - ReactDOMClient - hydrateRoot": "hydrateRoot: New method to hydrate a server rendered application. Use it instead of ReactDOM.hydrate in conjunction with the new React DOM Server APIs. New features in React 18 don’t work without it.",
  "View - Rerendering - Committing - Renderer - ReactDOM - ReactDOMServer": "These new APIs are now exported from react-dom/server and have full support for streaming Suspense on the server:",
  "View - Rerendering - Committing - Renderer - ReactDOM - ReactDOMServer - renderToPipeableStream": "renderToPipeableStream: for streaming in Node environments.",
  "View - Rerendering - Committing - Renderer - ReactDOM - ReactDOMServer - renderToReadableStream": "renderToReadableStream: for modern edge runtime environments, such as Deno and Cloudflare workers.",
	"View - Rerendering - Committing - Renderer - react-native": "Updates native mobile UI.",
	"View - Rerendering - Committing - Renderer - react-three-fiber": "Updates 3D WebGL scenes.",
	"View - Rerendering - Committing - Renderer - ink": "Updates command-line UI.",
	"View - Rerendering - Committing - Rendering": ".",
	"View - Rerendering - Committing - Rendering - Swap": "React WIP tree replaces the current tree. This is the point where it inserts, deletes, and updates DOM elements, making the final changes visible in the browser. The WIP tree becomes the new Current Fiber tree.",
	"View - Rerendering - Committing - Rendering - Swap - Flagged": "During the rendering process, React will start at the root of the component tree and loop downwards to find all components that have been flagged as needing updates. For each flagged component, React will call either FunctionComponent(props) (for function components), or classComponentInstance.render() (for class components) , and save the render output for the next steps of the render pass.",
  "View - Rerendering - Committing - Rendering - Swap - routing": "Instead of using the native browser routing and navigation, we keep all of that in the JavaScript memory and use JavaScript to handle pages and routing for us, and as a result, it will become a lot faster.",
	"View - Rerendering - Committing - Rendering - Updating": "These methods are called in the following order when a component is being re-rendered.",
  "View - Rerendering - Committing - Rendering - Updating - methods - getSnapshotBeforeUpdate()": "The getSnapshotBeforeUpdate() method is called just before the component's UI is updated. It allows the component to capture some information about the current state of the UI, such as the scroll position before it changes. This method returns a value that is passed as the third parameter to the componentDidUpdate() method.",
	"View - Rerendering - Committing - Rendering - Updating - methods - componentWillUnmount()": "React will call it before your component is removed (unmounted) from the screen on nodes tagged with the Deletion effect.",
  "View - Rerendering - Committing - Rendering - Updating - methods - componentDidMount()": "It then synchronously runs the componentDidMount and componentDidUpdate class lifecycle methods.",
  "View - Rerendering - Committing - Rendering - Updating - methods - componentDidUpdate()": "The componentDidUpdate() method is a lifecycle method in React that is called after a component has been updated and re-rendered.",
	"View - Rerendering - Committing - Rendering - Updating - methods - useLayoutEffect": "Runs the useLayoutEffect hooks.",
	"View - Rerendering - Committing - Rendering - Updating - methods - useEffect": "React then sets a short timeout, and when it expires, runs all the useEffect hooks. This step is also known as the 'Passive Effects' phase.",

  "Logic": "SECTION",
	"Logic - Client - ClientComponents - ": "The 'standard' React components we know and love have been rebranded as Client Components. It's a new name for an old thing.",
	"Logic - Client - ClientComponents - Structure - import": "React team added a rule: Client Components can only import other Client Components.",
	"Logic - Client - ClientComponents - Structure - use client": "In this new “React Server Components” paradigm, all components are assumed to be Server Components by default. We have to “opt in” for Client Components. That standalone string at the top, 'use client', is how we signal to React that the component(s) in this file are Client Components, that they should be included in our JS bundles so that they can re-render on the client.. Server Components are not sent to the browser, so they cannot use interactive APIs like useState. To add interactivity to Server Components, you can compose them with Client Component using the 'use client' directive. ",
	"Logic - Client - ClientComponents - Structure - use client - boundaries": "When we add the 'use client' directive to a component, we create a “client boundary”. All of the components within this boundary are implicitly converted to Client Components. Even though components don't have the 'use client' directive, they'll still hydrate/render on the client in this particular situation.*",
	"Logic - Client - ClientComponents - Rendering - rerender": "The name 'Client Component' implies that these components only render on the client, but that's not actually true. Client Components render on both the client and the server.",
	"Logic - Client - ClientComponents - Rendering - rerender - count": "console.count('render')",
	"Logic - Client - ClientComponents - UserInteraction - EventDelegationModel": "React does not attach event listeners directly to individual DOM elements. Instead, it uses React’s Event Delegation Model by attaching a single event listener to the root of the DOM tree (usually document or a container like #root).",
	"Logic - Client - ClientComponents - UserInteraction - EventDelegationModel - Listener": "React uses a single event listener at the document level (document.addEventListener).",
	"Logic - Client - ClientComponents - UserInteraction - EventDelegationModel - EventHandlers": "Defining Event Handlers in TypeScript.",
	"Logic - Client - ClientComponents - UserInteraction - EventDelegationModel - EventBubbling": "When an event occurs on a child component, it bubbles up to React’s root event handler.",
	"Logic - Client - ClientComponents - UserInteraction - EventDelegationModel - EventBubbling - onClick": "Most events are delegated (e.g., onClick, onChange). Even though we write onClick in JSX, React internally manages a single event listener at the document level.",
	"Logic - Client - ClientComponents - UserInteraction - EventDelegationModel - NoEventBubbling": "Some events do not bubble naturally (e.g., onBlur, onFocus) and React attaches those directly to elements.",
	"Logic - Client - ClientComponents - UserInteraction - EventDelegationModel - Benefits - Memory": "Better Performance & Less Memory Usage. Instead of attaching multiple event listeners to each individual element, React uses just one, reducing memory usage.",
	"Logic - Client - ClientComponents - UserInteraction - EventDelegationModel - Benefits - Dynamic": "Efficient Handling of Dynamic Elements. If elements are added/removed dynamically, React can still capture their events without needing to re-attach listeners.",
	"Logic - Client - ClientComponents - UserInteraction - EventDelegationModel - Benefits - Compatibility": "Consistent Synthetic Event System. React wraps native events inside Synthetic Events, ensuring cross-browser compatibility and making event handling consistent.",
	"Logic - Client - ClientComponents - UserInteraction - EventDelegationModel - Benefits - Batching": "Event Batching for Optimization. React batches multiple event updates in one go, reducing unnecessary re-renders.",
	"Logic - Client - ClientComponents - UserInteraction - SyntheticEvents": "React determines which component should handle the event using synthetic events.",
	"Logic - Client - ClientComponents - UserInteraction - SyntheticEvents - Features - encapsulate": "React synthetic events encapsulate native browser events, providing a unified API interface so that developers can handle events in the same way regardless of the browser environment. The main purpose of this approach is to ensure cross-browser consistency and integrate with React’s declarative programming model and lifecycle. React synthetic events handle all browser compatibility issues, providing developers with a clean, consistent interface for event handling.",
	"Logic - Client - ClientComponents - UserInteraction - SyntheticEvents - Features - CrossBrowser": "React normalizes events across browsers using SyntheticEvent, which wraps the native event to provide consistent behavior.",
	"Logic - Client - ClientComponents - UserInteraction - SyntheticEvents - Features - ClientComponents": "Only ClientComponents.",
	"Logic - Client - ClientComponents - UserInteraction - SyntheticEvents - Operation - pool": "React SyntheticEvent use an event pool to improve performance, i.e., reusing event objects. This means that after the event callback function is executed, all properties of the event object are cleared and recycled for reuse, reducing the pressure on garbage collection and memory usage.",
	"Logic - Client - ClientComponents - UserInteraction - SyntheticEvents - Operation - Throttling": "Throttling in React is a technique used to limit the number of times a function or an event handler is invoked by postponing the execution of a function. It ensures that the function is called at a specified interval, preventing it from being executed too frequently. Throttling allows you to control the rate at which the function is called by setting up a minimum time interval between each function invocation. If the function is called multiple times within that interval, only the first invocation is executed, and subsequent invocations are ignored until the interval elapses.",
	"Logic - Client - ClientComponents - UserInteraction - SyntheticEvents - Operation - Debouncing": "Debouncing, as opposed to throttling, is a method to stop the event trigger from firing too frequently. Debouncing, on the other hand, is also used to limit the number of times a function or an event handler is invoked. It ensures that the function is called only after a certain period of inactivity. Debouncing allows you to postpone the function call until the user has finished typing or a specific time has elapsed since the last event..",
	"Logic - Client - ClientComponents - SideEffects": "Side effects in React are operations that affect something outside the component",
	"Logic - Client - ClientComponents - SideEffects - Mixins - 2014": "A React Mixin got introduced as React's first advanced pattern for reusable component logic. With a Mixin, it's possible to extract logic from a React component as standalone object. When using a Mixin in a component, all features from the Mixin are introduced to the component:",
  "Logic - Client - ClientComponents - SideEffects - Mixins - drawbacks": "However, Mixins are not used anymore in modern React applications, because they come with several drawbacks.",
  "Logic - Client - ClientComponents - SideEffects - Mixins - drawbacks - dependencies": "Often, mixins come to depend on other mixins, and removing one of them breaks the other. In these situations it is very tricky to tell how the data flows in and out of mixins, and what their dependency graph looks like. Unlike components, mixins don’t form a hierarchy: they are flattened and operate in the same namespace. If you have a name conflict with a mixin from a third party package, you can’t just rename a method on it. Instead, you have to use awkward method names on your component to avoid clashes.",
  "Logic - Client - ClientComponents - SideEffects - Mixins - drawbacks - clashes": "There is no guarantee that two particular mixins can be used together. For example, if FluxListenerMixin defines handleChange() and WindowSizeMixin defines handleChange(), you can’t use them together. You also can’t define a method with this name on your own component.",
  "Logic - Client - ClientComponents - SideEffects - Mixins - drawbacks - complexity": "Even when mixins start out simple, they tend to become complex over time.",
	"Logic - Client - ClientComponents - SideEffects - HOCs": "React Higher-Order Components (HOCs), a popular advanced React pattern, are an alternative for React Mixins to deploy reusable logic across React components. The shortest explanation for a Higher-Order Component is that it is a component which takes a component as input and returns the component as output but with extended functionalities. Let's revisit the example with the local storage and how the functionality can be extracted into a reusable Higher-Order Component:",
	"Logic - Client - ClientComponents - SideEffects - Render Props": "Another popular advanced React pattern are React Render Prop Components, which are often used as alternative to React Higher-Order Components.",
	"Logic - Client - ClientComponents - SideEffects - Hooks - effect": "Effects let a component connect to and synchronize with external systems. This includes dealing with network, browser DOM, animations, widgets written using a different UI library, and other non-React code.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useInsertionEffect": "",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useInsertionEffect - Features - lifecycle": "useInsertionEffect is a version of useEffect that fires before any DOM mutations.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useInsertionEffect - Syntax": "useInsertionEffect(setup, dependencies?)",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useInsertionEffect - Usage": "Pitfall. useInsertionEffect is aimed at CSS-in-JS library authors. Unless you are working on a CSS-in-JS library and need a place to inject the styles, you probably want useEffect or useLayoutEffect instead.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect": "bring side-effects to Function Components to manipulate the real DOM (not the VirtualDOM). The primary purpose is to avoid visual inconsistencies that might arise if the effect was delayed until after the paint, as would be the case with useEffect. Good for layout-related updates.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Features - lifecycle": "runs  after all DOM mutations to make DOM manipulations BEFORE the Browser Paints the Screen.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Features - block": "BLOCKS rendering until the effect is complete.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Features - sync": "The useLayoutEffect hook runs synchronously.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Syntax": "useLayoutEffect(() => { /* Your effect logic here */ return () => { /* Optional cleanup logic here */ };},[dependencies]);",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Syntax - Function": "Effect Function: you can read from the DOM, manipulate it, and make changes that need to be visible immediately.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Syntax - FunctionReturn": "Cleanup Function (optional): This is returned from the main effect function. It will be called before the effect runs the next time, or when the component unmounts. This is useful for cleaning up any side effects (e.g., removing event listeners, cancelling timers).",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Syntax - Dependencies": "Dependencies: This is an array of values that the effect depends on. The effect will only re-run if one of these dependencies changes. If you pass an empty array, the effect will only run on mount and unmount.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Usages": "scenarios where you need to perform side effects that require direct interaction with the real DOM, or when you need to ensure that your updates are visible to the user without any flickering or delay. This is useful when you need to make measurements or changes to the DOM that should be applied before the screen is updated.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Usages - measure": "Measuring Layouts: For example, if you need to measure the position or size of a DOM element immediately after a render but before the browser has painted the screen.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Usages - styles": "apply styles or transformations immediately after rendering.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Usages - syncing": "Synchronizing State with the DOM: When you need to ensure that your component’s state is perfectly synchronized with the DOM in a way that affects the layout or style.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Usages - FOUC": "Avoiding Flash of Unstyled Content (FOUC): Ensuring that CSS changes are applied before the browser repaints can prevent users from seeing unstyled content.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Gotchas - performance": "Performance Impact: useLayoutEffect is synchronous, meaning it will block the browser from painting until the effect has finished executing. This can introduce performance issues, especially if the effect involves complex computations or multiple DOM manipulations. Always be mindful of the performance cost when deciding to use useLayoutEffect over useEffect.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Gotchas - UIJank": "UI Jank: If useLayoutEffect takes too long to execute, it can cause UI jank, where the interface feels sluggish or unresponsive. This is especially critical on lower-end devices or under heavy load, where the blocking behavior can become more noticeable.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - Gotchas - render": "Blocking Render Cycles: Since useLayoutEffect runs before the browser has a chance to repaint, it can block the render cycle, leading to delays in visual updates.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect": "bring side-effects to Function Components.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Features - lifecycle": "Runs AFTER the Browser Paints the Screen.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Features - block": "Does NOT BLOCK rendering.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Features - async": "useEffect() is asynchronous.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Syntax": "useEffect(<function>, <dependency>).",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Syntax - Function": ".",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Syntax - FunctionReturn": ".",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Syntax - Dependencies": "optional",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Syntax - Dependencies - mount/unmount/update": "React.useEffect(() => { console.log('I run on every render: mount + update.'); }); This is the most straightforward usage of useEffect where we only pass one argument -- a function. The effect runs after every render -- meaning it runs on the first render of the component (also called on mount or mounting of the component) and on every re-render of the component (also called on update or updating of the component).",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Syntax - Dependencies - mount/unmount": "React.useEffect(() => { console.log('I run only on the first render: mount.'); }, []); If you want to run React's useEffect Hook only on the first render of a component (also called only on mount), then you can pass in a second argument to useEffect: https://medium.com/@sassenthusiast/i-thought-i-knew-useeffect-but-i-was-wrong-useeffect-misconceptions-dcc2781010a9 . It behaves like componentDidMount in class components.",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Syntax - Dependencies - update": "React.useEffect(() => { console.log('I run only if toggle changes (and on mount).'); }, [toggle]); Now the side-effect function for this React component runs only when the variable in the dependency array changes. ",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - Syntax - Dependencies - update any": "React.useEffect(() => { console.log('I run if toggle or title change (and on mount).'); }, [toggle, title]); if we provide the new variable in the dependency array, the side-effect function will run for both updates:",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - async": "async callbacks cannot be utilised within the useEffect hook",
  "Logic - Client - ClientComponents - SideEffects - Hooks - effect - useEffect - async - solution": "create a new function that is declared inside the useEffect() hook and that contains the async function, and then we can call this new function inside the useEffect() hook.",
	"Logic - Client - ClientComponents - SideEffects - Hooks - useId": "useId is a React Hook for generating unique IDs that can be passed to accessibility attributes. const id = useId(). The problem with these strategies is re-hydration. If you were using SSR, this component would generate one id on the server and another id on the client",
  "Logic - Client - ClientComponents - SideEffects - Hooks - custom": "https://javascript.plainenglish.io/collection-of-custom-hooks-for-your-nextjs-react-project-1779379e6f4a",
	"Logic - Client - ClientComponents - DOMInteraction": "",
	"Logic - Client - ClientComponents - DOMInteraction - ref": "Refs let a component hold some information that isn’t used for rendering, like a DOM node or a timeout ID.",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Lifecycle": "After React has updated the DOM in the commit phase, it updates all refs accordingly to point to the requested DOM nodes and component instances.",
  "Logic - Client - ClientComponents - DOMInteraction - ref - Create - React.createRef": "React.createRef (for class components).",
  "Logic - Client - ClientComponents - DOMInteraction - ref - Create - useRef": "useRef (for functional components). useRef manipulates the real DOM, not the Virtual DOM.",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Create - useRef - current": "The useRef Hook returns an object with a single property called current. Initially, myRef.current will be null. When React creates a DOM node for this <div>, React will put a reference to this node into myRef.current. You can then access this DOM node from your event handlers and use the built-in browser APIs defined on it.",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Object": "ref is an object with a single property called current. Initially, myRef.current will be null. When React creates a DOM node for this <div>, React will put a reference to this node into myRef.current. You can then access this DOM node from your event handlers and use the built-in browser APIs defined on it.",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Types - TypeScript - Define": "When working with refs in React and TypeScript, you need to specify the correct type for the ref object, whether it’s a DOM element, a custom component, or a forwarded ref.",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Types - TypeScript - Define - DOMElement": "For standard HTML elements, use useRef<HTMLTagElement>(null).",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Types - TypeScript - Define - input": "useRef<HTMLInputElement>(null)",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Types - TypeScript - Define - CustomComponent": "When using useRef with a custom React component, specify the component instance type. ",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Types - TypeScript - Define - Mutable": "Using useRef with useState for Mutable Values. If using useRef for storing mutable values (not DOM refs), define the correct type.",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Usage": "Unlike with state, updating a ref does not re-render your component. Refs are an “escape hatch” from the React paradigm. They are useful when you need to work with non-React systems, such as the built-in browser APIs. A React Ref should only be used in rare cases such as accessing/manipulating the DOM manually (e.g. focus element), animations, and integrating third-party DOM libraries. ref directly references a DOM element, bypassing React’s Virtual DOM (VDOM) diffing process.",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Usage - mutable": "It can be used to store a mutable value that does not cause a re-render when updated.",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Usage - DOM": "It can be used to access a DOM element directly (focus, scroll, animations).",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Usage - previous": "Use useRef to store the previous value of a prop or state.",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Usage - avoid": "Avoiding Re-renders for Expensive Calculations: Use useRef to store the result of expensive calculations or side effects that do not need to trigger re-renders.",
	"Logic - Client - ClientComponents - DOMInteraction - ref - Usage - function": "do not works with function components",
	"Logic - Client - ClientComponents - DOMInteraction - ref - useImperativeHandle": "useImperativeHandle is a React Hook that lets you customize the handle exposed as a ref. useImperativeHandle(ref, createHandle, dependencies?)",
  "Logic - Client - ClientComponents - DOMInteraction - forwardRef": "Passes ref from parent to child function components",
	"Logic - Client - ClientComponents - DOMInteraction - forwardRef - Usage - function": "works with function components",
	"Logic - Client - ClientComponents - ErrorHandling": "These methods are called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component.",
  "Logic - Client - ClientComponents - ErrorHandling - static getDerivedStateFromError()": ".",
  "Logic - Client - ClientComponents - ErrorHandling - componentDidCatch()": "In the componentDidCatch method, you can handle errors, such as logging error information, displaying error information to the user, sending error reports, etc.",
	"Logic - Client - ClientComponents - ErrorHandling - <ErrorBoundary>": "React gives us what is known as 'Error Boundaries': a special API that turns a regular component into a try/catch statement in a way, only for React declarative code. ",
	"Logic - Client - ClientComponents - ErrorHandling - <ErrorBoundary> - onRecoverableError": "onRecoverableError, to provide better clarity on why the error is happening.",
	"Logic - Client - ClientComponents - ErrorHandling - <ErrorBoundary> - onCaughtError": "React 19. onCaughtError triggers when React catches an error in an Error Boundary.",
	"Logic - Client - ClientComponents - ErrorHandling - <ErrorBoundary> - onUncaughtError": "React 19. onUncaughtError triggers when an error is thrown and not caught by an Error Boundary.",
	"Logic - Client - ClientComponents - ErrorHandling - <StrictMode>": "<React.StrictMode><App /></React.StrictMode>,. Use StrictMode to enable additional development behaviors and warnings for the component tree inside: Strict Mode enables the following development-only behaviors: Your components will re-render an extra time to find bugs caused by impure rendering. Your components will re-run Effects an extra time to find bugs caused by missing Effect cleanup. Your components will be checked for usage of deprecated APIs.",
	"Logic - Client - Functions - Hooks - React16.8": "React 16.8 introduced entirely new concepts (hooks). React Hooks are functions that let you use state and lifecycle features in function components. They were introduced in React 16.8 to replace class components. Before hooks, only class components could handle state and side effects. Hooks allow function components to be more powerful and concise.",
	"Logic - Client - Functions - Hooks - Order": "When a component renders (initial mount & updates), Hooks execute in this order: useState > useReducer > useContext > useMemo / useCallback > useEffect / useLayoutEffect > useRef",
	"Logic - Client - Functions - Hooks - MemoryLeaks": "Memory leaks in React Hooks often occur due to: Unclosed subscriptions. Unresolved async operations. Unremoved event listeners. Unreleased timers or intervals. Stale closures or large state objects.",
	"Logic - Client - Functions - Hooks - RulesOfHooks": "React explicitly enforces the Rules of Hooks, which state that Hooks must be called at the top level of a component and not inside loops, conditionals, or nested functions. Violating these rules will cause React to throw an error.",
	"Logic - Client - Functions - Hooks - RulesOfHooks - Conditional": "React expects Hooks to be called in the same order on every render. If you conditionally call a Hook inside a loop or conditional, the order of Hooks might change between renders, leading to bugs and unexpected behavior.",
	"Logic - Client - Functions - Hooks - RulesOfHooks - Loops": "Conditionally calling Hooks inside loops can lead to unnecessary re-renders or re-initializations of Hooks, which can degrade performance.",
	"Logic - Client - Functions - Hooks - RulesOfHooks - Top": "always call Hooks at the top level of your component",
	"Logic - Client - Functions - Hooks - Custom - stateful": "allow you to extract and reuse stateful logic across multiple components.",
	"Logic - Client - Functions - Hooks - Custom - use": "They are JavaScript functions that follow the naming convention of starting with use (e.g., useFetch, useLocalStorage)",
	"Logic - Client - Functions - Hooks - Custom - built-in": "can call other Hooks like useState, useEffect, etc.",
	"Logic - Client - Functions - Hooks - Custom - encapsulate": "Custom Hooks enable you to encapsulate logic, making your components cleaner and more focused on rendering.",	
	"Logic - Client - Functions - Hooks - Pitfalls - Closures": "Closures can cause issues in React hooks, particularly with useEffect and useState, because they capture and retain the values of variables at the time the closure was created. This can lead to stale closures, where the closure holds onto outdated values, even after the state or props have changed. This is a common source of bugs in React applications.",	
	"Logic - Client - Functions - Hooks - Pitfalls - Closures - stale - useEffect": "Use the Dependency Array in useEffect: Ensure that all dependencies (state, props, or other variables) used inside useEffect are included in the dependency array. This ensures the effect is re-run whenever the dependencies change.",	
	"Logic - Client - Functions - Hooks - Pitfalls - Closures - stale - Ref": "Use a Ref to Access the Latest State: If you need to access the latest state value in a callback without re-creating the callback every time, you can use a useRef to store the current state and update it whenever the state changes.",	
	"Logic - Client - Functions - Hooks - Pitfalls - Closures - stale - useState": "Use a Functional Update in useState: When updating state based on the previous state, use the functional form of setState to ensure you're working with the latest state.",	
	"Logic - Client - Functions - Hooks - Pitfalls - Closures - stale - useCallback": "Use useCallback for Stable Callbacks: If you need to pass a callback to a child component or an event handler, use useCallback to memoize the callback and ensure it only updates when its dependencies change.",	
	"Logic - Client - Functions - Hooks - Pitfalls - Closures - stale - avoid": "Avoid Unnecessary Closures: If possible, structure your code to avoid creating closures that capture stale values. For example, move state-dependent logic directly into the component or hook where it belongs..",	
	"Logic - Server - RSC - React19": "ReactServerComponents run exclusively on the server.",
	"Logic - Server - RSC - default": "As a general rule, if a component can be a Server Component, it should be a Server Component.",
	"Logic - Server - RSC - Features - render": "RSC render at build time or for each request, reducing the workload on the client side and enhancing performance.",
	"Logic - Server - RSC - Features - rerender": "RSC never re-render. They run once on the server to generate the UI. The rendered value is sent to the client and locked in place. As far as React is concerned, this output is immutable, and will never change. Server Components aren't really React components, at least not as we've traditionally understood them. They're much more like PHP templates, rendered by a server to create the original HTML. The real innovation is that Server Components and Client Components can co-exist in the same application!",
	"Logic - Server - RSC - Features - async": "RSC introduce a new way to write Components using async/await. When you await in an async component, React will suspend and wait for the promise to resolve before resuming rendering. This works across server/client boundaries with streaming support for Suspense.",
  "Logic - Server - RSC - Features - stateless": "Therefore they can't have state or JavaScript events and there's no concept of 're-rendering' for them - because again, there is no 'component code' that goes to the client. This is why server components cannot be owned by client components -- because if a client component re-rendered on the client, there would be no way to 're-render' the server component it owns.",
  "Logic - Server - RSC - Features - cache": "cache is only for use with RSC.",
  "Logic - Server - RSC - Features - static": "RSC don't rehydrate to the client. They don't send their component code to the client at all. The results of a server component (HTML and other meta data) sit on the client statically without your component code being there in the client.",
	"Logic - Server - RSC - Usage": "This allows us to do things like write database queries right inside our React components!.",
	"Logic - Server - RSC - Arch - no server": "RSC can run at build time to read from the filesystem or fetch static content, so a web server is not required. For example, you may want to read static data from a content management system.",
	"Logic - Server - RSC - Arch - server": "RSC can also run on a web server during a request for a page, letting you access your data layer without having to build an API. They are rendered before your application is bundled, and can pass data and JSX as props to Client Components.",
	"Logic - Server - Functions - ServerFunctions": "Server Functions are asynchronous functions that are executed on the server. They can be used in Server and Client Components to handle form submissions",
  "Logic - Server - Functions - ServerFunctions - call": "This means that it isn’t just a function call: there is actually an HTTP request made to the API to call the function.",
  "Logic - Server - Functions - ServerFunctions - call - serializable": "Server actions are an abstraction that hides the complexity of the network calls and the data serialization/parsing.",
  "Logic - Server - Functions - ServerFunctions - call - developer": "As a developer I just write a function that I can call on the server and I can write tests for it, but React does a lot of heavy lifting to create the illusion that I’m “just calling a function” from the client to be executed on the server.",
  "Logic - Server - Functions - ServerFunctions - call - RPC": "Server actions offer a remote procedure call (RPC) pattern for Next.js applications.",
  "Logic - Server - Functions - ServerFunctions - ServerActions": "",
  "Logic - Server - Functions - ServerFunctions - ServerActions - client": "Client Components can import Server Functions",
  "Logic - Server - Functions - ServerFunctions - ServerActions - useActionState": "useActionState is a Hook that allows you to update state based on the result of a form action.",
  "Logic - Server - Functions - ServerFunctions - ServerActions - forms": "Server Actions work with the new Form features in React 19. You can pass a Server Action to a Form to automatically submit the form to the server. They can be replacement for (unexisting) events in ServerComponents.",
	"Logic - Server - Functions - ServerFunctions - howto - xyzAction.ts": "Name by default.",
  "Logic - Server - Functions - ServerFunctions - howto - use server": "The 'use server' directive is used to mark ServerActions. We don't specify the 'use server' directive in our Server Components; in the React Server Components paradigm, components are treated as Server Components by default. In fact, 'use server' is used for Server Actions, a totally different feature that is beyond the scope of this blog post.",
  "Logic - Server - Functions - ServerFunctions - howto - async": "Name by default.",
  "Logic - Server - Functions - ServerFunctions - howto - _actions": "By convention defined inside _actions folder inside /app.",
  "Logic - Server - Functions - ServerFunctions - attaching - as props": "Server Actions can be created in Server Components and passed as props to Client Components. Server Components can define Server Actions with the 'use server' directive",
  "Logic - Server - Functions - ServerFunctions - attaching - importing": "Server Actions can be imported and used in Client Components. Client Components can import Server Actions from files that use the 'use server' directive:",
  "Logic - Server - Functions - ServerFunctions - composing": "Server Actions can be composed with Actions on the client",
  "Logic - Server - Functions - ServerFunctions - FullStack": "React, with its addition of Server Components and Server Actions, is evolving into a full-stack framework. Once the most popular frontend framework, it has now successfully bridged the gap between frontend and backend to reign over both sides of the chasm.",
	"Logic - Async": "",
	"Logic - Async - Actions": "React 19. Actions streamline the process of handling form submissions and other async tasks, making your code cleaner and more maintainable.",
	"Logic - Async - use": "React 19. React's use API is still in experimental mode. It allows you to pass a Promise from a Server Component to a Client Component and resolve it in the Client Component.",
	"Logic - Async - useAsyncScript": "React 19. You can now render async scripts within any component, with React handling deduplication. This ensures that scripts are loaded efficiently without redundancy.",

  "CICD - Bundling": "SECTION",
	"CICD - Bundling - Arch - Patterns - Base UI Component": "",
  "CICD - Bundling - Arch - Patterns - Base UI Component - BaseUI": "https://baseweb.design/",
  "CICD - Bundling - Arch - Patterns - Inheritance": "No use",
  "CICD - Bundling - Arch - Patterns - Composition": "",
  "CICD - Bundling - Arch - Patterns - Compound": "The Compound Components pattern isn’t just a coding technique; it’s a design paradigm that promotes collaboration between components while maintaining loose coupling. Recognizing its value involves understanding the use of static properties, which resemble dot notation for accessing nested components within a parent component. https://medium.com/@khushi1399gupta/mastering-reacts-compound-components-a-guide-for-experienced-developers-8a35c1468acb",
	"CICD - Bundling - Arch - Patterns - Layout": ".",
	"CICD - Bundling - Arch - Patterns - Layout - Layout pattern": "The main idea behind the Layout component pattern is that components should not know where they are being displayed, and Layout components should only be concerned with displaying the component.",
  "CICD - Bundling - Arch - Patterns - Adapter": "The Adapter Pattern allows incompatible interfaces to work together. It converts the interface of a class into another interface clients expect. This pattern is often used to make existing classes work with others without modifying their source code.",
  "CICD - Bundling - Arch - Patterns - Repository": "The Repository Pattern abstracts the data layer, providing a collection-like interface for accessing domain objects. It mediates between the domain and data mapping layers, acting like an in-memory domain object collection.",
	"CICD - Bundling - Arch - Patterns - ContainerPresenter": "The Container-Presenter Pattern (also known as Smart and Dumb Components) is a fundamental pattern that helps you separate concerns in your React components. The basic idea is to split components into two categories: containers (which handle data fetching, state management, and logic) and presenters (which focus solely on rendering the UI).",
	"CICD - Bundling - Arch - Patterns - Higher-Order Components": "A Higher-Order Component (HOC) is a pattern where you take a component and return a new component with added functionality. HOCs are useful for reusing component logic, such as handling authentication, logging, or theming, without modifying the original component’s behavior.",
	"CICD - Bundling - Arch - Patterns - RenderProps": "The Render Props pattern is a technique where a component takes a function as a prop and uses it to render JSX. This pattern allows for better flexibility and reuse of logic within components. It’s particularly useful for cases where you need to share behavior between components but don’t want to use an HOC.",
	"CICD - Bundling - Arch - Patterns - CustomHooks": "With the rise of hooks, Custom Hooks have become a go-to pattern for reusing stateful logic. Custom hooks allow you to encapsulate stateful behavior and reuse it across different components without duplicating code. If you find yourself repeating logic across components, it’s often a sign that you can extract it into a custom hook.",
	"CICD - Bundling - Optimization - CodeReduction - Resources - Lists": "Virtualize Large Lists with react-window or react-virtualized. Rendering thousands of DOM elements at once slows down performance. Virtualization only renders visible items.",
	"CICD - Bundling - Optimization - CodeReduction - Resources - Lists - windowing": "List visualization, or windowing, involves rendering only the items currently visible on the screen. When dealing with a large number of items in a list, rendering all the items at once can lead to slow performance and consume a significant amount of memory. List virtualization tackles this issue by rendering only a subset of the list items currently visible within the view, which conserves resources as the users scroll through the list.",
  "CICD - Bundling - Optimization - CodeReduction - Resources - Lists - windowing - virtualization": "The virtualization technique dynamically replaces rendered items with new ones, keeping the visible portion of the list updated and responsive. It efficiently allows you to render large lists or tabular data by only rendering the visible portion, recycling components as needed, and optimizing scroll performance. There are different approaches to implementing list visualization in React, and one is using a popular library called React Virtualized.",
  "CICD - Bundling - Optimization - CodeReduction - Resources - Lists - windowing - Unique Keys": "When rendering lists, always provide unique keys to help React identify which items have changed, added, or removed. This can prevent unnecessary re-renders and improve overall performance.",
  "CICD - Bundling - Optimization - CodeReduction - Resources - Lists - windowing - Batch Updates": "Utilize React's batched updates mechanism to minimize the number of re-renders when updating lists. By batching multiple updates into a single render pass, you can optimize performance and ensure a smoother user experience.",
	"CICD - Bundling - Optimization - CodeSplitting - Loading - Lazy - React.lazy": "React.lazy is a feature that allows you to lazily load components, meaning they are loaded only when needed. const lazyComponent = React.lazy(() => import('./HeavyCoponent));",
	"CICD - Bundling - Optimization - CodeSplitting - Loading - Lazy - Suspense - React16.6.0": "It suspends rendering while waiting for data to load, and shows a fallback UI (like a loading spinner) instead of blocking the entire app.",
	"CICD - Bundling - Optimization - CodeSplitting - Loading - Lazy - Suspense - fallback": "Suspense is a component that can be used to define a fallback UI while the lazily loaded component is being loaded.",
	"CICD - Bundling - Optimization - CodeSplitting - Loading - Lazy - Suspense - datasources": "The Suspense documentation insists that the only way of using Suspense is via 'Suspense-enabled frameworks'.",
	"CICD - Bundling - Optimization - CodeFetching - PreLoading": "React v19 allows developers to preload resources using various strategies like prefetchDNS, preconnect, preload, and preinit. This ensures that critical resources are loaded quickly, improving performance.",
	"CICD - Bundling - Optimization - CodeFetching - PreLoading - prefetchDNS": "React 19. ",
	"CICD - Bundling - Optimization - CodeFetching - PreLoading - preconnect": "React 19. ",
	"CICD - Bundling - Optimization - CodeFetching - PreLoading - preload": "React 19. ",
	"CICD - Bundling - Optimization - CodeFetching - PreLoading - preinit": "React 19. ",

  "CICD - Building": "SECTION",
	"CICD - Building - Compilation - Type - ByPlace - SSR": "With Streaming SSR, React can send parts of the UI to the client as they’re ready, instead of waiting for the whole page to finish rendering. This helps reduce load times and gives a faster Time-to-Interactive.",
  "CICD - Building - FastRefresh - React19": "React 19 has turbocharged the development process with an even faster refresh. Your changes appear instantly without losing the component state.",
  "CICD - Building - production": "Make sure to test any performance issues you may be seeing with your React apps using the production build's minified version.",
  "CICD - Building - Tools - JSX - transpilation": "JSX allows you to write HTML-like code in your JavaScript. It gets transpiled by a tool like Babel to JavaScript before being rendered in the browser..",
  "CICD - Building - Tools - JSX - transpilation - Babel": "Browsers don’t understand JSX out of the box, so most React users rely on a compiler like Babel or TypeScript to transform JSX code into regular JavaScript.",
	"CICD - Building - Tools - ReactForget": "React 19 and the ReactCompiler, previously known as React Forget",
	"CICD - Building - Tools - ReactCompiler": "",
  "CICD - Building - Tools - ReactCompiler - plugAndPlay": "The Compiler is plug-and-play: you install it, and it Just Works; there is no need to rewrite existing code.",
  "CICD - Building - Tools - ReactCompiler - ReactCompilerConfig": "https://jherr2020.medium.com/react-compiler-with-react-18-1e39f60ae71a",
  "View - Building - Tools - ReactCompiler - memoization - automemoization - React19": "One of the standout features of React 19 is its ability to handle memoization automatically. Previously, developers had to use useMemo and useCallback to manually optimize component re-renders. With React 19, these concerns are handled under the hood, reducing the need for manual intervention.",
  "View - Building - Tools - ReactCompiler - memoization - manual": "While the compiler may provide impressive optimizations, there are still situations where manual memoization might be necessary.",
	"CICD - Building - Tools - Bit": "Bit is a next-generation building system that develops composable software. https://bit.dev/",

  "CICD - Execution": "SECTION",
	"CICD - Execution - Scopes - Block": "Block scope: The context inside of a pair of curly braces (only applies to variables created with const and let).",
	"CICD - Execution - Scopes - Function": "Function scope: The context within a JS-function.",
	"CICD - Execution - Scopes - Component": "Component scope: The context inside a functional or class component.",
	"CICD - Execution - Scopes - Module": "Module scope: The context for code running inside a JavaScript (JS), JSX, TypeScript (TS), or TSX file.",

  "CICD - Audit": "SECTION",
	"CICD - Audit - Security - XSS - JSX": "By default, React DOM escapes any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that’s not explicitly written in your application. Everything is converted to a string before being rendered. This helps prevent XSS (cross-site-scripting) attacks.",
	"CICD - Audit - Security - XSS - dangerouslySetInnerHTML": "Using dangerouslySetInnerHTML bypasses React’s built-in protections and can introduce XSS vulnerabilities. If you must use dangerouslySetInnerHTML (e.g., rendering HTML from a CMS), always sanitize the input before rendering.",
	"CICD - Audit - Security - XSS - EventHandlers": "React does not automatically sanitize event handler values, so avoid inserting untrusted user input into JavaScript code.",
	"CICD - Audit - Security - XSS - URL-Based": "When using URLs in attributes like href, ensure user input doesn’t allow JavaScript execution.",
	"CICD - Audit - Security - XSS - CSP": "Even if React escapes content, a misconfigured app may still be vulnerable. Use Content Security Policy (CSP) headers to block inline scripts.",
	"CICD - Audit - Testing - Jest": ".",
	"CICD - Audit - Testing - ReactTestingLibrary": "React Testing Library is not an alternative to Jest, because they need each other and every one of them has a clear task.",
  "CICD - Audit - Profiling - ReactDevTools": "React Developer Tools. Use React Developer Tools to inspect React components, edit props and state, and identify performance problems.",
  "CICD - Audit - Profiling - ReactDevTools - useDebugValue": "useDebugValue is a React Hook that lets you add a label to a custom Hook in ReactDevTools. useDebugValue(value, format?)",
  "CICD - Audit - Profiling - ReactDevTools - ReactProfiler": "The React Profiler is a tool that comes with the React Developer Tools extension. It allows you to measure and analyze the rendering performance of your components. The React Profiler lets you identify components that take longer to render and detect potential performance bottlenecks."

}