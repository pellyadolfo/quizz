{
  "ReactJS": "SECTION",
  "ReactJS - Feb2010": "2010 - the genesis for React came from an extension of PHP that Facebook had released as open source software in February 2010, called XHP.",
  "ReactJS - 2010": "2010 - However, because it was PHP — a server-side language — every time something changed, the page would need to re-render completely. So the Facebook team decided to move a lot of the application logic of XHP into JavaScript. Jordan Walke, a software engineer at Facebook, created an early prototype of React. js called 'FaxJS.'",
  "ReactJS - 2011": "2011 - An early prototype of React. Jordan Walke created FaxJS, the early prototype of React - shipped a search element on Facebook.",
  "ReactJS - 2012": "2012 - Something new had started at Facebook",
  "ReactJS - 2013": "2013 - The year of the Big Launch",
  "ReactJS - 2014": "2014 - The year of Expansion",
  "ReactJS - 2015": "2015 - React is Stable",
  "ReactJS - 2016": "2016 - React gets mainstream",
  "ReactJS - 2017": "2017 - The year of further improvements",
  "ReactJS - 2018": "",
  "ReactJS - 2019": "",
  "ReactJS - 2020": "",
  "ReactJS - 2021": "",
  "ReactJS - 2022": "",
  "ReactJS - 2023": "",
  "ReactJS - 2024": "",

  "Structure": "SECTION",
  "Structure - Components - CreateClass - ES5 - 2013": "Deprecated. Everything started out with React's createClass Components. The createClass method provided developers with a factory method to create React class components without using a JavaScript class. It was the status quo for creating React components prior JavaScript ES6, because in JavaScript ES5 there was no class syntax available. const MyComponent = React.createClass({ render() { return <p>I am a component!</p>; } });",
  "Structure - Components - CreateClass - deprecated": "Note: React's createClass method is no longer available in the React core package. If you want to try it, you have to install an additional node package: npm install create-react-class. After all, you should only use React's createClass method, if you have no JavaScript ES6 or beyond available in your project. Otherwise you should avoid using it. ",
  "Structure - Components - CreateClass - methods - getInitialState": "the getInitialState() function is used to set an initial state for the React component",
  "Structure - Components - CreateClass - methods - render": "the mandatory render() method is there to display the output with JSX",
  "Structure - Components - CreateClass - methods - onChange": "Additional methods (e.g. onChange()) are added by passing more functions to the object.",
  "Structure - Components - CreateClass - Lifecycle - componentDidUpdate": "Lifecycle methods for side-effects are available as well. For instance, in order to write every time the value from the input field to the browser's local storage, we could make use of the componentDidUpdate() lifecycle method by passing a function to the object with an object key named after a React lifecycle method.",
	"Structure - Components - Class - ES6 - 2015": "They have a more feature-rich API, including state and lifecycle methods.- They are used when you need to manage the component’s state or lifecycle events.",
	"Structure - Components - Class - deprecated": "Probably never need to use a Class component in React anymore. Even though Function components are preferred, there are no current plans on removing Class components from React",
  "Structure - Components - Class - React.Component": "Class components are ES6 classes that extend from `React.Component`.",
  "Structure - Components - Class - React.PureComponent": "React.PureComponent is similar to React.Component . The difference between them is that React.Component doesn't implement shouldComponentUpdate(). React.PureComponent is a base component class that checks the fields of state and props to know whether the component should be updated. React.PureComponent optimizes our components by reducing the number of wasted renders.",
  "Structure - Components - Class - Structure": "You want to have a clear structure in components so you can navigate through them quickly and have a pattern that is obvious to other engineers: 1- State declarations, 2 - Ref declarations, 3 - Memoized values, 4 - Memoized callbacks, 5 - Custom hooks, 6 - Effects, 7 Event handler, 8- JSX",
  "Structure - Components - Class - this": "React will not auto-bind your functions within components. However, you may manually achieve the binding. Here are some ways to bind your components and functions: Bind in render, Allow arrow function in render, Bind in constructor, Bind arrow function in the class property [Not in official ECMAscript]",
  "Structure - Components - Class - render()": "renders JSX",
	"Structure - Components - Class - Lifecycle - ": "These methods are called in the following order when an instance of a component is being created and inserted into the DOM.",
	"Structure - Components - HOC": "Higher-Order Components (HOC) stem from the concept of Higher-Order Functions (HOF) which is called this way whenever it takes a function as argument or returns a function with its return statement.",
	"Structure - Components - HOC - Techniques - Composition": "What's great about Higher-Order Components is that they are just functions which allow you to split functionality into multiple functions.",
	"Structure - Components - Functional": "Functional components are JavaScript functions that take in props as parameters and return React elements. Stateless, less code, easier to test and better perfaormance. ",
	"Structure - Components - Function - Preferred": "In the past, it wasn't possible to use state or side-effects in Function Components -- that's why they were called Functional Stateless Components -- but that's not the case anymore with React Hooks which rebranded them to Function Components. React Hooks bring state and side-effects to React Function Components.",
	"Structure - Components - Function - Lifecycle - No Constructor": "First of all, you have no constructor in a Function Component. Usually the constructor would have been used in a React Class Component to allocate initial state. As you have seen, you don't need it in a Function Component, because you allocate initial state with the useState hook and set up functions within the Function Component for further business logic",
	"Structure - Components - Function - Lifecycle - Simulate Mount": "there is the mounting lifecycle for React components when they are rendered for the first time. If you want to execute something when a React Function Component did mount, you can use the useEffect hook: https://www.robinwieruch.de/react-function-component/#react-arrow-function-component",
	"Structure - Components - Function - Lifecycle - Update": "Every time incoming props or state of the component change, the component triggers a rerender to display the latest status quo which is often derived from the props and state. A render executes everything within the Function Component's body.",
	"Structure - Components - Function - Lifecycle - Rerender": "React memo -- which is one of React's top level APIs -- can be used for React Function Components to prevent a rerender when the incoming props of this component haven't changed:",
	"Structure - Components - Function - Lifecycle - ref": "React Function Components cannot be given refs! If you try the following, the ref will be assigned to the component instance but not to the actual DOM node.",
  "Structure - Components - Function - Lifecycle - Hooks": "Before React 16.8, Class components were the only way to track state and lifecycle on a React component. With the addition of Hooks, Function components are now almost equivalent to Class components.",
	"Structure - Components - Function - Arrow Function": "With the introduction of JavaScript ES6, new coding concepts were introduced to JavaScript and therefore to React. For instance, a JavaScript function can be expressed as lambda (arrow function). That's why a Function Component is sometimes called Arrow Function Components (or maybe also Lambda Function Component). const App = () => { ... };",
	"Structure - Router - ReactRouter": "React Router is the perfect tool to link together the URL and your React app. React Router is the de-facto React routing library, and it's one of the most popular projects built on top of React. We can use ReactRouter with Suspense for LazyLoading.",
	"Structure - Router - TanStackRouter": "",
	"Structure - Router - Vike": "https://javascript.plainenglish.io/exploring-vike-vites-new-micro-frontend-framework-and-how-it-compares-with-other-major-tools-3acad4fa3fc4",

  "Data": "SECTION",
	"Data - Props": "React components use props to communicate with each other. The component receives the argument as a props object. Every parent component can pass some information to its child components by giving them props. Passing props from component to component in React doesn't make components interactive, because props are read-only and therefore immutable.",
  "Data - Props - syntax": "React Props are like function arguments in JavaScript and attributes in HTML. Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, and functions.",
  "Data - Props - syntax - quotes": "You may use quotes to specify string literals as attributes: const element = <a href='https://www.reactjs.org'> link </a>;",
  "Data - Props - syntax - curly braces": "You may also use curly braces to embed a JavaScript expression in an attribute: const element = <img src={user.avatarUrl}></img>;.",
	"Data - Props - syntax - spreading": "<div {...props}>{props.text}</div> should avoid spreading properties into a DOM element as it adds unknown HTML attribute, which is unnecessary and a bad practice.",
  "Data - Props - passing props": "Props are the information that you pass to a JSX tag.",
  "Data - Props - passing props - taintObjectReference": "lets you prevent a specific object instance from being passed to a Client Component like a user object.",
  "Data - Props - passing props - taintUniqueValue": "lets you prevent unique values from being passed to Client Components like passwords, keys, or tokens.",
	"Data - Props - forwarding props": "Props are the information that you pass to a JSX tag.",
	"Data - Props - Props Drilling": "At some point, you are passing a lot of props down your component tree. Depending on the depth of the component tree, it can happen that many props are passed from a top level component to all the leaf components. Every component in between has to pass the props even though it may not be interested in the props. The problem is called prop drilling in React. The solution is Context.",
	"Data - State ": "State lets a component “remember” information like user input. f you want interactive React components, you have to introduce stateful values by using React State. ",
	"Data - State - BuiltIn - State": "setting state requests a re-render from React. This means that for an interface to react to the event, you need to update the state.",
  "Data - State - BuiltIn - State - useState": "The React useState Hook allows us to track state in a function component. State generally refers to data or properties that need to be tracking in an application.",
  "Data - State - BuiltIn - State - SetState": "We recommend using a function and not an object in the setState function. React setState method is asynchronous. This means that rather than immediately mutating this.state, setState() creates a pending state transition. If you access this.state after calling this method, it would potentially return the existing value. To prevent this, use the callback function of setState to run code after the call is completed.",
	"Data - State - BuiltIn - State - useSyncState - React19": "React 19 introduces useSyncState, a simplified and intuitive way to manage component state.",
	"Data - State - BuiltIn - State - Batching": "Batching in React describes the internal implementation detail of React which treats multiple state updates as one state update.",
	"Data - State - BuiltIn - State - Batching - benefit": "The benefit: multiple state updates are batched as one state update and therefore trigger only one re-rendering of the component which improves the rendering performance especially for larger React applications.",
	"Data - State - BuiltIn - State - Batching - React <18": "Prior React 18, not all state updates were batched though. For example, state updates using asynchronous code (e.g. Promise) or third-party APIs (e.g. setTimeout) weren't batched and therefore triggered two re-renderings (for two respective state updates) of the component.",
	"Data - State - BuiltIn - State - Batching - React 18": "However, with React's additions in React 18, automatic batching became the default. If there are situations where a React developer would want to opt-out of batching, one could use the flushSync top-level API of React.",
	"Data - State - BuiltIn - State - Batching - flushSync": "The flushSync() forces React to apply the state updates in the callback function synchronously and therefore forces React to update the DOM immediately. Other pending state updates will be force applied too. After all, flushSync should be used sparingly (almost never), except for occassion where it is really needed, because it comes with caveats. Using flushSync is uncommon and can hurt the performance of your app. Most of the time, flushSync can be avoided, so use flushSync as a last resort.",
	"Data - State - BuiltIn - Reducer": "A reducer function takes the current state and an action with payload and computes it to a new state: (state, action) => newState.",
  "Data - State - BuiltIn - Reducer - useReducer": "The useReducer Hook is similar to the useState Hook. It allows for custom state logic. If you find yourself keeping track of multiple pieces of state that rely on complex logic, useReducer may be useful. useReducer(<reducer>, <initialState>). This is the key difference between useState and useReducer: with useReducer, state is altered by passing messages rather than calling the updater function.",
	"Data - State - BuiltIn - Context": "React Context is a way to manage state globally. Context is designed to share data that can be considered 'global' for a tree of React components, such as the current authenticated user, theme, or preferred language. Context is not a good solution for state management in most cases. Built into React, requiring no additional libraries. Context lets a component receive information from distant parents without passing it as props.",
	"Data - State - BuiltIn - Context - howto - 1.createContext": "createContext lets you create a context that components can provide or read. type CartContextValues = { count: number; ... } }; export const CartContext = createContext<CartContextValues | null>(null); - https://medium.com/@samhodev/zustand-how-is-it-better-than-react-context-with-an-example-24dad4c65753",
	"Data - State - BuiltIn - Context - howto - 2.Create Provider": "The CartContextProvider is a component that will wrap part of your component tree and provides the context value to all components within that tree. - export const CartContextProvider = ({children}: Props) => { return ( <CartContext.Provider value={{count, setCount, payTotal, subTotal, deliveryCost}}> {children}<CartContext.Provider>); } ",
  "Data - State - BuiltIn - Context - howto - 3.Apply Provider": "Wraps our component tree with CartContextProviderto make the context available to child components. - export const ReactContextDemo = () => { return (<> <CartContextProvider>.../CartContextProvider></>);};",
  "Data - State - BuiltIn - Context - howto - 4.useContext": "To access the context value, use the useContext hook in our child component. It can be used together with the useState Hook to share state between deeply nested components more easily than with useState alone. - const cartContext = useContext(CartContext);",
	"Data - State - BuiltIn - Context - Use - React19": "React Context is still a valuable tool when used correctly. It’s well-suited for:",
  "Data - State - BuiltIn - Context - Use - Theming": "Theme Management: Managing UI themes across an application.",
  "Data - State - BuiltIn - Context - Use - Locale": "Locale Management: Handling localization and language settings.",
  "Data - State - BuiltIn - Context - Use - Authentication": "Authentication State: Providing user authentication status throughout your app.",
  "Data - State - BuiltIn - Context - Use - Routing": "Routing: Most routing solutions use context internally to hold the current route. This is how every link “knows” whether it’s active or not. If you build your own router, you might want to do it too.",
  "Data - State - BuiltIn - Context - Use - State": "Managing state: As your app grows, you might end up with a lot of state closer to the top of your app. Many distant components below may want to change it. It is common to use a reducer together with context to manage complex state and pass it down to distant components without too much hassle.",
  "Data - State - BuiltIn - Context - NoUse": "Large Applications with Complex State Management Needs:, High-Frequency State Updates, Cross-Cutting Concerns, Frequent Debugging Issues",
	"Data - State - BuiltIn - Context - NoUse - Renders": "There are unnecessary re-renders on the delivery component.",
	"Data - State - BuiltIn - Context - NoUse - Performance": "React Context can lead to performance bottlenecks, especially in large applications. When you update the context, every component that consumes that context will re-render, even if the part of the state they use hasn’t changed. This can significantly impact performance.",
  "Data - State - BuiltIn - Context - NoUse - Debug": "When state is scattered across various contexts, debugging becomes more complex. Understanding the flow of state and tracking down where and why certain updates occur can be challenging. Example: Imagine having multiple contexts like UserContext, ThemeContext, and SettingsContext. Debugging why a component re-rendered unexpectedly becomes a complex task as you need to check updates across all these contexts.",
  "Data - State - BuiltIn - Context - NoUse - Code": "Using React Context for state management can introduce a lot of boilerplate code. You need to set up the provider, create context objects, and ensure proper usage throughout the application. Every new context requires similar setup, which can quickly add up and clutter your codebase.",
  "Data - State - BuiltIn - Context - NoUse - Scalability": "React Context is not inherently designed to handle complex state management tasks such as actions, reducers, or middleware. This limitation becomes apparent as your application grows and your state management needs become more complex.",
  "Data - State - BuiltIn - Context - NoUse - Testing": "Testing components that rely on React Context can be cumbersome. You often need to wrap your components with context providers, adding an extra layer of complexity to your tests.",
  "Data - State - libraries - ReactTracked": "",
  "Data - State - libraries - Zustand": "<b>Zustand is a single store similar to Redux</b>. A small, fast, and scalable state management library that provides a simpler API compared to Redux. https://medium.com/@samhodev/zustand-how-is-it-better-than-react-context-with-an-example-24dad4c65753",
	"Data - State - libraries - Zustand - builtOn": "Zustand uses React's custom hook-based approach to handle Component state distribution.",
  "Data - State - libraries - Zustand - howto - 1. Create Store.": "A 'store' in Zustand holds your application’s state. We create a store using the create function provided by Zustand, and define the cart state and actions. - interface CountState { ... }; export const useCartStore = create<CountState>((set) => ({ ... }));",
  "Data - State - libraries - Zustand - howto - 2. Use Store.": "We can use the Zustand store in our components by calling the custom hook we exported from CartStore.tsx. We can also prevent unnecessary re-render using useShallow hook provided by Zustand. The component re-renders only when state.deliveryCost change  const { deliveryCost } = useCartStore( useShallow((state) => ({ deliveryCost: state.deliveryCost })) );",
	"Data - State - libraries - Zustand - Use - State": "Use Zustand if you need simple, high-performance state management with minimal setup and are dealing with mostly global state",
  "Data - State - libraries - Zustand - Use - Performance": "While React Context provide a simple native solution of passing states to child components, Zustand can offer better performance in some scenarios, such as the above scenario where components only re-renders to the specific pieces of state they use.",
  "Data - State - libraries - Zustand - Use - Hooks": "works well with React’s hooks.",
  "Data - State - libraries - Zustand - Use - SSR": "smooth SSR integration.",
  "Data - State - libraries - Valtio": "Valtio is yet another library for global state. Unlike Zustand and Jotai, it's based on the mutating update model. It's primarily for module states like Zustand. It utilizes proxies to get an immutable snapshot, which is required to integrate with React.",
	"Data - State - libraries - Flux": "Flux uses a unidirectional data flow pattern to solve state management complexity. Remember it is not a framework – rather it's more of a pattern that targets to solve the state management issue.",
  "Data - State - libraries - Redux": "Centralizes state management using an event store, allowing easy tracking of all state changes, every change is immutable which serves as a single source of truth. Redux: Enforces One-way data flow. The flow starts from an action, dispatches changes to the store, and updates subscribed components.",
  "Data - State - libraries - Redux - performance": "A well-known flaw faced by Yahoo is a classic example to consider when React apps are built with Redux. Indeed the combination is deadly and enables complex situations to structurize, but when you use Redux, your React app rerenders and slows down your performance.",
  "Data - State - libraries - Redux - parts - Action": "Action: An action is dispatched, representing a change or event in the application.",
  "Data - State - libraries - Redux - parts - Reducer": "Reducer: The reducer function takes the current state and the action, processes the update, and returns a new state. The state is immutable, so a new state object is created rather than modifying the existing state.",
  "Data - State - libraries - Redux - parts - Store": "Store: The store holds the entire state tree of the application. When an action is dispatched and processed by the reducers, the store updates and notifies all components subscribed to it.",
  "Data - State - libraries - Redux - parts - Component": "Component: Components subscribe to the store and react to state changes by re-rendering, ensuring the UI reflects the current state.",
  "Data - State - libraries - Redux - Easy Peasy": "Easy Peasy is an abstraction of Redux, providing a reimagined API that focuses on developer experience. It allows you to quickly and easily manage your state, whilst leveraging the strong architectural guarantees and extensive eco-system that Redux has to offer. https://easy-peasy.vercel.app/",
  "Data - State - libraries - Recoil": "A state management library from Facebook that offers fine-grained state management with a simpler API.",
  "Data - State - libraries - Recoil - atoms": "Atoms contain the source of truth for our application state.",
  "Data - State - libraries - Recoil - builtOn": "Using React's internal Context API, Recoil internally uses this API to propagate state updates to the subscribed Components.",
	"Data - State - libraries - Jotai": "Jotai is a minimalistic state management library for React that focuses on atomic state",
	"Data - State - libraries - Jotai - atoms": "<b>Jotai consists of primitive atoms that can be composed together</b>. It allows you to manage state in small, isolated pieces called atoms. When your application benefits from fine-grained control over state and you prefer managing state in small, isolated pieces. Use Jotai if you prefer atomic state management, need fine-grained control over state, or are dealing with scoped or dynamic state requirements.",
  "Data - State - libraries - Mobx": "A library that makes state management simple and scalable through reactive state management.",
  "Data - State - libraries - Mobx - observable": "Mobx applies concepts from Functional Reactive Programming and Object-Oriented design to automatically track changes to state and propagate updates. Mobx lets you create individual 'store' classes and mark specific fields as 'observable', then mark React components and other logic as 'observers'. You can directly modify those observables fields in your code, and Mox will transparently update any observer code that depends on those fields.",
  "Data - State - libraries - Mobx - atoms": " Achieving this is pretty simple by using atoms, which is the class that MobX uses internally for all observable data types. Atoms can be used to signal to MobX that some observable data source has been observed or changed, and MobX will let the atom know when it's being used and when it's not.",
  "Data - State - libraries - Nuqs": " ",
  "Data - State - libraries - NanoStores": " ",
  "Data - State - libraries - statemachine - XState": " ",
  "Data - State - libraries - statemachine - Zag": " ",
	"Data - Forms - <form>": "The built-in browser <form> component lets you create interactive controls for submitting information.",
	"Data - Forms - <form> - reset": "On submit resets by default.",
	"Data - Forms - <form> - uncontrolled": "Uncontrolled forms use the native, built-in <form> functionalities of vanilla HTML and JavaScript to manage data.",
	"Data - Forms - <form> - controlled": "Controlled forms store each input’s value in React state, and then set the value of each input on each re-render from that state.",
	"Data - Forms - <form> - FormData": "FormData objects are used to capture HTML form and submit it using fetch or another network method.",
	"Data - Forms - <form> - FormData - location": "placed in server or ServerAction",
	"Data - Forms - <form> - FormData - content": "contains all params of the form as title: formData.get('title')",
	"Data - Forms - <form> - FormData - destructuring": "const { title, amount } = Object.fromEntries(formData);",
	"Data - Forms - <form> - FormData - noreset": "return formData as default value to prevent reset",
	"Data - Forms - <form> - Hooks - useActionState": "React 19. Declare form state and degrade gracefully if JS hasn’t executed yet.",
	"Data - Forms - <form> - Hooks - useFormState": "React 19. This hook provides an easy way to track the status of form submissions.",
	"Data - Forms - <form> - Hooks - useFormStatus": "React 19. useFormStatus is a Hook that gives you status information of the last form submission.",
	"Data - Forms - <form> - Hooks - useOptimistic": "React 19. Show the final state optimistically while an async request is underway.",
	"Data - Forms - form - libraries - react-hook-form": ".",
	"Data - Forms - form - libraries - Formik": ".",
	"Data - Forms - form - libraries - Zod": ".",
	"Data - Forms - form - libraries - Yup": "form validation.",

	"View": "SECTION",
	"View - JSX": "Returned by Components.",
  "View - JSX - elements": "React elements are immutable. Once you create an element, you can’t change its children or attributes.",
  "View - JSX - React.createElement()": "Babel compiles JSX down to React.createElement() calls. A component's render output is normally written in JSX syntax, which is then converted to React.createElement() calls as the JS is compiled and prepared for deployment. createElement returns React elements, which are plain JS objects that describe the intended structure of the UI.",
  "View - JSX - owner": "Component wrapping the JSX",
	"View - JSX - nesting": "When you nest content inside a JSX tag, the parent component will receive that content in a prop called children.",
  "View - JSX - parent": "Nested elements within the JSX.",
  "View - JSX - expressions": "You can put any valid JavaScript expression inside the curly braces in JSX.",
  "View - JSX - injection attacks": "By default, React DOM escapes any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that’s not explicitly written in your application. Everything is converted to a string before being rendered. This helps prevent XSS (cross-site-scripting) attacks.",
	"View - JSX - Conditional": ".",
	"View - JSX - Conditional - if - short-circuit": "<div>{count && <h1>Messages: {count}</h1>}</div>.",
	"View - JSX - Conditional - if - ternary": "<div>{count ? <h1>Messages: {count}</h1> : null}</div>. Preferred",
	"View - JSX - Built-in - Common": "All built-in browser components, such as <div>, support some common props and events. https://beta.reactjs.org/reference/react-dom/components/common",
	"View - JSX - Built-in - <Fragment>": "<Fragment>, often used via <>...</> syntax, lets you group elements without a wrapper node. This is particularly useful when you need to return multiple elements from a component's render method, but you don't want to introduce unnecessary DOM elements that could affect the layout or styles of your application.",
  "View - JSX - Built-in - <Profiler>": "<Profiler> lets you measure rendering performance of a React tree programmatically.",
  "View - JSX - Built-in - <StrictMode>": "<StrictMode> lets you find common bugs in your components early during development. <StrictMode> <App /> </StrictMode>",
  "View - JSX - Built-in - <Suspense>": "<Suspense> lets you display a fallback until its children have finished loading. <Suspense fallback={<Loading />}> <SomeComponent /> </Suspense>",
  "View - JSX - Built-in - <input>": "The built-in browser <input> component lets you render different kinds of form inputs. <input />",
  "View - JSX - Built-in - <option>": "The built-in browser <option> component lets you render an option inside a <select> box. <select>  <option value='someOption'>Some option</option> <option value='otherOption'>Other option</option> </select>",
  "View - JSX - Built-in - <progress>": "The built-in browser <progress> component lets you render a progress indicator. <progress value={0.5} />",
  "View - JSX - Built-in - <select>": "The built-in browser <select> component lets you render a select box with options. <select>  <option value='someOption'>Some option</option> <option value='otherOption'>Other option</option> </select>",
  "View - JSX - Built-in - <textarea>": "The built-in browser <textarea> component lets you render a multiline text input. <textarea />",
	"View - JSX - Built-in - lists - keys": "Keys must be unique among siblings. However, it’s okay to use the same keys for JSX nodes in different arrays. Keys must not change or that defeats their purpose! Don’t generate them while rendering.",
	"View - JSX - Built-in - lists - keys - index": "You might be tempted to use an item’s index in the array as its key. In fact, that’s what React will use if you don’t specify a key at all. But the order in which you render items will change over time if an item is inserted, deleted, or if the array gets reordered. Index as a key often leads to subtle and confusing bugs.",
	"View - JSX - Built-in - lists - keys - generated": "Similarly, do not generate keys on the fly, e.g. with key={Math.random()}. This will cause keys to never match up between renders, leading to all your components and DOM being recreated every time. Not only is this slow, but it will also lose any user input inside the list items. Instead, use a stable ID based on the data.",
	"View - JSX - Built-in - lists - filter": ".",
	"View - JSX - Built-in - lists - map": ".",
	"View - JSX - Built-in - lists - windowing": "List visualization, or windowing, involves rendering only the items currently visible on the screen. When dealing with a large number of items in a list, rendering all the items at once can lead to slow performance and consume a significant amount of memory. List virtualization tackles this issue by rendering only a subset of the list items currently visible within the view, which conserves resources as the users scroll through the list.",
  "View - JSX - Built-in - lists - windowing - virtualization": "The virtualization technique dynamically replaces rendered items with new ones, keeping the visible portion of the list updated and responsive. It efficiently allows you to render large lists or tabular data by only rendering the visible portion, recycling components as needed, and optimizing scroll performance. There are different approaches to implementing list visualization in React, and one is using a popular library called React Virtualized.",
  "View - JSX - Built-in - lists - windowing - Unique Keys": "When rendering lists, always provide unique keys to help React identify which items have changed, added, or removed. This can prevent unnecessary re-renders and improve overall performance.",
  "View - JSX - Built-in - lists - windowing - Batch Updates": "Utilize React's batched updates mechanism to minimize the number of re-renders when updating lists. By batching multiple updates into a single render pass, you can optimize performance and ensure a smoother user experience.",
  "View - Styling - className": "",
  "View - Styling - className - conditional": "classNames.push('box-error'); ... <div className={classNames.join(' ')}>",
	"View - Rerendering": "Any screen update in a React app happens in three steps: Trigger, Render, Commit. https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/",
	"View - Rerendering - Triggering - Triggers - FirstRender": "First Render.",
	"View - Rerendering - Triggering - Triggers - StateChange": "State change.",
  "View - Rerendering - Triggering - Triggers - StateChange - Cascading": "Re-renders in React are cascading. Every time you change state in a React component, you trigger a re-render of that component, every component inside, components inside of those components, etc., until the end of the component tree is reached.",
	"View - Rerendering - Triggering - NoTriggers - memoization": "Memoization in React is a technique used to optimize the performance of functional components by caching the results of expensive computations or function calls. In web development, memoization is the process of storing data (e.g. a variable value) in the cache and then retrieving this information next time it is needed (e.g. on a page or component re-render).",
  "View - Rerendering - Triggering - NoTriggers - memoization - React.memo": "By using React.memo(), the rendering result is cached based on props. If the props haven't changed since the last render, React reuses the previously rendered result instead of redoing the rendering process. This saves time and resources.",
  "View - Rerendering - Triggering - NoTriggers - memoization - useMemo": "useMemo allows us to remember a computed value between renders.",
  "View - Rerendering - Triggering - NoTriggers - memoization - useCallback": "useCallback allows us to remember a computed function between renders.",
  "View - Rerendering - Triggering - NoTriggers - memoization - ReactCompiler": "Now, everything I’ve just told you about useMemo and useCallback may become totally irrelevant when React Compiler is released! React Compiler is a low-level, auto-memoizing compiler that will handle all memoization without you - the developer - having to do anything at all. React Compiler is an ‘auto-memoizing compiler’ that automates all memoizations in your application. In simpler terms, this means that it will automatically detect the need for useMemo and useCallback so you will no longer have to think about these hooks or which one you need to use for a certain situation.",
  "View - Rerendering - Triggering - NoTriggers - memoization - ReactCompiler - automemoization - React19": "One of the standout features of React 19 is its ability to handle memoization automatically. Previously, developers had to use useMemo and useCallback to manually optimize component re-renders. With React 19, these concerns are handled under the hood, reducing the need for manual intervention.",
  "View - Rerendering - Triggering - NoTriggers - memoization - ReactCompiler - manual": "While the compiler may provide impressive optimizations, there are still situations where manual memoization might be necessary.",
	"View - Rerendering - Rendering - Flagged": "During the rendering process, React will start at the root of the component tree and loop downwards to find all components that have been flagged as needing updates. For each flagged component, React will call either FunctionComponent(props) (for function components), or classComponentInstance.render() (for class components) , and save the render output for the next steps of the render pass.",
	"View - Rerendering - Rendering - Diffing": "React performs a diffing algorithm to compare the previous Virtual DOM with the new one, and react determines which parts of the actual DOM need to be updated by comparing the differences.",
	"View - Rerendering - Rendering - Diffing - reconciliation": "The diffing and calculation process is known as 'reconciliation'. After the initial render, any changes to the application state or props trigger React’s reconciliation process. React optimization applies the necessary changes to the browser DOM to reflect the updated Virtual DOM. However, instead of updating every DOM node individually, React optimizes the process by batching updates and efficiently applying them. React uses a “reconciliation” technique to minimize the number of DOM manipulations required.",
	"View - Rerendering - Rendering - Diffing - hierarchy": "After rendering (calling) your components, React will modify the DOM. Parents Don't Re-Render Their Children but Owners do.",
  "View - Rerendering - Rendering - Diffing - shouldComponentUpdate()": "The shouldComponentUpdate()  method is called before a component is updated. It takes two arguments: nextProps and nextState. This method returns a boolean value that determines whether the component should update or not. If this method returns true, the component will update, and if it returns false, the component will not update.",
	"View - Rerendering - Rendering - Diffing - Why did you update": "If you are still not satisfied by the output of React performance tools, you can still use “why-did-you-update” library that hooks into React and detects potentially unnecessary component renders. The library once goes in an active stage will shout out into your console anytime a piece of state makes your component update which in reality shouldn’t update at all.",
	"View - Rerendering - Committing": "Commit phase is where React actually interacts with the DOM.",
	"View - Rerendering - Committing - goal": "This is the point where it inserts, deletes, and updates DOM elements, making the final changes visible in the browser.",
	"View - Rerendering - Committing - React": "React itself never interacts with the DOM. React is solely responsible for the render phase. React was designed to be platform-agnostic.",
	"View - Rerendering - Committing - VirtualDOM": "React element tree",
  "View - Rerendering - Committing - VirtualDOM - tree - WIP": "React uses a Virtual DOM, a lightweight representation of the browser DOM. The Virtual DOM allows React to efficiently manage and update the UI. React has introduced a new way of handling routing in web applications and it was the Virtual DOM. Instead of using the native browser routing and navigation, we keep all of that in the JavaScript memory and use JavaScript to handle pages and routing for us, and as a result, it will become a lot faster.",
  "View - Rerendering - Committing - VirtualDOM - tree - Curremt": "The real browser DOM rght now.",
	"View - Rerendering - Committing - VirtualDOM - ReactDOM": "A separate library called React DOM is responsible for writing to the DOM.",
	"View - Rerendering - Committing - VirtualDOM - ReactDOM - update": "React updates the DOM in the commit phase. React applications use components that form a hierarchical structure to build applications. Components can be functional or class-based and represent reusable UI elements.",
  "View - Rerendering - Committing - VirtualDOM - ReactDOM - operations - routing": "Instead of using the native browser routing and navigation, we keep all of that in the JavaScript memory and use JavaScript to handle pages and routing for us, and as a result, it will become a lot faster.",
	"View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler": "React updates only the parts of the DOM that have actually changed.",
	"View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler - stack": "React 15 and previous versions of React, in those versions, we had a reconciler called stack reconciler which was a LIFO data structure responsible for picking a work and returning the results just like how the JavaScript call stack works. The main problem was that the stack reconciler was synchronous and sequential meaning there was no chance for it to handle multiple units of work at the same time in parallel or concurrently.",
	"View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler - batches": "React’s virtual DOM improves performance by batching updates and reducing the number of direct manipulations to the actual DOM. Reflow and Repaint are both heavy. The Virtual DOM boosts performance by minimizing browser reflows and repaints. Reflows are particularly expensive because they involve recalculating the layout of the page. Without the Virtual DOM, each of the X DOM operations would trigger a reflow and repaint. However, with the Virtual DOM, holding a 'diff-tree' for the dom-difference, these operations are processed in batches, resulting in only one reflow and repaint.",
  "View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler - Fiber - React16": "In React version 16 and above, the React team has introduced a new way of handling the units of work and virtual DOM tree using the new meta called Fiber Reconciler to tackle two main challenges: 1- Synchronous way of processing the units of work 2- Prioritizing and concurrency of the units of work.",
  "View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler - Fiber - goal": "Each fiber holds the actual component state, props, and a queue of work. After reconciliation, this work queue contains the necessary DOM updates for that element.",
  "View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler - Fiber - features - prioritized - ": "",
  "View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler - Fiber - features - delayed - ": "",
  "View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler - Fiber - features - canceled - ": "",
	"View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler - Fiber - features - ConcurrentReact - React18": "The most important addition in React 18 is something we hope you never have to think about: concurrency.",
	"View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler - Fiber - features - ConcurrentReact - renderer": "Many of the features in React 18 are built on top of our new concurrent renderer, a behind-the-scenes change that unlocks powerful new capabilities. Concurrency is not a feature, per se. It’s a new behind-the-scenes mechanism that enables React to prepare multiple versions of your UI at the same time.",
	"View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler - Fiber - features - ConcurrentReact - optin": "Concurrent React is opt-in — it’s only enabled when you use a concurrent feature — but we think it will have a big impact on the way people build applications.",
	"View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler - Fiber - features - ConcurrentReact - interruptible": "A key property of Concurrent React is that rendering is interruptible. When you first upgrade to React 18, before adding any concurrent features, updates are rendered the same as in previous versions of React — in a single, uninterrupted, synchronous transaction. With synchronous rendering, once an update starts rendering, nothing can interrupt it until the user can see the result on screen. In a concurrent render, this is not always the case. React may start rendering an update, pause in the middle, then continue later. It may even abandon an in-progress render altogether. React guarantees that the UI will appear consistent even if a render is interrupted. To do this, it waits to perform DOM mutations until the end, once the entire tree has been evaluated. With this capability, React can prepare new screens in the background without blocking the main thread. This means the UI can respond immediately to user input even if it’s in the middle of a large rendering task, creating a fluid user experience.",
	"View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler - Fiber - features - ConcurrentReact - reusable": "Another example is reusable state. Concurrent React can remove sections of the UI from the screen, then add them back later while reusing the previous state. For example, when a user tabs away from a screen and back, React should be able to restore the previous screen in the same state it was in before. In an upcoming minor, we’re planning to add a new component called <Offscreen> that implements this pattern. Similarly, you’ll be able to use Offscreen to prepare new UI in the background so that it’s ready before the user reveals it.",
	"View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler - Fiber - features - ConcurrentReact - gradual": "Gradually Adopting Concurrent Features. Technically, concurrent rendering is a breaking change. Because concurrent rendering is interruptible, components behave slightly differently when it is enabled.",
  "View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler - Fiber - features - ConcurrentReact - delay - Urgent": "Urgent updates reflect direct interaction, like typing, clicking, pressing, and so on. Urgent updates like typing, clicking, or pressing, need immediate response to match our intuitions about how physical objects behave. Otherwise they feel “wrong”.",
  "View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler - Fiber - features - ConcurrentReact - delay - Transition": "Transition updates transition the UI from one view to another. However, transitions are different because the user doesn’t expect to see every intermediate value on screen.",
	"View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler - Fiber - features - ConcurrentReact - delay - Transition - useTransition": "useTransition is a React Hook that lets you update the state without blocking the UI. const [isPending, startTransition] = useTransition(). The useTransition hook in React plays a pivotal role in improving the performance of applications by allowing the marking of state updates as non-blocking transitions. This capability enables React to defer rendering for these updates, preventing UI blocking and enhancing overall responsiveness.",  
	"View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler - Fiber - features - ConcurrentReact - delay - Transition - startTransition - React18": "It allows developers to mark certain state updates as transitions.",  
	"View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler - Fiber - features - ConcurrentReact - delay - Transition - LowPriority": "These marked updates are considered low priority and non-blocking. If there are other higher priority updates (like user input), React will handle these first before restarting the state updates within startTransitions",  
	"View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler - Fiber - features - ConcurrentReact - delay - useDeferredValue - React18": "useDeferredValue is a React Hook that lets you defer updating a part of the UI. const deferredValue = useDeferredValue(value)",
	"View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler - Fiber - features - ConcurrentReact - SSR": "With Streaming SSR, React can send parts of the UI to the client as they’re ready, instead of waiting for the whole page to finish rendering. This helps reduce load times and gives a faster Time-to-Interactive.",
  "View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler - Fiber - features - async": "It’s important to remember that the render phase is asynchronous, allowing Fiber to prioritize tasks, split work into chunks, and pause or resume certain tasks as needed. parallelized to do multiple works concurrently at the same time",
  "View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler - Fiber - work - unit": "A unit of work in React can be a change in props or state or DOM updates, anything that can change the output for the screen. The fiber has a relation of 1 to 1 with something whether a component instance, DOM node, etc. ",
  "View - Rerendering - Committing - VirtualDOM - ReactDOM - Reconciler - Fiber - work - modules": "The current React Fiber Reconciler consists of many fiber nodes which are plain JavaScript objects with a lot of properties to handle their work. Fiber = { a JavaScript object with many properties OR unit of work }. Fiber Reconciler = The current React reconciler based on Fiber objects or units of work.",
	"View - Rerendering - Committing - VirtualDOM - ReactDOM - Rendering": "Rendering in React essentially means invoking the functions of those components.",
	"View - Rerendering - Committing - VirtualDOM - ReactDOM - Rendering - Mounting": "When a React application is first loaded, React constructs the initial Virtual DOM tree based on the component hierarchy. Each component’s render method is called to generate the corresponding Virtual DOM representation.",
  "View - Rerendering - Committing - VirtualDOM - ReactDOM - Rendering - Mounting - constructor()": "The constructor runs before your class component mounts (gets added to the screen). Typically, a constructor is only used for two purposes in React. It lets you declare state and bind your class methods to the class instance:",
  "View - Rerendering - Committing - VirtualDOM - ReactDOM - Rendering - Mounting - getDerivedStateFromProps()": "During the mounting phase, getDerivedStateFromProps() is called after the constructor and before render(). This method is called for every render cycle and provides an opportunity to update the component's state based on changes in props before the initial render.",
	"View - Rerendering - Committing - VirtualDOM - ReactDOM - Rendering - Mounting - render()": "The render() method is responsible for generating the component's virtual DOM representation based on its current props and state. It is called every time the component needs to be re-rendered, either because its props or state have changed, or because a parent component has been re-rendered.",
  "View - Rerendering - Committing - VirtualDOM - ReactDOM - Rendering - Mounting - componentDidMount()": "The componentDidMount() method is called once the component has been mounted into the DOM. It is typically used to set up any necessary event listeners or timers, perform any necessary API calls or data fetching, and perform other initialization tasks that require access to the browser's DOM API.",
  "View - Rerendering - Committing - VirtualDOM - ReactDOM - Rendering - Mounting - componentWillMount()": "Deprecated. ",
	"View - Rerendering - Committing - VirtualDOM - ReactDOM - Rendering - Updating": "An update can be caused by changes to props or state. These methods are called in the following order when a component is being re-rendered.",
  "View - Rerendering - Committing - VirtualDOM - ReactDOM - Rendering - Updating - static getDerivedStateFromProps()": ".",
  "View - Rerendering - Committing - VirtualDOM - ReactDOM - Rendering - Updating - render()": ".",
  "View - Rerendering - Committing - VirtualDOM - ReactDOM - Rendering - Updating - getSnapshotBeforeUpdate()": "The getSnapshotBeforeUpdate() method is called just before the component's UI is updated. It allows the component to capture some information about the current state of the UI, such as the scroll position before it changes. This method returns a value that is passed as the third parameter to the componentDidUpdate() method.",
  "View - Rerendering - Committing - VirtualDOM - ReactDOM - Rendering - Updating - componentWillUpdate()": "componentWillUpdate() is a lifecycle method in React that gets called just before a component's update cycle starts.",
  "View - Rerendering - Committing - VirtualDOM - ReactDOM - Rendering - Updating - componentDidUpdate()": "The componentDidUpdate() method is a lifecycle method in React that is called after a component has been updated and re-rendered.",
	"View - Rerendering - Committing - VirtualDOM - ReactDOM - Rendering - Unmounting - componentWillUnmount()": "React will call it before your component is removed (unmounted) from the screen.",
	"View - Rerendering - Committing - VirtualDOM - ReactDOM - Rendering - useLayoutEffect": "It then synchronously runs the componentDidMount and componentDidUpdate class lifecycle methods, and the useLayoutEffect hooks.",
	"View - Rerendering - Committing - VirtualDOM - ReactDOM - Rendering - pasiveEffects": "React then sets a short timeout, and when it expires, runs all the useEffect hooks. This step is also known as the 'Passive Effects' phase.",
	"View - Rerendering - Committing - VirtualDOM - ref": "Refs let a component hold some information that isn’t used for rendering, like a DOM node or a timeout ID. Unlike with state, updating a ref does not re-render your component. Refs are an “escape hatch” from the React paradigm. They are useful when you need to work with non-React systems, such as the built-in browser APIs. A React Ref should only be used in rare cases such as accessing/manipulating the DOM manually (e.g. focus element), animations, and integrating third-party DOM libraries.",
	"View - Rerendering - Committing - VirtualDOM - ref - update": "After React has updated the DOM in the commit phase, it updates all refs accordingly to point to the requested DOM nodes and component instances.",
  "View - Rerendering - Committing - VirtualDOM - ref - useRef": "The useRef Hook allows you to persist values between renders. It can be used to store a mutable value that does not cause a re-render when updated. It can be used to access a DOM element directly. The useRef Hook returns an object with a single property called current. Initially, myRef.current will be null. When React creates a DOM node for this <div>, React will put a reference to this node into myRef.current. You can then access this DOM node from your event handlers and use the built-in browser APIs defined on it.",
  "View - Rerendering - Committing - VirtualDOM - ref - useImperativeHandle": "useImperativeHandle is a React Hook that lets you customize the handle exposed as a ref. useImperativeHandle(ref, createHandle, dependencies?)",
  "View - Rerendering - Committing - VirtualDOM - ref - forwardRef": "forwardRef lets your component expose a DOM node to parent component with a ref. It's not recommended to pass a ref from a Parent Component to a Child Component and that's why the assumption has always been: React Function Components cannot have refs. However, if you need to pass a ref to a Function Component -- because you have to measure the size of a function component's DOM node, for example, or like in this case to focus an input field from the outside -- you can forward the ref:",
  "View - Rerendering - Committing - VirtualDOM - ReactDOMClient": "These new APIs are now exported from react-dom/client:",
  "View - Rerendering - Committing - VirtualDOM - ReactDOMClient - createRoot": "createRoot: New method to create a root to render or unmount. Use it instead of ReactDOM.render. New features in React 18 don’t work without it.",
  "View - Rerendering - Committing - VirtualDOM - ReactDOMClient - hydrateRoot": "hydrateRoot: New method to hydrate a server rendered application. Use it instead of ReactDOM.hydrate in conjunction with the new React DOM Server APIs. New features in React 18 don’t work without it.",
  "View - Rerendering - Committing - VirtualDOM - ReactDOMServer": "These new APIs are now exported from react-dom/server and have full support for streaming Suspense on the server:",
  "View - Rerendering - Committing - VirtualDOM - ReactDOMServer - renderToPipeableStream": "renderToPipeableStream: for streaming in Node environments.",
  "View - Rerendering - Committing - VirtualDOM - ReactDOMServer - renderToReadableStream": "renderToReadableStream: for modern edge runtime environments, such as Deno and Cloudflare workers.",
  "View - Rerendering - Committing - VirtualDOM - Million": "Million.js was designed to address virtual DOM diffing.",
  "View - Rerendering - Committing - VirtualDOM - Million - goal": "Million.js performs smart updates, only targeting DOM elements that need to be changed, bypassing the traditional diffing algorithm in many cases.",
  "View - Rerendering - Committing - VirtualDOM - Million - block()": "A standout feature in Million.js is the block() function, which wraps React components and provides ultra-efficient rendering. This function optimizes components by ensuring they only re-render when necessary, enhancing performance.",
  "View - Rerendering - Committing - VirtualDOM - Million - memo()": "Component memoization ensures that components only re-render when their props change, a vital strategy for optimizing performance in large applications.",
  "View - Rerendering - Committing - VirtualDOM - Million - compatibility": "Million.js v3.0.0 has evolved to offer better compatibility with React's core features and modern APIs, such as hooks (useState, useEffect, useMemo, and useCallback).",
	"View - Rerendering - Committing - NoVirtualDOM - Preact": "Preact X is what we always wanted Preact to be: A tiny, fast and feature-packed library. And speaking of size, you'll be happy to hear that all the new features and improved rendering fit into the same size footprint as 8.x!",
	"View - Rerendering - Committing - NoVirtualDOM - Preact vs React": "The main difference between Preact and React is that Preact does not implement a synthetic event system for size and performance reasons. Preact uses the browser's standard addEventListener to register event handlers, which means event naming and behavior works the same in Preact as it does in plain JavaScript / DOM.",

  "Logic": "SECTION",
	"Logic - Components - Async": "",
	"Logic - Components - Async - Actions": "React 19. Actions streamline the process of handling form submissions and other async tasks, making your code cleaner and more maintainable.",
	"Logic - Components - Async - use": "React 19. React's use API is still in experimental mode. It allows you to pass a Promise from a Server Component to a Client Component and resolve it in the Client Component.",
	"Logic - Components - Async - useAsyncScript": "React 19. You can now render async scripts within any component, with React handling deduplication. This ensures that scripts are loaded efficiently without redundancy.",
	"Logic - Components - Async - useOptimistic": "Another common UI pattern when performing a data mutation is to show the final state optimistically while the async request is underway. In React 19, we’re adding a new hook called useOptimistic to make this easier.",
	"Logic - Components - Hooks - React16.8": "React 16.8 introduced entirely new concepts (hooks)",
	"Logic - ClientComponents - ": "The 'standard' React components we know and love have been rebranded as Client Components. It's a new name for an old thing.",
	"Logic - ClientComponents - rerender": "The name 'Client Component' implies that these components only render on the client, but that's not actually true. Client Components render on both the client and the server.",
	"Logic - ClientComponents - rerender - count": "console.count('render')",
	"Logic - ClientComponents - import": "React team added a rule: Client Components can only import other Client Components.",
	"Logic - ClientComponents - use client": "In this new “React Server Components” paradigm, all components are assumed to be Server Components by default. We have to “opt in” for Client Components. That standalone string at the top, 'use client', is how we signal to React that the component(s) in this file are Client Components, that they should be included in our JS bundles so that they can re-render on the client.. Server Components are not sent to the browser, so they cannot use interactive APIs like useState. To add interactivity to Server Components, you can compose them with Client Component using the 'use client' directive. ",
	"Logic - ClientComponents - use client - boundaries": "When we add the 'use client' directive to a component, we create a “client boundary”. All of the components within this boundary are implicitly converted to Client Components. Even though components don't have the 'use client' directive, they'll still hydrate/render on the client in this particular situation.*",
	"Logic - ClientComponents - Events": "Only ClientComponents.",
	"Logic - ClientComponents - Events - SyntheticEvent": "React synthetic events encapsulate native browser events, providing a unified API interface so that developers can handle events in the same way regardless of the browser environment. The main purpose of this approach is to ensure cross-browser consistency and integrate with React’s declarative programming model and lifecycle. React synthetic events handle all browser compatibility issues, providing developers with a clean, consistent interface for event handling.",
	"Logic - ClientComponents - Events - SyntheticEvent - pool": "React synthetic events use an event pool to improve performance, i.e., reusing event objects. This means that after the event callback function is executed, all properties of the event object are cleared and recycled for reuse, reducing the pressure on garbage collection and memory usage.",
	"Logic - ClientComponents - Events - Throttling": "Throttling in React is a technique used to limit the number of times a function or an event handler is invoked by postponing the execution of a function. It ensures that the function is called at a specified interval, preventing it from being executed too frequently. Throttling allows you to control the rate at which the function is called by setting up a minimum time interval between each function invocation. If the function is called multiple times within that interval, only the first invocation is executed, and subsequent invocations are ignored until the interval elapses.",
	"Logic - ClientComponents - Events - Debouncing": "Debouncing, as opposed to throttling, is a method to stop the event trigger from firing too frequently. Debouncing, on the other hand, is also used to limit the number of times a function or an event handler is invoked. It ensures that the function is called only after a certain period of inactivity. Debouncing allows you to postpone the function call until the user has finished typing or a specific time has elapsed since the last event..",
	"Logic - ClientComponents - SideEffects - Mixins - 2014": "A React Mixin got introduced as React's first advanced pattern for reusable component logic. With a Mixin, it's possible to extract logic from a React component as standalone object. When using a Mixin in a component, all features from the Mixin are introduced to the component:",
  "Logic - ClientComponents - SideEffects - Mixins - drawbacks": "However, Mixins are not used anymore in modern React applications, because they come with several drawbacks.",
  "Logic - ClientComponents - SideEffects - Mixins - drawbacks - dependencies": "Often, mixins come to depend on other mixins, and removing one of them breaks the other. In these situations it is very tricky to tell how the data flows in and out of mixins, and what their dependency graph looks like. Unlike components, mixins don’t form a hierarchy: they are flattened and operate in the same namespace. If you have a name conflict with a mixin from a third party package, you can’t just rename a method on it. Instead, you have to use awkward method names on your component to avoid clashes.",
  "Logic - ClientComponents - SideEffects - Mixins - drawbacks - clashes": "There is no guarantee that two particular mixins can be used together. For example, if FluxListenerMixin defines handleChange() and WindowSizeMixin defines handleChange(), you can’t use them together. You also can’t define a method with this name on your own component.",
  "Logic - ClientComponents - SideEffects - Mixins - drawbacks - complexity": "Even when mixins start out simple, they tend to become complex over time.",
	"Logic - ClientComponents - SideEffects - HOCs": "React Higher-Order Components (HOCs), a popular advanced React pattern, are an alternative for React Mixins to deploy reusable logic across React components. The shortest explanation for a Higher-Order Component is that it is a component which takes a component as input and returns the component as output but with extended functionalities. Let's revisit the example with the local storage and how the functionality can be extracted into a reusable Higher-Order Component:",
	"Logic - ClientComponents - SideEffects - Render Props": "Another popular advanced React pattern are React Render Prop Components, which are often used as alternative to React Higher-Order Components. This kind of abstraction isn't shown here though, but I highly recommend you to check out the linked tutorial which teaches more about them.",
	"Logic - ClientComponents - SideEffects - Hooks - effect": "Effects let a component connect to and synchronize with external systems. This includes dealing with network, browser DOM, animations, widgets written using a different UI library, and other non-React code.",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useEffect": "React Hooks were also introduced to bring side-effects to Function Components. In general, the built-in React useEffect Hook is used to execute a function every time props or state of the component are changed. The useEffect Hook allows you to perform side effects in your components.",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useEffect - async": "since useEffect() is an asynchronous, non-blocking function.",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useEffect - callbacks": "async callbacks cannot be utilised within the useEffect hook",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useEffect - callbacks - solution": "create a new function that is declared inside the useEffect() hook and that contains the async function, and then we can call this new function inside the useEffect() hook.",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useEffect - cases": "Some examples of side effects are: fetching data, directly updating the DOM, and timers.",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useEffect - cases - mount/update": "React.useEffect(() => { console.log('I run on every render: mount + update.'); }); This is the most straightforward usage of useEffect where we only pass one argument -- a function. This function will render on every render -- meaning it runs on the first render of the component (also called on mount or mounting of the component) and on every re-render of the component (also called on update or updating of the component).",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useEffect - cases - mount": "React.useEffect(() => { console.log('I run only on the first render: mount.'); }, []); If you want to run React's useEffect Hook only on the first render of a component (also called only on mount), then you can pass in a second argument to useEffect: ",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useEffect - cases - update": "React.useEffect(() => { console.log('I run only if toggle changes (and on mount).'); }, [toggle]); Now the side-effect function for this React component runs only when the variable in the dependency array changes. ",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useEffect - cases - update any": "React.useEffect(() => { console.log('I run if toggle or title change (and on mount).'); }, [toggle, title]); if we provide the new variable in the dependency array, the side-effect function will run for both updates:",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useEffect - syntax": "useEffect accepts two arguments. The second argument is optional. useEffect(<function>, <dependency>). https://medium.com/@sassenthusiast/i-thought-i-knew-useeffect-but-i-was-wrong-useeffect-misconceptions-dcc2781010a9",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect": "The useLayoutEffect hook in React is one of the more advanced hooks, intended for scenarios where you need to perform side effects that require direct interaction with the DOM, or when you need to ensure that your updates are visible to the user without any flickering or delay.",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - purpose": "The useLayoutEffect hook was designed to address cases where you need to ensure that DOM manipulations and updates happen before the browser paints. The primary purpose is to avoid visual inconsistencies that might arise if the effect was delayed until after the paint, as would be the case with useEffect.",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - sync": "The useLayoutEffect hook runs synchronously after all DOM mutations but before the browser has a chance to paint. This means that it will block the painting process until your code has run. This is useful when you need to make measurements or changes to the DOM that should be applied before the screen is updated.",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - structure": "useLayoutEffect(() => { /* Your effect logic here */ return () => { /* Optional cleanup logic here */ };},[dependencies]);",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - structure - Effect": "Effect Function: This is the main body of the effect. The function you pass will run after DOM updates but before the browser repaints the screen. Here you can read from the DOM, manipulate it, and make changes that need to be visible immediately.",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - structure - Cleanup": "Cleanup Function (optional): This is returned from the main effect function. It will be called before the effect runs the next time, or when the component unmounts. This is useful for cleaning up any side effects (e.g., removing event listeners, cancelling timers).",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - structure - Dependencies": "Dependencies: This is an array of values that the effect depends on. The effect will only re-run if one of these dependencies changes. If you pass an empty array, the effect will only run on mount and unmount.",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - usages - measuring": "Measuring Layouts: For example, if you need to measure the position or size of a DOM element immediately after a render but before the browser has painted the screen.",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - usages - styles": "apply styles or transformations immediately after rendering.",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - usages - syncing": "Synchronizing State with the DOM: When you need to ensure that your component’s state is perfectly synchronized with the DOM in a way that affects the layout or style.",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - usages - FOUC": "Avoiding Flash of Unstyled Content (FOUC): Ensuring that CSS changes are applied before the browser repaints can prevent users from seeing unstyled content.",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - gotchas - performance": "Performance Impact: useLayoutEffect is synchronous, meaning it will block the browser from painting until the effect has finished executing. This can introduce performance issues, especially if the effect involves complex computations or multiple DOM manipulations. Always be mindful of the performance cost when deciding to use useLayoutEffect over useEffect.",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - gotchas - UIJank": "UI Jank: If useLayoutEffect takes too long to execute, it can cause UI jank, where the interface feels sluggish or unresponsive. This is especially critical on lower-end devices or under heavy load, where the blocking behavior can become more noticeable.",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useLayoutEffect - gotchas - render": "Blocking Render Cycles: Since useLayoutEffect runs before the browser has a chance to repaint, it can block the render cycle, leading to delays in visual updates.",
  "Logic - ClientComponents - SideEffects - Hooks - effect - useInsertionEffect": "Pitfall. useInsertionEffect is aimed at CSS-in-JS library authors. Unless you are working on a CSS-in-JS library and need a place to inject the styles, you probably want useEffect or useLayoutEffect instead. useInsertionEffect is a version of useEffect that fires before any DOM mutations. useInsertionEffect(setup, dependencies?)",
	"Logic - ClientComponents - SideEffects - Hooks - useId": "useId is a React Hook for generating unique IDs that can be passed to accessibility attributes. const id = useId(). The problem with these strategies is re-hydration. If you were using SSR, this component would generate one id on the server and another id on the client",
  "Logic - ClientComponents - SideEffects - Hooks - custom": "https://javascript.plainenglish.io/collection-of-custom-hooks-for-your-nextjs-react-project-1779379e6f4a",
  "Logic - ClientComponents - DI": "https://medium.com/@matthill8286/dependency-injection-in-react-a-good-guide-with-code-examples-4afc8adc6cdb",
	"Logic - ClientComponents - DataFetching - tip - minimize": "Only data to user events should be fetched at ClientComponents.",
	"Logic - ClientComponents - DataFetching - tip - caching": "Cache data fetched from APIs or expensive computations to prevent unnecessary re-fetching or re-computation.",
  "Logic - ClientComponents - DataFetching - libs - axios": ".",
  "Logic - ClientComponents - DataFetching - libs - tRPC": ".",
	"Logic - ClientComponents - DataFetching - Hooks": "React Hooks are not be intended for data fetching in React.",
  "Logic - ClientComponents - DataFetching - Hooks - useQuery": "ReactQuery. We can cache it, invalidate it, and fetch it anew.",
	"Logic - ClientComponents - DataFetching - Hooks - useSyncExternalStore": "useSyncExternalStore is a React 18 hook that lets you subscribe to an external store. const snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)",
	"Logic - ClientComponents - DataFetching - Hooks - useSyncExternalStore - subscribe": "subscribe: function to register a callback that is called whenever the store changes.",
	"Logic - ClientComponents - DataFetching - Hooks - useSyncExternalStore - getSnapshot": "getSnapshot: function that returns the current value of the store.",
	"Logic - ClientComponents - DataFetching - Hooks - useSyncExternalStore - getServerSnapshot": "getServerSnapshot: function that returns the snapshot used during server rendering.",
  "Logic - ClientComponents - DataFetching - Hooks - SWR": "React Hooks for data fetching. Standing for “stale-while-revalidate,” SWR is a strategy and library that makes fetching, caching, and updating data in your React applications a breeze.",
	"Logic - ClientComponents - Error Handling": "These methods are called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component.",
  "Logic - ClientComponents - Error Handling - static getDerivedStateFromError()": ".",
  "Logic - ClientComponents - Error Handling - componentDidCatch()": "In the componentDidCatch method, you can handle errors, such as logging error information, displaying error information to the user, sending error reports, etc.",
	"Logic - ClientComponents - Error Handling - <ErrorBoundary>": "React gives us what is known as 'Error Boundaries': a special API that turns a regular component into a try/catch statement in a way, only for React declarative code. ",
	"Logic - ClientComponents - Error Handling - <ErrorBoundary> - onRecoverableError": "onRecoverableError, to provide better clarity on why the error is happening.",
	"Logic - ClientComponents - Error Handling - <ErrorBoundary> - onCaughtError": "React 19. onCaughtError triggers when React catches an error in an Error Boundary.",
	"Logic - ClientComponents - Error Handling - <ErrorBoundary> - onUncaughtError": "React 19. onUncaughtError triggers when an error is thrown and not caught by an Error Boundary.",
	"Logic - ClientComponents - Error Handling - <StrictMode>": "<React.StrictMode><App /></React.StrictMode>,. Use StrictMode to enable additional development behaviors and warnings for the component tree inside: Strict Mode enables the following development-only behaviors: Your components will re-render an extra time to find bugs caused by impure rendering. Your components will re-run Effects an extra time to find bugs caused by missing Effect cleanup. Your components will be checked for usage of deprecated APIs.",
	"Logic - ServerComponents": "At a high level, React Server Components is the name for a brand-new paradigm. In this new world, we can create components that run exclusively on the server. This allows us to do things like write database queries right inside our React components!. React 19. React Server Components (RSC) are a game-changer. These components render at build time or for each request, reducing the workload on the client side and enhancing performance. As a general rule, if a component can be a Server Component, it should be a Server Component.",
	"Logic - ServerComponents - rerender": "Server Components never re-render. They run once on the server to generate the UI. The rendered value is sent to the client and locked in place. As far as React is concerned, this output is immutable, and will never change. Server Components aren't really React components, at least not as we've traditionally understood them. They're much more like PHP templates, rendered by a server to create the original HTML. The real innovation is that Server Components and Client Components can co-exist in the same application!",
	"Logic - ServerComponents - no server": "Server components can run at build time to read from the filesystem or fetch static content, so a web server is not required. For example, you may want to read static data from a content management system.",
	"Logic - ServerComponents - server": "Server Components can also run on a web server during a request for a page, letting you access your data layer without having to build an API. They are rendered before your application is bundled, and can pass data and JSX as props to Client Components.",
	"Logic - ServerComponents - async": "Server Components introduce a new way to write Components using async/await. When you await in an async component, React will suspend and wait for the promise to resolve before resuming rendering. This works across server/client boundaries with streaming support for Suspense.",
  "Logic - ServerComponents - static": "Server components don't rehydrate to the client. They don't send their component code to the client at all. The results of a server component (HTML and other meta data) sit on the client statically without your component code being there in the client.",
  "Logic - ServerComponents - stateless": "Therefore they can't have state or JavaScript events and there's no concept of 're-rendering' for them - because again, there is no 'component code' that goes to the client. This is why server components cannot be owned by client components -- because if a client component re-rendered on the client, there would be no way to 're-render' the server component it owns.",
  "Logic - ServerComponents - cache": "cache is only for use with React Server Components.",
	"Logic - ServerComponents - DataFetching": "In a React Server Component, data fetching is straightforward. Since these components allow you to execute code on the server, you can directly access the data layer (e.g. database) from the UI: ",
  "Logic - ServerComponents - DataFetching - preferred": "whenever possible, recommend you to just fetch data in Server Components and to pass it down to Client Components.",
	"Logic - ServerFunctions": "Server Functions are asynchronous functions that are executed on the server. They can be used in Server and Client Components to handle form submissions",
  "Logic - ServerFunctions - call": "This means that it isn’t just a function call: there is actually an HTTP request made to the API to call the function.",
  "Logic - ServerFunctions - call - serializable": "Server actions are an abstraction that hides the complexity of the network calls and the data serialization/parsing.",
  "Logic - ServerFunctions - call - developer": "As a developer I just write a function that I can call on the server and I can write tests for it, but React does a lot of heavy lifting to create the illusion that I’m “just calling a function” from the client to be executed on the server.",
  "Logic - ServerFunctions - call - RPC": "Server actions offer a remote procedure call (RPC) pattern for Next.js applications.",
  "Logic - ServerFunctions - ServerActions": "",
  "Logic - ServerFunctions - ServerActions - client": "Client Components can import Server Functions",
  "Logic - ServerFunctions - ServerActions - useActionState": "useActionState is a Hook that allows you to update state based on the result of a form action.",
  "Logic - ServerFunctions - ServerActions - forms": "Server Actions work with the new Form features in React 19. You can pass a Server Action to a Form to automatically submit the form to the server. They can be replacement for (unexisting) events in ServerComponents.",
	"Logic - ServerFunctions - howto - xyzAction.ts": "Name by default.",
  "Logic - ServerFunctions - howto - use server": "The 'use server' directive is used to mark ServerActions. We don't specify the 'use server' directive in our Server Components; in the React Server Components paradigm, components are treated as Server Components by default. In fact, 'use server' is used for Server Actions, a totally different feature that is beyond the scope of this blog post.",
  "Logic - ServerFunctions - howto - async": "Name by default.",
  "Logic - ServerFunctions - howto - _actions": "By convention defined inside _actions folder inside /app.",
  "Logic - ServerFunctions - attaching - as props": "Server Actions can be created in Server Components and passed as props to Client Components. Server Components can define Server Actions with the 'use server' directive",
  "Logic - ServerFunctions - attaching - importing": "Server Actions can be imported and used in Client Components. Client Components can import Server Actions from files that use the 'use server' directive:",
  "Logic - ServerFunctions - composing": "Server Actions can be composed with Actions on the client",
  "Logic - ServerFunctions - DataFetching - ocassional": "Data fetching with Server Actions comes with drawbacks too: Server Actions perform HTTP POST requests Server Actions run in sequence",
  "Logic - ServerFunctions - DataFetching - drawbacks": "Using a Server Action for data fetching in a Client Component only happens occasionally",
  "Logic - ServerFunctions - FullStack": "React, with its addition of Server Components and Server Actions, is evolving into a full-stack framework. Once the most popular frontend framework, it has now successfully bridged the gap between frontend and backend to reign over both sides of the chasm.",

  "CICD - Bundling": "SECTION",
	"CICD - Bundling - Arch - Patterns - Base UI Component": "",
  "CICD - Bundling - Arch - Patterns - Base UI Component - BaseUI": "https://baseweb.design/",
  "CICD - Bundling - Arch - Patterns - Inheritance": "No use",
  "CICD - Bundling - Arch - Patterns - Composition": "",
  "CICD - Bundling - Arch - Patterns - Compound": "The Compound Components pattern isn’t just a coding technique; it’s a design paradigm that promotes collaboration between components while maintaining loose coupling. Recognizing its value involves understanding the use of static properties, which resemble dot notation for accessing nested components within a parent component. https://medium.com/@khushi1399gupta/mastering-reacts-compound-components-a-guide-for-experienced-developers-8a35c1468acb",
	"CICD - Bundling - Arch - Patterns - Layout": ".",
	"CICD - Bundling - Arch - Patterns - Layout - Layout pattern": "The main idea behind the Layout component pattern is that components should not know where they are being displayed, and Layout components should only be concerned with displaying the component.",
  "CICD - Bundling - Arch - Patterns - Adapter": "The Adapter Pattern allows incompatible interfaces to work together. It converts the interface of a class into another interface clients expect. This pattern is often used to make existing classes work with others without modifying their source code.",
  "CICD - Bundling - Arch - Patterns - Repository": "The Repository Pattern abstracts the data layer, providing a collection-like interface for accessing domain objects. It mediates between the domain and data mapping layers, acting like an in-memory domain object collection.",
	"CICD - Bundling - Arch - Patterns - ContainerPresenter": "The Container-Presenter Pattern (also known as Smart and Dumb Components) is a fundamental pattern that helps you separate concerns in your React components. The basic idea is to split components into two categories: containers (which handle data fetching, state management, and logic) and presenters (which focus solely on rendering the UI).",
	"CICD - Bundling - Arch - Patterns - Higher-Order Components": "A Higher-Order Component (HOC) is a pattern where you take a component and return a new component with added functionality. HOCs are useful for reusing component logic, such as handling authentication, logging, or theming, without modifying the original component’s behavior.",
	"CICD - Bundling - Arch - Patterns - RenderProps": "The Render Props pattern is a technique where a component takes a function as a prop and uses it to render JSX. This pattern allows for better flexibility and reuse of logic within components. It’s particularly useful for cases where you need to share behavior between components but don’t want to use an HOC.",
	"CICD - Bundling - Arch - Patterns - CustomHooks": "With the rise of hooks, Custom Hooks have become a go-to pattern for reusing stateful logic. Custom hooks allow you to encapsulate stateful behavior and reuse it across different components without duplicating code. If you find yourself repeating logic across components, it’s often a sign that you can extract it into a custom hook.",
	"CICD - Bundling - Optimization - CodeFecthing - Prefetching": "React v19 allows developers to preload resources using various strategies like prefetchDNS, preconnect, preload, and preinit. This ensures that critical resources are loaded quickly, improving performance.",
	"CICD - Bundling - Optimization - CodeFecthing - Prefetching - prefetchDNS": "React 19. ",
	"CICD - Bundling - Optimization - CodeFecthing - Prefetching - preconnect": "React 19. ",
	"CICD - Bundling - Optimization - CodeFecthing - Prefetching - preload": "React 19. ",
	"CICD - Bundling - Optimization - CodeFecthing - Prefetching - preinit": "React 19. ",
	"CICD - Bundling - Optimization - CodeFecthing - LazyLoading - React.lazy": "React.lazy is a feature that allows you to lazily load components, meaning they are loaded only when needed. const lazyComponent = React.lazy(() => import('./HeavyCoponent));",
	"CICD - Bundling - Optimization - CodeFecthing - LazyLoading - Suspense": "React v16.6.0.. By reducing lazy-loading components that are not immediately needed, you can lower the initial load time of your application. This technique is especially useful for large applications with complex component hierarchies.",
	"CICD - Bundling - Optimization - CodeFecthing - LazyLoading - Suspense - fallback": "Suspense is a component that can be used to define a fallback UI while the lazily loaded component is being loaded.",
	"CICD - Bundling - Optimization - CodeFecthing - LazyLoading - Suspense - datasources": "The Suspense documentation insists that the only way of using Suspense is via 'Suspense-enabled frameworks'.",

  "CICD - Building": "SECTION",
  "CICD - Bundling - Tools - JSX - transpilation": "JSX allows you to write HTML-like code in your JavaScript. It gets transpiled by a tool like Babel to JavaScript before being rendered in the browser..",
  "CICD - Bundling - Tools - JSX - transpilation - Babel": "Browsers don’t understand JSX out of the box, so most React users rely on a compiler like Babel or TypeScript to transform JSX code into regular JavaScript.",
	"CICD - Building - Tools - ReactForget": "React 19 and the ReactCompiler, previously known as React Forget",
	"CICD - Building - Tools - ReactCompiler": "",
  "CICD - Building - Tools - ReactCompiler - plugAndPlay": "The Compiler is plug-and-play: you install it, and it Just Works; there is no need to rewrite existing code.",
  "CICD - Building - Tools - ReactCompiler - ReactCompilerConfig": "https://jherr2020.medium.com/react-compiler-with-react-18-1e39f60ae71a",
	"CICD - Building - Tools - Bit": "Bit is a next-generation building system that develops composable software. https://bit.dev/",
  "CICD - Building - FastRefresh - React19": "React 19 has turbocharged the development process with an even faster refresh. Your changes appear instantly without losing the component state.",
  "CICD - Building - production": "Make sure to test any performance issues you may be seeing with your React apps using the production build's minified version.",

  "CICD - Execution": "SECTION",
	"CICD - Execution - Scopes - Block": "Block scope: The context inside of a pair of curly braces (only applies to variables created with const and let).",
	"CICD - Execution - Scopes - Function": "Function scope: The context within a JS-function.",
	"CICD - Execution - Scopes - Component": "Component scope: The context inside a functional or class component.",
	"CICD - Execution - Scopes - Module": "Module scope: The context for code running inside a JavaScript (JS), JSX, TypeScript (TS), or TSX file.",

  "CICD - Audit": "SECTION",
	"CICD - Audit - Testing - ReactTesting": "React Testing Library is not an alternative to Jest, because they need each other and every one of them has a clear task.",
  "CICD - Audit - Profiling - react Profiler": "The React Profiler is a tool that comes with the React Developer Tools extension. It allows you to measure and analyze the rendering performance of your components. The React Profiler lets you identify components that take longer to render and detect potential performance bottlenecks.",
  "CICD - Audit - Profiling - ReactDevTools": "React Developer Tools. Use React Developer Tools to inspect React components, edit props and state, and identify performance problems.",
  "CICD - Audit - Profiling - ReactDevTools - useDebugValue": "useDebugValue is a React Hook that lets you add a label to a custom Hook in ReactDevTools. useDebugValue(value, format?)"

}