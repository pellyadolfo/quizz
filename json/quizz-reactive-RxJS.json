{
	"RxJS": "SECTION",
	"RxJS - desc": "Reactive Extensions for JavaScript (RxJS) library.",
	
	"Observable": "SECTION",
	"Observable - ObservablePattern": "",
	"Observable - Observable - features - declarative": "Observables are declarative, they present a blueprint for data stream but do not produce values unitl a subscriber subscribes to them.",
	"Observable - Observable - features - unicast": "Observables are unicast (each subscribed Observer owns an independent execution of the Observable).",
	"Observable - Observable - features - initial": "Observables do not have initial value. They start emitting values when the subscriber is listening.",
	"Observable - Observable - features - usage": "Observables are generally used when you want to produce data in a lazy and declarative way, such as HTTP requests, user input events, or other asynchronous datasources.",
	"Observable - Observable - creation": ".",
	"Observable - Observable - creation - frompromise": "const data = from(fetch('/api/endpoint'));",
	"Observable - Observable - creation - fromAJAX": "const apiData = ajax('/api/data');",
	"Observable - Observable - creation - fromcounter": "const secondsCounter = interval(1000);",
	"Observable - Observable - creation - fromevent": "const mouseMoves = fromEvent(el, 'mousemove');",
	"Observable - Subject": "A Subject in RxJS is a special type of Observable that acts as both an observer and an observable. Think of it as a bridge that can both emit values (like a broadcaster) and subscribe to receive values (like a listener).",
	"Observable - Subject - features - multicast": "It is a multicast observable that maintains a list of observers and notifies all of them when a new value is emitted using the next() method.",
	"Observable - Subject - features - imperative": "Observables are imperative, they can produce values independently of whether there are subscribers.",
	"Observable - Subject - features - initial": "Subject do not have initial value. They start emitting values when the subscriber is listening.",
	"Observable - Subject - features - usage": "Observables are commoly used in scenarios where you wnat to multicast events or share data between multiple subscribers, such as intercomponent communication or event broadcasting.",
	"Observable - BehaviorSubject - features - initial": "It has an initial value and will immediately emit the initial value to any subscriber as soon as they subscribe, even if no values have been emitted yet using the next() method.",
	"Observable - BehaviorSubject - features - after": "After the initial value is emitted, it behaves like a regular Subject and notifies subscribers about new values emitted using next().",
	"Observable - BehaviorSubject - features - usage": "This is useful when you want to provide the last known value to new subscribers, such as the current state of an application or the latest data fetched from an API.",
	"Observable - ReplaySubject - features - initial": "The ReplaySubject is a subject that can buffer and replay a specific number of values to new subscribers. When you create a ReplaySubject, you can specify the buffer size, which determines how many previous values should be replayed to new subscribers.",
	"Observable - ReplaySubject - features - usage": "This is useful when you want to provide a history of values to new subscribers or when you need to cache values for later use.",
	"Observable - AsyncSubject - features - initial": "The AsyncSubject is a subject that only emits the last value when it completes.",
	"Observable - AsyncSubject - features - after": "It will not emit any values until the subjectâ€™s complete() method is called. When completed, it will emit the last value (if any) to subscribers.",
	"Observable - AsyncSubject - features - usage": "This is useful when you need to wait for an operation to complete before emitting a final value, such as waiting for an HTTP request to finish and emitting the response as a single value.",

	"Observer": "SECTION",
	"Observer - Observer": "is a collection of callbacks that knows how to listen to values delivered by the Observable.",
	"Observer - Observer - subscribe": "Usually, an observer object can define any combination of next, error, and complete notification type handlers. If you don't supply a handler for a notification type, the observer just ignores notifications of that type.",
	"Observer - Observer - subscribe - next": "",
	"Observer - Observer - subscribe - error": "",
	"Observer - Observer - subscribe - complete": "",
	"Observer - Subscription": "represents the execution of an Observable, is primarily useful for cancelling the execution.",
	"Observer - Operators": "are pure functions that enable a functional programming style of dealing with collections with operations like map, filter, concat, reduce, etc.",
	"Observer - Operators - transform - map": "",
	"Observer - Operators - transform - mergeMap": "",
	"Observer - Operators - transform - switchMap": "",
	"Observer - Operators - transform - concatMap": "",
	"Observer - Operators - filter - filter": "",
	"Observer - Operators - filter - find": "",
	"Observer - Operators - filter - distinct": "",
	"Observer - Operators - filter - distinctUntilChanged": "",
	"Observer - Operators - filter - distinctUntilKeyChanged": "",
	"Observer - Operators - filter - sample": "",
	"Observer - Operators - filter - first": "",
	"Observer - Operators - filter - last": "",
	"Observer - Operators - filter - skip": "",
	"Observer - Operators - filter - skipUntil": "",
	"Observer - Operators - filter - skipWhile": "",
	"Observer - Operators - filter - take": "",
	"Observer - Operators - filter - takeLast": "",
	"Observer - Operators - filter - takeUntil": "",
	"Observer - Operators - filter - takeWhile": "",
	"Observer - Operators - filter - throttle": "",
	"Observer - Operators - filter - throttleTime": "",
	"Observer - Schedulers": "are centralized dispatchers to control concurrency, allowing us to coordinate when computation happens on e.g. setTimeout or requestAnimationFrame or others."

	
}