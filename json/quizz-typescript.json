{
	"ts": "SECTION",
	"ts - Typescript": "TypeScript is a superset of JavaScript in which you add types to JavaScript. JavaScript is a loosely typed language which leads to lot of types error in production code. With TypeScript developers can catch those error, even before running the code.",

	"Variables": "SECTION",
	"Variables - DataTypes - type": "Types allow you to create complex types by combining existing types, union types, intersection types, and even utility types.",
	"Variables - DataTypes - Inmutable - readonly": "",
	"Variables - DataTypes - Union": "Union types are used when the property can be more then one value, like string or number. For this reason, they are also called OR and are used by using | symbol.",
	"Variables - DataTypes - Enum": "An enum is a type of variables which are constants. You have to use the values within it only. The values are numeric by default and starts with 0 and increments by 1.",
	"Variables - DataTypes - Array - string[]": "",
	"Variables - DataTypes - Array - Inference": "If we don’t give any type to an array, it will infer the type.",
	"Variables - DataTypes - Tuple": "It is a type array with pre-defined length and types. let ourTuple: [number, boolean, string]; ourTuple = [5, false, 'Coding Hero was here'];",
	"Variables - DataTypes - Objects": ".",
	"Variables - DataTypes - Objects - Record": "Record is a shortcut to define an object, with specified key type and value type.",
	"Variables - DataTypes - Objects - Typed": "We can give the type of object by creating another object like structure and specifying the keys and the type of the keys in the object. const car: { brand: string, model: string, year: number } = { brand: 'Tata', model: 'Tiago', year: 2016 };.",
	"Variables - DataTypes - Objects - Typed - Optional": "const car: { brand: string, model: string, year?: number } = { brand: 'Tata', model: 'Punch' };",
	"Variables - DataTypes - Objects - Typed - Partial": "Partial changes all the properties to be optional in an object. let rectPart: Partial<Rectangle> = {}; ",
	"Variables - DataTypes - Objects - Typed - Required": "Required changes all the properties to be required in an object. let rectPart: Required<Rectangle> = {}; ",
	"Variables - DataTypes - Objects - Typed - Omit": "Omit removes keys from any object type.",
	"Variables - DataTypes - Objects - Typed - Pick": "Pick removes all the keys from any object, excep the specified keys.",
	"Variables - DataTypes - Objects - Typed - Exclude": "Exclude is used to removes types from a union.",
	"Variables - DataTypes - Objects - Typed - Readonly": "Readonly is used to create a type which cannot be modified once assigned a value.",
	"Variables - DataTypes - Generics": ".",
	"Variables - DataTypes - Generics - Partial<T>": "Partial<T> constructs a type that makes all properties of the given type T optional.",
	"Variables - DataTypes - Generics - Required<T>": "Required<T> constructs a type that makes all properties of the given type T required.",
	"Variables - DataTypes - Generics - Readonly<T>": "Readonly<T> makes all properties of the type T immutable, i.e., they cannot be reassigned.",
	"Variables - DataTypes - Generics - Record<K, T>": "Record<K, T> constructs a type with keys of type K and values of type T.",
	"Variables - DataTypes - Generics - Pick<T, K>": "Pick<T, K> constructs a type by picking a set of properties K from T.",
	"Variables - DataTypes - Generics - Omit<T, K>": "Omit<T, K> constructs a type by removing a set of properties K from T.",
	"Variables - DataTypes - Generics - ReturnType<T>": "ReturnType<T> extracts the return type of a function type T.",
	"Variables - DataTypes - Generics - Parameters<T>": "Parameters<T> constructs a tuple type from the types used in the parameters of a function type T.",
	"Variables - DataTypes - Generics - InstanceType<T>": "InstanceType<T> constructs a type consisting of the instance type of a constructor function type T.",
	"Variables - DataTypes - Generics - NonNullable<T>": "NonNullable<T> constructs a type by excluding null and undefined from T.",
	"Variables - DataTypes - Generics - Awaited<T>": "Awaited<T> unwraps the type T if it's a promise.",
	"Variables - DataTypes - Generics - ThisType<T>": "ThisType<T> allows you to specify the type of this within an object or class.",
	"Variables - DataTypes - Generics - Indexed Access Types": "Indexed Access Types allow you to access a specific property type of a type T using a key K.",
	"Variables - DataTypes - Generics - keyof T": "keyof T extracts the keys of type T as a union of string literals.",
	"Variables - DataTypes - Generics - Exclude<T, U>": "Exclude<T, U> constructs a type by excluding from T all union members that are assignable to U.",
	"Variables - DataTypes - Generics - Extract<T, U>": "Extract<T, U> constructs a type by extracting from T all union members that are assignable to U.",
	"Variables - DataTypes - Generics - Template Literal Types": "Template Literal Types allow you to create types by combining string literals and union types.",
	"Variables - DataTypes - Generics - Conditional Types": "Conditional Types allow you to choose one of two types based on a condition expressed as a type relationship.",
	"Variables - DataTypes - Generics - Infer": "The infer keyword allows for type inference in conditional types.",
	"Variables - DataTypes - Generics - Decorator": "Decorators are functions that can modify classes, methods, accessors, or properties.",
	"Variables - DataTypes - Interfaces - contract": "Interfaces are a core feature of TypeScript. They allow you to define a contract for your objects.",
	"Variables - DataTypes - Interfaces - vs Types - extensibility": "One of the most significant differences is how you extend them. Interfaces are built with extension in mind. You can easily extend an interface using the extends keyword. This makes interfaces a natural choice when you're working with object-oriented design patterns. Types, on the other hand, are more flexible but less formal in their extensibility. You can’t directly extend a type in the same way, but you can achieve similar results using intersection types:",
	"Variables - DataTypes - Interfaces - vs Types - merging": "Another difference is that interfaces can be merged, while types cannot. This is particularly useful when you’re working with third-party libraries or want to add additional properties to an existing interface.:",
	"Variables - DataTypes - Operations - DataTypes - TypeAliases": "Type aliases create a new name for a type. Type aliases are sometimes similar to interfaces, but can name primitives, unions, tuples, and any other types that you’d otherwise have to write by hand.",
	"Variables - DataTypes - Operations - TypeGuards": "A type guard is some expression that performs a runtime check that guarantees the type in some scope.",
	"Variables - DataTypes - Operations - TypeGuards - typeof": "function isNumber(x: any): x is number { return typeof x === 'number'; }",
	"Variables - DataTypes - Operations - TypeGuards - instanceof": "",
	"Variables - DataTypes - Operations - TypeGuards - custom": "To define a type guard, we simply need to define a function whose return type is a type predicate:. function isFish(pet: Fish | Bird): pet is Fish { return (pet as Fish).swim !== undefined; }",
	"Variables - DataTypes - Operations - Conversion - Casting": "Casting is the process of overriding a type of a variable.",
	"Variables - Declaration - implicit": "Explicit means writing out the type. let firstName: string = 'Nabendu';",
	"Variables - Declaration - explicit": "Implicit means TypeScript will guess the type, based on the value. Like below type will be considered a number let age = 41;",
	"Variables - Declaration - Types - any": "The type of any is used to assign any type of a variable. It will not give error even if you reassign another type. let x: any = 10;",
	"Variables - Declaration - Types - unknown": "The type unknown is better than type any, because it requires us checking the type before performing operations on value. let y: unknown = 10;",
	"Variables - Declaration - Types - never": "The type never represents value that never occurs. It is typically used for return statements of function that doesn’t returns properly.",
	"Variables - Declaration - Assignment - NullishCoalescence": "Nullish Coalescence is used in expressions which have a fallback feature while dealing with null or undefined. It is used with the ?? operator.",
	"Variables - Declaration - Assignment - satisfies": "TypeScript satisfies operator allow developers to check and validate the value of a variable against a given type.",
	"Variables - Declaration - Assignment - :": "The : tells the variable will always be this type. const obj: Record<string, string> = {}",
	"Variables - Declaration - Assignment - as": "Third way to declare type is using as annotation, I will really suggest not to use this way of declaring types since this is literally like telling lie to TypeScript.",
	"Variables - Declaration - Assignment - infer": "not annotating and letting TS infer it.",

	"Logic - Conditions - Errors": "https://tomaszs2.medium.com/typescript-5-6-release-candidate-no-more-condition-errors-you-can-skip-type-checking-too-169a782ae30b",
	"Logic - Patterns - ts-pattern": "https://tauantcamargo.medium.com/how-ts-pattern-can-improve-your-code-readability-d64996841646",

	"Files - .d.ts": "Their purpose is to hold declarations (not implementations) and public types. Having a single add.ts file, containing both the declaration and implementation, is the equivalent of having the add.d.ts and add.js files defined separately. This means you don’t need to worry about organizing declaration files with their respective implemention files, which is great for developer experience.",
	"Files - .d.ts - autogenerate": "You can simply auto-generate .d.ts files from your .ts files, just by changing a few settings in your tsconfig.json 'compilerOptions': { 'declaration': true } and package.json 'main': 'dist/index.js', 'types': 'dist/index.d.ts',     ",

	"Props Chaining": "",
	"Props Chaining - optional": "example?.a?.[0]",

	"CICD - Bundling - Arch - Functions": "",
	"CICD - Bundling - Arch - Classes": "",
	"CICD - Bundling - Arch - Classes - Abstract": "When we declare a base class with abstract keyword, we cannot create objects for the same. In this method, we generally use the methods of the abstract class in a child class.",
	"CICD - Bundling - Arch - Classes - Overriding": "",
	"CICD - Bundling - Arch - Classes - Singleton": "",

	"CICD - Execution - Scopes": "",
	"CICD - Execution - Scopes - public": "public — Default if not mentioned and allows the class member to be accessed from anywhere.",
	"CICD - Execution - Scopes - private": "private- The class member can be accessed from only within the class.",
	"CICD - Execution - Scopes - protected": "protected — The class member can be accessed by itself or an inherited class."

}