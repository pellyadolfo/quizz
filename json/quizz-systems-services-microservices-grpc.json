{			

	"gRPC": "SECTION",
	"gRPC - Protocol": "A high-performance RPC protocol that uses Protocol Buffers (protobuf) instead of JSON, making it faster and more efficient than REST. ",
	"gRPC - Protocol - HTTP/2": "gRPC leverages the HTTP/2 protocol under the covers.",
	"gRPC - Request": ".",
	"gRPC - Request - ProtocolBuffers": "Protocol Buffers are a language-neutral, platform-neutral extensible mechanism for serializing structured data.",
	"gRPC - Request - ProtocolBuffers - features - binary": "Protobuf is binary-based",
	"gRPC - Request - ProtocolBuffers - features - contracts": "Everyone uses the same proto file to generate packages to serialize and deserialize.",
	"gRPC - Request - ProtocolBuffers - features - fast": "faster to transport, a lot faster than JSON during serialization and deserialization.",
	"gRPC - Request - ProtocolBuffers - features - IDL": "By default, gRPC uses protocol buffers as the Interface Definition Language (IDL) for describing both the service interface and the structure of the payload messages. It is possible to use other alternatives if desired.",
	"gRPC - Request - ProtocolBuffers - features - Format": "It’s like JSON, except it’s smaller and faster, and it generates native language bindings. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.",
	"gRPC - Request - ProtocolBuffers - Parts": "Protocol buffers are a combination of the definition language (created in .proto files), the code that the proto compiler generates to interface with data, language-specific runtime libraries, the serialization format for data that is written to a file (or sent across a network connection), and the serialized data.",
	"gRPC - Request - ProtocolBuffers - Parts - definition": "Protocol buffer messages and services are described by engineer-authored .proto files.",
	"gRPC - Request - ProtocolBuffers - Parts - definition - proto": "message Person { optional string name = 1; optional int32 id = 2; optional string email = 3; }",
	"gRPC - Request - ProtocolBuffers - Parts - compiler": "The proto compiler is invoked at build time on .proto files to generate code in various programming languages (covered in Cross-language Compatibility later in this topic) to manipulate the corresponding protocol buffer. Each generated class contains simple accessors for each field and methods to serialize and parse the whole structure to and from raw bytes.",
	"gRPC - Request - ProtocolBuffers - Parts - compiler - protoc": "The same messages can be read by code written in any supported programming language. You can have a Java program on one platform capture data from one software system, serialize it based on a .proto definition, and then extract specific values from that serialized data in a separate Python application running on another platform.",
	"gRPC - Request - ProtocolBuffers - Parts - compiler - languages": "The following languages are supported directly in the protocol buffers compiler, protoc: C++ C# Java Kotlin Objective-C PHP Python Ruby",
	"gRPC - Request - ProtocolBuffers - Parts - code": "",
	"gRPC - Request - ProtocolBuffers - Parts - runtimes": "",
	"gRPC - Request - ProtocolBuffers - Parts - serialization - format": "",
	"gRPC - Request - ProtocolBuffers - Parts - serialization - data": "",
	"gRPC - Request - Format": "The binary nature of gRPC requests makes them highly efficient but less human-readable than REST/JSON APIs. The strict formatting ensures consistent parsing across all supported languages while maintaining high performance.",
	"gRPC - Request - Format - Structure": "A complete gRPC response consists of: HeadersFrame, DataFrames, TrailersFrame.",
	"gRPC - Request - Format - Structure - HeadersFrame": "Headers Frame (HTTP/2 HEADERS frame) Contains method, content-type, and metadata",
	"gRPC - Request - Format - Structure - DataFrames": "Message Frame(s) (HTTP/2 DATA frames) Contains the serialized protocol buffer message",
	"gRPC - Request - Format - Structure - TrailersFrame": "Trailers Frame (HTTP/2 HEADERS frame - optional) Used for streaming requests to signal end of request stream",
	"gRPC - Request - Format - Binary": "For unary calls, the request message format is: [Compressed-Flag] [Message-Length] [Message]",
	"gRPC - Request - Format - Binary - Compressed-Flag": "Compressed-Flag: 1 byte (0 = uncompressed, 1 = compressed)",
	"gRPC - Request - Format - Binary - MessageLength": "Message-Length: 4 bytes (message size in bytes, big-endian)",
	"gRPC - Request - Format - Binary - Message": "Message: Serialized ProtocolBuffer data.",
	"gRPC - Request - Format - Headers - :method": ":method → POST",
	"gRPC - Request - Format - Headers - :scheme": ":scheme → http",
	"gRPC - Request - Format - Headers - :path": ":path → /package.Service/Method",
	"gRPC - Request - Format - Headers - :authority": ":authority → api.example.com",
	"gRPC - Request - Format - Headers - content-type": "content-type → application/grpc",
	"gRPC - Request - Format - Headers - te": "te → trailers  # Required for gRPC",
	"gRPC - Request - Format - Headers - grpc-accept-encoding:": "grpc-accept-encoding: gzip,deflate",
	"gRPC - Request - Format - Headers - grpc-encoding": "grpc-encoding: gzip",
	"gRPC - Request - Format - Headers - grpc-timeout": "grpc-timeout → 500m  # 500 milliseconds",
	"gRPC - Client": "",
	"gRPC - Client - ServiceDiscovery": ".",
	"gRPC - Client - ServiceDiscovery - EndPoints": "Multiple endpoints for different resources (//myapiservice.com/users/1, //myapiservice.com/users/2)",
	"gRPC - Client - Caching": "gRPC is based on HTTP/2 which already supports caching. HTTP/2 doesn't change anything in terms of caching so the same headers and controls are used as under HTTP/1",
	"gRPC - Client - Versioning": "",
	"gRPC - Client - Versioning - deprecation": "USER_TYPE_LEGACY = 3 [deprecated = true];  // Mark as deprecated",
	"gRPC - Client - Versioning - PackageVersioning": "The most common approach is to version your Protocol Buffer package: package acme.weather.v1;",
	"gRPC - Client - Versioning - ServiceVersioning": "Add version information to the service name: WeatherServiceV2",
	"gRPC - Client - Versioning - MessageVersioning": "For evolving message definitions while maintaining backward compatibility: ",
	"gRPC - Client - Versioning - VersionFieldInRequests": "Include explicit version information in your messages: ApiVersion api_version = 2;",
	"gRPC - Client - Versioning - gRPCHeaderVersioning": "Pass version information in metadata headers: md := metadata.Pairs('x-api-version', '2.0')",
	"gRPC - Client - ResponseSize": ".",
	"gRPC - Service": "",
	"gRPC - Service - Services": "Like many RPC systems, gRPC is based around the idea of defining a service, specifying the methods that can be called remotely with their parameters and return types.",
	"gRPC - Service - Services - definition": "You define gRPC services in ordinary proto files, with RPC method parameters and return types specified as protocol buffer messages:",
	"gRPC - Service - Services - Types": "",
	"gRPC - Service - Services - Types - UnaryRPCs": "Unary RPCs where the client sends a single request to the server and gets a single response back, just like a normal function call. rpc SayHello(HelloRequest) returns (HelloResponse);",
	"gRPC - Service - Services - Types - ClientStreamingRPCs": "Client streaming RPCs where the client writes a sequence of messages and sends them to the server, again using a provided stream. Once the client has finished writing the messages, it waits for the server to read them and return its response. Again gRPC guarantees message ordering within an individual RPC call. rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);",
	"gRPC - Service - Services - Types - ServerStreamingRPCs": "Server streaming RPCs where the client sends a request to the server and gets a stream to read a sequence of messages back. The client reads from the returned stream until there are no more messages. gRPC guarantees message ordering within an individual RPC call. rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);",
	"gRPC - Service - Services - Types - BidirectionalStreamingRPCs": "Bidirectional streaming RPCs where both sides send a sequence of messages using a read-write stream. The two streams operate independently, so clients and servers can read and write in whatever order they like: for example, the server could wait to receive all the client messages before writing its responses, or it could alternately read a message then write a message, or some other combination of reads and writes. The order of messages in each stream is preserved. rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);",
	"gRPC - Service - Services - Metadata": "Metadata is information about a particular RPC call (such as authentication details) in the form of a list of key-value pairs, where the keys are strings and the values are typically strings, but can be binary data. Keys are case insensitive and consist of ASCII letters, digits, and special characters -, _, . and must not start with grpc- (which is reserved for gRPC itself). Binary-valued keys end in -bin while ASCII-valued keys do not. User-defined metadata is not used by gRPC, which allows the client to provide information associated with the call to the server and vice versa. Access to metadata is language dependent.",
	"gRPC - Service - Services - Channels": "A gRPC channel provides a connection to a gRPC server on a specified host and port. It is used when creating a client stub. Clients can specify channel arguments to modify gRPC’s default behavior, such as switching message compression on or off. A channel has state, including connected and idle. How gRPC deals with closing a channel is language dependent. Some languages also permit querying channel state.",
	"gRPC - Response": "",
	"gRPC - Response - HTTPCode": "gRPC responses nearly always have an HTTP status of 200 OK, even when the server returns an error.",
	"gRPC - Response - Codes": "gRPC uses a sophisticated status code system that provides more granular error information than traditional HTTP status codes. gRPC status codes provide much richer semantics than HTTP status codes, enabling more precise error handling in distributed systems.",
	"gRPC - Response - Codes - grpc-status": "These codes are defined in the grpc-status header and are represented by the google.rpc.Code enum in Protocol Buffers.",
	"gRPC - Response - Codes - Standard - 0": "OK - Success response ( = HTTP200)",
	"gRPC - Response - Codes - Standard - 1": "CANCELLED Operation was cancelled ( = HTTP499)",
	"gRPC - Response - Codes - Standard - 2": "UNKNOW Unknown error",
	"gRPC - Response - Codes - Standard - 3": "INVALID_ARGUMENT Client specified an invalid argument ( = HTTP400)",
	"gRPC - Response - Codes - Standard - 4": "DEADLINE_EXCEEDED Operation timed out before completion ( = HTTP504)",
	"gRPC - Response - Codes - Standard - 5": "NOT_FOUND Requested entity not found ( = HTTP404)",
	"gRPC - Response - Codes - Standard - 6": "ALREADY_EXISTS Entity already exists ( = HTTP409)",
	"gRPC - Response - Codes - Standard - 7": "PERMISSION_DENIED Caller doesn't have permission ( = HTTP402)",
	"gRPC - Response - Codes - Standard - 8": "RESOURCE_EXHAUSTED Resource exhausted (quotas, rate limiting) ( = HTTP429)",
	"gRPC - Response - Codes - Standard - 9": "FAILED_PRECONDITION Operation rejected because system is not in required state",
	"gRPC - Response - Codes - Standard - 10": "ABORTED Operation aborted (e.g., due to concurrency conflict)",
	"gRPC - Response - Codes - Standard - 11": "OUT_OF_RANGE Operation attempted beyond valid range",
	"gRPC - Response - Codes - Standard - 12": "UNIMPLEMENTED Operation not implemented or supported ( = HTTP501)",
	"gRPC - Response - Codes - Standard - 13": "INTERNAL Internal server error ( = HTTP500)",
	"gRPC - Response - Codes - Standard - 14": "UNAVAILABLE Service unavailable (retryable) ( = HTTP503)",
	"gRPC - Response - Codes - Standard - 15": "DATA_LOSS Unrecoverable data loss or corruption",
	"gRPC - Response - Codes - Standard - 16": "UNAUTHENTICATED Request lacks valid authentication credentials ( = HTTP401)",
	"gRPC - Response - Codes - Extended - 100+": "CLIENT_CLOSED_REQUEST Client closed the connection before receiving response",
	"gRPC - Response - Codes - Extended - 101+": "MISSING_REQUIRED_FIELD Required field is missing in request",
	"gRPC - Response - Codes - Extended - 102+": "RESOURCE_IN_USE Resource is already in use by another process",
	"gRPC - Response - Codes - Extended - 103+": "CONFLICT Request conflicts with existing state",
	"gRPC - Response - Codes - Extended - 104+": "TOO_MANY_REQUESTS Rate limiting (more specific than RESOURCE_EXHAUSTED)",
	"gRPC - Response - Format": "gRPC responses follow a structured binary format that includes both the payload data and metadata.",
	"gRPC - Response - Format - Structure": "A complete gRPC response consists of: HeadersFrame, DataFrames, TrailersFrame.",
	"gRPC - Response - Format - Structure - HeadersFrame": "Headers Frame (HTTP/2 HEADERS frame) Contains response metadata and status",
	"gRPC - Response - Format - Structure - DataFrames": "Zero or more Data Frames (HTTP/2 DATA frames) Contains the actual payload data",
	"gRPC - Response - Format - Structure - TrailersFrame": "Trailers Frame (HTTP/2 HEADERS frame) Contains status code and any trailing metadata",
	"gRPC - Response - Format - Binary": "The payload format for unary responses (protobuf encoding): [Compressed-Flag] [Message-Length] [Message]",
	"gRPC - Response - Format - Binary - Compressed-Flag": "Compressed-Flag: 1 byte (0 = uncompressed, 1 = compressed)",
	"gRPC - Response - Format - Binary - MessageLength": "Message-Length: 4 bytes (message size in bytes, big-endian)",
	"gRPC - Response - Format - Binary - Message": "Message: Serialized Protocol Buffer data.",
	"gRPC - Response - Format - Metadata": ".",
	"gRPC - Response - Format - Metadata - HeadersFrame - grpc-status": ".",
	"gRPC - Response - Format - Metadata - HeadersFrame - grpc-message": ".",
	"gRPC - Response - Format - Metadata - HeadersFrame - grpc-accept-encoding": "Compression algorithms supported",
	"gRPC - Response - Format - Metadata - TrailingFrame - grpc-status": ".",
	"gRPC - Response - Format - Metadata - TrailingFrame - grpc-message": ".",
	"gRPC - Response - Format - Metadata - TrailingFrame - grpc-status-details-bin": "Binary-encoded Status proto.",
	"gRPC - Response - Format - Headers": ".",
	"gRPC - Response - Format - Headers - content-type": "content-type → application/grpc[-proto|-json]",
	"gRPC - Response - Format - Headers - grpc-status": ".",
	"gRPC - Response - Format - Headers - grpc-message": ".",
	"gRPC - Response - Format - Headers - grpc-accept-encoding": "Compression algorithms supported",
	"gRPC - Response - Format - Headers - grpc-encoding": "Compression actually used",
	"gRPC - Response - Error": ""

}