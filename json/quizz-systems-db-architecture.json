{

	"DataModelling": "SECTION",
	"DataModelling - Decomposition": "",
	"DataModelling - Decomposition - by Capability": "Define services corresponding to business capabilities. A business capability is a concept from business architecture modeling. It is something that a business does in order to generate value. A business capability often corresponds to a business object, e.g. Order Management is responsible for orders Customer Management is responsible for customers Business capabilities are often organized into a multi-level hierarchy. For example, an enterprise application might have top-level categories such as Product/Service development, Product/Service delivery, Demand generation, etc.",
	"DataModelling - Decomposition - by Subdomain": "Define services corresponding to Domain-Driven Design (DDD) subdomains. DDD refers to the application’s problem space - the business - as the domain. A domain is consists of multiple subdomains. Each subdomain corresponds to a different part of the business. Subdomains can be classified as follows: Core - key differentiator for the business and the most valuable part of the application Supporting - related to what the business does but not a differentiator. These can be implemented in-house or outsourced. Generic - not specific to the business and are ideally implemented using off the shelf software",
	"DataModelling - Decomposition - by Subdomain - DDD": ".",
	"DataModelling - Decomposition - by Subdomain - DDD - description": ".",
	"DataModelling - Decomposition - by Subdomain - DDD - components - BoundedContext": "Bounded Contexts are used to represent well-defined logical boundaries around concepts within an application. They represent a distinct area of the application where a specific domain model is used, and where the terminology, rules, and data representations are consistent and cohesive.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - Entities": "Entities are objects that have a distinct identity that runs through time and different states. The identity is usually represented by an ID.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - ValueObjects": "Value objects are objects that are defined by their attributes. They do not have a distinct identity.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - Repositories": "Repositories are used to retrieve and store entities. They act as a collection of entities.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - Factories": "Factories are used to create complex objects and aggregates.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - Aggregates": "Aggregates are clusters of entities and value objects that are treated as a single unit.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - Services": "Services contain business logic that doesn’t naturally fit within an entity or value object.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - Services - stateless": "1.Stateless: Services are typically stateless. They do not hold any state themselves but operate on the state of entities and value objects.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - Services - Encapsulation": "2.Encapsulation of Business Logic: They encapsulate business logic that spans multiple entities or value objects or that doesn’t fit neatly within a single entity or value object.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - Services - Coordination": "3.Coordination: They often coordinate interactions between multiple entities and value objects.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - DomainEvents": "Domain events are used to communicate changes in the state of the business.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - DomainEvents - published": "Where Domain Events Are Published:",
	"DataModelling - Decomposition - by Subdomain - DDD - components - DomainEvents - published - EventBus": "1.Event Bus: Domain events are often published to an in-memory event bus within the application. This allows other parts of the application to subscribe to and handle these events. Since it is in-memory, the events are ephemeral and will be lost if the application restarts or crashes. It is suitable for scenarios where events need to be processed quickly and do not require persistence, such as inter-component communication within a single application instance.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - DomainEvents - published - EventStore": "2.Event Store: For more complex scenarios, domain events can be published to an event store, such as AWS EventBridge, Kafka, or a custom event store. This allows for durable storage and replay of events.",
	"DataModelling - Decomposition - by Subdomain - DDD - components - DomainEvents - published - MessageBrokers": "3.Message Brokers: Domain events can also be published to message brokers like RabbitMQ or AWS SNS/SQS for asynchronous processing and integration with other systems.",
	"DataModelling - Decomposition - by maturity": "",
	"DataModelling - Decomposition - by data-access": "decomposing by data-access pattern (read versus write)",
	"DataModelling - Decomposition - by data source": "decomposition by data source (rather than partitioning a data source per microservice, create a microservice per data source)",
	"DataModelling - Decomposition - by functionality": "aggregation for a derived functionality (create an orchestrating service for a few other services)",
	"DataModelling - Decomposition - by client": "aggregation for client convenience (such as the backend for frontend pattern)",
	"DataModelling - Decomposition - by client - BFF": "At its core, Backend for Frontend is a architecture pattern that provides a dedicated backend layer for each frontend interface. Each frontend (e.g., mobile app, web app, smart device, etc.) may have different performance, data, and interaction needs. Instead of relying on a single monolithic or generalized API, a BFF tailors the backend to the specific needs of a given frontend.",
	"DataModelling - Decomposition - by client - BFF Layer": "BFF Layer: The BFF consolidates data from multiple microservices, performs any transformations or optimizations, and responds with a tailored response.",
	"DataModelling - Decomposition - by performance": "aggregation to aid system performance",
	"DataModelling - Decomposition and Storage - Persisting state (modularization) vs persisting events (aggregates = materialized views)": "by Capability has the problem of 2PC because dependencies (violates encapsulation). We can use Saga but is not ACID but ACD (no isolation). Therefore use DDD aggregates instead modularization. Rules: (1) Refer entitites by primary key. (2) One aggregate to comand per atomic transaction. (3) How to maintain consistency between aggregates?? Events sourcing solves this by persisting events instead state. But has challenge of maintain consistency between aggregates",

	"DataArchitecture": "SECTION",
	"DataArchitecture 0": "https://www.linkedin.com/posts/deepak-kumar0301_datascience-bigdata-analytics-activity-7322825006776823808-K3dd?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"DataArchitecture 1": "https://www.linkedin.com/posts/pooja-jain-898253106_data-engineering-bigdata-activity-7324408690466283520-Nksq?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"DataArchitecture 2": "https://www.linkedin.com/posts/abhisek-sahu-84a404b1_dataengineering-cloud-bigdata-activity-7309196954607992832-uxZ5?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"DataArchitecture 3": "https://www.linkedin.com/posts/mr-deepak-bhardwaj_%F0%9D%97%95%F0%9D%97%AE%F0%9D%97%B1-%F0%9D%97%97%F0%9D%97%AE%F0%9D%98%81%F0%9D%97%AE-%F0%9D%97%95%F0%9D%97%AE%F0%9D%97%B1-%F0%9D%97%97%F0%9D%97%B2%F0%9D%97%B0%F0%9D%97%B6%F0%9D%98%80%F0%9D%97%B6%F0%9D%97%BC%F0%9D%97%BB%F0%9D%98%80-activity-7325139142357454850-asYk?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"DataArchitecture 4": "https://www.linkedin.com/posts/sachincw_powerbi-interview-questionspdf-activity-7322816913040957440-NVMF?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"DataArchitecture 5": "https://www.linkedin.com/posts/aitolla-venkatesh22_data-egineer-interview-questions-activity-7323930490896273408-R2ub/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"DataArchitecture 6": "https://www.linkedin.com/posts/andrew-madson_dataengineering-dataanalytics-sql-activity-7325279137600876544-DFd8?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"DataArchitecture 7": "https://www.linkedin.com/posts/pooja-jain-898253106_data-engineering-dataquality-activity-7325456862093414402-nReJ?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"DataArchitecture 8": "https://www.linkedin.com/posts/sachincw_top-questions-for-data-engineering-interviewspdf-activity-7326908880972648448-_YU_?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"DataArchitecture 9": "https://www.linkedin.com/posts/careerwithhina_bigdata-cloudcomputing-aws-activity-7328622687033917443-lAva/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"DataArchitecture 10": "",
	"DataArchitecture 11": "",
	"DataArchitecture 12": "",
	"DataArchitecture 13": "",
	"DataArchitecture 14": "",
	"DataArchitecture 15": "",
	"DataArchitecture 16": "",
	"DataArchitecture 17": "",
	"DataArchitecture 18": "",
	"DataArchitecture 19": "",
	"DataArchitecture - Storage": "Main challenge is address the eventual consistency issue: Database per Service - Shared database - Saga - API Composition - CQRS - Event sourcing - Application events",
	"DataArchitecture - Storage - Architecture - EventSourcing": "Instead of storing the current state of a model, append-only event stores are used to record the full series of actions taken on a model.",
	"DataArchitecture - Storage - Architecture - EventSourcing - CQRS": "Used with CQRS.",
	"DataArchitecture - Storage - Architecture - EventSourcing - rehydration": "When a new Command occurs, the current state of the Model/Entity is ‘rehydrated’ by replaying all of the events that have ever happened for that instance.",
	"DataArchitecture - Storage - Architecture - CQRS": "CQRS allows different techniques to be used for writing data (Write Side) and reading data (Read Side).",
	"DataArchitecture - Storage - Architecture - CQRS ": "Split the application into two parts: the command-side and the query-side. The command-side handles create, update, and delete requests and emits events when data changes. The query-side handles queries by executing them against one or more materialized views that are kept up to date by subscribing to the stream of events emitted when data changes.",
	"DataArchitecture - Storage - Architecture - CQRS - Responsibilities": ".",
	"DataArchitecture - Storage - Architecture - CQRS - Responsibilities - Command": ".",
	"DataArchitecture - Storage - Architecture - CQRS - Responsibilities - Command - Operations": "Handles create, update, delete operations.",
	"DataArchitecture - Storage - Architecture - CQRS - Responsibilities - Command - Goal": "Uses domain models and business logic to validate and process commands.",
	"DataArchitecture - Storage - Architecture - CQRS - Responsibilities - Query": ".",
	"DataArchitecture - Storage - Architecture - CQRS - Responsibilities - Query - Operations": "Handles read operations (queries).",
	"DataArchitecture - Storage - Architecture - CQRS - Responsibilities - Query - Goal": "Optimized for fast reads using denormalized data or caching mechanisms.",
	"DataArchitecture - Storage - Architecture - CQRS - Strategies": "",
	"DataArchitecture - Storage - Architecture - CQRS - Strategies - EventSourcing": "command model generates events -> events are published to an event store or message broker -> query model listens to these events and updates its own database",
	"DataArchitecture - Storage - Architecture - CQRS - Strategies - EventSourcing - DomainEvents": "Domain events play a crucial role in CQRS by ensuring event-driven communication between the command and query sides of an application. They capture important state changes in the domain and propagate them to other parts of the system, improving scalability, consistency, and decoupling.",
	"DataArchitecture - Storage - Architecture - CQRS - Strategies - DatabaseReplication": "command database acts as the primary data source -> query database is a replica of the command database, updated using replication mechanisms",
	"DataArchitecture - Storage - Architecture - CQRS - Strategies - ChangeDataCapture": "command database logs changes -> CDC tool (Debezium, AWS DMS) captures these changes and propagates them to the query database",
	"DataArchitecture - Storage - Architecture - CQRS - Strategies - ScheduledBatchProcessing": "command model periodically exports data into the query model at scheduled intervals",
	"DataArchitecture - Storage - Architecture - CQRS - Strategies - DualWrites": "application writes to both the command and query databases in the same transaction.",
	"DataArchitecture - Storage - Architecture - CQRS - Challenges": "",
	"DataArchitecture - Storage - Architecture - CQRS - Challenges - EventualConsistency": "In CQRS (Command Query Responsibility Segregation), the command model (write side) and the query model (read side) are often stored separately. Because of this separation, they may not always be in sync immediately, leading to eventual consistency rather than strong consistency.",
	"DataArchitecture - Storage - Architecture - CQRS - Challenges - EventualConsistency - Strategies - EventDrivenUpdates": "There is a delay between command event and query update.",
	"DataArchitecture - Storage - Architecture - CQRS - Challenges - EventualConsistency - Strategies - ReadModelLagHandling": "Since the read model updates asynchronously, you can: Show stale data with a refresh option. Use real-time notifications (WebSockets, polling, or push updates) to alert users when data is updated. Use a 'read-your-own-writes' strategy (storing pending changes in the session or caching).",
	"DataArchitecture - Storage - Architecture - CQRS - Challenges - EventualConsistency - Strategies - CompensatingActions": "Compensating actions to resolve inconsistencies: Retries (e.g., the query model keeps retrying updates until successful). Conflict Resolution Policies (decide what happens if a query model update fails). Delayed Response Handling (return a pending state until data is available).",
	"DataArchitecture - Storage - Architecture - CQRS - Challenges - EventualConsistency - Strategies - QueryingWriteModel": "Querying the write model when strict consistency is needed.",
	"DataArchitecture - Storage - Architecture - CQRS - Challenges - EventualConsistency - Strategies - ReadThroughCache": "Caching mechanisms to reduce visible inconsistencies.",
	"DataArchitecture - Storage - Transactions - 2PC - Not an option": "One attempt to solve this problem in an automated and hassle-free manner is the XA protocol implementing the two-phase commit (2PC) pattern. But in modern high-scale applications (especially in a cloud environment), 2PC doesn’t seem to perform so well. To eliminate the disadvantages of 2PC, we have to trade ACID for BASE and cover consistency concerns ourselves in different ways depending on the requirements.",
	"DataArchitecture - Storage - Transactions - Saga": "Manages distributed transactions using a sequence of local transactions and compensating actions.",
	"DataArchitecture - Storage - Transactions - Saga - Operation - success": "Each local transaction updates the database and publishes a message or event to trigger the next local transaction in the saga",
	"DataArchitecture - Storage - Transactions - Saga - Operation - failure": "If a local transaction fails because it violates a business rule then the saga executes a series of compensating transactions that undo the changes that were made by the preceding local transactions",
	"DataArchitecture - Storage - Transactions - Saga - Coordination": "There are two ways of coordination sagas: Choreography and Orchestration.",
	"DataArchitecture - Storage - Transactions - Saga - Coordination - Choreography": "Choreography - each local transaction publishes domain events that trigger local transactions in other services",
	"DataArchitecture - Storage - Transactions - Saga - Coordination - Orchestration": "Orchestration - an orchestrator (object) tells the participants what local transactions to execute.",
	"DataArchitecture - Storage - Transactions - Saga - ACD": "Saga provides ACD but misses I (isolation).",
	"DataArchitecture - Storage - Transactions - Saga - Products - Tram": "",
	"DataArchitecture - Storage - Transactions - Saga - Products - AXON Framework": ""

}