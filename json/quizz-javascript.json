{
	"JS": "SECTION",
	"JS - ECMAScript": "JavaScript was invented by Brendan Eich in 1995, and became an ECMA standard in 1997.",
	"JS - ECMAScript - ES1": "1997",
	"JS - ECMAScript - ES2": "1998",
	"JS - ECMAScript - ES3": "1999",
	"JS - ECMAScript - ES4": "Never released",
	"JS - ECMAScript - ES5": "2009. Added 'strict mode'. Added JSON support. Added String.trim(). Added Array.isArray(). Added Array iteration methods. Allows trailing commas for object literals",
	"JS - ECMAScript - ES6": "2015. Added let and const. Added default parameter values. Added Array.find(). Added Array.findIndex(). ECMAScript 6 introduced the let and const keywords. These keywords can be used in place of the var keyword.",
	"JS - ECMAScript - ES2016": "2016. Added exponential operator (**). Added Array.includes()",
	"JS - ECMAScript - ES2017": "2017. Added string padding. Added Object.entries(). Added Object.values(). Added async functions. Added shared memory. Allows trailing commas for function parameters",
	"JS - ECMAScript - ES2018": "2018. Added rest / spread properties. Added asynchronous iteration. Added Promise.finally(). Additions to RegExp",
	"JS - ECMAScript - ES2019": "2019. String.trimStart(). String.trimEnd(). Array.flat(). Object.fromEntries. Optional catch binding",
	"JS - ECMAScript - ES2020": "2020. The Nullish Coalescing Operator (??)",
	"JS - ECMAScript - ES2021": "2021. Promise.any(). String replaceAll(). Numeric Separators (_)",
	"JS - ECMAScript - ES2022": "2022. Array at(). String at(). RegExp /d. Object.hasOwn(). error.cause. await import. Class field declarations. Private methods and fields",
	"JS - ECMAScript - ES2023": "2023. Array findLast(). Array findLastIndex(). Array toReversed(). Array toSorted(). Array toSpliced(). Array with(). #! (Shebang)",
	"JS - ECMAScript - ES2024": "2024. Object.groupBy(). Map.groupBy(). Temporal.PlainDate(). Temporal.PlainTime(). Temporal.PlainMonthDay(). Temporal.PlainYearMonth()",

	"DataTypes": "SECTION",
	"DataTypes - Inmutable - Primitive": "In JavaScript, primitive data types represent the simplest and most basic building blocks of data. They are fundamental values that are immutable, meaning they cannot be altered once they are created. Primitive types are stored directly in memory and have a fixed size. These are stored directly in the stack, which is a simple memory allocation delivering quick access.",
	"DataTypes - Inmutable - Primitive - Undefined": "Undefined: undefined is a special value that represents the absence of a value. It is often used as the default value of variables or function parameters that have not been assigned a value. Variables that are declared but not initialized are automatically assigned the value undefined.",
	"DataTypes - Inmutable - Primitive - Null": "Null: null represents the intentional absence of any object value. It is often used when you want to indicate that a variable should have no value or that an object property is intentionally empty. It is distinct from undefined.",
	"DataTypes - Inmutable - Primitive - String": "String: Strings represent text and are enclosed in either single (‘’) or double quotes. They are used for storing and manipulating textual data. Strings are immutable, which means that any operation on a string creates a new string rather than modifying the original one.",
	"DataTypes - Inmutable - Primitive - Number": "Number: Numbers represent numeric values, both integers and floating-point numbers. They are used for performing mathematical operations. Numbers in JavaScript follow the IEEE 754 standard for floating-point arithmetic. Like strings, numbers are also immutable.",
	"DataTypes - Inmutable - Primitive - BigInt": ".",
	"DataTypes - Inmutable - Primitive - Boolean": "Boolean: Booleans have only two possible values: true and false. They are used to represent logical values and are essential for making decisions in your code. Booleans are immutable and serve as the basis for conditional statements and boolean algebra.",
	"DataTypes - Inmutable - Primitive - Symbol": "Symbol (ES6): Symbols are unique and immutable values introduced in ECMAScript 2015 (ES6). They are often used as property keys in objects to avoid naming conflicts.",
	"DataTypes - Inmutable - Record": "A Record is an immutable collection of key-value pairs, similar to JavaScript objects, but Records are immutable and have deep equality. Records are created using an object-like literal syntax prefixed with #. const record = #{ key1: 'value1', key2: 'value2' };",
	"DataTypes - Inmutable - Tuple": "A Tuple is an immutable ordered list, similar to JavaScript arrays, but Tuples are immutable and have deep equality. Tuples are created using an array-like literal syntax prefixed with #. const tuple = #['value1', 'value2'];",
	"DataTypes - Reference": "Reference types store a reference to the object in the stack, while the object itself lives in the heap, a more complex but expansive memory structure.",
	"DataTypes - Reference - Object": "",
	"DataTypes - Reference - Object - Map": "let map = new Map(); https://medium.com/@jacobmacinnis/javascript-map-vs-javascript-object-vs-traditional-hash-tables-83e5c3068fbd",
	"DataTypes - Reference - Object - Map vs Object - Key Types": "Flexible Key Types: One of the most significant advantages of Map over objects is its flexibility with key types. In an object, keys must be strings or symbols. In a Map, keys can be anything – from primitive values to complex objects. https://javascript.plainenglish.io/are-you-still-using-objects-discover-the-game-changing-power-of-map-in-js-ts-3600a6c28b60",
	"DataTypes - Reference - Object - Map vs Object - Order": "Maintains Order: Maps maintain the order of their entries, which means the sequence in which items are added is preserved. This is particularly useful when you need a predictable iteration order.",
	"DataTypes - Reference - Object - Map vs Object - Performance": "Better Performance for Frequent Additions/Removals: Maps are optimized for frequent additions and removals of key-value pairs. Objects, on the other hand, can suffer performance issues when properties are added or removed frequently, especially when dealing with a large number of entries.",
	"DataTypes - Reference - Object - Map vs Object - Size": "Size Property: Maps have a size property that provides the number of elements in the map. This is more efficient than calculating the size of an object using Object.keys(obj).length, which has to traverse the entire key set.",
	"DataTypes - Reference - Object - Map vs Object - Methods": "Built-In Methods: Maps come with built-in methods like set, get, has, delete, and clear which make manipulating key-value pairs straightforward and intuitive.",
	"DataTypes - Reference - Object - Map vs Object - overhead": "Maps have a bit more overhead compared to plain objects due to their internal structure and additional features. For scenarios where performance is critical and the collection is small and simple, this overhead might be unnecessary.",
	"DataTypes - Reference - Object - Map vs Object - JSON": "Unlike plain objects, Maps cannot be directly serialized to JSON. If you need to serialize your data, you’ll need to convert the Map to an object or an array first.",
	"DataTypes - Reference - Object - URL - ES5": "const endpoint = 'https://api.example.com' + '/users/' + userId + '/details';",
	"DataTypes - Reference - Object - URL - ES6": "const endpoint = `${baseUrl}/users/${userId}/details`;",
	"DataTypes - Reference - Object - URL - Constructor": "const url = new URL(`/users/${userId}/details`, baseUrl);",
	"DataTypes - Reference - Object - URL - Constructor - params": "url.searchParams.append('type', 'EDIT');",
	"DataTypes - Reference - Object - Time - Date": "Date: The Date object represents date and time information. It provides methods for working with dates, times, and time zones. The Date object is used for tasks like date calculations and formatting.",
	"DataTypes - Reference - Object - Time - TemporalAPI": "The Temporal API aims to provide a powerful and flexible toolkit for handling dates and times, making it easier for developers to manage various time-related tasks. https://javascript.plainenglish.io/exploring-the-new-javascript-feature-the-temporal-api-2c7318f047e7",
	"DataTypes - Reference - Array": "",
	"DataTypes - Reference - Array - Spread Operator": "The Spread operator is a key feature in JavaScript that enables an iterable to expand wherever zero or more arguments are required. Its primary use case is with arrays, especially when expecting multiple values. This operator provides the convenience of easily extracting a list of parameters from an array, making our code more versatile and readable.",	
	"DataTypes - Reference - Array - Destructuring": "Destructuring was introduced in ES6. It’s a JavaScript feature that allows us to extract multiple pieces of data from an array or object and assign them to their own variables. const { firstName, lastName, city } = person;.",
	"DataTypes - Reference - Functions": "Functions: Functions are first-class citizens in JavaScript. They are objects that can be invoked and passed around as arguments to other functions. Functions are used for encapsulating reusable code and implementing logic in JavaScript programs.",
	"DataTypes - Operations - typeof": "The typeof operator returns the data type of a JavaScript variable.",
	"DataTypes - Operations - Comparing - Value Comparison": "Primitive Types: Value Comparison. Primitive types are compared based on their values. When you compare two primitive values, you’re checking if their actual content is the same.",
	"DataTypes - Operations - Comparing - Reference Comparison": "Reference Types: Reference Comparison. Reference types, on the other hand, are compared based on their references to memory locations. When you compare two reference type variables, you’re checking if they point to the same memory address, not whether the objects they reference have the same content:.",
	"DataTypes - Operations - Equalying - Shallow": "Shallow equality compares the references themselves, while deep equality compares the content of nested objects or arrays within reference types. For shallow equality, you can use the === operator or its counterpart, the Object.is() method, which behaves similarly but handles edge cases differently (e.g., handling NaN and -0 differently).",
	"DataTypes - Operations - Equalying - Deep": "Deep equality requires custom comparison logic or libraries like Lodash’s isEqual method, which recursively checks the content of nested objects or arrays.",
	"DataTypes - Operations - Copying - Shallow": "To create an independent copy of an object (copy by value), you can use methods like Object.assign() or the spread operator (...). These methods create a shallow copy, which means they copy the top-level properties of the object but not nested objects. It’s essential to note that a shallow copy does not create copies of nested objects within the original object. Shallow Copy means the original data is unaffected by changes to the copied data for fundamental types. For reference types, a shallow copy might duplicate the first layer of an object, protecting the original data when modifying shallow properties in the copied object. https://javascript.plainenglish.io/is-the-spread-operator-a-deep-copy-261c109fb708",
	"DataTypes - Operations - Copying - Deep": "To create deep copies, which include all nested objects, you would need to implement a custom copying function or use a library like Lodash. Deep Copy represents limitless hierarchical duplication. Changes to either fundamental or reference data types in the deep copy do not affect the original.",
	"DataTypes - Operations - Clone - Shallow": "Object.create(), Spread Operator {...}",
	"DataTypes - Operations - Clone - Deep": "JSON.parse(JSON.stringify()), lodash.deepClone",
	"DataTypes - Operations - Passing by Value": "Passing Primitive Values: Passing by Value. When you pass a primitive value to a function, you are essentially passing a copy of that value. This is known as passing by value. Any changes made to the parameter within the function do not affect the original variable outside the function.",
	"DataTypes - Operations - Passing by Reference": "Passing Reference Values: Passing by Reference. When you pass a reference type (such as an object or array) to a function, you are passing a reference to the actual data. This is known as passing by reference. Any modifications made to the parameter within the function directly affect the original variable outside the function. Let’s see this in action:",
	"DataTypes - Operations - Conversion - Strings to Numbers": ".",
	"DataTypes - Operations - Conversion - Numbers to Strings": ".",
	"DataTypes - Operations - Conversion - Dates to Numbers": ".",
	"DataTypes - Operations - Conversion - Numbers to Dates": ".",
	"DataTypes - Operations - Conversion - Booleans to Numbers": ".",
	"DataTypes - Operations - Conversion - Numbers to Booleans": ".",
	"DataTypes - Operations - Chaining - old": "user && user.address && user.address.city",
	"DataTypes - Operations - Chaining - new": "user?.address?.city",
	"DataTypes - Operations - Chaining - Nullish Coalescing": "user.name ?? 'Guest'",

	"Logic": "SECTION",
	"Logic - Conditions - if": "",
	"Logic - Conditions - switch": "",
	"Logic - Loops": "",
	"Logic - Loops - for": "",
	"Logic - Loops - for...in": "",
	"Logic - Loops - for...of": "The for...of loop, introduced in ES6, offers a more flexible way to iterate over iterable objects (including arrays): ",
	"Logic - Loops - for...of - examples - object properties": "for( const[key,value] of Object.entries(user)) { ... }",
	"Logic - Loops - for...of - examples - destructuring": "for( const {name, age} of users) { ... }",
	"Logic - Loops - while": "",
	"Logic - Loops - do while": "",
	"Logic - Loops - forEach": "",
	"Logic - Loops - forEach - problem - break continue": "The flow of a forEach loop is uninterruptible. If you wish to break/continue an iteration, you are better off using the class “for i” loop or the “for of” loop statement.",
	"Logic - Loops - forEach - problem - no async": "The forEach loop will not wait for the completion of async functions, which could lead to unexpected output orders.",
	"Logic - Loops - forEach - problem - no Modify": "https://levelup.gitconnected.com/4-major-problems-with-javascript-foreach-b79f717c61b8",
	"Logic - Loops - forEach - problem - exception": "In other words, if an error occurs inside a forEach, the error will not be caught by the loop itself, which means you must handle exceptions explicitly within the callback.",
	"Logic - HOFs": "JavaScript offers a powerful feature known as higher order functions (HOFs). These functions elevate your code by treating other functions as citizens of the language itself.  In simpler terms, HOFs can accept functions as arguments and even return functions as results. This ability allows developers to write clean, reusable, and expressive code. https://www.freecodecamp.org/news/higher-order-functions-explained/",
	"Logic - HOFs - map": ".",
	"Logic - HOFs - filter": ".",
	"Logic - HOFs - reduce": ".",
	"Logic - HOFs - forEach": ".",
	"Logic - HOFs - some": ".",
	"Logic - HOFs - every": ".",
	"Logic - Async": "",
	"Logic - Async - Callback": "take a function as an argument that would be called when the response is available, freeing the CPU for other things while we wait for the response. in Node.js, almost every call is asynchronous",
	"Logic - Async - Callback - Callback Hell": "Callbacks are very good for the CPU but they are not so good for the programmer. multiple, deep nested callbacks within a function",
	"Logic - Async - Promises (ES6)": "A promise represents the eventual result of an asynchronous operation. It is a placeholder into which the successful result value or reason for failure will materialize. ES6 follows the standard Promises/A+ [1].",
	"Logic - Async - Promises - States": "A promise can be in one of 3 states:(1) Pending - the promise’s outcome hasn’t yet been determined, because the asynchronous operation that will produce its result hasn’t completed yet. (2) Fulfilled - the asynchronous operation has completed, and the promise has a value. (3) Rejected - the asynchronous operation failed, and the promise will never be fulfilled. In the rejected state, a promise has a reason that indicates why the operation failed..",
	"Logic - Async - Promises - Creation": "new Promise( /* executor */ function(resolve, reject) { ... } ).",
	"Logic - Async - Promises - Parallel": "When you need to execute multiple asynchronous operations in parallel and continue executing subsequent code only when all asynchronous operations complete successfully. Promise.all([ asyncFunc1(), asyncFunc2(), ]).then(([result1, result2]) => {  ··· })",
	"Logic - Async - Promises - Parallel Wait": "When you want to wait for multiple asynchronous operations to complete and you need to know the result of each asynchronous operation. Promise.allSettled([promise1, promise2, promise3]).then((values) => { console.log(values); });",
	"Logic - Async - Promises - Race": "When you have multiple asynchronous operations and you only care which one completes first, whether it succeeds or fails. Promise.race([promise1, promise2, promise3]).then((values) => { console.log(values); });",
	"Logic - Async - Promises - Any": "When you have multiple asynchronous operations and you want to get the result of the first successful asynchronous operation and ignore the other asynchronous operations that have failed. Promise.any([promise1, promise2, promise3]).then((values) => { console.log(values); });",
	"Logic - Async - Promises - Resolvers": "In some scenarios, we want to control the state of the Promise object externally. For example, in the scenario of requesting network data, the resolve method is called to set the return data of the current Promise only after all data is successfully received. https://javascript.plainenglish.io/ecmascript-2024-es15-is-coming-5-new-js-features-you-cant-miss-0d2833a53cfc",
	"Logic - Async - Promises - Chaining": "asyncFunc1().then().then()....",
	"Logic - Async - Promises - Handling Errors": ".then(function (greeting) { .... }, function(error) { ... }), or .then(result2 => { ... }) catch(error => { ... })",
	"Logic - Async - async/await": "The word “async” before a function means one simple thing: a function always returns a promise. The keyword await, works only inside async functions, makes JavaScript wait until that promise settles and returns its result.",
	"Logic - Async - async/await - Handling Errors": "await Promise.reject(new Error('Whoops!')), or throw new Error('Whoops!')",
	"Logic - Async - async/await - Global level await": "Before ES13 we could never use await in the global scope. We always had to put it in an async function or create an async IIFE. After ES13 we can. https://medium.com/coding-beauty/best-es13-js-features-f4517fffddc7",
	"Logic - Async - Observables": "An Observable is an array or a sequence of events over time. It has at least two participants, the creator (the data source) and the subscriber (subscription where data is being consumed)",
	"Logic - Async - Observables - Observable": "you create an Observable instance that defines a subscriber function. This is the function that is executed when a consumer calls the subscribe() method producing vales asynchonously.",
	"Logic - Async - Observables - Observable handler": "implements the Observer interface. Defines callback methods to handle the three types of notifications that an observable can send: next, error and complete",
	"Logic - Async - Observables - Subscribing to Observable": "An Observable instance begins publishing values only when someone subscribes to it. You subscribe by calling the subscribe() method of the instance, passing an observer object to receive the notifications.",
	"Logic - Async - Observables - Observable Multicasting": "practice of broadcasting to a list of multiple subscribers in a single execution.",
	"Logic - Async - Observables - Observable Error Handling": "error callback on the observer",
	"Logic - Async - Observables - Observable Unsubscribe": "On the ngOnDestroy lifecycle hook, unsubscribe to subscription to prevent memory leaks",
	"Logic - Async - Observables - RxJS Operators List": "Creation (from, fromPromise, fromEvent, of), Combination (combineLatest , concat , merge , startWith , withLatestFrom , zip), Filtering (debounceTime , distinctUntilChanged , filter , take , takeUntil), Transformation (bufferTime , concatMap , map , mergeMap , scan , switchMap), Utility (tap), Multicasting  (share)",
	"Logic - Async - Observables - RxJS Error Handling": "catchError operator",
	"Logic - Async - Observables - RxJS Retry failed observable": "Use the retry operator before the catchError operator. It resubscribes to the original source observable, which can then re-run the full sequence of actions that resulted in the error. If this includes an HTTP request, it will retry that HTTP request.",
	"Logic - Async - Observables - Examples": "(1) EventEmitter class extends Observable, (2) HTTP module uses observables to handle AJAX requests and responses, (3) Router and Forms modules use observables",
	"Logic - Async - Observables - Observables compared to promises. Creation and subscription": "Observables are declarative, computation does not start until subscription. Promises execute immediately on creation",
	"Logic - Async - Observables - Observables compared to promises. Chaining": "Observables differentiate between chaining and subscription. Promises only have .then() clauses",
	"Logic - Async - Observables - Observables compared to promises. Cancellation": "Observable subscriptions are cancellable. Unsubscribing removes the listener. Promises are not cancellable.",
	"Logic - Async - Observables - Observables compared to promises. Error Handling": "Observables subscribe() is responsible for handling errors. Promises push errors to the child promises (then().then().then().catch())",
	"Logic - Async - Observables - Observables compared to promises. Multiplicity": "Observables provide many values. Promises provide one",
	"Logic - Async - Observables - Observables compared to events API": "you can configure an observable to transform an event before passing the event to the handler",
	"Logic - Async - Observables - Observables compared to arrays": "An observable produces values over time. An array is created as a static set of values. In a sense, observables are asynchronous where arrays are synchronous. ",
	"Logic - Async - AsyncLocalStorage": "Async context provides a way to handle asynchronous operations more gracefully, preserving the context across async calls, making debugging and tracing easier. A go-to feature for backend developers working with Node.js and complex async operations. AsyncLocalStorage  is a Node.js API (based on the async_hooks API) that is used to create asynchronous state within callbacks and promise chains.",
	"Logic - Functional - Monads": "https://medium.com/@yourfuse/what-are-monads-in-javascript-and-how-can-they-improve-your-functional-programming-e42e56e7af9d https://medium.com/javascript-scene/javascript-monads-made-simple-7856be57bfe8",
	"Logic - Functional - Monads2": "https://javascript.plainenglish.io/50-single-line-code-examples-that-showcase-your-fundamental-skills-ea495082de45",
	"Logic - Functional - |>": "The pipeline operator (|>) allows for a more readable and functional approach to chaining functions, inspired by languages like Elixir.",
	
	"View - Rendering": "SECTION",
	"View - Rendering - resources - lazy loading": "Similar to the list virtualization technique, lazy loading images prevents the creation of unnecessary DOM nodes, thereby boosting performance. Lazy loading allows you to defer or delay the loading of images until they are needed or visible to the user instead of loading all the images on page load..",
	"View - Rendering - resources - lazy loading - technique": "The concept behind lazy loading is to initiate the load of a placeholder or a small low-resolution version of the image, typically a small-sized thumbnail or a blurred placeholder. As the user scrolls or interacts with the page, the actual image is loaded dynamically, replacing the placeholder when the user enters the viewport or when it becomes visible. Lazy loading in React can be achieved using various libraries and techniques. One of the popular libraries is the react-lazyload.  .",
	"View - Rendering - resources - lazy loading - compression": "Image compression reduces the file size of images without significant loss of visual quality..",
	"View - Rendering - resources - loading - sync": "<script src='script.js'></script>",
	"View - Rendering - resources - loading - async": "<script src='script.js' async></script>",
	"View - Rendering - resources - loading - defer": "<script src='script.js' defer></script>",
	"View - Rendering - DOM": "The DOM is not part of the JavaScript language, but is instead a Web API which defines the structure and properties of elements on a webpage.",
	"View - Rendering - DOM - access": ".",
	"View - Rendering - DOM - access - minimize": "Accessing and manipulating the DOM can be slow. Minimize the amount of DOM access by caching references to elements and avoiding unnecessary changes.",

	"CICD - Bundling": "SECTION",
	"CICD - Bundling - Arch - Functions - Arrow": "(a,b)=>a+b;",
	"CICD - Bundling - Arch - Functions - Strict": "Strict Mode imposes restrictions that save hours of debugging. With Strict Mode, you’ll get an error if a variable doesn’t exist or has a typo, stopping your app from running and pinpointing the bug immediately. It throws visible errors for silent issues like wrong variable names and prevents using reserved keywords that could cause future problems. Use the use strict line to enable Strict Mode anywhere in your code. I recommend placing it in the global context. It will cover the entire file.",
	"CICD - Bundling - Arch - Functions - Pure": "If I call a pure function, it will only take the data passed as parameters, perform an X operation, and return the output as a value. Pure functions do not print the output, call another function, perform another Y operation, etc. They only return a value.",
	"CICD - Bundling - Arch - Functions - Hoisting": "Hoisting is a concept or behavior in JavaScript where the declaration of a function, variable, or class goes to the top of the scope they were defined in. Hoisting a variable inside a function is a very useful and preferred way of dealing with a variable without even declaring it. It mainly helps to keep variables as local variables in a function and can be used only inside a function. Also note hoisting won’t be allowed if you are executing JavaScript in Strict mode which has ECMAScript version 5, in that it is not legal to use a variable before its declaration and will throw an error.",
	"CICD - Bundling - Arch - Functions - Generator": "Regular functions return only one, single value (or nothing). Generators can return (“yield”) multiple values, one after another, on-demand. They work great with iterables, allowing to create data streams with ease. function* generateSequence() { yield 1; yield 2; return 3; }",
	"CICD - Bundling - Arch - Functions - Generator Function (ES6)": "Functions in JavaScript are known as “run to completion”. When a function is invoked, the body of the function will execute until it reaches the end. The function can’t be paused for other code to execute. Generator functions however are not “run to completion”. Generator functions can be paused and resumed so that other code can execute in between. The great thing about this behavior is that we can use generators to manage flow control. Because generators allow us to pause execution, we can easily cancel asynchronous operations. Generators also allow us to turn asynchronous code into synchronous-looking code. When you invoke a generator function, it won’t execute the body of the function like a regular function. Instead, it will return a generator object called an iterator.",
	"CICD - Bundling - Arch - Functions - Generator Function - example": "A generator function is declared just like a regular function but with an asterisk after the function keyword: function *myGenerator() {}, let iterator = myGenerator(), let firstYield = iterator.next(),",
	"CICD - Bundling - Arch - Functions - Currying": "https://javascript.info/currying-partials",
	"CICD - Bundling - Arch - Closure": "A closure is an inner function that has access to the outer (enclosing) function’s variables—scope chain. The closure has three scope chains: it has access to its own scope (variables defined between its curly brackets), it has access to the outer function’s variables, and it has access to the global variables.",
  "CICD - Bundling - Arch - trimming": "If you wish to eliminate code redundancy, learn to trim your Javascript packages. When you cut-off duplicates and unnecessary code, the possibility of your React app performance multiplies. You must analyze and determine bundled code..",
	"CICD - Bundling - Packaging - Modules": "A module is just a file. One script is one module. As simple as that. Modules can load each other and use special directives export and import to interchange functionality, call functions of one module from another one:",
	"CICD - Bundling - Packaging - Modules - ESM": "ECMAScript Module (ESM). ECMAScript Modules (ESM) is a specification for using Modules in the Web. It's supported by all modern browsers and the recommended way of writing modular code for the Web.",
	"CICD - Bundling - Packaging - Modules - ESM - standard": "ESM is the official standard module system for modern JavaScript and is natively supported by the latest versions of browsers.",
	"CICD - Bundling - Packaging - Modules - ESM - static": "Unlike CommonJS, they are designed to be static, which means you cannot dynamically load or create modules at runtime.",
	"CICD - Bundling - Packaging - Modules - ESM - async loading": "Since ESM was introduced to Node.js, its asynchronous loading feature and module resolution logic have been well received.",
  "CICD - Bundling - Packaging - Modules - ESM - import": "Importing more components or modules than necessary can increase bundle size and negatively impact performance. Import only the specific components or functions you need from a module. Use code-splitting to load components on demand.",
	"CICD - Bundling - Packaging - Modules - ESM - import default": "",
	"CICD - Bundling - Packaging - Modules - ESM - import dynamic": "import('path/to/module').then(module => { ... });",
  "CICD - Bundling - Packaging - Modules - ESM - export": ".",
	"CICD - Bundling - Packaging - Modules - CommonJS": "CommonJS (CJS).",
	"CICD - Bundling - Packaging - Modules - CommonJS - require": "CJS uses the require function to load modules and expose code as a module using either module.exports or exports objects.",
	"CICD - Bundling - Packaging - Modules - CommonJS - NodeJS": "CommonJS is a module system natively supported by Node.js, initially introduced to meet the needs of server-side modularity. .js file extension is by default associated with CommonJS modules.",
	"CICD - Bundling - Packaging - Modules - package.js": "Node.js allows the use of .mjs file extension or explicitly specifying the “type”: “module” property in package.json to indicate ESM modules.",
	"CICD - Bundling - Packaging - Modules - compatibility": "Using require to load ES modules is not supported because ES modules are executed asynchronously. So, there’s nothing wrong with supporting require() for ESM that doesn’t include top-level await. Although some libraries may have valid reasons to use top-level await, it may not be so common.",
	"CICD - Bundling - Packaging - Modules - compatibility - joyeecheung": "https://levelup.gitconnected.com/commonjs-and-es-module-are-finally-going-to-be-compatible-with-each-other-39b8b880796b.",
	"CICD - Bundling - Packaging - Modules - compatibility - polyfill": "https://amy-blankenship.medium.com/those-scary-stories-about-polyfill-io-theyre-just-the-beginning-5e24e7b5fe8a.",
	"CICD - Bundling - Packaging - resources - package managers - npm": "",
	"CICD - Bundling - Packaging - resources - package managers - yarn": "",
	"CICD - Bundling - Packaging - resources - package managers - JSR": "https://denoland.medium.com/jsr-is-not-another-package-manager-77fa596c345d",
	"CICD - Bundling - Packaging - resources - tree shaking": "Tree shaking is a form of dead code elimination. Modern JavaScript bundlers like Webpack can automatically remove unused code, reducing the final bundle size. To enable tree shaking in Webpack, ensure you’re using ES6 module syntax (import and export). Webpack will analyze the dependencies and eliminate code that is not used.",
	"CICD - Bundling - tools - WebPack": "",
	"CICD - Bundling - tools - WebPack - splitting": "When you develop a new React application, all your JavaScript code is typically bundled together into a single file. This file contains all the components, libraries, and other code required for your application to function. But as your application grows, the bundle size can become quite large, resulting in slow initial load times for your users. Code splitting allows you to divide a single bundle into multiple chunks, which can be loaded selectively based on the current needs of your application. Instead of downloading the entire bundle upfront, only the necessary code is fetched and executed when a user visits a particular page or triggers a specific action.",
  "CICD - Bundling - tools - WebPack - splitting - CommonsChunkPlugin": "",
  "CICD - Bundling - tools - WebPack - splitting - SplitChunksPlugin": "",
  "CICD - Bundling - tools - Webpack - Bundle Analyzer": "Webpack Bundle Analyzer helps analyze the size of webpack bundles and identify opportunities for optimization. By visualizing the composition of your bundles, you can pinpoint large dependencies or chunks that can be split or optimized.",
  "CICD - Bundling - tools - Vite": "native ES modules in the browser https://vitejs.dev/",

	"CICD - Building": "SECTION",
	"CICD - Building - types - JIT": "",
	"CICD - Building - types - AOTC": "",
	"CICD - Building - Babel": "Babel is a toolchain that is mainly used to convert ECMAScript 2015+ code into a backwards compatible version of JavaScript in current and older browsers or environments.",
	"CICD - Building - Optiflow": "https://itnext.io/optiflow-a-compiler-based-solution-for-next-generation-javascript-performance-e51c8c8de6ee",

	"CICD - Execution": "SECTION",
	"CICD - Execution - Execution Context": "Execution context (EC) is defined as the environment in which JavaScript code is executed. By environment I mean the value of this, variables, objects, and functions JavaScript code has access to, constitutes it’s environment.",
	"CICD - Execution - Execution Context - Types": "Execution context in JavaScript are of three types: Global execution context, Functional execution context, Eval",
	"CICD - Execution - Execution Context - Global": "Global execution context (GEC): This is the default execution context in which JS code start it’s execution when the file first loads in the browser. All the global code are executed inside global execution context. In the browser context, if the code is executing in strict mode value of this is undefined else it is window object. Global execution context cannot be more than one because only one global environment is possible for JS code execution.",
	"CICD - Execution - Execution Context - Function": "Functional execution context (FEC): Functional execution context is defined as the context created by the execution of code inside a function. Each function has it’s own execution context. It can be more than one. Functional execution context have access to all the code of global execution context. While executing global execution context code, if JS engine finds a function call, it creates a new functional execution context for that function.",
	"CICD - Execution - Execution Context - Eval": "Eval: Execution context inside eval function.",
	"CICD - Execution - Execution Context - Execution context stack (ECS)": "Execution context stack (ECS): Execution context stack is a stack data structure to store all the execution stacks created while executing the JS code. Global execution context is present by default in execution context stack and it is at the bottom of the stack. While executing global execution context code, if JS engines finds a function call, it creates functional execution context of that function and pushes that function execution context on top of execution context stack. JS engine executes the function whose execution context is at the top of the execution context stack. Once all the code of the function is executed, JS engines pop’s out that function’s execution context and start’s executing the function which is below it..",
	"CICD - Execution - Scopes": "The namespace is sometimes an interchangeable word for scope, but usually the refers to the highest level scope. They are: Global, Function, Lexical (Closures), Block (ES6",
	"CICD - Execution - Scopes - Global Scope": "Contrary to the var keyword, the let and const keywords support the declaration of local scope inside block statements.",
	"CICD - Execution - Scopes - Local/Function Scope": "All scopes in JavaScript are created with Function Scope only, they aren’t created by for or while loops or expression statements like if or switch. New functions = new scope - that’s the rule..",
	"CICD - Execution - Scopes - Lexical Scope": "Whenever you see a function within another function, the inner function has access to the scope in the outer function, this is called Lexical Scope or Closure - also referred to as Static Scope. Any variables/objects/functions defined in its parent scope, are available in the scope chain. ",
	"CICD - Execution - Scopes - Block Scope (ES6)": "Contrary to the var keyword, the let and const keywords support the declaration of local scope inside block statements.",
	"CICD - Execution - Scopes - Scope Chain": "Scope chains establish the scope for a given function. Each function defined has its own nested scope as we know, and any function defined within another function has a local scope which is linked to the outer function - this link is called the chain. It’s always the position in the code that defines the scope. When resolving a variable, JavaScript starts at the innermost scope and searches outwards until it finds the variable/object/function it was looking for..",
	"CICD - Execution - Scopes - this": "Each scope binds a different value of this depending on how the function is invoked. We’ve all used the this keyword, but not all of us understand it and how it differs when invoked. By default this refers to the outer most global object, the window",
	"CICD - Execution - Scopes - Changing Scope": "Sometimes you need to manipulate the scopes of your JavaScript depending on what you’re looking to do: .call() and .apply() and .bind()",
	"CICD - Execution - Scopes - Changing Scope - .call() and .apply()": "The .call() and .apply() methods are really sweet, they allows you to pass in a scope to a function, which binds the correct this value. We can use either .call() or .apply() to change the scope, but any further arguments are where the two differ: .call(scope, arg1, arg2, arg3) takes individual arguments, comma separated, whereas .apply(scope, [arg1, arg2]) takes an Array of arguments.",
	"CICD - Execution - Scopes - Changing Scope - .bind() (ES5)": "Unlike the above, using .bind() does not invoke a function, it merely binds the values before the function is invoked.",
	"CICD - Execution - Environment - runtime - node": "",
	"CICD - Execution - Environment - runtime - deno": "",
	"CICD - Execution - Environment - engine - Google V8": "",
	"CICD - Execution - WebWorkers": "Web Workers allow you to run JavaScript in background threads. This can be useful for offloading heavy computations and keeping your UI responsive. JS code runs on a single thread. Running a long process on the same thread will seriously affect the UI-rendering code, so the best bet is to move the process to another thread. This is done by Web workers. They are the gateway where we can create a thread and run it parallel to the main thread without hampering the UI-flow.",
  "CICD - Execution - WebWorkers - HTML5": "Web Workers, part of the HTML5 spec, have actually been around for a while! They were first proposed back in 2009. Web Workers let you run scripts in background threads, independent of your main webpage’s thread. This means smoother performance and happier users. 😃",
  "CICD - Execution - WebWorkers - usage - Parallel Processing": "Web Workers enable parallel processing by allowing you to execute JavaScript code in separate threads. This means that computationally intensive tasks can be offloaded to Web Workers, running concurrently with the main thread and significantly reducing the impact on overall performance.",
  "CICD - Execution - WebWorkers - usage - Offloading Expensive Computations": "By moving complex calculations, data processing, or heavy algorithms to Web Workers, you prevent them from blocking the main thread. This ensures that user interactions remain responsive and smooth UI even when dealing with intensive computations.",
  "CICD - Execution - WebWorkers - usage - Asynchronous Execution": "Web Workers communicate with the main thread via messages, allowing for asynchronous execution of tasks. This means time-consuming operations can be processed in the background without blocking the main thread, and results can be sent back asynchronously when ready.",
  "CICD - Execution - WebWorkers - usage - Improved Responsiveness": "Offloading expensive computations to Web Workers prevents UI freezes or slowdowns caused by long-running operations. Users can continue interacting with the application while the Web Workers handle the computationally intensive tasks in the background, leading to a more responsive and seamless experience.",
  "CICD - Execution - WebWorkers - errors": "Web Workers provide two helpful error-handling events:",
  "CICD - Execution - WebWorkers - errors - error": "error: Triggered when an error happens within the worker.",
  "CICD - Execution - WebWorkers - errors - messageerror": "messageerror: This one fires if the worker receives a message that can't be properly deserialized.",
	"CICD - Execution - WebWorkers - interthreads": "JavaScript’s Web Workers employ clever mechanisms to facilitate data exchange between threads:",
  "CICD - Execution - WebWorkers - interthreads - Structured Clone Algorithm": "Structured Clone Algorithm: This is the default and most compatible method. It’s a robust way to create deep copies of objects that can be safely shared between threads.",
  "CICD - Execution - WebWorkers - interthreads - Transferable Objects": "Transferable Objects: For scenarios demanding optimal performance, Transferable Objects are the way to go. They enable the transfer of ownership of certain data types, like ArrayBuffers, from one thread to another, eliminating unnecessary copying.",
  "CICD - Execution - WebWorkers - interthreads - SharedArrayBuffer": "SharedArrayBuffer: This one enables true shared memory between threads, allowing simultaneous access and modification. However, be aware that extra care needs to be taken to prevent race conditions and ensure data integrity.",
	"CICD - Execution - WebWorkers - main": "const worker = new Worker('worker.js'); worker.onmessage = function(e) { console.log('Worker said: ', e.data); };​ worker.postMessage('Hello, Worker!');.",
	"CICD - Execution - WebWorkers - worker": "self.onmessage = function(e) { console.log('Main thread said: ', e.data); self.postMessage('Hello, Main thread!'); };.",
	"CICD - Execution - WebWorkers - type - Dedicated": "Dedicated Workers: These workers are tied to the specific script that created them. It’s a one-on-one relationship.",
  "CICD - Execution - WebWorkers - type - Shared": "Shared Workers: As the name suggests, these workers can be shared by multiple scripts running in different windows or iframes, provided they belong to the same domain.",
  "CICD - Execution - WebWorkers - type - Service": "Service Workers: These special workers act like proxies, sitting between your web app, the browser, and the network. They’re essential for building robust offline experiences, intercepting network requests, and enabling features like push notifications.",
	"CICD - Execution - WebWorkers - type - Service - usage": "Service Workers can be used to cache assets and handle offline functionality. This can significantly improve the load time of your web app, especially on repeat visits.",
	"CICD - Execution - WebWorkers - type - Service - register": "navigator.serviceWorker.register('/service-worker.js').then(function(registration) {})",
	"CICD - Execution - performance - debounce": "Debounce function is a javascript programming pattern for delaying execution of a function.",
	"CICD - Execution - performance - throttle": "Throttling is a technique that limits how often a function can be called in a given period of time. It is useful for improving the performance. Throttling is used to call a function after every millisecond or a particular interval of time only the first click is executed immediately.",

	"CICD - Audit": "SECTION",
	"CICD - Audit - Logging - console.log": "",
	"CICD - Audit - Logging - process.stdout.write": "https://medium.com/coding-beauty/javascript-console-log-without-newline-20e7e63cca36",
	"CICD - Audit - Testing - JEST": "https://www.robinwieruch.de/react-testing-tutorial/.",
	"CICD - Audit - Testing - Mocha": ".",
	"CICD - Audit - Testing - Chai": ".",
	"CICD - Audit - Testing - Vite": ".",
	"CICD - Audit - Testing - Playwright": ".",
	"CICD - Audit - Testing - Cypress": ".",
	"CICD - Audit - Profiling - Lighthouse": "Lighthouse is an open-source tool by Google for auditing performance, accessibility, and SEO.",
	"CICD - Audit - Profiling - WebPageTest": "WebPageTest allows you to run performance tests from multiple locations around the world. It provides detailed insights into your site’s loading times, resource usage, and more.",
	"CICD - Audit - Profiling - Chrome DevTools": "Chrome DevTools offers a suite of performance profiling and debugging tools.",
	"CICD - Audit - Profiling - Firefox Developer Tools": "Similar to Chrome, open DevTools (F12), go to the “Performance” tab, and start recording.",
	"CICD - Audit - Profiling - NodeJS - prof": "",
	"CICD - Audit - Profiling - NodeJS - clinic": ""

	}