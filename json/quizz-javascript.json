{
	"JS types": "SECTION",
	"JS Types - ES6": "ECMAScript 6 introduced the let and const keywords. These keywords can be used in place of the var keyword.",

	"structure": "SECTION",
	"structure - Closure": "A closure is an inner function that has access to the outer (enclosing) function’s variables—scope chain. The closure has three scope chains: it has access to its own scope (variables defined between its curly brackets), it has access to the outer function’s variables, and it has access to the global variables.",
	"structure - Modules": "A module is just a file. One script is one module. As simple as that. Modules can load each other and use special directives export and import to interchange functionality, call functions of one module from another one:",
	"structure - Modules - ESM": "ECMAScript Module (ESM)",
	"structure - Modules - ESM - standard": "ESM is the official standard module system for modern JavaScript and is natively supported by the latest versions of browsers.",
	"structure - Modules - ESM - static": "Unlike CommonJS, they are designed to be static, which means you cannot dynamically load or create modules at runtime.",
	"structure - Modules - ESM - async loading": "Since ESM was introduced to Node.js, its asynchronous loading feature and module resolution logic have been well received.",
	"structure - Modules - ESM - export": "",
	"structure - Modules - ESM - import": "",
	"structure - Modules - ESM - import default": "",
	"structure - Modules - CommonJS": "CommonJS (CJS).",
	"structure - Modules - CommonJS - require": "CJS uses the require function to load modules and expose code as a module using either module.exports or exports objects.",
	"structure - Modules - CommonJS - NodeJS": "CommonJS is a module system natively supported by Node.js, initially introduced to meet the needs of server-side modularity. .js file extension is by default associated with CommonJS modules.",
	"structure - Modules - package.js": "Node.js allows the use of .mjs file extension or explicitly specifying the “type”: “module” property in package.json to indicate ESM modules.",
	"structure - Modules - compatibility": "Using require to load ES modules is not supported because ES modules are executed asynchronously. So, there’s nothing wrong with supporting require() for ESM that doesn’t include top-level await. Although some libraries may have valid reasons to use top-level await, it may not be so common.",
	"structure - Modules - compatibility - joyeecheung": "https://levelup.gitconnected.com/commonjs-and-es-module-are-finally-going-to-be-compatible-with-each-other-39b8b880796b.",

	"scopes": "SECTION",
	"Execution Context": "Execution context (EC) is defined as the environment in which JavaScript code is executed. By environment I mean the value of this, variables, objects, and functions JavaScript code has access to, constitutes it’s environment.",
	"Execution Context - Types": "Execution context in JavaScript are of three types: Global execution context, Functional execution context, Eval",
	"Execution Context - Global": "Global execution context (GEC): This is the default execution context in which JS code start it’s execution when the file first loads in the browser. All the global code are executed inside global execution context. In the browser context, if the code is executing in strict mode value of this is undefined else it is window object. Global execution context cannot be more than one because only one global environment is possible for JS code execution.",
	"Execution Context - Function": "Functional execution context (FEC): Functional execution context is defined as the context created by the execution of code inside a function. Each function has it’s own execution context. It can be more than one. Functional execution context have access to all the code of global execution context. While executing global execution context code, if JS engine finds a function call, it creates a new functional execution context for that function.",
	"Execution Context - Eval": "Eval: Execution context inside eval function.",
	"Execution Context - Execution context stack (ECS)": "Execution context stack (ECS): Execution context stack is a stack data structure to store all the execution stacks created while executing the JS code. Global execution context is present by default in execution context stack and it is at the bottom of the stack. While executing global execution context code, if JS engines finds a function call, it creates functional execution context of that function and pushes that function execution context on top of execution context stack. JS engine executes the function whose execution context is at the top of the execution context stack. Once all the code of the function is executed, JS engines pop’s out that function’s execution context and start’s executing the function which is below it..",
	"JS Scopes": "The namespace is sometimes an interchangeable word for scope, but usually the refers to the highest level scope. They are: Global, Function, Lexical (Closures), Block (ES6",
	"JS Scopes - Global Scope": "Contrary to the var keyword, the let and const keywords support the declaration of local scope inside block statements.",
	"JS Scopes - Local/Function Scope": "All scopes in JavaScript are created with Function Scope only, they aren’t created by for or while loops or expression statements like if or switch. New functions = new scope - that’s the rule..",
	"JS Scopes - Lexical Scope": "Whenever you see a function within another function, the inner function has access to the scope in the outer function, this is called Lexical Scope or Closure - also referred to as Static Scope. Any variables/objects/functions defined in its parent scope, are available in the scope chain. ",
	"JS Scopes - Block Scope (ES6)": "Contrary to the var keyword, the let and const keywords support the declaration of local scope inside block statements.",
	"JS Scopes - Scope Chain": "Scope chains establish the scope for a given function. Each function defined has its own nested scope as we know, and any function defined within another function has a local scope which is linked to the outer function - this link is called the chain. It’s always the position in the code that defines the scope. When resolving a variable, JavaScript starts at the innermost scope and searches outwards until it finds the variable/object/function it was looking for..",
	"JS Scopes - this": "Each scope binds a different value of this depending on how the function is invoked. We’ve all used the this keyword, but not all of us understand it and how it differs when invoked. By default this refers to the outer most global object, the window",
	"JS Scopes - Changing Scope": "Sometimes you need to manipulate the scopes of your JavaScript depending on what you’re looking to do: .call() and .apply() and .bind()",
	"JS Scopes - Changing Scope - .call() and .apply()": "The .call() and .apply() methods are really sweet, they allows you to pass in a scope to a function, which binds the correct this value. We can use either .call() or .apply() to change the scope, but any further arguments are where the two differ: .call(scope, arg1, arg2, arg3) takes individual arguments, comma separated, whereas .apply(scope, [arg1, arg2]) takes an Array of arguments.",
	"JS Scopes - Changing Scope - .bind() (ES5)": "Unlike the above, using .bind() does not invoke a function, it merely binds the values before the function is invoked.",

	"async": "SECTION",
	"JS Async": "",
	"JS Async - Callback": "take a function as an argument that would be called when the response is available, freeing the CPU for other things while we wait for the response. in Node.js, almost every call is asynchronous",
	"JS Async - Callback - Callback Hell": "Callbacks are very good for the CPU but they are not so good for the programmer. multiple, deep nested callbacks within a function",
	"JS Async - Generator Function (ES6)": "Functions in JavaScript are known as “run to completion”. When a function is invoked, the body of the function will execute until it reaches the end. The function can’t be paused for other code to execute. Generator functions however are not “run to completion”. Generator functions can be paused and resumed so that other code can execute in between. The great thing about this behavior is that we can use generators to manage flow control. Because generators allow us to pause execution, we can easily cancel asynchronous operations. Generators also allow us to turn asynchronous code into synchronous-looking code. When you invoke a generator function, it won’t execute the body of the function like a regular function. Instead, it will return a generator object called an iterator.",
	"JS Async - Generator Function - example": "A generator function is declared just like a regular function but with an asterisk after the function keyword: function *myGenerator() {}, let iterator = myGenerator(), let firstYield = iterator.next(),",
	"JS Async - Promises (ES6)": "A promise represents the eventual result of an asynchronous operation. It is a placeholder into which the successful result value or reason for failure will materialize. ES6 follows the standard Promises/A+ [1].",
	"JS Async - Promises - States": "A promise can be in one of 3 states:(1) Pending - the promise’s outcome hasn’t yet been determined, because the asynchronous operation that will produce its result hasn’t completed yet. (2) Fulfilled - the asynchronous operation has completed, and the promise has a value. (3) Rejected - the asynchronous operation failed, and the promise will never be fulfilled. In the rejected state, a promise has a reason that indicates why the operation failed..",
	"JS Async - Promises - Creation": "new Promise( /* executor */ function(resolve, reject) { ... } ).",
	"JS Async - Promises - Parallel": "Promise.all([ asyncFunc1(), asyncFunc2(), ]).then(([result1, result2]) => {  ··· })",
	"JS Async - Promises - Chaining": "asyncFunc1().then().then()....",
	"JS Async - Promises - Handling Errors": ".then(function (greeting) { .... }, function(error) { ... }), or .then(result2 => { ... }) catch(error => { ... })",
	"JS Async - async/await": "The word “async” before a function means one simple thing: a function always returns a promise. The keyword await, works only inside async functions, makes JavaScript wait until that promise settles and returns its result.",
	"JS Async - async/await - Handling Errors": "await Promise.reject(new Error('Whoops!')), or throw new Error('Whoops!')",
	"JS Async - Observables": "An Observable is an array or a sequence of events over time. It has at least two participants, the creator (the data source) and the subscriber (subscription where data is being consumed)",
	"JS Async - Observables - Observable": "you create an Observable instance that defines a subscriber function. This is the function that is executed when a consumer calls the subscribe() method producing vales asynchonously.",
	"JS Async - Observables - Observable handler": "implements the Observer interface. Defines callback methods to handle the three types of notifications that an observable can send: next, error and complete",
	"JS Async - Observables - Subscribing to Observable": "An Observable instance begins publishing values only when someone subscribes to it. You subscribe by calling the subscribe() method of the instance, passing an observer object to receive the notifications.",
	"JS Async - Observables - Observable Multicasting": "practice of broadcasting to a list of multiple subscribers in a single execution.",
	"JS Async - Observables - Observable Error Handling": "error callback on the observer",
	"JS Async - Observables - Observable Unsubscribe": "On the ngOnDestroy lifecycle hook, unsubscribe to subscription to prevent memory leaks",
	"JS Async - Observables - RxJS Operators List": "Creation (from, fromPromise, fromEvent, of), Combination (combineLatest , concat , merge , startWith , withLatestFrom , zip), Filtering (debounceTime , distinctUntilChanged , filter , take , takeUntil), Transformation (bufferTime , concatMap , map , mergeMap , scan , switchMap), Utility (tap), Multicasting  (share)",
	"JS Async - Observables - RxJS Error Handling": "catchError operator",
	"JS Async - Observables - RxJS Retry failed observable": "Use the retry operator before the catchError operator. It resubscribes to the original source observable, which can then re-run the full sequence of actions that resulted in the error. If this includes an HTTP request, it will retry that HTTP request.",
	"JS Async - Observables - Examples": "(1) EventEmitter class extends Observable, (2) HTTP module uses observables to handle AJAX requests and responses, (3) Router and Forms modules use observables",
	"JS Async - Observables - Observables compared to promises. Creation and subscription": "Observables are declarative, computation does not start until subscription. Promises execute immediately on creation",
	"JS Async - Observables - Observables compared to promises. Chaining": "Observables differentiate between chaining and subscription. Promises only have .then() clauses",
	"JS Async - Observables - Observables compared to promises. Cancellation": "Observable subscriptions are cancellable. Unsubscribing removes the listener. Promises are not cancellable.",
	"JS Async - Observables - Observables compared to promises. Error Handling": "Observables subscribe() is responsible for handling errors. Promises push errors to the child promises (then().then().then().catch())",
	"JS Async - Observables - Observables compared to promises. Multiplicity": "Observables provide many values. Promises provide one",
	"JS Async - Observables - Observables compared to events API": "you can configure an observable to transform an event before passing the event to the handler",
	"JS Async - Observables - Observables compared to arrays": "An observable produces values over time. An array is created as a static set of values. In a sense, observables are asynchronous where arrays are synchronous. "
	}