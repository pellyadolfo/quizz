{

	"Hibernate": "SECTION",
	"Hibernate ": "",

	"Schema": "SECTION",
	"Schema - Scenarios - Hibernate - hibernate.hbm2ddl.auto": "Hibernate's behavior regarding table creation is controlled by the hibernate.hbm2ddl.auto property (or spring.jpa.hibernate.ddl-auto in Spring Boot)",
	"Schema - Scenarios - SpringBoot - or spring.jpa.hibernate.ddl-auto": "Hibernate's behavior regarding table creation is controlled by the hibernate.hbm2ddl.auto property (or spring.jpa.hibernate.ddl-auto in Spring Boot)",
	"Schema - Scenarios - create": "Drops existing tables and creates new ones every time the SessionFactory starts",
	"Schema - Scenarios - create-drop": "Same as create, but also drops tables when SessionFactory closes (good for testing)",
	"Schema - Scenarios - Update": "Updates the schema if needed (adds new columns, but won't remove columns or change data types)",
	"Schema - Scenarios - validate": "Validates the schema against your entities but makes no changes",
	"Schema - Scenarios - none": "Does nothing with the schema (uses existing tables)",

	"Persistence": "SECTION",
	"Persistence - PersistenceContext": "Both the org.hibernate.Session API and javax.persistence.EntityManager API represent a context for dealing with persistent data. This concept is called a persistence context. Persistent data has a state in relation to both a persistence context and the underlying database.",
	"Persistence - PersistenceContext - @PersistenceUnit - JPA": "The @PersistenceUnit annotation is used to specify the EntityManagerFactory that needs to be injected as a dependency.",
	"Persistence - PersistenceContext - @PersistenceUnits - JPA": "The @PersistenceUnits annotation is used to group multiple @PersistenceUnit annotations.",
	"Persistence - PersistenceContext - @PersistenceContext - JPA": "The @PersistenceContext annotation is used to specify the EntityManager that needs to be injected as a dependency.",
	"Persistence - PersistenceContext - @PersistenceContexts - JPA": "The @PersistenceContexts annotation is used to group multiple @PersistenceContext annotations.",
	"Persistence - PersistenceContext - @PersistenceProperty - JPA": "The @PersistenceProperty annotation is used by the @PersistenceContext annotation to declare JPA provider properties that are passed to the underlying container when the EntityManager instance is created.",
	"Persistence - EntityManagement - JPA - EntityManager - EntityManagerFactory": "A thread-safe (and immutable) representation of the mapping of the application domain model to a database. Acts as a factory for org.hibernate.Session instances. The EntityManagerFactory is the JPA equivalent of a SessionFactory and basically those two converge into the same SessionFactory implementation. A SessionFactory is very expensive to create, so, for any given database, the application should have only one associated SessionFactory. The SessionFactory maintains services that Hibernate uses across all Session(s) such as second level caches, connection pools, transaction system integrations, etc.",
	"Persistence - EntityManagement - JPA - EntityManager - EntityManager": "A single-threaded, short-lived object conceptually modeling a Unit of Work PoEAA. In JPA nomenclature, the Session is represented by an EntityManager. Behind the scenes, the Hibernate Session wraps a JDBC java.sql.Connection and acts as a factory for org.hibernate.Transaction instances. It maintains a generally repeatable read persistence context (first level cache) of the application domain model.",
	"Persistence - EntityManagement - JPA - EntityManager - EntityTransaction": "A single-threaded, short-lived object used by the application to demarcate individual physical transaction boundaries. EntityTransaction is the JPA equivalent and both act as an abstraction API to isolate the application from the underlying transaction system in use (JDBC or JTA).",
	"Persistence - EntityManagement - JPA - EntityManager - Clearing": "entityManager.clear(), (JPA)",
	"Persistence - EntityManagement - Hibernate - SessionFactory": "A thread-safe (and immutable) representation of the mapping of the application domain model to a database. Acts as a factory for org.hibernate.Session instances. The EntityManagerFactory is the JPA equivalent of a SessionFactory and basically those two converge into the same SessionFactory implementation. A SessionFactory is very expensive to create, so, for any given database, the application should have only one associated SessionFactory. The SessionFactory maintains services that Hibernate uses across all Session(s) such as second level caches, connection pools, transaction system integrations, etc.",
	"Persistence - EntityManagement - Hibernate - Session": "A single-threaded, short-lived object conceptually modeling a Unit of Work PoEAA. In JPA nomenclature, the Session is represented by an EntityManager. Behind the scenes, the Hibernate Session wraps a JDBC java.sql.Connection and acts as a factory for org.hibernate.Transaction instances. It maintains a generally repeatable read persistence context (first level cache) of the application domain model.",
	"Persistence - EntityManagement - Hibernate - Transaction": "A single-threaded, short-lived object used by the application to demarcate individual physical transaction boundaries. EntityTransaction is the JPA equivalent and both act as an abstraction API to isolate the application from the underlying transaction system in use (JDBC or JTA).",
	"Persistence - EntityManagement - Hibernate - Clearing": "session.clear(), (hibernate)",
	"Persistence - Transactions": "",
	"Persistence - Transactions - Features - Flush": "Hibernate does not automatically flush on rollback",
	"Persistence - Transactions - Features - ThreadSafe": "Transactions are not thread-safe by default",
	"Persistence - Transactions - Features - JTA": "For distributed transactions, use JTA with proper XA datasources",
	"Persistence - Transactions - Features - L2Cache": "Second-level cache updates happen during transaction commit",
	"Persistence - Transactions - lifecycle - JPA - start": "Hibernate starts the transactions by calling getTransaction() (JPA's implementation)",
	"Persistence - Transactions - lifecycle - JPA - instance": "According to used persistence mechanism, a transaction can be an instance of javax.persistence.EntityTransaction (for JPA)",
	"Persistence - Transactions - lifecycle - JPA - transaction.rollback()": "",
	"Persistence - Transactions - lifecycle - JPA - transaction.commit()": "",
	"Persistence - Transactions - lifecycle - Hibernate - start": "Hibernate starts the transactions by calling beginTransaction() (Hibernate's Session)",
	"Persistence - Transactions - lifecycle - Hibernate - instance": "According to used persistence mechanism, a transaction can be an instance of org.hibernate.Transaction (for Hibernate's Session)",
	"Persistence - Transactions - lifecycle - Hibernate - session.beginTransaction()": "",
	"Persistence - Transactions - lifecycle - Hibernate - transaction.rollback()": "",
	"Persistence - Transactions - lifecycle - Hibernate - transaction.commit()": "",
	"Persistence - Transactions - lifecycle - Spring - @Transactional": "When using Spring, transaction management is typically delegated to Spring:",
	"Persistence - Transactions - Isolation": "",
	"Persistence - Transactions - Isolation - Levels - JDBC - Connection.TRANSACTION_NONE": "It is represented by integer value 0 does not support transactions.",
	"Persistence - Transactions - Isolation - Levels - JDBC - Connection.TRANSACTION_READ_UNCOMMITTED": "It is represented by integer value 2 supports transactions allowing Non-Repeatable Reads and, Phantom Reads.",
	"Persistence - Transactions - Isolation - Levels - JDBC - Connection.TRANSACTION_READ_COMMITTED": "It is represented by integer value 1 supports transactions allowing Dirty Reads, Non-Repeatable Reads and, Phantom Reads.",
	"Persistence - Transactions - Isolation - Levels - JDBC - Connection.TRANSACTION_REPEATABLE_READ": "It is represented by integer value 4 supports transactions allowing only Phantom Reads.",
	"Persistence - Transactions - Isolation - Levels - JDBC - Connection.TRANSACTION_SERIALIZABLE": "It is represented by integer value 8 supports transactions without allowing Dirty Reads, Non-Repeatable Reads and, Phantom Reads.",
	"Persistence - Transactions - Isolation - Levels - Spring - Isolation.DEFAULT": "Use the default isolation level of the underlying data store.",
	"Persistence - Transactions - Isolation - Levels - Spring - Isolation.READ_UNCOMMITTED": "A constant indicating that dirty reads, non-repeatable reads, and phantom reads can occur.",
	"Persistence - Transactions - Isolation - Levels - Spring - Isolation.READ_COMMITTED": "A constant indicating that dirty reads are prevented; non-repeatable reads and phantom reads can occur.",
	"Persistence - Transactions - Isolation - Levels - Spring - Isolation.REPEATABLE_READ": "A constant indicating that dirty reads and non-repeatable reads are prevented; phantom reads can occur.",
	"Persistence - Transactions - Isolation - Levels - Spring - Isolation.SERIALIZABLE": "A constant indicating that dirty reads, non-repeatable reads, and phantom reads are prevented.",
	"Persistence - Transactions - Locking": "Locking is a mechanism that prevents concurrent access to data to maintain consistency.",
	"Persistence - Transactions - Locking - Config - LockModeType - JPA": "FORCE, NONE, OPTIMISTIC, OPTIMISTIC_FORCE_INCREMENT, PESSIMISTIC_FORCE_INCREMENT, PESSIMISTIC_READ, PESSIMISTIC_WRITE, READ, UPGRADE, UPGRADE_NOWAIT, UPGRADE_SKIPLOCKED, WRITE",
	"Persistence - Transactions - Locking - Config - LockMode - Hibernate": "FORCE, NONE, OPTIMISTIC, OPTIMISTIC_FORCE_INCREMENT, PESSIMISTIC_FORCE_INCREMENT, PESSIMISTIC_READ, PESSIMISTIC_WRITE, READ, UPGRADE, UPGRADE_NOWAIT, UPGRADE_SKIPLOCKED, WRITE",
	"Persistence - Transactions - Locking - Types": "Your locking strategy can be either optimistic or pessimistic.",
	"Persistence - Transactions - Locking - Types - Optimistic": "Assumes that multiple transactions can complete without affecting each other, and that therefore transactions can proceed without locking the data resources that they affect.",
	"Persistence - Transactions - Locking - Types - Optimistic - Rollback": "Before committing, each transaction verifies that no other transaction has modified its data. If the check reveals conflicting modifications, the committing transaction rolls back.",
	"Persistence - Transactions - Locking - Types - Optimistic - @OptimisticLocking - JPA": "The @OptimisticLock annotation is used to specify if the currently annotated attribute will trigger an entity version increment upon being modified.",
	"Persistence - Transactions - Locking - Types - Optimistic - @OptimisticLocking - Hibernate": "The @OptimisticLocking annotation is used to specify the currently annotated an entity optimistic locking strategy.",
	"Persistence - Transactions - Locking - Types - Optimistic - @OptimisticLocking - Strategies": "NONE, VERSION, ALL, DIRTY",
	"Persistence - Transactions - Locking - Types - Optimistic - @OptimisticLocking - Strategies - NONE": "NONE The implicit optimistic locking mechanism is disabled.",
	"Persistence - Transactions - Locking - Types - Optimistic - @OptimisticLocking - Strategies - VERSION": "VERSION The implicit optimistic locking mechanism is using a dedicated version column.",
	"Persistence - Transactions - Locking - Types - Optimistic - @OptimisticLocking - Strategies - VERSION - @Version": "Uses versioning (a version number or timestamp). Implemented using @Version annotation",
	"Persistence - Transactions - Locking - Types - Optimistic - @OptimisticLocking - Strategies - ALL": "ALL The implicit optimistic locking mechanism is using all attributes as part of an expanded WHERE clause restriction for the Update and Delete SQL statements.",
	"Persistence - Transactions - Locking - Types - Optimistic - @OptimisticLocking - Strategies - DIRTY": "DIRTY The implicit optimistic locking mechanism is using the dirty attributes (the attributes that were modified) as part of an expanded WHERE clause restriction for the Update and Delete SQL statements.",
	"Persistence - Transactions - Locking - Types - Pessimistic": "Pessimistic locking assumes that concurrent transactions will conflict with each other, and requires resources to be locked after they are read and only unlocked after the application has finished using the data.",
	"Persistence - Entity - JPA - Locate - Reference": "Obtain an entity reference without initializing its data: book.setAuthor( entityManager.getReference( Person.class, personId ) ) (JPA)",
	"Persistence - Entity - JPA - Locate - ReferenceBySimpleNaturalId": "session.bySimpleNaturalId( Book.class ).getReference( isbn ) (hibernate)",
	"Persistence - Entity - JPA - Locate - ReferenceByNaturalId": "session.byNaturalId( Book.class ).using( 'isbn', isbn ).load( ), (hibernate)",
	"Persistence - Entity - JPA - Locate - Find": "Person person = entityManager.find( Person.class, personId ) (JPA)",
	"Persistence - Entity - JPA - Locate - Contains": "entityManager.contains( person ) (JPA)",
	"Persistence - Entity - JPA - Persist - Persist": "entityManager.persist( person ) (JPA)",
	"Persistence - Entity - JPA - Persist - Merging": "Merging detached data: entityManager.merge( person ) (JPA)",
	"Persistence - Entity - JPA - Persist - Remove": "entityManager.remove( person ) (JPA)",
	"Persistence - Entity - JPA - Persist - Refresh": "Refresh entity state entityManager.refresh( person ) (JPA)",
	"Persistence - Entity - JPA - Persist - Evicting": "entityManager.detach( person ) (JPA)",
	"Persistence - Entity - JPA - Persist - Laziness": "persistenceUnitUtil.isLoaded( person ) (JPA)",
	"Persistence - Entity - JPA - Cascade": "Cascading refers to the propagation of operations from a parent entity to its associated child entities.",
	"Persistence - Entity - JPA - Cascade - @Cascade - JPA": "JPA allows you to propagate the state transition from a parent entity to a child. The JPA javax.persistence.CascadeType defines various cascade types: ALL, PERSIST, MERGE, REMOVE, REFRESH, DETACH.",
	"Persistence - Entity - JPA - Cascade - @Cascade - Hibernate": "Hibernate allows you to propagate the state transition from a parent entity to a child. The Hibernate javax.persistence.CascadeType defines various cascade types: the JPA ones (ALL, PERSIST, MERGE, REMOVE, REFRESH, DETACH) plus SAVE_Update, REPLICATE, LOCK",
	"Persistence - Entity - JPA - Cascade - CascadeType - ALL (Hibernate/JPA)": "CascadeType.ALL will propagate any Hibernate-specific operation, which is defined by the org.hibernate.annotations.CascadeType enum: SAVE_Update, REPLICATE, LOCK.",
	"Persistence - Entity - JPA - Cascade - CascadeType - MERGE (Hibernate/JPA)": "The CascadeType.MERGE allows us to merge a child entity along with the parent one.",
	"Persistence - Entity - JPA - Cascade - CascadeType - PERSIST (Hibernate/JPA)": "The CascadeType.PERSIST allows us to persist a child entity along with the parent one.",
	"Persistence - Entity - JPA - Cascade - CascadeType - REMOVE (Hibernate/JPA)": "The CascadeType.REMOVE allows us to remove a child entity along with the parent one. Traditionally, Hibernate called this operation Delete, that's why the org.hibernate.annotations.CascadeType provides a Delete cascade option. However, CascadeType.REMOVE and org.hibernate.annotations.CascadeType.Delete are identical.",
	"Persistence - Entity - JPA - Cascade - CascadeType - REFRESH (Hibernate/JPA)": "The CascadeType.REFRESH is used to propagate the refresh operation from a parent entity to a child. The refresh operation will discard the current entity state, and it will override it using the one loaded from the database.",
	"Persistence - Entity - JPA - Cascade - CascadeType - DETACH (Hibernate/JPA)": "CascadeType.DETACH is used to propagate the detach operation from a parent entity to a child.",
	"Persistence - Entity - JPA - Cascade - CascadeType - LOCK (Hibernate)": "Although unintuitively, CascadeType.LOCK does not propagate a lock request from a parent entity to its children. Such a use case requires the use of the PessimisticLockScope.EXTENDED value of the javax.persistence.lock.scope property. However, CascadeType.LOCK allows us to reattach a parent entity along with its children to the currently running Persistence Context.",
	"Persistence - Entity - JPA - Cascade - CascadeType - REPLICATE (Hibernate)": "The CascadeType.REPLICATE is to replicate both the parent and the child entities. The replicate operation allows you to synchronize entities coming from different sources of data.",
	"Persistence - Entity - JPA - Cascade - CascadeType - SAVE_Update (Hibernate)": "Either save() or Update() the given instance, depending upon the value of its identifier property. By default the instance is always saved. This behaviour may be adjusted by specifying an unsaved-value attribute of the identifier property mapping. This operation cascades to associated instances if the association is mapped with cascade='save-Update'.",
	"Persistence - Entity - JPA - Cascade - OrphanRemoval": "Use orphanRemoval = true to automatically delete child entities when they're removed from the collection.",
	"Persistence - Entity - Hibernate - Locate - Reference": "Obtain an entity reference without initializing its data: book.setAuthor( session.load( Person.class, personId ) ) (hibernate)",
	"Persistence - Entity - Hibernate - Locate - ReferenceBySimpleNaturalId": "session.bySimpleNaturalId( Book.class ).getReference( isbn ) (hibernate)",
	"Persistence - Entity - Hibernate - Locate - ReferenceByNaturalId": "session.byNaturalId( Book.class ).using( 'isbn', isbn ).load( ), (hibernate)",
	"Persistence - Entity - Hibernate - Locate - Find": "session.get( Person.class, personId ) and session.byId( Person.class ).load( personId ) (hibernate)",
	"Persistence - Entity - Hibernate - Locate - Contains": "session.contains( person ) (hibernate)",
	"Persistence - Entity - Hibernate - Persist - Persist": "session.save( person ) (hibernate)",
	"Persistence - Entity - Hibernate - Persist - Merging": "Merging detached data: session.merge( person ) (hibernate)",
	"Persistence - Entity - Hibernate - Persist - Remove": "session.delete( person ) (hibernate)",
	"Persistence - Entity - Hibernate - Persist - Refresh": "Refresh entity state: session.refresh( person ) (hibernate)",
	"Persistence - Entity - Hibernate - Persist - Evicting": "session.evict( person ) (hibernate)",
	"Persistence - Entity - Hibernate - Persist - Reattaching": "session.lock( person, LockMode.NONE ) (hibernate) or session.saveOrUpdate( person ) (hibernate).",
	"Persistence - Entity - Hibernate - Persist - Laziness": "Hibernate.isInitialized( person ) (hibernate)",
	"Persistence - Entity - Hibernate - @OnDelete": "The @OnDelete annotation is a Hibernate-specific feature that allows you to specify the database-level action that should occur when a referenced entity is deleted.",
	"Persistence - Entity - Hibernate - @OnDelete - ON DELETE": "This annotation generates the appropriate ON DELETE clause in the foreign key constraint at the database level.",
	"Persistence - Entity - Hibernate - @OnDelete - OnDeleteAction": "",
	"Persistence - Entity - Hibernate - @OnDelete - OnDeleteAction - CASCADE": "Delete child records when parent is deleted",
	"Persistence - Entity - Hibernate - @OnDelete - OnDeleteAction - NO_ACTION": "Default behavior (throws error if children exist)",
	"Persistence - Entity - Hibernate - @OnDelete - OnDeleteAction - RESTRICT": "Similar to NO_ACTION but checked before attempting deletion",
	"Persistence - Entity - Hibernate - @OnDelete - OnDeleteAction - SET_NULL": "Set foreign key to NULL (requires nullable column)",
	"Persistence - Entity - Hibernate - @OnDelete - OnDeleteAction - SET_DEFAULT": "Set foreign key to its default value",
	"Persistence - States": "Transient, managed or persistent, detached, removed",
	"Persistence - States - Transient": "new or transient. The entity has just been instantiated and is not associated with a persistence context. It has no persistent representation in the database and typically no identifier value has been assigned (unless the assigned generator was used).",
	"Persistence - States - Persistent": "managed or persistent. The entity has an associated identifier and is associated with a persistence context. It may or may not physically exist in the database yet.",
	"Persistence - States - Detached": "The entity has an associated identifier, but is no longer associated with a persistence context (usually because the persistence context was closed or the instance was evicted from the context).",
	"Persistence - States - Removed": "The entity has an associated identifier and is associated with a persistence context, however it is scheduled for removal from the database.",
	"Persistence - States - JPA - Modifying": "person.setName('John Doe'), entityManager.flush(), (JPA)",
	"Persistence - States - Hibernate - Modifying": "person.setName('John Doe'), session.flush(), (hibernate)",
	"Persistence - Flushing": "Flushing is the process of synchronizing the state of the persistence context with the underlying database. The EntityManager and the Hibernate Session expose a set of methods, through which the application developer can change the persistent state of an entity. The persistence context acts as a transactional write-behind cache, queuing any entity state change. Like any write-behind cache, changes are first applied in-memory and synchronized with the database during flush time. The flush operation takes every entity state change and translates it to an INSERT, Update or Delete statement.",
	"Persistence - Flushing - ChangeDetection - Hibernate": "Hibernate's change detection is the core feature that enables automatic synchronization between Java object state and database records.",
	"Persistence - Flushing - ChangeDetection - InitialState": "Initial State Capture: When an entity is loaded, Hibernate takes a 'snapshot' of all its persistent state",
	"Persistence - Flushing - ChangeDetection - DeepComparison": "During flush operations, compares current state with the original snapshot.",
	"Persistence - Flushing - ChangeDetection - GranularTracking": "Works at the individual property level.",
	"Persistence - Flushing - ChangeDetection - DirtyChecking": "Hibernate's dirty checking is the process of detecting which entity properties have changed since they were loaded from the database, so only those changes are persisted.",
	"Persistence - Flushing - ChangeDetection - DirtyChecking - SnapshotMechanism": "When an entity is loaded, Hibernate takes a snapshot of its state. At flush time (before query execution or transaction commit), Hibernate compares",
	"Persistence - Flushing - ChangeDetection - DirtyChecking - BytecodeEnhancement": "For better performance, Hibernate can use bytecode enhancement to: Add tracking at the field level, Replace collections with smart proxies that track modifications",
	"Persistence - Flushing - Strategies - JTA": "JPA defines only two flushing strategies (AUTO and COMMIT)",
	"Persistence - Flushing - Strategies - JTA - AUTO": "",
	"Persistence - Flushing - Strategies - JTA - COMMIT": "",
	"Persistence - Flushing - Strategies - Hibernate": "The flushing strategy is given by the flushMode of the current running Hibernate Session. Although JPA defines only two flushing strategies (AUTO and COMMIT), Hibernate has a much broader spectrum of flush types: ALWAYS, AUTO, COMMIT, MANUAl",
	"Persistence - Flushing - Strategies - Hibernate - NEVER": "The Session is never flushed unless Session.flush() is explicitly called by the application. This mode is very efficient for read only transactions.",
	"Persistence - Flushing - Strategies - Hibernate - COMMIT": "The Session is flushed when Transaction.commit() is called.",
	"Persistence - Flushing - Strategies - Hibernate - AUTO": "The Session is flushed if necessary before query execution in order to ensure that queries never return stale state. This is the default flush mode.",
	"Persistence - Flushing - Strategies - Hibernate - MANUAL": "The Session flushing is delegated to the application, which must call Session.flush() explicitly in order to apply the persistence context changes.",
	"Persistence - Flushing - Strategies - Hibernate - ALWAYS": "The Session is flushed before every query. This is almost always unnecessary and inefficient.",
	"Persistence - Flushing - Process": "When changes are detected.",
	"Persistence - Flushing - Process - 1. IdentifyDirtyEntities": "Compare all managed entities with snapshots.",
	"Persistence - Flushing - Process - 2. Processcollections:": "Apply collection updates first.",
	"Persistence - Flushing - Process - 3. GenerateSQL": "Hibernate generates appropriate SQL: INSERT for new entities, UPDATE for changed entities, DELETE for removed entities",
	"Persistence - Flushing - Process - 4. ExecuteSQL": "Execute SQL in optimal order: Inserts (to generate IDs needed for FKs), Updates, Deletes",
	"Persistence - Flushing - Process - 5. ReferentialIntegrity": "Maintains referential integrity: Handles foreign key updates, Processes cascading operations",
	"Persistence - Flushing - Process - 6. OrderOptimally": "Orders operations optimally: Inserts before updates (to generate IDs), Deletes last",
	"Persistence - Flushing - Process - 7. BatchOperations": "When enabled via hibernate.jdbc.batch_size",
	"Persistence - Events": "Both interceptors and event listeners allow you to hook into Hibernate's lifecycle events, making them powerful tools for implementing auditing functionality.",
	"Persistence - Events - JPA - Listeners": "The JPA specification provides two related mechanisms for this purpose: callback method and entity listener",
	"Persistence - Events - JPA - Listeners - JPA Callbacks": "JPA also defines a more limited set of callbacks through annotations: @PrePersist, @PreRemove, @PostPersist, @PostRemove, @PreCUpdate, @PostUpdate, @PostLoad",
	"Persistence - Events - JPA - Listeners - JPA Callbacks - @PrePersist - JPA": "Executes before entity insertion.",
	"Persistence - Events - JPA - Listeners - JPA Callbacks - @PostPersist - JPA": "Executes after entity insertion.",
	"Persistence - Events - JPA - Listeners - JPA Callbacks - @PreUpdate - JPA": "Executes before entity update.",
	"Persistence - Events - JPA - Listeners - JPA Callbacks - @PostUpdate - JPA": "Executes after entity update.",
	"Persistence - Events - JPA - Listeners - JPA Callbacks - @PreRemove - JPA": "Executes before entity deletion.",
	"Persistence - Events - JPA - Listeners - JPA Callbacks - @PostRemove - JPA": "Executes after entity deletion.",
	"Persistence - Events - JPA - Listeners - JPA Callbacks - @PostLoad - JPA": "Executes after loading an entity.",
	"Persistence - Events - JPA - Listeners - JPA EntityListeners - @EntityListeners": "The @EntityListeners annotation is used to specify an array of callback listener classes that are used by the currently annotated entity.",
	"Persistence - Events - JPA - Listeners - JPA EntityListeners - @ExcludeDefaultListeners": "The @ExcludeDefaultListeners annotation is used to specify that the currently annotated entity skips the invocation of any default listener.",
	"Persistence - Events - JPA - Listeners - JPA EntityListeners - @ExcludeSuperclassListeners": "The @ExcludeSuperclassListeners annotation is used to specify that the currently annotated entity skips the invocation of listeners declared by its superclass.",
	"Persistence - Events - Hibernate - Interceptor": "The org.hibernate.Interceptor interface provides callbacks from the session to the application, allowing the application to inspect and/or manipulate properties of a persistent object before it is saved, Updated, Deleted or loaded.",
	"Persistence - Events - Hibernate - Interceptor - Scope": "An Interceptor can be either Session-scoped or SessionFactory-scoped",
	"Persistence - Events - Hibernate - Interceptor - Scope - Session": "A Session-scoped interceptor is specified when a session is opened.",
	"Persistence - Events - Hibernate - Interceptor - Scope - SessionFactory": "A SessionFactory-scoped interceptor is registered with the Configuration object prior to building the SessionFactory. Unless a session is opened explicitly specifying the interceptor to use, the SessionFactory-scoped interceptor will be applied to all sessions opened from that SessionFactory. SessionFactory-scoped interceptors must be thread safe. Ensure that you do not store session-specific states since multiple sessions will use this interceptor potentially concurrently.",
	"Persistence - Events - Hibernate - NativeEventSystem": "React to particular events in the persistence layer. The full range of defined event types is declared on org.hibernate.event.spi.EventType: AUTO_FLUSH, CLEAR, Delete, DIRTY_CHECK, EVICT, FLUSH, FLUSH_ENTITY, INIT_COLLECTION, LOAD, LOCK, MERGE, PERSIST, PERSIST_ONFLUSH, POST_COLLECTION_RECREATE, POST_COLLECTION_REMOVE, POST_COLLECTION_Update, POST_COMMIT_Delete, POST_COMMIT_INSERT, POST_COMMIT_Update, POST_Delete, POST_INSERT, POST_LOAD, POST_Update, PRE_COLLECTION_RECREATE, PRE_COLLECTION_REMOVE, PRE_COLLECTION_Update, PRE_Delete, PRE_INSERT, PRE_LOAD, PRE_Update, REFRESH, REPLICATE, RESOLVE_NATURAL_ID, SAVE, SAVE_Update, Update ",
	"Persistence - Events - Hibernate - EventListeners": "Event listeners provide a more fine-grained approach to handling persistence events.",
	"Persistence - Events - Hibernate - EventListeners - hibernate.cfg.xml": "< listener type='post-insert' class='com.example.AuditEventListener'/> ",
	"Persistence - Events - Hibernate - EventListeners - PreInsertEvent": ".",
	"Persistence - Events - Hibernate - EventListeners - PostInsertEvent": ".",
	"Persistence - Events - Hibernate - EventListeners - PreUpdateEvent": ".",
	"Persistence - Events - Hibernate - EventListeners - PostUpdateEvent": ".",
	"Persistence - Events - Hibernate - EventListeners - PreDeleteEvent": ".",
	"Persistence - Events - Hibernate - EventListeners - PostDeleteEvent": ".",

	"Types": "SECTION",
	"Types - All - Immutability": "Immutability can be specified for both entities and collections.",			
	"Types - All - Immutability - @Updatable - JPA": "@Updatable(false)",			
	"Types - All - Immutability - @Immutable - Hibernate": "The @Immutable annotation is used to specify that the annotated entity, attribute, or collection is immutable.",			
	"Types - All - Immutability - Entity": "If a specific entity is immutable, it is good practice to mark it with the @Immutable annotation. @Immutable means is till ignore Updates and throw Exceptions for Deletes",
	"Types - All - Immutability - Entity - @Subselect - Hibernate": "@Subselect allows us to map an immutable entity to the SQL query",
	"Types - All - Immutability - Collection": "Just like entities, collections can also be marked with the @Immutable annotation. This means is till throw Exceptions for Updates and Deletes",
	"Types - All - Java - @Target": "Defines the allowed locations where an annotation can be used.",
	"Types - All - Java - @Target - Syntax": "Takes an array of ElementType values (e.g., TYPE, FIELD, METHOD, etc.).",
	"Types - All - Java - @Target - Entities": "@Entity → @Target(TYPE) (can only be applied to classes).",
	"Types - All - Java - @Target - Identifiers": "@Id → @Target({METHOD, FIELD}) (can be on fields or getter methods).",
	"Types - All - Java - @Target - Associations": "The @ManyToOne, @OneToOne, @OneToMany, and @ManyToMany feature a targetEntity attribute to specify the actual class of the entiity association when an interface is used for the mapping.",
	"Types - All - Java - @Target - BasicTypes": "@Column → @Target({METHOD, FIELD}).",
	"Types - All - Java - @Target - Embeddable": "For simple embeddable types, use the Hibernate-specific @Target annotation instead.",
	"Types - All - Java - @Target - @ElementCollection": "The @ElementCollection association has a targetClass attribute for the same purpose.",
	"Types - Entities": "Entities, by nature of their unique identifier, exist independently of other objects whereas values do not. Entities are domain model classes which correlate to rows in a database table, using a unique identifier. Because of the requirement for a unique identifier, entities exist independently and define their own lifecycle. The Contact class itself would be an example of an entity.",
	"Types - Entities - Requirements JPA 2.1": "Section 2.1 The Entity Class of the JPA 2.1 specification defines its requirements for an entity class.",
	"Types - Entities - Requirements JPA 2.1 - @Entity": "(1) The entity class must be annotated with the @Entity annotation (or be denoted as such in XML mapping),",
	"Types - Entities - Requirements JPA 2.1 - constructor": "(2) The entity class must have a public or protected no-argument constructor.",
	"Types - Entities - Requirements JPA 2.1 - class": "(3) The entity class must be a top-level class. An enum or interface may not be designated as an entity.",
	"Types - Entities - Requirements JPA 2.1 - nofinal": "(4) The entity class must not be final. No methods or persistent instance variables of the entity class may be final.",
	"Types - Entities - Requirements JPA 2.1 - Serializable": "(5) If an entity instance is to be used remotely as a detached object, the entity class must implement the Serializable interface.",
	"Types - Entities - Requirements JPA 2.1 - abstract": "(6) Both abstract and concrete classes can be entities.",
	"Types - Entities - Requirements JPA 2.1 - extend": "(7) Entities may extend non-entity classes as well as entity classes, and non-entity classes may extend entity classes.",
	"Types - Entities - Requirements JPA 2.1 - JavaBean": "(8) The persistent state of an entity is represented by instance variables, which may correspond to JavaBean-style properties.",
	"Types - Entities - Requirements JPA 2.1 - within": "(9) An instance variable must be directly accessed only from within the methods of the entity by the entity instance itself.",
	"Types - Entities - Requirements JPA 2.1 - Accessors": "(10) The state of the entity is available to clients only through the entity’s accessor methods (getter/setter methods) or other business methods.",
	"Types - Entities - Requirements Hibernate": "Hibernate, however, is not as strict in its requirements.",
	"Types - Entities - Requirements Hibernate - constructor": "(1) The entity class must have a no-argument constructor, which may be public, protected or package visibility. The entity class should have a no-argument constructor. Both Hibernate and JPA require this. JPA requires that this constructor be defined as public or protected. Hibernate, for the most part, does not care about the constructor visibility, as long as the system SecurityManager allows overriding the visibility setting. That said, the constructor should be defined with at least package visibility if you wish to leverage runtime proxy generation.",
	"Types - Entities - Requirements Hibernate - constructors": "(2) It may define additional constructors as well.",
	"Types - Entities - Requirements Hibernate - class": "(3) The entity class need not be a top-level class.",
	"Types - Entities - Requirements Hibernate - final": "(4) Hibernate can persist final classes or classes with final persistent state accessor (getter/setter) methods. However, it is generally not a good idea as doing so will stop Hibernate from being able to generate proxies for lazy-loading the entity. A central feature of Hibernate is the ability to load lazily certain entity instance variables (attributes) via runtime proxies. This feature depends upon the entity class being non-final or else implementing an interface that declares all the attribute getters/setters. You can still persist final classes that do not implement such an interface with Hibernate, but you will not be able to use proxies for fetching lazy associations, therefore limiting your options for performance tuning. For the very same reason, you should also avoid declaring persistent attribute getters and setters as final.",
	"Types - Entities - Requirements Hibernate - variables": "(5) Hibernate does not restrict the application developer from exposing instance variables and reference them from outside the entity class itself.",
	"Types - Entities - Requirements Hibernate - JavaBean": "The JPA specification requires this, otherwise the model would prevent accessing the entity persistent state fields directly from outside the entity itself. Although Hibernate does not require it, it is recommended to follow the JavaBean conventions and define getters and setters for entity persistent attributes. Nevertheless, you can still tell Hibernate to directly access the entity fields. Attributes (whether fields or getters/setters) need not be declared public. Hibernate can deal with attributes declared with public, protected, package or private visibility. Again, if wanting to use runtime proxy generation for lazy loading, the getter/setter should grant access to at least package visibility.",			
	"Types - Entities - Class": ".",
	"Types - Entities - Class - Config - JPA - @Entity": "@Entity anno defines just one attribute name which is used to give a specific entity name for use in JPQL queries. By default, the entity name represents the unqualified name of the entity class itself. An entity models a database table. The identifier uniquely identifies each row in that table. By default, the name of the table is assumed to be the same as the name of the entity. To explicitly give the name of the table or to specify other information about the table, we would use the javax.persistence.Table annotation.",
	"Types - Entities - Class - Config - JPA - @Table": "The @Table annotation is used to specify the primary table of the currently annotated entity.",
	"Types - Entities - Class - Config - JPA - @Tables": "The @Tables annotation is used to group multiple @Table annotations.",
	"Types - Entities - Class - Config - JPA - @SecondaryTable": "The @SecondaryTable annotation is used to specify a secondary table for the currently annotated entity. = you want to map a single entity to multiple tables in database such that some fields from entity are stored in one table and other fields into other table. Attribute pkJoinColumns specifies the PK/FK",
	"Types - Entities - Class - Config - JPA - @SecondaryTables": "The @SecondaryTables annotation is used to group multiple @SecondaryTable annotations.",
	"Types - Entities - Class - Config - JPA - @Transient": "Excludes a field from persistence.",
	"Types - Entities - Class - Config - Hibernate - @Where": "Sometimes, you want to filter out entities or collections using custom SQL criteria. This can be achieved using the @Where annotation, which can be applied to entities and collections. @Where( clause = 'active = true' )",
	"Types - Entities - Class - Config - Hibernate - @WhereJoinTable": "Just like @Where annotation, @WhereJoinTable is used to filter out collections using a joined table (e.g. @ManyToMany association).",
	"Types - Entities - Class - Config - Hibernate - @Persister": "The @Persister annotation is used to specify a custom entity or collection persister. For entities, the custom persister must implement the EntityPersister interface. For collections, the custom persister must implement the CollectionPersister interface. @Persister(impl=MyEntityPersister.class)",
	"Types - Entities - Class - Config - Hibernate - @Tuplizer": "It is possible to map your entities as dynamic proxies using the @Tuplizer annotation. The @Tuplizer instructs Hibernate to use the DynamicEntityTuplizer and DynamicEmbeddableTuplizer to handle the associated entity and embeddable object types.",
	"Types - Entities - Class - Config - Hibernate - @Tuplizers": "The @Tuplizers annotation is used to group multiple @Tuplizer annotations.",
	"Types - Entities - Class - Config - Hibernate - @Check": "Adds a SQL CHECK constraint.",
	"Types - Entities - Class - Config - Hibernate - @Index": "@Table(appliesTo = 'customers', indexes = @Index(...)) – Hibernate-style index definition.",
	"Types - Entities - Class - Inheritance": "Although relational database systems don’t provide support for inheritance, Hibernate provides several strategies to leverage this object-oriented trait onto domain model entities: MappedSuperclass, Single table, Joined table, Table per class",
	"Types - Entities - Class - Inheritance - JPA - @Inheritance": "The @Inheritance annotation is used to specify the inheritance strategy of a given entity class hierarchy.",
	"Types - Entities - Class - Inheritance - JPA - @MappedSuperclass": "Inheritance is implemented in domain model only without reflecting it in the database schema. When using MappedSuperclass, the inheritance is visible in the domain model only and each database table contains both the base class and the subclass properties. Because the @MappedSuperclass inheritance model is not mirrored at database level, it’s not possible to use polymorphic queries (fetching subclasses by their base class).",
	"Types - Entities - Class - Inheritance - JPA - @PrimaryKeyJoinColumn": "The @PrimaryKeyJoinColumn annotation is used to specify that the primary key column of the currently annotated entity is also a foreign key to some other entity (e.g. a base class table in a JOINED inheritance strategy, the primary table in a secondary table mapping, or the parent table in a @OneToOne relationship).",
	"Types - Entities - Class - Inheritance - JPA - @PrimaryKeyJoinColumns": "The @PrimaryKeyJoinColumns annotation is used to group multiple @PrimaryKeyJoinColumn annotations.",
	"Types - Entities - Class - Inheritance - PolymorphicQueries": "Querying across inheritance hierarchies",
	"Types - Entities - Class - Inheritance - PolymorphicQueries - @Inheritance - JPA": "Inheritance Mapping Strategies.",
	"Types - Entities - Class - Inheritance - PolymorphicQueries - @Inheritance - SINGLE_TABLE": "The domain model class hierarchy is materialized into a single table which contains entities belonging to different class types. The single table inheritance strategy maps all subclasses to only one database table. Each subclass declares its own persistent properties. Version and id properties are assumed to be inherited from the root class. When omitting an explicit inheritance strategy (e.g. @Inheritance), JPA will choose the SINGLE_TABLE strategy by default.",
	"Types - Entities - Class - Inheritance - PolymorphicQueries - @Inheritance - JOINED": "The base class and all the subclasses have their own database tables and fetching a subclass entity requires a join with the parent table as well. Each subclass can also be mapped to its own table. This is also called table-per-subclass mapping strategy. An inherited state is Appd by joining with the table of the superclass. A discriminator column is not required for this mapping strategy. Each subclass must, however, declare a table column holding the object identifier. The primary key of this table is also a foreign key to the superclass table and described by the @PrimaryKeyJoinColumns. The table name still defaults to the non-qualified class name. Also, if @PrimaryKeyJoinColumn is not set, the primary key / foreign key columns are assumed to have the same names as the primary key columns of the primary table of the superclass.",
	"Types - Entities - Class - Inheritance - PolymorphicQueries - @Inheritance - TABLE_PER_CLASS": "Each subclass has its own table containing both the subclass and the base class properties. A third option is to map only the concrete classes of an inheritance hierarchy to tables. This is called the table-per-concrete-class strategy. Each table defines all persistent states of the class, including the inherited state. In Hibernate, it is not necessary to explicitly map such inheritance hierarchies. You can map each class as a separate entity root. However, if you wish use polymorphic associations (e.g. an association to the superclass of your hierarchy), you need to use the union subclass mapping.",
	"Types - Entities - Class - Inheritance - PolymorphicQueries - Config - @Any - Hibernate": "(One-to-Any) The @Any annotation is used to define the any-to-one association which can point to one one of several entity types. The @Any mapping defines a polymorphic association to classes from multiple tables. This type of mapping requires more than one column. The first column contains the type of the associated entity. The remaining columns contain the identifier. It is impossible to specify a foreign key constraint for this kind of association. This is not the usual way of mapping polymorphic associations and you should use this only in special cases (e.g. audit logs, user session data, etc). The @Any annotation describes the column holding the metadata information. To link the value of the metadata information and an actual entity type, the @AnyDef and @AnyDefs annotations are used. The metaType attribute allows the application to specify a custom type that maps database column values to persistent classes that have identifier properties of the type specified by idType. You must specify the mapping from values of the metaType to class names.",
	"Types - Entities - Class - Inheritance - PolymorphicQueries - Config - @ManyToAny - Hibernate": "Creates a polymorphic many-to-many association. Requires a join table with type information. Similar triple-column approach as @Any",
	"Types - Entities - Class - Inheritance - PolymorphicQueries - Config - Metadata - @AnyMetaDef - Hibernate": "The @AnyMetaDef annotation is used to provide metadata about an @Any or @ManyToAny mapping.",
	"Types - Entities - Class - Inheritance - PolymorphicQueries - Config - Metadata - @AnyMetaDefs - Hibernate": "The @AnyMetaDefs annotation is used to group multiple @AnyMetaDef annotations.",
	"Types - Entities - Access - Strategies - JPA": "As a JPA provider, Hibernate can introspect both the entity attributes (instance fields) or the accessors (instance properties). When @Id placed on a field, Hibernate will assume field-based access. When @Id placed on the identifier getter, Hibernate will use property-based access.",
	"Types - Entities - Access - Strategies - FieldBasedAccess": "When using field-based access, adding other entity-level methods is much more flexible because Hibernate won’t consider those part of the persistence state. To exclude a field from being part of the entity persistent state, the field must be marked with the @Transient annotation.",
	"Types - Entities - Access - Strategies - PropertyBasedAccess": "get/set. When using property-based access, Hibernate uses the accessors for both reading and writing the entity state. Every other method that will be added to the entity (e.g. helper methods for synchronizing both ends of a bidirectional one-to-many association) will have to be marked with the @Transient annotation.",
	"Types - Entities - Access - Strategies - Overriding": "The default access strategy mechanism can be overridden with the JPA @Access annotation. In the following example, the @Version attribute is accessed by its field and not by its getter, like the rest of entity attributes.",
	"Types - Entities - Access - Strategies - EmbeddableTypes": "Because embeddables are managed by their owning entities, the access strategy is therefore inherited from the entity too. This applies to both simple embeddable types as well as for collection of embeddables. The embeddable types can overrule the default implicit access strategy (inherited from the owning entity). In the following example, the embeddable uses property-based access, no matter what access strategy the owning entity is choosing:",
	"Types - Identifiers": "Identifiers model the primary key of an entity. They are used to uniquely identify each specific entity. Hibernate and JPA both make the following assumptions about the corresponding database column(s): unique, not-null, immutable. Every entity must define an identifier. For entity inheritance hierarchies, the identifier must be defined just on the entity that is the root of the hierarchy. ",
	"Types - Identifiers - Types": "An identifier might be simple (single value) or composite (multiple values).",
	"Types - Identifiers - Types - Unique": "",
	"Types - Identifiers - Types - Unique - Column": "@Column(unique = true) Adds a single-column unique constraint to the database schema.",
	"Types - Identifiers - Types - Unique - Columns": "@Table(uniqueConstraints = ...) Defines multi-column unique constraints at the table level.",
	"Types - Identifiers - Types - Unique - Relationships": "Use @JoinColumn(unique = true) to enforce uniqueness in relationships (e.g., one-to-one).",
	"Types - Identifiers - Types - Simple": "Simple identifiers map to a single basic attribute, and are denoted using the javax.persistence.Id annotation. According to JPA only the following types should be used as identifier attribute types: * any Java primitive type * any primitive wrapper type * java.lang.String * java.util.Date (TemporalType#DATE) * java.sql.Date * java.math.BigDecimal * java.math.BigInteger Any types used for identifier attributes beyond this list will not be portable.",
	"Types - Identifiers - Types - Simple - JPA - @Id": "Assigned identifiers (@Id) and Generated identifiers (@GeneratedValue)",
	"Types - Identifiers - Types - Simple - JPA - @GeneratedValue": "Hibernate will generate the value when the save/persist occurs.",
	"Types - Identifiers - Types - Simple - JPA - @GeneratedValue - AUTO - default": "JPA picks the best strategy (default).",
	"Types - Identifiers - Types - Simple - JPA - @GeneratedValue - IDENTITY": "Database auto-increments the ID (e.g., MySQL AUTO_INCREMENT).",
	"Types - Identifiers - Types - Simple - JPA - @GeneratedValue - SEQUENCE": "Uses a database sequence (e.g., PostgreSQL SEQUENCE).",
	"Types - Identifiers - Types - Simple - JPA - @GeneratedValue - TABLE": "Indicates that a database table should be used for obtaining primary key values.",
	"Types - Identifiers - Types - Simple - JPA - @GeneratedValue - UUID": "Generates a UUID (e.g., 550e8400-e29b-41d4-a716-446655440000)",
	"Types - Identifiers - Types - Simple - Hibernate - @GenericGenerator": "@GenericGenerator allows integration of any Hibernate org.hibernate.id.IdentifierGenerator implementation, including any of the specific ones discussed here and any custom ones. To make use of the pooled or pooled-lo optimizers, the entity mapping must use the @GenericGenerator annotation:",
	"Types - Identifiers - Types - Composite": "Composite identifiers correspond to one or more persistent attributes.",
	"Types - Identifiers - Types - Composite - JPA": "JPA spec says",
	"Types - Identifiers - Types - Composite - JPA - PrimaryKey": "(1) The composite identifier must be represented by <b> a primary key class</b>.",
	"Types - Identifiers - Types - Composite - JPA - Definition": "(2) The primary key class may be defined using the @EmbeddedId or @IdClass.",
	"Types - Identifiers - Types - Composite - JPA - Definition - @EmbeddedId": "Modeling a composite identifier using an EmbeddedId simply means defining an embeddable to be a composition for the one or more attributes making up the identifier, and then exposing an attribute of that embeddable type on the entity.",
	"Types - Identifiers - Types - Composite - JPA - Definition - @IdClass": "Modeling a composite identifier using an IdClass differs from using an EmbeddedId in that the entity defines each individual attribute making up the composition. The IdClass simply acts as a shadow. @Entity@IdClass(EmployeeId.class) public class Employee {@Id private String branchName,@Id private int idEmployee, ... }",
	"Types - Identifiers - Types - Composite - JPA - Definition - @MapsId": "JPA 2.0 added support for derived identifiers which allow an entity to borrow the identifier from a many-to-one or one-to-one association.",
	"Types - Identifiers - Types - Composite - JPA - Constructor": "(3) The primary key class must be public and must have a public no-arg constructor.",
	"Types - Identifiers - Types - Composite - JPA - Serializable": "(4) The primary key class must be serializable.",
	"Types - Identifiers - Types - Composite - JPA - Hascode": "(5) The primary key class must define equals and hashCode methods",
	"Types - Identifiers - Types - Composite - Hibernate": "Hibernate allows defining a composite identifier out of entity associations.",
	"Types - Identifiers - Types - Composite - Hibernate - @RowId": "If you annotate a given entity with the @RowId annotation and the underlying database supports fetching a record by ROWID (e.g. Oracle), then Hibernate can use the ROWID pseudo-column for CRUD operations.",
	"Types - Identifiers - Types - Composite - Hibernate - @ValueGenerationType": "The @ValueGenerationType annotation is used to specify that the current annotation type should be used as a generator annotation type. Lets you implement complex value generation that isn't covered by JPA.",
	"Types - Identifiers - Types - Composite - Hibernate - @ValueGenerationType - AnnotationValueGeneration": "You implement the AnnotationValueGeneration interface.",
	"Types - Identifiers - NaturalIds - Hibernate": "Natural ids represent domain model unique identifiers that have a meaning in the real world too. Even if a natural id does not make a good primary key (surrogate keys being usually preferred), it’s still useful to tell Hibernate about it.",
	"Types - Identifiers - NaturalIds - Hibernate - @NaturalId": "The @NaturalId annotation is used to specify that the currently annotated attribute is part of the natural id of the entity.",
	"Types - Identifiers - NaturalIds - Hibernate - @NaturalId - Usage": "When you need optimized queries for business keys.",
	"Types - Identifiers - NaturalIds - Hibernate - @NaturalId - Mutable": "A natural id may be mutable or immutable. By default the @NaturalId annotation marks an immutable natural id attribute. An immutable natural id is expected to never change its value. If the value(s) of the natural id attribute(s) change, @NaturalId(mutable=true) should be used instead.",
	"Types - Identifiers - NaturalIds - Hibernate - @NaturalIdCache": "The @NaturalIdCache annotation is used to specify that the natural id values associated with the annotated entity should be stored in the second-level cache.",
	"Types - Identifiers - NaturalIds - Hibernate - NaturalIdLoadAccess": "Hibernate provides an API for loading entities by their associate natural id. This is represented by the org.hibernate.NaturalIdLoadAccess contract obtained via Session#byNaturalId.",
	"Types - Identifiers - Generate - JPA - @TableGenerator": "The @TableGenerator annotation is used to specify the database table used by the identity generator of the currently annotated entity.",
	"Types - Identifiers - Generate - JPA - @SequenceGenerator": "The @SequenceGenerator annotation is used to specify the database sequence used by the identifier generator of the currently annotated entity.",
	"Types - Associations": ".",
	"Types - Associations ": "Associations describe how two or more entities form a relationship based on a database joining semantics.",
	"Types - Associations - JPA - Config - @JoinColumn": "The @JoinColumn annotation is used to specify the FOREIGN KEY column used when joining an entity association or an embeddable collection.",
	"Types - Associations - JPA - KeyPoints - ClassToColumn": "First part of the relationship is the containing class (Table), second part is the column of the other table.",
	"Types - Associations - JPA - KeyPoints - Changes": "Only changes made to the owning side will be persisted to the database. Changes to the inverse side will be ignored unless you synchronize both sides.",
	"Types - Associations - JPA - Unidirectional": "Only one entity has a reference to the other.",
	"Types - Associations - JPA - Unidirectional - KeyPoints - Direction": "creates a foreign key in the Order table",
	"Types - Associations - JPA - Unidirectional - KeyPoints - Direction - Owner": "the only one",
	"Types - Associations - JPA - Unidirectional - KeyPoints - Direction - Uses - OneToMany": "When you only need to navigate from parent to children",
	"Types - Associations - JPA - Unidirectional - KeyPoints - Direction - Uses - ManyToOne": "When you only need to navigate from child to parent",
	"Types - Associations - JPA - Unidirectional - KeyPoints - Direction - Uses - complexity": "When you want to avoid the complexity of bidirectional relationships",
	"Types - Associations - JPA - Unidirectional - KeyPoints - Direction - Uses - know": "When the child entity doesn't need to know about its parent",
	"Types - Associations - JPA - Unidirectional - KeyPoints - Direction - @JoinColumn": "@JoinColumn indicates that this entity is the owner of the relationship.",
	"Types - Associations - JPA - Unidirectional - Cases - @OneToOne": "One entity is associated with exactly one instance of another entity.",
	"Types - Associations - JPA - Unidirectional - Cases - @OneToOne - Config": ".",
	"Types - Associations - JPA - Unidirectional - Cases - @OneToOne - Example": "Customer -> CustomerDetails",
	"Types - Associations - JPA - Unidirectional - Cases - @OneToOne - From": "                    Class Customer        - @OneToOne @JoinColumn(name='customer_detail_id')   CustomerDetail customerDetail",
	"Types - Associations - JPA - Unidirectional - Cases - @OneToOne - To": "                      Class CustomerDetail  -",
	"Types - Associations - JPA - Unidirectional - Cases - @OneToMany": "Only the 'one' side has a reference to the 'many' side",
	"Types - Associations - JPA - Unidirectional - Cases - @OneToMany - Example": "Customer -=> Order",
	"Types - Associations - JPA - Unidirectional - Cases - @OneToMany - Syntax - From": "          Class Customer        - @OneToMany @JoinColumn(name = 'customer_id')       List<Order> orders",
	"Types - Associations - JPA - Unidirectional - Cases - @OneToMany - Syntax - To": "            Class Order           -",
	"Types - Associations - JPA - Unidirectional - Cases - @ManyToOne": "multiple instances are associated with a single instance",
	"Types - Associations - JPA - Unidirectional - Cases - @ManyToOne - Example": "Customer <-= Order",
	"Types - Associations - JPA - Unidirectional - Cases - @ManyToOne - Syntax - To": "            Class Customer        -",
	"Types - Associations - JPA - Unidirectional - Cases - @ManyToOne - Syntax - From": "          Class Order           - @ManyToOne @JoinColumn(name = 'customer_id')       Customer customer",
	"Types - Associations - JPA - Unidirectional - Cases - @ManyToOne - BestPractices - lazy": "Use lazy loading unless you specifically need eager loading",
	"Types - Associations - JPA - Unidirectional - Cases - @ManyToOne - BestPractices - indexing": "Consider indexing the foreign key column for better performance",
	"Types - Associations - JPA - Unidirectional - Cases - @ManyToMany": "Has an owning and a mappedBy side - Only one entity maintains the relationship.",
	"Types - Associations - JPA - Unidirectional - Cases - @ManyToMany - Example": "Order => Items",
	"Types - Associations - JPA - Unidirectional - Cases - @ManyToMany - Syntax - From": "         Class Order           - @ManyToMany @JoinTable(name = 'order_items', joinColumns = @JoinColumn(name = 'order_id'), inverseJoinColumns = @JoinColumn(name = 'item_id'))            Set<Item> items",
	"Types - Associations - JPA - Unidirectional - Cases - @ManyToMany - Syntax - To": "           Class Items           -",
	"Types - Associations - JPA - Bidirectional": "Both entities have references to each other.",
	"Types - Associations - JPA - Bidirectional - KeyPoints - Owner": "The entity that contains the foreign key in the database (the 'many') is typically the owner.",
	"Types - Associations - JPA - Bidirectional - KeyPoints - @JoinColumn": "@JoinColumn indicates that this entity is the owner of the relationship.",
	"Types - Associations - JPA - Bidirectional - KeyPoints - mappedBy": "mappedBy indicates that the entity in this side is the inverse of the relationship",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToOne": "One entity is associated with exactly one instance of another entity.",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToOne - Example": "Customer <--> CustomerDetails",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToOne - Syntax - From": "            Class Customer        - @OneToOne(mappedBy = 'customer'                    CustomerDetail customerDetail",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToOne - Syntax - To": "              Class CustomerDetail  - @OneToOne @JoinColumn(name = 'id')                 Customer customer",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToOne - BestPractices - lazy": "Use lazy loading unless you specifically need eager loading",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToOne - BestPractices - key": "Choose the appropriate strategy (foreign key vs shared primary key) based on your requirements",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToManyManyToOne": "",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToManyManyToOne - Example": "Customer <-=-> Order",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToManyManyToOne - Syntax - From": "  Class Customer        - @OneToMany(mappedBy = 'customer' ... )             List<Order> orders",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToManyManyToOne - Syntax - To": "    Class Order           - @ManyToOne @JoinColumn(name = 'customer_id')       Customer customer", 
	"Types - Associations - JPA - Bidirectional - Cases - @OneToManyManyToOne - BestPractices - helper": "Use helper methods (like addOrder()) to maintain relationship consistency",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToManyManyToOne - BestPractices - Initialize": "Initialize collections to avoid NullPointerException",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToManyManyToOne - BestPractices - Lazy": "Lazy loading is generally preferred for performance",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToManyManyToOne - BestPractices - indexing": "Consider indexing the foreign key column for better performance",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToManyManyToOne - BestPractices - pagination": "For large collections, consider: Pagination (setFirstResult(), setMaxResults())",
	"Types - Associations - JPA - Bidirectional - Cases - @OneToManyManyToOne - BestPractices - BatchFetching": "For large collections, consider: Batch fetching (@BatchSize)",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany": "",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Example": "Order <==> Items",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Syntax - From": "          Class Order            - @ManyToMany @JoinTable(name = 'order_items', joinColumns = @JoinColumn(name = 'order_id'), inverseJoinColumns = @JoinColumn(name = 'item_id'))            Set<Item> items",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Syntax - To": "            Class Item             - @ManyToMany(mappedBy = 'items')                   Set<Order> orders",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - BestPractices - @JoinedTable": "In Many-To-Many association, an extra table is used (known as Joined table) whose primary key is the combination of primary key of both the associated tables.",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - BestPractices - Sets": "Use Sets instead of Lists to avoid duplicate entries",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - BestPractices - equals": "Implement proper equals() and hashCode() methods for both entities",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - BestPractices - Initialize": "Initialize collections to avoid NullPointerException",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - BestPractices - helper": "Use helper methods to maintain relationship consistency",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - BestPractices - lazy": "Consider lazy loading (default for @ManyToMany) for performance",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - BestPractices - pagination": "For large collections, consider: Pagination",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - BestPractices - separated": "For large collections, consider: Using a separate entity for the join table", 
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Limitations - Attributes": "No Additional Attributes on Join Table. The join table can only contain the two foreign keys. You cannot store additional metadata about the relationship (like creation date, status, etc.)",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Limitations - JoinTable": "Limited Control Over Join Table. Hibernate automatically manages the join table. Difficult to add custom constraints or indexes. Hard to implement soft-Deletes on relationships",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Limitations - Performance": "Performance Issues. Can lead to inefficient queries with large datasets. Hibernate may load entire collections when you only need a subset. Pagination is more complex to implement",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Limitations - Cascade": "Cascade Challenges. Cascade operations can be tricky to configure correctly. May accidentally Delete more entities than intended",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Limitations - Complexity": "Bidirectional Management Complexity. Requires careful synchronization of both sides of the relationship. Easy to get into inconsistent state if not managed properly",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Limitations - Querying": "Limited Querying Capabilities. Difficult to query based on relationship attributes (since there aren't any). Complex to filter relationships based on conditions",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Limitations - Evolution": "Schema Evolution Difficulties. Hard to modify the relationship later if requirements change. Converting to a more complex relationship requires migration",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Limitations - Lifecycle": "Limited ability to intercept relationship changes. Hard to add business logic during association/disassociation",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Alternative - 2xManyToOne": "You can replace a @ManyToMany relationship between two entities with a separate join table that has two @ManyToOne relationships. This is actually a recommended approach when you need to: Add additional attributes to the relationship, Have more control over the join table, Avoid the limitations of @ManyToMany",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Alternative - 2xManyToOne - AdditionalAttributes": "You can store metadata about the relationship (like enrollment date, grade, status, etc.)",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Alternative - 2xManyToOne - BetterControl": "More explicit control over the relationship",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Alternative - 2xManyToOne - EasierQueries": "Simpler to write complex queries involving relationship attributes",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Alternative - 2xManyToOne - Performance": "Often better performance for certain operations",
	"Types - Associations - JPA - Bidirectional - Cases - @ManyToMany - Alternative - 2xManyToOne - Flexibility": "Easier to evolve the model later",
	"Types - Associations - Hibernate - @JoinColumn": "While @JoinColumn is JPA-standard, Hibernate adds extra attributes ",
	"Types - Associations - Hibernate - @JoinFormula - Hibernate": "The @JoinFormula annotation is used to customize the join between a child Foreign Key and a parent row Primary Key. @JoinFormula( \"REGEXP_REPLACE(phoneNumber, '\\+(\\d+)-.*', '\\1')::int\" )",
	"Types - Associations - Hibernate - @JoinColumnOrFormula - Hibernate": "The @JoinColumnOrFormula annotation is used to specify that the entity association is resolved either through a FOREIGN KEY join (e.g. @JoinColumn) or using the result of a given SQL formula (e.g. @JoinFormula).",
	"Types - Associations - Hibernate - @NotFound": "The @NotFound annotation is used to specify the NotFoundAction strategy for when an element is not found in a given association.",
	"Types - Associations - Hibernate - @NotFound - NotFoundAction": "The NotFoundAction defines with two possibilities: EXCEPTION, IGNORE",
	"Types - Associations - Hibernate - @NotFound - NotFoundAction - EXCEPTION": "An exception is thrown when an element is not found (default and recommended).",
	"Types - Associations - Hibernate - @NotFound - NotFoundAction - IGNORE": "Ignore the element when not found in the database.",
	"Types - Associations - Hibernate - @LazyToOne": "The @LazyToOne annotation is used to specify the laziness options, represented by LazyToOneOption, available for a @OneToOne or @ManyToOne association.",
	"Types - Associations - Hibernate - @LazyToOne - LazyToOneOption": "LazyToOneOption defines the following alternatives: FALSE, NO_PROXY, PROXY",
	"Types - Associations - Hibernate - @LazyToOne - LazyToOneOption - FALSE": "Eagerly load the association. This one is not needed since the JPA FetchType.EAGER offers the same behavior.",
	"Types - Associations - Hibernate - @LazyToOne - LazyToOneOption - NO_PROXY": "This option will fetch the association lazily while returning real entity object.",
	"Types - Associations - Hibernate - @LazyToOne - LazyToOneOption - PROXY": "This option will fetch the association lazily while returning a proxy instead.",
	"Types - Associations - Hibernate - @LazyGroup": "This annotation allows defining different groups of attributes to be initialized together when access one attribute in the group.",
	"Types - Associations - Hibernate - @LazyGroup - default": "By default, all non-collection attributes are loaded in one group named 'DEFAULT'.",
	"Types - Associations - Hibernate - @LazyGroup - BytecodeEnhancement": "To load entity attributes lazily, bytecode enhancement is needed.",
	"Types - EntityCollections": "If value type collections can only form a one-to-many association between an owner entity and multiple basic or embeddable types, entity collections can represent both @OneToMany and @ManyToMany associations.",
	"Types - EntityCollections - Types": "By underlying collection typebags: indexed lists, sets, sorted sets, maps, sorted maps, arrays",
	"Types - EntityCollections - Types - JPA - OrderedList": "Although they use the List interface on the Java side, bags don’t retain element order. To preserve the collection element order, there are two possibilities: @OrderBy (the collection is ordered upon retrieval using a child entity property), @OrderColumn (the collection uses a dedicated order column in the collection link table)",
	"Types - EntityCollections - Types - JPA - OrderedList - Unidirectional ": "When using the @OrderBy annotation",
	"Types - EntityCollections - Types - JPA - OrderedList - Bidirectional": "The mapping is similar with the Bidirectional bags example, just that the parent side is going to be annotated with either @OrderBy or @OrderColumn.",
	"Types - EntityCollections - Types - JPA - Sets": "Sets are collections that don’t allow duplicate entries and Hibernate supports both the unordered Set and the natural-ordering SortedSet.",
	"Types - EntityCollections - Types - JPA - Sets - Unidirectional": "The unidirectional set uses a link table to hold the parent-child associations",
	"Types - EntityCollections - Types - JPA - Sets - Bidirectional": "Just like bidirectional bags, the bidirectional set doesn’t use a link table, and the child table has a foreign key referencing the parent table primary key. The lifecycle is just like with bidirectional bags except for the duplicates which are filtered out.",
	"Types - EntityCollections - Types - JPA - Sets - Sorted": "For sorted sets, the entity mapping must use the SortedSet interface instead. According to the SortedSet contract, all elements must implement the Comparable interface and therefore provide the sorting logic.",
	"Types - EntityCollections - Types - JPA - Sets - Sorted - UnidirectionalSorted": "A SortedSet that relies on the natural sorting order given by the child element Comparable implementation logic must be annotated with the @SortNatural Hibernate annotation. The lifecycle and the database mapping are identical to the Unidirectional bags, so they are intentionally omitted. To provide a custom sorting logic, Hibernate also provides a @SortComparator annotation",
	"Types - EntityCollections - Types - JPA - Sets - Sorted - BidirectionalSorted": "The @SortNatural and @SortComparator work the same for bidirectional sorted sets too",
	"Types - EntityCollections - Types - JPA - Sets - Sorted - BidirectionalSorted - @SortNatural": "",
	"Types - EntityCollections - Types - JPA - Sets - Sorted - BidirectionalSorted - @SortComparator": "",
	"Types - EntityCollections - Types - JPA - Maps": "A java.util.Map is a ternary association because it requires a parent entity, a map key and a value. An entity can either be a map key or a map value, depending on the mapping:",
	"Types - EntityCollections - Types - JPA - Maps - @MapKey": "MapKey(the map key is either the primary key or another property of the entity stored as a map entry value), ",
	"Types - EntityCollections - Types - JPA - Maps - @MapKeyColumn": "MapKeyColumn (for value type maps, the map key is a column in the link table that defines the grouping logic)",
	"Types - EntityCollections - Types - JPA - Maps - @MapKeyEnumerated": "MapKeyEnumerated (the map key is an Enum of the target child entity)",
	"Types - EntityCollections - Types - JPA - Maps - @MapKeyTemporal": "MapKeyTemporal (the map key is a Date or a Calendar of the target child entity)",
	"Types - EntityCollections - Types - JPA - Maps - @MapKeyJoinColumn": "MapKeyJoinColumn (the map key is an entity mapped as an association in the child entity that’s stored as a map entry key)",
	"Types - EntityCollections - Types - JPA - Maps - Unidirectional": "A unidirectional map exposes a parent-child association from the parent-side only.",
	"Types - EntityCollections - Types - JPA - Maps - Bidirectional": "Like most bidirectional associations, this relationship is owned by the child-side while the parent is the inverse side and can propagate its own state transitions to the child entities.",
	"Types - EntityCollections - Types - Hibernate - Bag": "Bags are unordered lists and we can have unidirectional bags or bidirectional ones.",
	"Types - EntityCollections - Types - Hibernate - Bag - Unidirectional": "The unidirectional bag is mapped using a single @OneToMany annotation on the parent side of the association. Behind the scenes, Hibernate requires an association table to manage the parent-child relationship",
	"Types - EntityCollections - Types - Hibernate - Bag - Bidirectional": "The bidirectional bag is the most common type of entity collection. The @ManyToOne side is the owning side of the bidirectional bag association, while the @OneToMany is the inverse side, being marked with the mappedBy attribute.",
	"Types - ValueTypes": "A value type is a piece of data that does not define its own lifecycle. It is, in effect, owned by an entity, which defines its lifecycle.",
	"Types - ValueTypes - PersistentAttributes": "All the state of an entity is made up entirely of value types. These state fields or JavaBean properties are termed persistent attributes.",
	"Types - ValueTypes - Config - JPA - @Convert": "Customize how entity attribute values are mapped to database columns. It allows you to define custom conversion logic between your Java object model and database representation. e.g. @Convert(converter = BooleanToYNConverter.class)",
	"Types - ValueTypes - Config - Hibernate - @TypeDef": "The @TypeDef annotation is used to specify a @Type definition which can later be reused for multiple basic attribute mappings. @TypeDef(name = 'dateNoMs', typeClass = com.gorillalogic.type.DateNoMsType.class })",
	"Types - ValueTypes - Config - Hibernate - @TypeDefs": "The @TypeDefs annotation is used to group multiple @TypeDef annotations: @TypeDefs( { @TypeDef(name = 'dateNoMs', typeClass = com.gorillalogic.type.DateNoMsType.class  }) package com.gorillalogic.type,",
	"Types - ValueTypes - Config - Hibernate - @Type": "The @Type annotation is used to specify the Hibernate @Type used by the currently annotated basic attribute. @Type(type='com.gorillalogic.type.DateNoMsType')    @Column(name = 'PAYMENT_DATE')    private DateNoMs m_paymentDate,",
	"Types - ValueTypes - Types": "Value types are further classified into three sub-categories: Basic types, Embeddable types, Collection types" ,
	"Types - ValueTypes - Types - BasicTypes": "Basic value types usually map a single database column, to a single, non-aggregated Java type. Hibernate provides a number of built-in basic types, which follow the natural mappings recommended by the JDBC specifications. Internally Hibernate uses a registry of basic types when it needs to resolve a specific org.hibernate.type.Type. Strictly speaking, a basic type is denoted by the @Basic annotation. @Basic annotation can be ignored, as it is assumed by default.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Basic": "Attributes: (1) optional - boolean (defaults to true) Defines whether this attribute allows nulls. JPA defines this as a hint, which essentially means that it effect is specifically required. As long as the type is not primitive, Hibernate takes this to mean that the underlying column should be NULLABLE. (2) fetch - FetchType (defaults to EAGER) Defines whether this attribute should be fetched eagerly or lazily. JPA says that EAGER is a requirement to the provider (Hibernate) that the value should be fetched when the owner is fetched, while LAZY is merely a hint that the value be fetched when the attribute is accessed. Hibernate ignores this setting for basic types unless you are using bytecode enhancement.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Column": "For basic type attributes, the implicit naming rule is that the column name is the same as the attribute name. If that implicit naming rule does not meet your requirements, you can explicitly tell Hibernate (and other providers) the column name to use.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Column - table": "the name of the database table that hosts the JPA mapped column.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Column - columnDefinition": "the name of an SQL fragment that contains DDL for the column.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Column - updatable": "whether the column can be used with SQL UPDATE statements.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Column - insertable": "whether the column should allow SQL INSERT statements.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Column - unique": "whether the column represents a unique database key.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Column - precision": "decimal precision for the column.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Column - nullable": "whether the column can contain null values.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Column - length": "how many characters the database column must support.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Columns": "The @Columns annotation is used to group multiple JPA @Column annotations.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Enumerated": "Hibernate supports the mapping of Java enums as basic value types in a number of different ways. @Enumerated The original JPA-compliant way to map enums was via the @Enumerated and @MapKeyEnumerated for map keys annotations which works on the principle that the enum values are stored according to one of 2 strategies indicated by javax.persistence.EnumType: ORDINAL (stored according to the enum value’s ordinal position within the enum class, as indicated by java.lang.Enum#ordinal), STRING (stored according to the enum value’s name, as indicated by java.lang.Enum#name)",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Lob": "Mapping LOBs (database Large Objects) come in 2 forms, those using the JDBC locator types and those materializing the LOB data. Materialized deals with the entire LOB contents in memory, whereas LOB locators (in theory) allow streaming parts of the LOB contents into memory as needed.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Lob - locators": "JDBC LOB locators exist to allow efficient access to the LOB data. They allow the JDBC driver to stream parts of the LOB data as needed, potentially freeing up memory space. However they can be unnatural to deal with and have certain limitations. For example, a LOB locator is only portably valid during the duration of the transaction in which it was obtained.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Lob - locators - Types": "The JDBC LOB locator types include: java.sql.Blob, java.sql.Clob, java.sql.NClob.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Lob - materialized": "The idea of materialized LOBs is to trade-off the potential efficiency (not all drivers handle LOB data efficiently) for a more natural programming paradigm using familiar Java types such as String or byte[], etc for these LOBs.",
	"Types - ValueTypes - Types - BasicTypes - JPA - @Lob - materialized - Types": "Mapping materialized forms of these LOB values would use more familiar Java types such as String, char[], byte[], etc. The trade off for more familiar is usually performance.",
	"Types - ValueTypes - Types - BasicTypes - Hibernate - @ColumnTransformer": "The @ColumnTransformer annotation is used to customize how a given column value is read from or write into the database. @ColumnTransformer(read = 'decrypt(credit_card_num)', write = 'encrypt(?)') ",
	"Types - ValueTypes - Types - BasicTypes - Hibernate - @ColumnTransformers": "The @ColumnTransformers annotation iis used to group multiple @ColumnTransformer annotations.",
	"Types - ValueTypes - Types - BasicTypes - Hibernate - @Filters": "The @Filters annotation is used to group multiple @Filter annotations.",
	"Types - ValueTypes - Types - BasicTypes - Hibernate - @Filter": "The @Filter annotation is another way to filter out entities or collections using custom SQL criteria. Unlike the @Where annotation, @Filter allows you to parameterize the filter clause at runtime. Example: @FilterDef( name='firstAccounts', parameters=@ParamDef( name='maxOrderId', type='int' ) ) @Filter( name='firstAccounts', condition='order_id <= :maxOrderId' ) )",
	"Types - ValueTypes - Types - BasicTypes - Hibernate - @FilterDefs": "The @FilterDefs annotation is used to group multiple @FilterDef annotations.",
	"Types - ValueTypes - Types - BasicTypes - Hibernate - @FilterDef": "The @FilterDef annotation is used to specify a @Filter definition (name, default condition and parameter types, if any).. Example: @FilterDef( name='firstAccounts', parameters=@ParamDef( name='maxOrderId', type='int' ) ) @Filter( name='firstAccounts', condition='order_id < = :maxOrderId' ) )",
	"Types - ValueTypes - Types - BasicTypes - Hibernate - @ParamDef": "The @ParamDef annotation is used in conjunction with @FilterDef so that the Hibernate Filter can be customized with runtime-provided parameter values.",
	"Types - ValueTypes - Types - BasicTypes - Hibernate - @FilterJoinTables": "The @FilterJoinTables annotation is used to group multiple @FilterJoinTable annotations.",
	"Types - ValueTypes - Types - BasicTypes - Hibernate - @FilterJoinTable": "When using the @Filter annotation with collections, the filtering is done against the child entries (entities or embeddables). However, if you have a link table between the parent entity and the child table, then you need to use the @FilterJoinTable to filter child entries according to some column contained in the join table. The @FilterJoinTable annotation can be, therefore, applied to a unidirectional @OneToMany collection",
	"Types - ValueTypes - Types - BasicTypes - Hibernate - @Filter + @SqlFragmentAlias": "When using the @Filter annotation and working with entities that are mapped onto multiple database tables, you will need to use the @SqlFragmentAlias annotation if the @Filter defines a condition that uses predicates across multiple tables. @Filter(name='activeAccount', condition='{a}.active = :active and {ad}.Deleted = false', aliases = { @SqlFragmentAlias( alias = 'a', table= 'account'), @SqlFragmentAlias( alias = 'ad', table= 'account_details'), } )",
	"Types - ValueTypes - Types - BasicTypes - Hibernate - @Formula": "Sometimes, you want the Database to do some computation for you rather than in the JVM, you might also create some kind of virtual column. You can use a SQL fragment (aka formula) instead of mapping a property into a column. This kind of property is read only (its value is calculated by your formula fragment) @Formula(value = 'credit * rate')",
	"Types - ValueTypes - Types - @EmbeddableTypes": "Historically Hibernate called these components. JPA calls them embeddables. Either way the concept is the same: a composition of values. An embeddable type is another form of value type, and its lifecycle is bound to a parent entity type, therefore inheriting the attribute access from its parent (for details on attribute access, see Access strategies). Embeddable types can be made up of basic values as well as associations, with the caveat that, when used as collection elements, they cannot define collections themselves.",
	"Types - ValueTypes - Types - @EmbeddableTypes - JPA - @Embeddable": "The @Embeddable annotation is used to specify embeddable types. Like basic types, embeddable types do not have any identity, being managed by their owning entity.",
	"Types - ValueTypes - Types - @EmbeddableTypes - JPA - @Embedded": "The @Embedded annotation is used to specify that a given entity attribute represents an embeddable type.",
	"Types - ValueTypes - Types - @EmbeddableTypes - JPA - @EmbeddedId": "The @EmbeddedId annotation is used to specify the entity identifier is an embeddable type.",
	"Types - ValueTypes - Types - @EmbeddableTypes - JPA - Compound": "Most often, embeddable types are used to group multiple basic type mappings and reuse them across several entities.",
	"Types - ValueTypes - Types - @EmbeddableTypes - JPA - Multiple": "Although from an object-oriented perspective, it’s much more convenient to work with embeddable types, this example doesn’t work as-is. When the same embeddable type is included multiple times in the same parent entity type, the JPA specification demands setting the associated column names explicitly. This requirement is due to how object properties are mapped to database columns. By default, JPA expects a database column having the same name with its associated object property. When including multiple embeddables, the implicit name-based mapping rule doesn’t work anymore because multiple object properties could end-up being mapped to the same database column.",
	"Types - ValueTypes - Types - @EmbeddableTypes - JPA - @AttributeOverride": "JPA defines the @AttributeOverride annotation to handle this scenario. This way, the mapping conflict is resolved by setting up explicit name-based property-column type mappings. If an Embeddabe type is used multiple times in some entity, you need to use the @AttributeOverride and @AssociationOverride annotations to override the default column names definied by the Embeddable.",
	"Types - ValueTypes - Types - @EmbeddableTypes - Hibernate - @Parent": "The Hibernate-specific @Parent annotation allows you to reference the owner entity from within an embeddable.",
	"Types - ValueTypes - Types - ValueTypeCollections": "The owner of the collection is always an entity, even if the collection is defined by an embeddable type. Collections form one/many-to-many associations between types so there can be: value type collections, embeddable type collections, entity collections",
	"Types - ValueTypes - Types - ValueTypeCollections - Config -  JPA - @OrderBy": "The @OrderBy annotation is used to specify the entity attributes used for sorting when fetching the currently annotated collection.",
	"Types - ValueTypes - Types - ValueTypeCollections - Config -  JPA - @OrderColumn": "The @OrderColumn annotation is used to specify that the current annotation collection order should be materialized in the database.",
	"Types - ValueTypes - Types - ValueTypeCollections - Config -  Hibernate - @CollectionId": "The @CollectionId annotation is used to specify an identifier column for an idbag collection.",
	"Types - ValueTypes - Types - ValueTypeCollections - Config -  Hibernate - @CollectionType": "The @CollectionType annotation is used to specify a custom collection type. The collection can also name a @Type, which defines the Hibernate Type of the collection elements.",
	"Types - ValueTypes - Types - ValueTypeCollections - Config -  Hibernate - @LazyCollection": "The @LazyCollection annotation is used to specify the lazy fetching behavior of a given collection. The possible values are given by the LazyCollectionOption enumeration: TRUE Load it when the state is requested. FALS Eagerly load it. EXTRA Prefer extra queries over full collection loading. The TRUE and FALSE values are deprecated since you should be using the JPA FetchType attribute of the @ElementCollection, @OneToMany, or @ManyToMany collection. The EXTRA value has no equivalent in the JPA specification, and it’s used to avoid loading the entire collection even when the collection is accessed for the first time. Each element is fetched individually using a secondary query.",
	"Types - ValueTypes - Types - ValueTypeCollections - Types": "Collections of value type include basic and embeddable types. Collections cannot be nested, and, when used in collections, embeddable types are not allowed to define other collections.",
	"Types - ValueTypes - Types - ValueTypeCollections - Types - ValueTypes": ".",
	"Types - ValueTypes - Types - ValueTypeCollections - Types - ValueTypes - Config - JPA - @ElementCollection": "Defines a collection of instances of a basic type or embeddable class (i.e. not entities). Must be specified if the collection is to be mapped by means of a collection table.",
	"Types - ValueTypes - Types - ValueTypeCollections - Types - ValueTypes - Config - Hibernate - @CollectionOfElements": "Equivalent to JPA @ElementCollection",
	"Types - ValueTypes - Types - ValueTypeCollections - Types - ValueTypes - BasicTypes": ".",
	"Types - ValueTypes - Types - ValueTypeCollections - Types - ValueTypes - EmbeddableTypes": ".",
	"Types - ValueTypes - Types - ValueTypeCollections - CustomCollections": "If you wish to use other collection types than List, Set or Map, like Queue for instance, you have to use a custom collection type. The custom collection type can still be customized as long as the base type is one of the aformentioned persistent types.",
	"Types - ValueTypes - Types - ValueTypeCollections - CustomCollections - JPA - AttributeConverter": "AttributeConverter (JPA 2.1+) – For simple custom collections (e.g., converting a List to a JSON string in the DB).",
	"Types - ValueTypes - Types - ValueTypeCollections - CustomCollections - Hibernate": "Hibernate only allows the following types: java.util.List, java.util.Set, java.util.Map, java.util.SortedSet, java.util.SortedMap.",
	"Types - ValueTypes - Types - ValueTypeCollections - CustomCollections - Hibernate - UserCollectionType": "Fully custom collection types.",
	"Types - ValueTypes - Types - ValueTypeCollections - CustomCollections - Hibernate - Arrays": "Hibernate does support the mapping of arrays in the Java domain model - conceptually the same as mapping a List.",
	"Types - ValueTypes - Types - ValueTypeCollections - CustomCollections - Hibernate - Arrays - binary": "By default, Hibernate will choose a BINARY type, as supported by the current Dialect",
	"Types - ValueTypes - Types - ValueTypeCollections - CustomCollections - Hibernate - Arrays - noRecommended": "It is important to realize that it is impossible for Hibernate to offer lazy-loading for arrays of entities and, for this reason, it is strongly recommended to map a collection of entities using a List rather than an array.",

	"App": "SECTION",
	"App - Fetching ": "Fetching, essentially, is the process of grabbing data from the database and making it available to the application.",
	"App - Fetching - hibernate.jdbc.fetch_size": "Used to specify number of rows to be fetched in a select query.",
	"App - Fetching - Strategies - Static": "Static definition of fetching strategies is done in the mappings. The statically-defined fetch strategies is used in the absence of any dynamically defined strategies.",
	"App - Fetching - Strategies - Static - @Fetch": "FetchType",
	"App - Fetching - Strategies - Static - @Fetch - JPA - FetchType": "FetchType, on the other hand, defines whether will load data eagerly or lazily.",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY": "When you load an entity with lazy associations, Hibernate doesn't load the associated entities immediately. Instead, it creates dynamic proxy objects that stand in for the real entities",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - SubClass": "Proxies look like real entities but contain no actual data initially. These proxies are subclasses of your entity classes generated at runtime",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - Initialization": "When you access any method of the proxy (except the identifier), Hibernate triggers a database query to load the real data. This is called 'initialization' of the proxy",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - Mechanisms": "",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - Mechanisms - BytecodeEnhancement": "Hibernate uses bytecode instrumentation (via libraries like Javassist or Byte Buddy) to: Generate proxy classes at runtime Intercept method calls to trigger lazy loading Maintain the illusion of a fully-loaded object",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - Mechanisms - SessionBoundProxies": "Proxies are only valid while the Hibernate Session is open. Accessing a proxy after session closure throws LazyInitializationException",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - Patterns": "",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - Patterns - RuntimeProxies": "Runtime proxies (default): Dynamic subclass generation",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - Patterns - BytecodeEnhancedProxies": "Bytecode-enhanced proxies: More efficient but requires build-time weaving",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - @Proxy": "Define a custom entity proxy. By default, when it needs to use a proxy instead of the actual Pojo, Hibernate is going to use a Bytecode manipulation library like Javassist or Byte Buddy. However, if the entity class is final, Javassist will not create a proxy and you will get a Pojo even when you only need a proxy reference. The @Proxy annotation is used to specify a custom proxy implementation for the current annotated entity. @Proxy(proxyClass = Identifiable.class)",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - @Proxy - Custom": "The @Proxy annotation is used to specify a custom proxy implementation for the current annotated entity. @Proxy(proxyClass = Identifiable.class)",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - @Proxy - Bytecode": "Hibernate is going to use a Bytecode manipulation library like Javassist or Byte Buddy.",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - Proxy - @Proxy - final": "If the entity class is final, Javassist will not create a proxy and you will get a Pojo even when you only need a proxy reference.",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - NoProxy": "No-proxy Lazy Loading: @LazyToOne(LazyToOneOption.NO_PROXY) private Customer customer;",
	"App - Fetching - Strategies - Static - @Fetch - JPA - LAZY - FieldLevel": "Allows lazy loading of basic fields (not just associations)",
	"App - Fetching - Strategies - Static - @Fetch - JPA - EAGER - default": "In the eager loading strategy, if we load the User data, it will also load up all orders associated with it and will store it in memory.",
	"App - Fetching - Strategies - Static - @Fetch - Hibernate - FetchMode": "FetchMode defines how Hibernate will fetch the dat",
	"App - Fetching - Strategies - Static - @Fetch - Hibernate - FetchMode.SELECT": "Performs a separate SQL select to load the data. This is the strategy generally termed N+1.",
	"App - Fetching - Strategies - Static - @Fetch - Hibernate - FetchMode.SELECT - @BatchSize - Hibernate": "Hibernate will try to load the orders collection in batches defined by the size parameter. @BatchSize(size=10)",
	"App - Fetching - Strategies - Static - @Fetch - Hibernate - FetchMode.JOIN": "FetchMode.JOIN loads relations eagerly through the use of an SQL outer join.",
	"App - Fetching - Strategies - Static - @Fetch - Hibernate - FetchMode.BATCH": "Performs a separate SQL select to load a number of related data items using an IN-restriction as part of the SQL WHERE-clause based on a batch size.",
	"App - Fetching - Strategies - Static - @Fetch - Hibernate - FetchMode.SUBSELECT": "Performs a separate SQL select to load associated data based on the SQL restriction used to load the owner.",
	"App - Fetching - Strategies - Dynamic": "Dynamic definition is really use-case centric. There are multiple ways to define dynamic fetching: fetch profiles, HQL/JPQL, entity graphs",
	"App - Fetching - Strategies - Dynamic - JPA - EntityGraphs": "JPA 2.1 introduced entity graphs so the application developer has more control over fetch plans.",
	"App - Fetching - Strategies - Dynamic - JPA - EntityGraphs - Types": ".",
	"App - Fetching - Strategies - Dynamic - JPA - EntityGraphs - Types - FetchGraphs": "Strict specification - only listed attributes are eager.",
	"App - Fetching - Strategies - Dynamic - JPA - EntityGraphs - Types - FetchGraphs - javax.persistence.fetchgraph": "JPA standard specifies that you can override an EAGER fetching association at runtime using the javax.persistence.fetchgraph hint",
	"App - Fetching - Strategies - Dynamic - JPA - EntityGraphs - Types - LoadGraphs": "Additive specification - listed attributes + default eager ones.",
	"App - Fetching - Strategies - Dynamic - JPA - EntityGraphs - Types - LoadGraphs - javax.persistence.loadgraph": "JPA standard specifies that you can override an EAGER fetching association at runtime using the javax.persistence.fetchgraph hint",
	"App - Fetching - Strategies - Dynamic - JPA - EntityGraphs - Types - NamedEntityGraph": ".",
	"App - Fetching - Strategies - Dynamic - JPA - EntityGraphs - Types - DynamicEntityGraphs": "Created programmatically using createEntityGraph():",
	"App - Fetching - Strategies - Dynamic - Hibernate - FetchProfile": "FetchProfiles are a powerful feature in Hibernate that allow you to define dynamic fetching strategies that can be activated at runtime, giving you more control over how associated entities and collections are loaded.",
	"App - Fetching - Strategies - Dynamic - Hibernate - FetchProfile - Definition": "Defined in entity mappings or programmatic.",
	"App - Fetching - Strategies - Dynamic - Hibernate - FetchProfile - Definition - mapping": "@FetchProfile(name = 'employee-with-department', ... )",
	"App - Fetching - Strategies - Dynamic - Hibernate - FetchProfile - Definition - programmatic": "FetchProfile profile = new FetchProfile('employee-with-address'); profile.addFetch(Employee.class, 'address');",
	"App - Fetching - Strategies - Dynamic - Hibernate - FetchProfile - Enable": "Can be enabled/disabled on the Session session.enableFetchProfile('employee-with-department');",
	"App - Fetching - Strategies - Dynamic - Querying - QueryGeneration": "",
	"App - Fetching - Strategies - Dynamic - Querying - QueryGeneration - Hibernate - @DynamicUpdate": "Modifies the Update statement to include only the changed columns instead of all fields.",
	"App - Fetching - Strategies - Dynamic - Querying - QueryGeneration - Hibernate - @DynamicInsert": "Modifies the INSERT statement to include only non-null columns instead of all fields.",
	"App - Fetching - Strategies - Dynamic - Querying - QueryGeneration - Hibernate - hibernate.order_inserts": "Modifies the INSERT statement to include only non-null columns instead of all fields.",
	"App - Fetching - Strategies - Dynamic - Querying - QueryGeneration - Hibernate - hibernate.jdbc.batch_size": "Used to specify number of inserts or updates to be carried out in a single database hit..",
	"App - Fetching - Strategies - Dynamic - Querying - QueryGeneration - Hibernate - org.hibernate.dialect": "Hibernate uses SQL dialects (org.hibernate.dialect) to: Adapt SQL syntax for different databases, Handle: Pagination (LIMIT vs ROWNUM vs FETCH), Locking syntax, Function names, Data types. Example dialects: MySQL8Dialect, PostgreSQL10Dialect, Oracle12cDialect",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems": "Hibernate generates SQL queries automatically based on your entity mappings and operations, but provides several ways to customize this behavior.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - SQLQueries": "JPA also supports executing SQL queries through the javax.persistence.Query interface",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - SQLQueries - @NamedNativeQuery - JPA": "Defines a reusable SQL query.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - JPA": "Criteria queries are a programmatic, type-safe way to express a query. They are type-safe in terms of using interfaces and classes to represent various structural parts of a query such as the query itself, the select clause, or an order-by, etc. They can also be type-safe in terms of referencing attributes as we will see in a bit",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaBuilder": "Criteria queries are essentially an object graph, where each part of the graph represents an increasing (as we navigate down this graph) more atomic part of the query. The first step in performing a criteria query is building this graph. The javax.persistence.criteria.CriteriaBuilder interface is the first thing with which you need to become acquainted with begin using criteria queries. Its role is that of a factory for all the individual pieces of the criteria. You obtain a javax.persistence.criteria.CriteriaBuilder instance by CriteriaBuilder builder = entityManager.getCriteriaBuilder(),",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Typed": "The type of the criteria query (aka the <T>) indicates the expected types in the query result. This might be an entity, an Integer, or any other object.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Create Criteria": "The next step is to obtain a javax.persistence.criteria.CriteriaQuery. This is accomplished using one of the three methods on javax.persistence.criteria.CriteriaBuilder for this purpose: (1) <T> CriteriaQuery<T> createQuery( Class<T> resultClass ) (2) CriteriaQuery<Tuple> createTupleQuery() (3) CriteriaQuery<Object> createQuery() Each serves a different purpose depending on the expected type of the query results.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Create - createCriteria(Class.class)": "Criteria crit = sess.createCriteria(Cat.class), (hibernate) vs Session#createCriteria(String entityName) or StatelessSession#createCriteria(String entityName) (JPA)",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Create - CriteriaQuery<Tuple> createTupleQuery()": "A better approach to Selecting multiple values is to use either a wrapper (which we just saw in Selecting a wrapper) or using the javax.persistence.Tuple contract. The javax.persistence.Tuple contract provides three forms of access to the underlying elements: typed, positional, aliased",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Create - DetachedCriteria": "The DetachedCriteria class allows you to create a query outside the scope of a session and then execute it using an arbitrary Session. DetachedCriteria.forClass(Cat.class)",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Restrictions": ".add( Restrictions.like('name', 'Fritz%') ) and .add(Restrictions.eq('fullName.lastName', 'Cattington')) (embedded)",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Fetching": ".setFetchMode('mate', FetchMode.EAGER)",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Projections": ".setProjection( Projections.rowCount() )",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Projections - Aggregation": "Projections.projectionList().add( Projections.rowCount() ) .add( Projections.avg('weight') )",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - criteria.groupBy(root.get('address'))": "Specify the expressions that are used to form groups over the query results.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - having(Expression<Boolean> restriction)": "Specify a restriction over the groups of the query.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - distinct(boolean distinct)": "Specify whether duplicate query results will be eliminated.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Ordering": ".addOrder( Order.asc('catName') )",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - By Natural Id": "add( Restrictions.naturalId().set('name', 'gavin').set('org', 'hb'))",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - from(Class<X> entityClass)": "Create and add a query root corresponding to the given entity, forming a cartesian product with any existing roots.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - where(Expression<Boolean> restriction)": "Modify the query to restrict the query results according to the specified boolean expression.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Roots": "Roots define the basis from which all joins, paths and attributes are available in the query. A root is always an entity type. Roots are defined and added to the criteria by the overloaded from methods on javax.persistence.criteria.CriteriaQuery:",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Joins": "Joins allow navigation from other javax.persistence.criteria.From to either association or embedded attributes. Joins are created by the numerous overloaded join methods of the javax.persistence.criteria.From interface.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPACriteriaAPI - CriteriaQuery - Fetches": "Just like in HQL and JPQL, criteria queries can specify that associated data be fetched along with the owner. Fetches are created by the numerous overloaded fetch methods of the javax.persistence.criteria.From interface.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPQLQueries": "JPQL stands for Java Persistence Query Language. Used by Spring Data JPA.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - JPA - JPQLQueries - @NamedQuery": "Defines a reusable JPQL query.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - Hibernate - SQLQueries": "",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - Hibernate - SQLQueries - @SQLInsert": " ",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - Hibernate - SQLQueries - @SQLUpdate": " ",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - Hibernate - SQLQueries - @SQLDelete": " ",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - Hibernate - HQLQueries": "HQL stands for Hibernate Query Language.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - Hibernate - HCQLQueries": "Hibernate Criteria Query Language (HCQL) lets you build queries using Java code.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - Hibernate - HCQLQueries - deprecated": "Hibernate offers a legacy org.hibernate.Criteria API. Eventually, Hibernate-specific criteria features will be ported as extensions to the JPA javax.persistence.criteria.CriteriaQuery",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - Hibernate - Config - hibernate.show_sql": "Controls whether Hibernate logs the SQL statements it executes.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - Hibernate - Config - hibernate.format_sql": "Formats the logged SQL to be more readable.",
	"App - Fetching - Strategies - Dynamic - Querying - QuerySystems - Hibernate - Config - hibernate.use_sql_comments": "Adds informative comments to generated SQL.",
	"App - Fetching - Strategies - Dynamic - Querying - QueryExecution": "",
	"App - Fetching - Strategies - Dynamic - Querying - QueryExecution - 1. Parse": "Parse operation (HQL/Criteria/API call)",
	"App - Fetching - Strategies - Dynamic - Querying - QueryExecution - 2. AST": "Generate abstract syntax tree",
	"App - Fetching - Strategies - Dynamic - Querying - QueryExecution - 3. Optimizations": "Apply optimizations",
	"App - Fetching - Strategies - Dynamic - Querying - QueryExecution - 4. SQL": "Convert to SQL (with dialect)",
	"App - Fetching - Strategies - Dynamic - Querying - QueryExecution - 5. PrepareStatement": "",
	"App - Fetching - Strategies - Dynamic - Querying - QueryExecution - 6. Execute": "Execute and return results",
	"App - Caching - L1Cache": "In Hibernate, the first-level cache (L1 cache) is a session-level cache that is enabled by default and exists for the duration of a Hibernate Session.",
	"App - Caching - L1Cache - Features - Mandatory": "Automatic & Mandatory – Enabled by default; cannot be disabled.",
	"App - Caching - L1Cache - Features - NoConfig": "No Configuration Needed – Works out of the box.",
	"App - Caching - L1Cache - Lifecycle - Create": "When an entity is loaded via session.get(), session.load(), or queries, Hibernate stores it in the L1 cache.",
	"App - Caching - L1Cache - Lifecycle - Run": "Session-Scoped – Exists only while the Session is open. Once the session is closed, the cache is destroyed.",
	"App - Caching - L1Cache - Lifecycle - Delete": "Short-Lived – Cleared when session.evict(), session.clear(), or session.close() is called.",
	"App - Caching - L2Cache": "It is possible to configure a JVM-level (SessionFactory-level) or even a cluster cache on a class-by-class and collection-by-collection basis. Be aware that caches are not aware of changes made to the persistent store by other applications. They can, however, be configured to regularly expire cached data.",
	"App - Caching - L2Cache - @Cacheable - JPA": "The @Cacheable annotation is used to specify whether an entity should be stored in the second-level cache.",
	"App - Caching - L2Cache - @Cacheable - ENABLE_SELECTIVE": "If the persistence.xml shared-cache-mode XML attribute is set to ENABLE_SELECTIVE, then only the entities annotated with the @Cacheable are going to be stored in the second-level cache.",
	"App - Caching - L2Cache - @Cacheable - DISABLE_SELECTIVE": "If shared-cache-mode XML attribute value is DISABLE_SELECTIVE, then the entities marked with the @Cacheable annotation are not going to be stored in the second-level cache, while all the other entities are stored in the cache.",
	"App - Caching - L2Cache - @Cacheable - Hibernate": ".",
	"App - Caching - L2Cache - CacheableObjects - Entity": "Hibernate stores cached entities in a dehydrated form, which is similar to the database representation. Aside from the foreign key column values of the @ManyToOne or @OneToOne child-side associations, entity relationships are not stored in the cache,",
	"App - Caching - L2Cache - CacheableObjects - Collection": "Hibernate can also cache collections, and the @Cache annotation must be on added to the collection property. If the collection is made of value types (basic or embeddables mapped with @ElementCollection), the collection is stored as such. If the collection contains other entities (@OneToMany or @ManyToMany), the collection cache entry will store the entity identifiers only.",
	"App - Caching - L2Cache - CacheableObjects - Query": "Hibernate offers a query cache, useful for frequently executed queries with fixed parameter values. Caching of query results introduces some overhead. Disabled by default.",
	"App - Caching - L2Cache - CacheManagement - JPA": "JPA split cache modes by storage and retrieval. JPA provides basic caching support (@Cacheable), but advanced features require provider extensions.",
	"App - Caching - L2Cache - CacheManagement - JPA - CacheStoreMode": "USE, REFRESH, BYPASS",
	"App - Caching - L2Cache - CacheManagement - JPA - CacheStoreMode - USE": "",
	"App - Caching - L2Cache - CacheManagement - JPA - CacheStoreMode - REFRESH": "",
	"App - Caching - L2Cache - CacheManagement - JPA - CacheStoreMode - BYPASS": "",
	"App - Caching - L2Cache - CacheManagement - JPA - CacheAppMode": "USE, BYPASS",
	"App - Caching - L2Cache - CacheManagement - JPA - CacheAppMode - USE": "",
	"App - Caching - L2Cache - CacheManagement - JPA - CacheAppMode - BYPASS": "",
	"App - Caching - L2Cache - CacheManagement - Hibernate": "Hibernate defined the CacheMode enumeration: CacheMode.NORMAL, CacheMode.REFRESH, CacheMode.PUT, CacheMode.GET, CacheMode.IGNORE",
	"App - Caching - L2Cache - CacheManagement - Hibernate - CacheMode.NORMAL": "Default. Reads/writes data from/into the cache",
	"App - Caching - L2Cache - CacheManagement - Hibernate - CacheMode.REFRESH": "Doesn’t read from cache, but writes to the cache upon loading from the database",
	"App - Caching - L2Cache - CacheManagement - Hibernate - CacheMode.PUT": "Doesn’t read from cache, but writes to the cache as it reads from the database",
	"App - Caching - L2Cache - CacheManagement - Hibernate - CacheMode.GET": "Read from the cache, but doesn’t write to cache",
	"App - Caching - L2Cache - CacheManagement - Hibernate - CacheMode.IGNORE": "Doesn’t read/write data from/into the cache",
	"App - Caching - L2Cache - CacheConcurrencyStrategy - Hibernate": "The @Cache annotation is used to specify the CacheConcurrencyStrategy of a root entity or a collection. The @Cache annotation define three attributes: usage (Defines the CacheConcurrencyStrategy), region (Defines a cache region where entries will be stored), include (If lazy properties should be included in the second level cache. The default value is all so lazy properties are cacheable. The other possible value is non-lazy so lazy properties are not cacheable).",
	"App - Caching - L2Cache - CacheConcurrencyStrategy - Hibernate - @Cache": "The @Cache annotation is used to specify the CacheConcurrencyStrategy of a root entity or a collection.",
	"App - Caching - L2Cache - CacheConcurrencyStrategy - Hibernate - @Cache - attr - usage": "Defines the CacheConcurrencyStrategy.",
	"App - Caching - L2Cache - CacheConcurrencyStrategy - Hibernate - @Cache - attr - region": "Defines a cache region where entries will be stored.",
	"App - Caching - L2Cache - CacheConcurrencyStrategy - Hibernate - @Cache - attr - include": "If lazy properties should be included in the second level cache.",
	"App - Caching - L2Cache - CacheConcurrencyStrategy - Hibernate - @Cache - values - NONE": "Indicates that no concurrency strategy is specified, and that a default strategy should be used.",
	"App - Caching - L2Cache - CacheConcurrencyStrategy - Hibernate - @Cache - values - NONSTRICT_READ_WRITE": "Read/write access to the shared second-level cache with no locking.",
	"App - Caching - L2Cache - CacheConcurrencyStrategy - Hibernate - @Cache - values - READ_ONLY": "Read-only access to the shared second-level cache.",
	"App - Caching - L2Cache - CacheConcurrencyStrategy - Hibernate - @Cache - values - READ_WRITE": "Read/write access to the shared second-level cache using soft locks.",
	"App - Caching - L2Cache - CacheConcurrencyStrategy - Hibernate - @Cache - values - TRANSACTIONAL": "Transactional access to the shared second-level cache.",
	"App - Caching - L2Cache - Statistics": "If you enable the hibernate.generate_statistics configuration property, Hibernate will expose a number of metrics via SessionFactory.getStatistics(). Hibernate can even be configured to expose these statistics via JMX. This way, you can get access to the Statistics class which comprises all sort of second-level cache metrics.",
	"App - Caching - L2Cache - RegionFactory": "org.hibernate.cache.spi.RegionFactory defines the integration between Hibernate and a pluggable caching provider. hibernate.cache.region.factory_class is used to declare the provider to use.",
	"App - Caching - L2Cache - RegionFactory - hibernate.cache.region.factory_class": "hibernate.cache.region.factory_class is used to declare the provider to use.",
	"App - Caching - L2Cache - RegionFactory - Tools:": "Hibernate comes with built-in support for the Java caching standard JCache and also two popular caching libraries: Ehcache and Infinispan.",
	"App - Caching - L2Cache - RegionFactory - Tools - JCache:": "",
	"App - Caching - L2Cache - RegionFactory - Tools - Ehcache:": "",
	"App - Caching - L2Cache - RegionFactory - Tools - Infinispan:": "",
	"App - Performance": "Tuning how an application does fetching is one of the biggest factors in determining how an application will perform. Fetching too much data, in terms of width (values/columns) and/or depth (results/rows), adds unnecessary overhead in terms of both JDBC communication and ResultSet processing. Fetching too little data might cause additional fetching to be needed. Tuning how an application fetches data presents a great opportunity to influence the application overall performance.",
	"App - Performance - N+1": "The N+1 problem is a common performance issue in Hibernate (and other ORMs) where the framework executes many more SQL queries than necessary to fetch associated entities. (1) Execute 1 query to get N entities (the '1' in N+1) (2) Then Hibernate executes N additional queries (the 'N' in N+1) to fetch associated entities for each of the original N entities",
	"App - Performance - N+1 - Solutions - JOIN FETCH": "Eager Fetching with JOIN FETCH List<Author> authors = session.createQuery('SELECT a FROM Author a JOIN FETCH a.books', Author.class).list(); This generates a single SQL query with a JOIN.",
	"App - Performance - N+1 - Solutions - JOIN FETCH - drawback": "JOIN FETCH can lead to Cartesian product explosions with multiple collections.",
	"App - Performance - N+1 - Solutions - @BatchSize": "Configuring Hibernate to load collections in batches. This fetches associations in batches rather than one-by-one.: @BatchSize(size = 10) private Set<Book> books; ",
	"App - Performance - N+1 - Solutions - @BatchSize - drawback": "Batch fetching still involves multiple queries, albeit fewer than the pure N+1 scenario.",
	"App - Performance - N+1 - Solutions - FetchMode.SUBSELECT": "This executes a second query that fetches all collections at once: @Fetch(FetchMode.SUBSELECT) private Set<Book> books;. FetchMode.SUBSELECT is useful as it solves the N+1 query¹ issue of FetchMode.SELECT. But FetchMode.SUBSELECT leads to increased memory usage.",
	"App - Performance - N+1 - Solutions - EntityGraph": "EntityGraph<Author> graph = session.createEntityGraph(Author.class); Defining fetch plans using JPA’s @EntityGraph annotation.",
	"App - Performance - N+1 - Solutions - EntityGraph - drawback": "require careful configuration",
	"App - Performance - N+1 - Solutions - DTOProjections": "Instead of fetching entire entity graphs, select only the data you need. Use DTO projections when you only need a subset of data",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - SpringBoot3.5": "This feature intelligently analyzes your application’s data access patterns at runtime and automatically optimizes fetching strategies based on observed behavior.",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - BasedOn - DynamicQueryRewriting": "When Spring Boot 3.5 detects potential N+1 scenarios, it dynamically rewrites subsequent queries into efficient batch queries. This happens transparently without requiring developer intervention. For instance, if your code first loads all orders and then accesses their line items, Spring Boot’s enhanced EntityManager intercepts the individual line item access operations and consolidates them into a single optimized query.",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - BasedOn - PredictiveDataLoading": "@EnablePredictiveEntityLoading Spring Boot 3.5 introduces a learning algorithm that analyzes access patterns across requests. After observing that a particular entity relationship is consistently accessed together, it begins preemptively loading the related entities in an optimal way. With this configuration, Spring Boot automatically adapts to your application’s specific data access needs, optimizing queries based on real usage patterns rather than static configuration.",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - BasedOn - TransparentCachingLayer": "@EnableJpaRepositories(enableRelationshipCache = true) The framework now includes a transparent second-level cache specifically designed to eliminate redundant N+1 queries. This cache is context-aware and understands entity relationships, ensuring that related entities are stored and retrieved together. What makes this solution particularly powerful is how little developer intervention it requires. In many cases, it “just works” without additional configuration.",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - Steps - QueryPlanAnalysis": "The enhanced JPA implementation analyzes SQL query plans before execution. When it detects patterns indicative of N+1 scenarios, it intercepts and optimizes the execution plan.",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - Steps - BytecodeEnhancement": "@EnableEnhancedJpaEntities For maximum performance, Spring Boot now offers enhanced bytecode instrumentation that makes relationship traversal operations more efficient:",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - Steps - AdaptiveRepositoryImplementation": "Spring Data repositories now leverage this enhanced infrastructure automatically. The standard repository methods are implemented with awareness of relationship loading patterns:",
	"App - Performance - N+1 - Solutions - RelationshipAwareEntityLoading - Adoption": "spring.jpa.properties.hibernate.batch_fetch_style=DYNAMIC - spring.jpa.properties.hibernate.query.optimizer.enabled=true - spring.jpa.properties.hibernate.query.relation_aware_loading=true"

}