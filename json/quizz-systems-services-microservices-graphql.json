{
	"GraphQL": "SECTION",
	"GraphQL - Features": "GraphQL, a query language and execution engine originally created at Facebook in 2012",
	"GraphQL - Features - Transport": "GraphQL and REST typically use HTTP as their transport layer, and they both leverage the standard HTTP POST method to send and receive data. The GraphQL specification doesn’t require particular client-server protocols when sending API requests and responses, but HTTP is the most common choice because of its ubiquity.",
	"GraphQL - Features - Formats": "GraphQL and REST use standard data formats for communication. JSON is the most commonly used format, but other formats, like XML or HTML, can also be used, especially in REST.",
	"GraphQL - Features - Stateless": "the server does not save response history between requests",
	"GraphQL - Protocol - Schema - required": "GraphQL requires a schema that defines the data types and relationships between each type. The schema provides clients with a description of the data that is available to them.",
	"GraphQL - Protocol - Schema - Introspection": "GraphQL APIs are self-documenting. Clients can query the API schema to discover the types, queries, mutations, and fields it supports. This introspective capability makes it easier to understand and explore the capabilities of a GraphQL API.",
	"GraphQL - Protocol - Schema - Types": "",
	"GraphQL - Protocol - Schema - Types - Scalar": "Built-in primitive types",
	"GraphQL - Protocol - Schema - Types - Scalar - Int": "",
	"GraphQL - Protocol - Schema - Types - Scalar - Float": "",
	"GraphQL - Protocol - Schema - Types - Scalar - String": "",
	"GraphQL - Protocol - Schema - Types - Scalar - Boolean": "",
	"GraphQL - Protocol - Schema - Types - Scalar - ID": "",
	"GraphQL - Protocol - Schema - Types - Object": "Custom types representing entities in your application.",
	"GraphQL - Protocol - Schema - Types - Enum": "A set of predefined constant values.",
	"GraphQL - Protocol - Schema - Types - Input": "Used for mutations to pass complex input data.",
	"GraphQL - Protocol - Schema - Types - Interfaces": "An interface is an abstract type that defines a set of fields that multiple types must implement. Any type that implements an interface must have all the fields declared in that interface.",
	"GraphQL - Protocol - Schema - Types - Union": "A union is similar to an interface, but unlike interfaces, union types do not require shared fields.",
	"GraphQL - Protocol - Schema - Fragments": "Reusable query parts to avoid duplication.",
	"GraphQL - Protocol - Schema - Directives": "GraphQL directives are special annotations that modify the behavior of queries, mutations, fields, and schemas at runtime. They provide dynamic control over query execution, validation, and schema transformation.",
	"GraphQL - Protocol - Schema - Directives - Built-in": "",
	"GraphQL - Protocol - Schema - Directives - Custom": "You can create custom directives to extend GraphQL’s functionality.",
	"GraphQL - Client ": "Used by frontend applications to communicate with a GraphQL API.",
	"GraphQL - Client - Queries": "Queries allow clients to request specific pieces of data.",
	"GraphQL - Client - Queries - Directives": "Special annotations to modify query behavior dynamically.",
	"GraphQL - Client - Queries - FileUploads": "The last major difference between REST and GraphQL is that GraphQL doesn't understand files, it only understands text.",
	"GraphQL - Client - Mutations": "Used to modify data (create, update, delete).",
	"GraphQL - Client - Mutations - RPC": "GraphQL mutations are in fact RPC.",
	"GraphQL - Client - Subscriptions": "Used for real-time updates via WebSockets.",
	"GraphQL - Client - Tools - ApolloClient": ".",
	"GraphQL - Client - Tools - Relay": ".",
	"GraphQL - Client - Tools - urql": ".",
	"GraphQL - Request - ServiceDiscovery": "GraphQL is discoverable by default.",
	"GraphQL - Request - ServiceDiscovery - Introspection": "Allows clients to query the schema of a GraphQL API to discover its types, fields, queries, mutations, and other details.",
	"GraphQL - Request - ServiceDiscovery - Introspection - fields": "Introspection is performed using special reserved fields and types in GraphQL.",
	"GraphQL - Request - ServiceDiscovery - Introspection - fields - __schema": ".",
	"GraphQL - Request - ServiceDiscovery - Introspection - fields - __type": ".",
	"GraphQL - Request - ServiceDiscovery - Introspection - fields - __typename": ".",
	"GraphQL - Request - Caching": "GraphQL handles caching in a completely different manner than a REST API, primarily because GraphQL requests are not strictly based on the HTTP specification. GraphQL, on the other hand, doesn't know about HTTP caching.",
	"GraphQL - Request - Caching - POST": "In a typical GraphQL request, every request is a POST request, and thus, there isn’t any concept of GET, POST, PUT, or DELETE. Therefore, it relies on uniquely identifying objects on the client end for caching behavior.",
	"GraphQL - Request - Caching - Problem": "In URL-based requests, such as REST, the caching is done by identifying unique URL endpoints. However, in GraphQL and its associated libraries, there is no such concept; instead, it relies on exposing a unique identifier on the client side (see below).",
	"GraphQL - Request - Caching - GlobalID": "One solution for caching data on the client side could be to use an ID as a global identifier for getting responses back from the API server. That unique ID is used to handle caching on the client side. If the backend is already using some sort of library, such as a universally unique identifier (UUID), then the API can leverage that for identifying data objects sent from the server. This further helps in the identification of unique objects (distinguished based on their IDs) that need to be cached again.",
	"GraphQL - Request - Versioning": "Breaking changes do not require a new version.",
	"GraphQL - Request - Versioning - SchemaEvolution": "Clients request only the fields they need, so adding new fields doesn’t break existing queries.",
	"GraphQL - Request - Versioning - SchemaEvolution - AddFields": "New fields can be introduced without affecting existing queries.",
	"GraphQL - Request - Versioning - SchemaEvolution - DeprecateFields": "Fields can be marked as deprecated while still working.",
	"GraphQL - Request - Versioning - SchemaEvolution - Extensions": "New optional arguments can be added without breaking existing queries.",
	"GraphQL - Request - Versioning - NewSchema": "If a change is truly incompatible (e.g., removing a critical field), you may need a new schema or a temporary workaround.",
	"GraphQL - Request - Versioning - NewSchema - Stitching": ".",
	"GraphQL - Request - Versioning - NewSchema - Federation": ".",
	"GraphQL - Server": "The backend implementation that interprets queries and executes resolvers. Can aggregate data from databases, REST APIs, and microservices.",
	"GraphQL - Server - Resolvers": "Functions that handle how GraphQL queries and mutations retrieve or modify data.",
	"GraphQL - Server - Resolvers - Operation - QueryExecution": "Query Execution – When a GraphQL query is executed, each field in the query is processed by a resolver.",
	"GraphQL - Server - Resolvers - Operation - DataFetching": "Data Fetching – The resolver fetches data from a database, API, or another data source.",
	"GraphQL - Server - Resolvers - Operation - ResponseConstruction": "Response Construction – Once all resolvers return data, GraphQL assembles the final response and sends it back to the client.",
	"GraphQL - Server - Resolvers - Format": "A resolver is typically defined as a function with the following signature: const resolverFunction = (parent, args, context, info) => { ... };",
	"GraphQL - Server - Resolvers - Format - Parent": "It represents the data that is returned by the parent's resolver field, if we have nested resolvers present inside the query.",
	"GraphQL - Server - Resolvers - Format - Arguments": "These represent the additional arguments that is passed to the query by the user.",
	"GraphQL - Server - Resolvers - Format - Context": "It represents a shared object that is present across the resolvers that get called during a single query operation.",
	"GraphQL - Server - Resolvers - Format - Info": "It represents the data that is present during the query operation, and represents the state of the query, like the field or the path to the field for which the resolver is getting resolved.",
	"GraphQL - Server - Tools - ApolloServer": ".",
	"GraphQL - Server - Tools - GraphQLYoga": ".",
	"GraphQL - Server - Tools - Express-GraphQL": ".",
	"GraphQL - Server - Tools - Hasura": ".",
	"GraphQL - Server - Tools - GraphQL.NET": ".",
	"GraphQL - Server - Tools - Strawberry": ".",
	"GraphQL - Response - Format - JSON": "GraphQL always returns a JSON response.",
	"GraphQL - Response - Codes - 200": "GraphQL uses the 200 status code for all responses, including error responses. The error response is typically included in the response payload itself.",
	"GraphQL - Response - Error": "The Error Array.",
	"GraphQL - Response - Security": "GraphQL allows clients to construct complex queries, which can lead to vulnerabilities if not properly secured.",
	"GraphQL - Response - Security - Risk - Overload": "Overfetching & Excessive Query Depth (Denial of Service - DoS) Attackers can craft deeply nested queries that overload the server. Impact: Server CPU/memory exhaustion.",
	"GraphQL - Response - Security - Risk - Batch": "Batch Query Attacks (Batching & Aliasing) Attackers can send multiple queries in a single request. Impact: Database overload.",
	"GraphQL - Response - Security - Risk - Disclosure": "Information Disclosure (Introspection Exploits). GraphQL’s introspection reveals the schema: Impact: Attackers discover hidden fields or internal logic.",
	"GraphQL - Response - Security - Risk - InjectionAttacks": "Injection Attacks (SQL, NoSQL, etc.) Unsanitized inputs in queries/mutations: Impact: Bypass authentication, data leaks.",
	"GraphQL - Response - Security - Risk - AuthorizationBypass": "Authorization Bypass (Missing Access Control). GraphQL doesn’t enforce authorization by default: Impact: Unauthorized access to sensitive data..",
	"GraphQL - Response - Security - GoodPractices - QueryDepthLimiting": "Restrict nested queries to prevent DoS: depthLimit(5)",
	"GraphQL - Response - Security - GoodPractices - RateLimiting": "costAnalysis({ maximumCost: 1000 })",
	"GraphQL - Response - Security - GoodPractices - DisableIntrospection": "Prevent schema leaks.",
	"GraphQL - Response - Security - GoodPractices - InputValidationSanitization": "Validate arguments to prevent injection",
	"GraphQL - Response - Security - GoodPractices - ProperAuthorization": "Use middleware (e.g., GraphQL Shield)",
	"GraphQL - Response - Security - GoodPractices - PersistedQueries": "Use Persisted Queries (Allowlisting) Only allow pre-approved queries.",
	"GraphQL - Response - Security - GoodPractices - MonitorSuspiciousQueries": "Detect malicious patterns.",
	"GraphQL - Response - Security - Tools - GraphQLArmor": "Protection against DoS, injections",
	"GraphQL - Response - Security - Tools - GraphQLShield": "Authorization layer",
	"GraphQL - Response - Security - Tools - PersistedQueries": "Allowlist known queries",
	"GraphQL - Response - Security - Tools - RateLimiting": "Prevent brute force attacks",
	"GraphQL - Response - Security - Tools - ApolloStudio": "Monitoring & analytics",
	"GraphQL - Response - ResponseSize - Pagination": "",

	"SpringForGraphQL": "SECTION",
	"SpringForGraphQL - definition": "Spring for GraphQL provides support for Spring applications built on GraphQL Java.",
	"SpringForGraphQL - successor": "Spring for GraphQL is the successor of the GraphQL Java Spring project from the GraphQL Java team. It aims to be the foundation for all Spring, GraphQL applications."

}