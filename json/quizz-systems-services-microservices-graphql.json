{
	"GraphQL": "SECTION",
	"GraphQL - Features": "GraphQL, a query language and execution engine originally created at Facebook in 2012",
	"GraphQL - Features - Transport": "GraphQL and REST typically use HTTP as their transport layer, and they both leverage the standard HTTP POST method to send and receive data. The GraphQL specification doesn’t require particular client-server protocols when sending API requests and responses, but HTTP is the most common choice because of its ubiquity.",
	"GraphQL - Features - Formats": "GraphQL and REST use standard data formats for communication. JSON is the most commonly used format, but other formats, like XML or HTML, can also be used, especially in REST.",
	"GraphQL - Features - Stateless": "the server does not save response history between requests",
	"GraphQL - Protocol - Schema - required": "GraphQL requires a schema that defines the data types and relationships between each type. The schema provides clients with a description of the data that is available to them.",
	"GraphQL - Protocol - Schema - Introspection": "GraphQL APIs are self-documenting. Clients can query the API schema to discover the types, queries, mutations, and fields it supports. This introspective capability makes it easier to understand and explore the capabilities of a GraphQL API.",
	"GraphQL - Protocol - Schema - Types": "",
	"GraphQL - Protocol - Schema - Types - Scalar": "Built-in primitive types",
	"GraphQL - Protocol - Schema - Types - Scalar - Int": "",
	"GraphQL - Protocol - Schema - Types - Scalar - Float": "",
	"GraphQL - Protocol - Schema - Types - Scalar - String": "",
	"GraphQL - Protocol - Schema - Types - Scalar - Boolean": "",
	"GraphQL - Protocol - Schema - Types - Scalar - ID": "",
	"GraphQL - Protocol - Schema - Types - Object": "Custom types representing entities in your application.",
	"GraphQL - Protocol - Schema - Types - Enum": "A set of predefined constant values.",
	"GraphQL - Protocol - Schema - Types - Input": "Used for mutations to pass complex input data.",
	"GraphQL - Protocol - Schema - Types - Interfaces": "An interface is an abstract type that defines a set of fields that multiple types must implement. Any type that implements an interface must have all the fields declared in that interface.",
	"GraphQL - Protocol - Schema - Types - Union": "A union is similar to an interface, but unlike interfaces, union types do not require shared fields.",
	"GraphQL - Protocol - Schema - Fragments": "Reusable query parts to avoid duplication.",
	"GraphQL - Protocol - Directives": "GraphQL directives are special annotations that modify the behavior of queries, mutations, fields, and schemas at runtime. They provide dynamic control over query execution, validation, and schema transformation.",
	"GraphQL - Protocol - Directives - Built-in": "",
	"GraphQL - Protocol - Directives - Custom": "You can create custom directives to extend GraphQL’s functionality.",
	"GraphQL - Protocol - Client ": "Used by frontend applications to communicate with a GraphQL API.",
	"GraphQL - Protocol - Client - Client - Queries": "Queries allow clients to request specific pieces of data.",
	"GraphQL - Protocol - Client - Client - Queries - Directives": "Special annotations to modify query behavior dynamically.",
	"GraphQL - Protocol - Client - Client - Mutations": "Used to modify data (create, update, delete).",
	"GraphQL - Protocol - Client - Client - Mutations - RPC": "GraphQL mutations are in fact RPC.",
	"GraphQL - Protocol - Client - Client - Subscriptions": "Used for real-time updates via WebSockets.",
	"GraphQL - Protocol - Client - Client - Introspection": "Allows clients to query the schema of a GraphQL API to discover its types, fields, queries, mutations, and other details.",
	"GraphQL - Protocol - Client - Client - Introspection - fields": "Introspection is performed using special reserved fields and types in GraphQL.",
	"GraphQL - Protocol - Client - Client - Introspection - fields - __schema": ".",
	"GraphQL - Protocol - Client - Client - Introspection - fields - __type": ".",
	"GraphQL - Protocol - Client - Client - Introspection - fields - __typename": ".",
	"GraphQL - Protocol - Server": "The backend implementation that interprets queries and executes resolvers.",
	"GraphQL - Protocol - Server - sources": "Can aggregate data from databases, REST APIs, and microservices.",
	"GraphQL - Protocol - Server - Resolvers": "Functions that handle how GraphQL queries and mutations retrieve or modify data.",
	"GraphQL - Protocol - Server - Resolvers - Operation - QueryExecution": "Query Execution – When a GraphQL query is executed, each field in the query is processed by a resolver.",
	"GraphQL - Protocol - Server - Resolvers - Operation - DataFetching": "Data Fetching – The resolver fetches data from a database, API, or another data source.",
	"GraphQL - Protocol - Server - Resolvers - Operation - ResponseConstruction": "Response Construction – Once all resolvers return data, GraphQL assembles the final response and sends it back to the client.",
	"GraphQL - Protocol - Server - Resolvers - Format": "A resolver is typically defined as a function with the following signature: const resolverFunction = (parent, args, context, info) => { ... };",
	"GraphQL - Requests - Caching": "GraphQL handles caching in a completely different manner than a REST API, primarily because GraphQL requests are not strictly based on the HTTP specification.",
	"GraphQL - Requests - Caching - POST": "In a typical GraphQL request, every request is a POST request, and thus, there isn’t any concept of GET, POST, PUT, or DELETE. Therefore, it relies on uniquely identifying objects on the client end for caching behavior.",
	"GraphQL - Requests - Caching - Problem": "In URL-based requests, such as REST, the caching is done by identifying unique URL endpoints. However, in GraphQL and its associated libraries, there is no such concept; instead, it relies on exposing a unique identifier on the client side (see below).",
	"GraphQL - Requests - Caching - GlobalID": "One solution for caching data on the client side could be to use an ID as a global identifier for getting responses back from the API server. That unique ID is used to handle caching on the client side. If the backend is already using some sort of library, such as a universally unique identifier (UUID), then the API can leverage that for identifying data objects sent from the server. This further helps in the identification of unique objects (distinguished based on their IDs) that need to be cached again.",
	"GraphQL - Response": "",
	"GraphQL - Response - 200": "GraphQL uses the 200 status code for all responses, including error responses. The error response is typically included in the response payload itself.",
	"GraphQL - Response - ResponseSize - Pagination": "",

	"GraphQL - Clients": "SECTION",
	"GraphQL - Clients - ApolloClient": ".",
	"GraphQL - Clients - Relay": ".",
	"GraphQL - Clients - urql": ".",

	"GraphQL - Servers": "SECTION",
	"GraphQL - Servers - ApolloServer": ".",
	"GraphQL - Servers - GraphQLYoga": ".",
	"GraphQL - Servers - Express-GraphQL": ".",
	"GraphQL - Servers - Hasura": ".",
	"GraphQL - Servers - GraphQL.NET": ".",
	"GraphQL - Servers- Strawberry": "."


}