{
	"Kubernetes": "SECTION",
	"Kubernetes - Releases - 1.33": "Octarine",
	"Kubernetes 0": "https://www.linkedin.com/posts/vsadhwani_kubernetes-isnt-that-hard-they-said-you-activity-7328081564624416768-78PG/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 32": "CKA - https://www.linkedin.com/posts/activity-7319283380200558593-wgC4/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 48 - CKA": "https://www.linkedin.com/posts/praveen-singampalli_kubernetes-terminology-activity-7313041928143417345-hjyL?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",	
	"Kubernetes 54 - CKA": "https://www.linkedin.com/posts/praveen-singampalli_complete-cka-package-for-free-activity-7319924434046173186-yEf5?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 30": "CKA - https://www.linkedin.com/posts/aniket-ghosh-5g_kubernetes-activity-7320050902835339265-6urT?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 111": "CKA https://www.linkedin.com/posts/pothugunta-rakesh-93b8a8352_kubernetes-activity-7326126288732106752-icE3/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes  3": "ALL - https://www.linkedin.com/posts/prasanjit-sahoo4_100-kubernetes-interview-questions-you-must-activity-7321937756857782273-dB31/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 10": "ALL - https://www.linkedin.com/posts/mozahid-husain_kubernetesbasicstoadvance-activity-7322668498608934912-oAEQ?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 20": "ALL - https://www.linkedin.com/posts/hamidhirsi_kubernetes-cka-devops-activity-7320348174945079297-jhjj?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 23": "ALL - https://www.linkedin.com/posts/devops-expert_an-introduction-to-kubernetes-activity-7320657739146297344-LXbE?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 27": "ALL - https://www.linkedin.com/posts/mohan6201_kubernetes-notes-activity-7321131660572254209-od_q?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 33": "ALL - https://www.linkedin.com/posts/moole-muralidhara-reddy_kubernetes-zero-to-hero-syllabus-techworld-activity-7319026938856017920-kOqU?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 47": "ALL - https://www.linkedin.com/posts/govardhana-miriyala-kannaiah_25-blogs-to-learn-25-kubernetes-concepts-activity-7313526946829606913-zZdh/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 71": "ALL - https://www.linkedin.com/posts/paulinadubas_kubernetes-bible-second-edition-my-honest-activity-7322690764734365696-i7Fd?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 84": "ALL - https://www.linkedin.com/posts/dineshthiyagarajan_kubernetes-for-everyone-activity-7322864195488628736-uKnF?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 103": "ALL - https://www.linkedin.com/posts/manuelmorejon_once-upon-a-time-kubernetes-sample-activity-7324961033075195904-dkyS?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 91": "ALL - https://www.linkedin.com/posts/zaeem-bhatti_master-of-kubernetes-interview-activity-7324984372103643137--WpJ?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 114": "ALL https://www.linkedin.com/posts/saedf_securityengineering-kubernetes-tech-activity-7326150804405444608-G4-x?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 115": "ALL https://www.linkedin.com/posts/devops-learner-community_ace-your-job-interview-in-kubernetes-application-activity-7325746409234665474-4xAt/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 31": "ARCH - https://www.linkedin.com/posts/hadibalegh_5g-kubernetes-cloudnative-activity-7319041492705067008-UU9e?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 36": "ARCH - https://www.linkedin.com/posts/suryaprakshreddyb_kubernetes-kt-document-activity-7317258322401710081-zTdl?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 53": "ARCH - https://www.linkedin.com/posts/govardhana-miriyala-kannaiah_for-those-9999999999-boys-and-girls-who-activity-7323907598758350848-YDMi?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 49": "ARCH - https://www.linkedin.com/posts/zoranmilosevic_the-main-components-of-kubernetes-explained-activity-7314400272640835584-0JC2?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 51": "ARCH - https://www.linkedin.com/posts/vsadhwani_when-you-dont-remember-which-kubectl-command-activity-7313224446008295425-Bxa7?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 81": "ARCH - https://www.linkedin.com/posts/kaushalya-n-a0663114b_k8s-terminologies-activity-7325029417229897728-Eym7?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 88": "ARCH - https://www.linkedin.com/posts/devopscube_container-orchestration-kubernetesecs-activity-7323943204813201408-lWt4?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 89": "ARCH - https://www.linkedin.com/posts/jonbonso_tdlearn-kubernetes-cloudcomputing-activity-7323481308934918144-n8uz?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",	
	"Kubernetes 94": "ARCH - https://www.linkedin.com/pulse/kubernetes-learning-series-all-chapters-one-place-prashant-singh-negi-86jic/?trackingId=zfwR1VvJSwmbz47pqAjmYg%3D%3D",
	"Kubernetes 95": "ARCH - https://www.linkedin.com/posts/mumtaz-rajper-14a35927_kubernetes-notes-activity-7325096583220314113-yJ4t?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 97": "ARCH - https://www.linkedin.com/posts/arjunraj-r-r-10168b294_mastering-kubernetes-basics-to-indermediate-activity-7325602518825160704-jpKS?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 99": "ARCH - https://www.linkedin.com/posts/mohammed-yasir-khan_kubernetes-architecture-activity-7326314206121619457-rJ9a?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 100": "ARCH - https://stackoverflow.com/questions/53053888/where-is-the-complete-list-of-kubernetes-objects",
	"Kubernetes 102": "ARCH - https://www.linkedin.com/posts/devops-expert_kubernetes-interview-questions-activity-7326455930861080576-MF4s/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 68": "ARCH - https://www.linkedin.com/posts/manojofficialmj_k8s-kubernetes-devops-activity-7323870942336557056-p3qi?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 60": "CHEATSHEET - https://www.linkedin.com/posts/vsadhwani_kubernetesterminologycheatsheetforquickreference-ugcPost-7307463273820360705-Y6ac?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 98": "CHEATSHEET - https://www.linkedin.com/posts/milan-neupane-b471ab182_kubernetes-cheat-sheet-activity-7326229589221916672-5spd?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 64": "YAML files - https://www.linkedin.com/posts/swapna-adhav-05075462_kubernetes-essential-yaml-files-activity-7324720698105516032-7eIu?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 15": "DEVOPS  - https://www.linkedin.com/posts/mokhtariafef_kubernetes-activity-7320665249471229952-ghjS?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 41": "POD - https://www.linkedin.com/posts/sandip-das-developer_kubernetes-pods-simplified-1-pod-activity-7316101501163094016-yy2C?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 43": "SERVICES - https://www.linkedin.com/posts/y-david-prabhakar-34152425b_kubernetes-devops-k8sforbeginners-activity-7315783635238834176-SHYk?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 50": "CONTROLLER MANAGER - https://www.linkedin.com/posts/aswin-vijayan-6b745b218_devops-kubernetes-activity-7313779022780407809-hvKq?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 55": "SECURITY - https://www.linkedin.com/posts/temitope-adebunmi_custom-webhook-admission-controller-activity-7318250542399442945-S48D?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 56": "CICD - https://www.linkedin.com/posts/prince-pansuriya-167564221_day-29-activity-7318105878186868736-pkmF?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 70": "PDB - https://www.linkedin.com/posts/sandip-das-developer_kubernetes-pod-disruption-budget-pdb-simplified-activity-7323270231521427456-42hz?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 75": "Daemonset - https://www.linkedin.com/posts/sandip-das-developer_60daysofdevops-activity-7320447056047656962-liS2?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 82": "Kubelet - https://www.linkedin.com/posts/arun-lal-preman_kubernetes-activity-7323217058010120192-53-u?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 85": "Antipatters - https://www.linkedin.com/posts/leo-ely_kubernetes-anti-patterns-activity-7325232825979330560-l7gw?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 87": "volumes - https://www.linkedin.com/posts/aman-jaiswall_devops-sre-kubernetes-activity-7322820727919824897-Zl5F?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 104": "CONFIGMAP - https://www.linkedin.com/posts/sandip-das-developer_60daysofdevops-activity-7322628484839657477-s8dz?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 138": "CONFIGMAP https://www.linkedin.com/posts/rohitsurwade_day-3-of-14-kubernetes-activity-7326466786378297344-D43i?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 105": "https://www.linkedin.com/posts/vishugoyal247_devops-kubernetes-docker-activity-7322631187003252736-UIMd?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 106": "https://www.linkedin.com/posts/akhilesh-mishra-0ab886124_devops-project-multi-container-flask-application-activity-7323743712138682369-ZtNP?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 107": "https://www.linkedin.com/posts/junaif_devopsday07-activity-7323338114813374466-_rp5?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 108": "https://www.linkedin.com/posts/jatinbansaldevops_devops-like-comment-activity-7317134701792567296-ceGS?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 109": "https://www.linkedin.com/posts/govardhana-miriyala-kannaiah_many-devops-engineers-dont-fully-understand-activity-7317381114627530752-NpzB?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 110": "https://www.linkedin.com/posts/mahendra-reddy-naga_complete-cicd-project-activity-7325748763044515840-xkGq?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 112": "https://www.linkedin.com/posts/hagersobhy_kubernetes-activity-7325883567727681538-khjp?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 113": "NAMESPACES https://www.linkedin.com/posts/sawsan-salah-83614132_kubernetes-devops-dailydevopstips-activity-7326990068319961089-UNv4/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 116": "https://www.linkedin.com/posts/neamul-kabir-emon_aws-ecs-eks-activity-7324886549345509376-YFVW/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 117": "https://www.linkedin.com/posts/divine-odazie_6-basic-kubernetes-concepts-activity-7326893783130763265-EGqS?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 118": "ERRORS https://www.linkedin.com/posts/pavankumar557_k8s-errors-and-solutions-activity-7325365775412674560-dfo0?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 119": "https://www.linkedin.com/posts/manjunath-kotegar_kubernetes-a-complete-guide-activity-7325932802271498240-QT2B?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 120": "https://www.linkedin.com/posts/dineshthiyagarajan_kubernetes-best-practices-activity-7325751086844190721-L34v/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 121": "security https://www.linkedin.com/posts/bavicnative_kubernetes-security-checklist-activity-7326093508656672768-TGbw?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 122": "ALL https://www.linkedin.com/posts/devops-expert_kubernetes-interview-questions-activity-7326455930861080576-MF4s?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 123": "https://www.linkedin.com/posts/mohammed-yasir-khan_kubernetes-architecture-activity-7326314206121619457-rJ9a?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 124": "NETWOKRING https://www.linkedin.com/posts/dr-david-soldani_kubernetes-networking-activity-7326908873678696448-GZek?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 125": "ALL https://www.linkedin.com/posts/suresh-bandi-9a727b225_the-ultimate-kubernetes-visual-guide-for-activity-7327225171499442178-TaZH?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 126": "ALL https://www.linkedin.com/posts/balavignesh-manoharan_kubernetes-architecture-activity-7326869913954893824-8YGf?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 127": "https://www.linkedin.com/posts/poojabhavani08-devops_kubernetes-in-one-shot-day-3-activity-7328022375772356608-GO3r/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 128": "https://www.linkedin.com/posts/jaswindder-kummar_resolve-the-insufficient-capacity-error-in-activity-7327535501400297473-yqvS/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 129": "https://www.linkedin.com/posts/sonu-kumar-538039273_devops-shack-top-200-kubernetes-commands-activity-7327658162260459520-gMiJ/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 130": "https://www.linkedin.com/posts/vsadhwani_kubernetes-isnt-that-hard-they-said-you-activity-7328081564624416768-78PG?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 131": "https://www.linkedin.com/posts/d-anil-kumar-347731338_125-recent-interview-questions-activity-7327563573050695680-LWM4/?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 132": "https://www.linkedin.com/posts/venkatesh-jilakarra-976513113_5-real-time-kubernetes-interview-questions-activity-7326298849075965952-BMnM?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 133": "https://www.linkedin.com/posts/arjunraj-r-r-10168b294_mastering-kubernetes-basics-to-indermediate-activity-7325602518825160704-jpKS?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 134": "COMMANDS https://www.linkedin.com/posts/namanjainai_kubernetes-commands-activity-7326976100754952192-9uZE?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 136": "COMMANDS https://www.linkedin.com/posts/devops-learner-community_kubernetes-skills-commands-cheat-sheet-activity-7327195899271483393-da5k?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 135": "https://www.linkedin.com/posts/a-abukar_devops-interviewtips-kubernetes-activity-7325557885378191362-uCw7?utm_source=share&utm_medium=member_android&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 137": "ETCD https://www.linkedin.com/posts/activity-7328381450980847616-y1BU?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 139": "https://www.linkedin.com/posts/habib-tahar-djebbar-2a3683125_kubernetes-devops-cloudnative-activity-7328701663030972416-IM_z?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 140": "https://www.linkedin.com/posts/mozahid-husain_kubernetesservicetype-activity-7328732277264277504-wDLm?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 141": "https://www.linkedin.com/posts/kubernetes-architect_kube-resource-orchestrator-kro-is-a-kubernetes-native-activity-7326277477067096064-rQmO?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABC9LwBrHjPW40o31rZRtAXH6eii8ctLzQ",
	"Kubernetes 142": "",
	"Kubernetes 143": "",
	"Kubernetes 144": "",
	"Kubernetes 145": "",
	"Kubernetes 146": "",
	"Kubernetes 147": "",
	"Kubernetes 148": "",
	"Kubernetes 149": "",

	"Arch": "SECTION",
  "Arch - FEDERATION": "KubeFed (Kubernetes Federation) is an open-source project designed to enable the management and coordination of multiple Kubernetes clusters.",
  "Arch - CLUSTER": "A Cluster is a group of nodes managed by a control pane.",
  "Arch - CLUSTER - MASTERNODE": "The Kubernetes Master is a collection of three processes that run on a single node in your cluster, which is designated as the master node. Those processes are: kube-apiserver, kube-controller-manager and kube-scheduler.",
  "Arch - CLUSTER - MASTERNODE - ControlPlane": "The ControlPlane manages the cluster. It is the brain of Kubernetes.",
  "Arch - CLUSTER - MASTERNODE - ControlPlane - processes": "The Kubernetes Master Node is a collection of three processes that run on a single node in your cluster, which is designated as the master node. Those processes are: kube-apiserver, kube-controller-manager and kube-scheduler.",
	"Arch - CLUSTER - MASTERNODE - ControlPlane - processes - kube-scheduler": "The Kubernetes scheduler is a control plane process which schedules pods.",
  "Arch - CLUSTER - MASTERNODE - ControlPlane - processes - kube-apiserver": "Fron End of the ControlPlane through which all other components interact with the cluster.",
  "Arch - CLUSTER - MASTERNODE - ControlPlane - processes - kube-apiserver - REST": "exposes the Kubernetes API. The API Server services REST operations, validates and configures data for the api objects which include pods, services, ReplicationController, and others.",
  "Arch - CLUSTER - MASTERNODE - ControlPlane - processes - kube-apiserver - HA": "its unavailability disrupts key functionalities. Run multiple API server replicas in an HA setup. kube-apiserver is designed to scale horizontally—that is, it scales by deploying more instances. You can run several instances of kube-apiserver and balance traffic between those instances.",
  "Arch - CLUSTER - MASTERNODE - ControlPlane - processes - kube-apiserver - AdmissionController": "Admission controllers are code within the Kubernetes API server that check the data arriving in a request to modify a resource. Admission controllers apply to requests that create, delete, or modify objects.",
  "Arch - CLUSTER - MASTERNODE - ControlPlane - processes - kube-apiserver - AdmissionController - MutatingWebhooks": "",
  "Arch - CLUSTER - MASTERNODE - ControlPlane - processes - kube-apiserver - AdmissionController - ValidatingWebhooks": "",
  "Arch - CLUSTER - MASTERNODE - ControlPlane - processes - kube-controller-manager": "daemon that watches the Kubernetes API server. If something deviates (e.g., a pod crashes), the appropriate controller takes action to fix it.",
  "Arch - CLUSTER - MASTERNODE - ControlPlane - processes - kube-controller-manager - Controllers": "Logically, each controller is a separate process, but to reduce complexity, they are all compiled into a single binary and run in a single process.",
	"Arch - CLUSTER - MASTERNODE - ControlPlane - processes - kube-controller-manager - Controllers - sync": "A controller tracks at least one Kubernetes resource type. These objects have a spec field that represents the desired state. The controller(s) for that resource are responsible for making the current state come closer to that desired state.",
  "Arch - CLUSTER - MASTERNODE - ControlPlane - processes - kube-controller-manager - Controllers - Garbage Collection": "Garbage collection is a collective term for the various mechanisms Kubernetes uses to clean up cluster resources.",
  "Arch - CLUSTER - MASTERNODE - ControlPlane - processes - kube-controller-manager - Controllers - ServiceController": "Responsible for configuring ClusterIP, NodePort, and LoadBalancer configuration based on Service objects.",
	"Arch - CLUSTER - MASTERNODE - ControlPlane - processes - cloud-controller-manager": "Connects Kubernetes with cloud providers (AWS, Azure, GCP).",
	"Arch - CLUSTER - MASTERNODE - ControlPlane - processes - cloud-controller-manager - specific": "runs controllers that are specific to your cloud provider.",
	"Arch - CLUSTER - MASTERNODE - ControlPlane - processes - cloud-controller-manager - optional": "If you are running Kubernetes on your own premises, or in a learning environment inside your own PC, the cluster does not have a cloud controller manager.",
  "Arch - CLUSTER - MASTERNODE - ControlPlane - processes - etcd": "Primary datastore of Kubernetes. It saves the current state of the cluster.",
  "Arch - CLUSTER - MASTERNODE - ControlPlane - processes - etcd - keyvalue": "key-value backing store for all cluster data",
  "Arch - CLUSTER - MASTERNODE - ControlPlane - processes - etcd - Features - Distributed": "",
  "Arch - CLUSTER - MASTERNODE - ControlPlane - processes - etcd - Features - HA": "highly-available",
  "Arch - CLUSTER - MASTERNODE - ControlPlane - processes - etcd - Features - Consistent": "",
  "Arch - CLUSTER - MASTERNODE - ControlPlane - processes - etcd - Features - FaultTolerant": "",
	"Arch - CLUSTER - Configuration": "",
	"Arch - CLUSTER - Configuration - Charts": "recipe for deploying your application in a cluster, including deployments, services, and config maps, among others.",
	"Arch - CLUSTER - Configuration - Charts - Deployments": "Let's say you have an application that consists of multiple Kubernetes resources, such as deployments, services, and config maps. Without Helm, you would need to manually create and manage each of these resources, which can be time-consuming and error-prone. With Helm, you can package all these resources into a single chart and deploy it with a single command. This means that Helm installs the whole dependency tree of a project if you run the install command for the top-level chart. You just a single command to install your entire application, instead of listing the files to install via kubectl.",
	"Arch - CLUSTER - Configuration - Charts - Deployments - BlueGreen": "Blue-Green Deployment in Kubernetes is a deployment strategy that reduces downtime and risk by running two separate environments (Blue and Green) and switching traffic between them.",
	"Arch - CLUSTER - Configuration - Charts - Deployments - Blue": "The currently running, stable version.",
	"Arch - CLUSTER - Configuration - Charts - Deployments - Green": "The new version that you want to deploy.",
	"Arch - CLUSTER - Configuration - Charts - Helm": "the package manager for Kubernetes.",
	"Arch - CLUSTER - Configuration - Charts - Helm - Features - DeployAnywhere": "Package once, deploy anywhere: Helm Charts let you wrap up a whole app with sensible defaults.",
	"Arch - CLUSTER - Configuration - Charts - Helm - Features - values.yaml": "Customizability with values.yaml: You get one file to rule them all. Change ports? Image tags? TLS? It’s all in there.",
	"Arch - CLUSTER - Configuration - Charts - Helm - Features - Rollback": "Rollback-friendly: Helm tracks releases like Git does commits. One bad deployment? Just roll it back.",
	"Arch - CLUSTER - Configuration - Charts - Helm - Features - Ecosystem": "Ecosystem-rich: There’s a chart for everything from databases to observability tools to that obscure crypto node your CTO suddenly wants to “experiment” with.",
	"Arch - CLUSTER - Configuration - Charts - Helm - components": ".",
	"Arch - CLUSTER - Configuration - Charts - Helm - components - CLI": "The helm CLI is a command-line tool that you use to interact with Helm.",
	"Arch - CLUSTER - Configuration - Charts - Helm - components - Tiller": "Tiller is a server-side component that is responsible for deploying and managing the resources in a chart on your Kubernetes cluster.",
	"Arch - CLUSTER - Configuration - Charts - Helm - Drawbacks - Templatehell": "Helm templates are written in Go’s templating language.",
	"Arch - CLUSTER - Configuration - Charts - Helm - Drawbacks - values.yaml": "values.yaml becomes a jungle: As your chart grows, values.yaml becomes a sprawling monster. Want to change one thing? Hope you enjoy tracing through 4 layers of defaults, conditionals, and overrides.",
	"Arch - CLUSTER - Configuration - Charts - Helm - Drawbacks - Debugging": "Debugging is pain: Debugging a Helm chart is like trying to guess what your YAML will look like after rendering. You run helm template, stare at the output, make changes, rinse, repeat.",
	"Arch - CLUSTER - Configuration - Charts - Helm - Drawbacks - GitOps": "GitOps unfriendly: If you’re living the GitOps dream with ArgoCD or Flux, Helm adds an extra layer of abstraction between what’s in Git and what’s in your cluster.",
	"Arch - CLUSTER - Configuration - Charts - Kustomize": ".",
	"Arch - CLUSTER - Configuration - Charts - kro": "Kro is a new approach to Kubernetes app delivery that drops templating entirely. Built by Viktor Farcic, it’s a declarative, opinionated, and GitOps-native tool for defining, composing, and deploying Kubernetes applications — without duct-taping variables into templated YAML spaghetti.",
	"Arch - CLUSTER - Configuration - Charts - kro - Features - templating": "Instead of compiling dynamic templates, Kro uses what Kubernetes understands: actual Kubernetes objects. No abstraction, no guessing what will be rendered, no helm template needed just to see your own app.",
	"Arch - CLUSTER - Configuration - Charts - Structure": "A Helm chart is organized into a directory structure with a few key files.",
	"Arch - CLUSTER - Configuration - Charts - Structure - Chart.yaml": "The Chart.yaml file contains the metadata for the chart, such as the chart name, version, and description.",
	"Arch - CLUSTER - Configuration - Charts - Structure - values.yaml": "The values.yaml file contains the default configuration values for the chart.",
	"Arch - CLUSTER - Configuration - Charts - Structure - /templates/": "The templates/ directory contains the Kubernetes resource definitions for the chart, written in YAML or JSON.",
	"Arch - CLUSTER - Configuration - Charts - Structure - templates/deployment.yaml": ".",
	"Arch - CLUSTER - Configuration - Charts - Structure - templates/service.yaml": ".",
	"Arch - CLUSTER - Configuration - Objects": "Kubernetes objects are persistent entities in the Kubernetes system.",
	"Arch - CLUSTER - Configuration - Objects - namespaces": "Namespaces divide cluster resources among multiple users or teams, creating isolated environments within the same cluster. Virtual clusters that provide a mechanism for isolating groups of resources within a physical cluster.",
	"Arch - CLUSTER - Configuration - Objects - namespaces - names": "Names of resources need to be unique within a namespace, but not across namespaces.",
	"Arch - CLUSTER - Configuration - Objects - namespaces - unique": "Each namescape has its own resources, policies and quotas.",
	"Arch - CLUSTER - Configuration - Objects - namespaces - multitenancy": "Useful for multitenancy (e.g. different teams or environments).",
	"Arch - CLUSTER - Configuration - Objects - namespaces - scope": "Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc.) and not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc.).",
  "Arch - CLUSTER - Configuration - Objects - namespaces - kubectl - create": "kubectl create namespace default-mem-example",
  "Arch - CLUSTER - Configuration - Objects - namespaces - kubectl - delete": "kubectl delete namespace default-mem-example",
	"Arch - CLUSTER - Configuration - Objects - yaml": "Kubernetes objects can be expressed in .yaml format.",
  "Arch - CLUSTER - Configuration - Objects - yaml - fields - apiVersion": "Which version of the Kubernetes API you're using to create this object.",
  "Arch - CLUSTER - Configuration - Objects - yaml - fields - kind": "What kind of object you want to create.",
  "Arch - CLUSTER - Configuration - Objects - yaml - fields - metadata": "Data that helps uniquely identify the object, including a name string, UID, and optional namespace",
  "Arch - CLUSTER - Configuration - Objects - yaml - fields - spec": "What state you desire for the object. The precise format of the object spec is different for every Kubernetes object",
  "Arch - CLUSTER - Configuration - Objects - yaml - kubectl": "kubectl apply -f < file_name >.yaml Create resource",
  "Arch - CLUSTER - Configuration - Objects - manage": "To work with Kubernetes objects--whether to create, modify, or delete them--you'll need to use the Kubernetes API. When you use the kubectl command-line interface, for example, the CLI makes the necessary Kubernetes API calls for you.",
	"Arch - CLUSTER - Configuration - Kustomize": "Kustomize is a standalone tool to customize Kubernetes objects through a kustomization file.",
	"Arch - CLUSTER - Configuration - ConfigMaps": "Stores non-sensitive configuration data. ConfigMaps can be mounted as data volumes.",
	"Arch - CLUSTER - Configuration - ConfigMaps - DataType": "Plain text",
	"Arch - CLUSTER - Configuration - ConfigMaps - kubectl": "kubectl create configmap",
	"Arch - CLUSTER - Configuration - Secrets": "Stores sensitive data (passwords, API keys, certificates)",
	"Arch - CLUSTER - Configuration - Secrets - DataType": "Base64-encoded text",
	"Arch - CLUSTER - Configuration - Secrets - kubectl - create": "kubectl create secret",
	"Arch - CLUSTER - Configuration - Secrets - kubectl - get": "kubectl get secret",
	"Arch - CLUSTER - Configuration - Secrets - kubectl - describe": "kubectl describe secret",
	"Arch - CLUSTER - Configuration - Secrets - kubectl - delete": "kubectl delete secret",
	"Arch - CLUSTER - Configuration - Secrets - kubectl - edit": "kubectl edit secret",
	"Arch - CLUSTER - GarbageCollection": "Garbage collection is a collective term for the various mechanisms Kubernetes uses to clean up cluster resources.",
	"Arch - CLUSTER - Security - RBAC": "Use RBAC (Role Based Access Control) to manage permissions",
	"Arch - CLUSTER - Security - RBAC - ClusterRole": "A ClusterRole defines permissions for resources at the cluster level, facilitating access control across all namespaces.",
	"Arch - CLUSTER - Security - RBAC - Parts": "Consist of: Role, ClusterNode, RoleBinding, ClusterRoleBinding",
	"Arch - CLUSTER - Security - RBAC - Parts - Role": "applies within namespace",
	"Arch - CLUSTER - Security - RBAC - Parts - ClusterNode": "applies to Cluster",
	"Arch - CLUSTER - Security - RBAC - Parts - RoleBinding": "assign a Role to a User or Group",
	"Arch - CLUSTER - Security - RBAC - Parts - ClusterRoleBinding": "assigns a ClusterRole globally",
	"Arch - CLUSTER - Security - ResourceLimits": "Dynamically adjust cluster resources based on actual demand patterns using HPA and Cluster Autoscaler to eliminate idle capacity costs while maintaining performance.",
	"Arch - CLUSTER - Security - ResourceLimits - CPUThrottling": "Understand How CPU Throttling Works. Analyze resource usage patterns to set ap- propriate CPU and memory requests/lim- its, preventing over-provisioning while ensuring application performance.",
	"Arch - CLUSTER - Security - ResourceLimits - OOM": "Memory Limits Trigger OOM Kills. Unlike CPU, memory usage cannot be throttled. If a pod exceeds its memory limit, the OOM (Out of Memory) killer ter- minates it. Always ensure memory re- quests and limits are realistic to avoid unnecessary crashes.",
	"Arch - CLUSTER - Security - ResourceLimits - Adjust": "Monitor and Adjust Requests and Limits Dynamically. Use metrics (e.g., from Prometheus, Kubernetes Metrics Server) to analyze actual resource usage. And adjust requests and limits appropriately. Tools like Vertical Pod Autoscaler (VPA) can help automatically optimize requests.",
	"Arch - CLUSTER - Security - ResourceLimits - QoS": "Understand How QoS Classes Are Determined. Kubernetes assigns Quality of Service (QoS) classes to pods based on their re- quests and limits. Setting proper requests and limits helps ensure critical workloads get the resources they need.",
	"Arch - CLUSTER - Security - NetworkPolicies": "Enable Network Policies to restrict pod-to-pod communication.",
	"Arch - CLUSTER - Security - Encryption": "Enable TLS Encryption for secure API communication",
	"Arch - CLUSTER - Security - Secrets": "Instead of ConfigMaps for sensitive data.",
	"Arch - CLUSTER - Security - Scan": "Scan images for vulnerabilities before deploying.",
	"Arch - CLUSTER - Security - Priviledges": "Limit container priviledges (e.g. root acccess)",
	"Arch - CLUSTER - Logs": ".",
	"Arch - CLUSTER - Logs - Container": "/var/log/pods",
	"Arch - CLUSTER - Monitoring": "Kubernetes does not store logs but provide options as EFK Stack or Prometehus / Graphana (metrics and alerting).",
	"Arch - CLUSTER - Monitoring - kubectl": "kubectl logs 'podname'",
	"Arch - CLUSTER - Monitoring - Tools - Prometheus-Graphana": "Prometheus collects Kubernetes metrics, while Grafana visualizes them in dashboards.",
	"Arch - CLUSTER - Monitoring - Tools - Prometheus-Graphana - ServiceMonitor": "A ServiceMonitor specifies how Prometheus should discover and monitor services, configuring metric scraping and integration with Prometheus.",
	"Arch - CLUSTER - Monitoring - Tools - KubernetesMetricsServer": "Built-in Kubernetes component that provides cluster-wide CPU and memory metrics.",
	"Arch - CLUSTER - Monitoring - Tools - Loki-Fluentd/Fluent Bit": "Loki (by Grafana) is a lightweight log aggregation system. Fluentd and Fluent Bit collect logs from Pods and send them to Loki or Elasticsearch.",
	"Arch - CLUSTER - Monitoring - Tools - KubeStateMetrics": "Exports detailed Kubernetes object metrics (Deployments, Pods, Nodes, etc.).",
	"Arch - CLUSTER - Monitoring - Tools - Falco": "Falco is an open-source intrusion detection system (IDS) for Kubernetes.",
	"Arch - CLUSTER - Monitoring - Tools - Jaeger-OpenTelemetry": "Jaeger provides distributed tracing to debug slow microservices. OpenTelemetry is a modern alternative for tracing across cloud environments.",
	"Arch - CLUSTER - Clients": "Users interact with the API Server (via kubectl, Kubernetes Dashboard, or another tool).",
	"Arch - CLUSTER - Clients - CommandLine - kubectl": "The Kubernetes command-line tool, kubectl, allows you to run commands against Kubernetes clusters. kubectl is the primary Kubernetes CLI — you use it for all interactions with a Kubernetes cluster, no matter how the cluster was created.",
	"Arch - CLUSTER - Clients - CommandLine - kubeadm": "You can use the kubeadm tool to create and manage Kubernetes clusters. It performs the actions necessary to get a minimum viable, secure cluster up and running in a user friendly way.",
	"Arch - CLUSTER - Clients - Dashboard - Kubernetes Dashboard": ".",
	"Arch - CLUSTER - Clients - Dashboard - Rancher": ".",
	"Arch - CLUSTER - Clients - Dashboard - Lens": ".",
	"Arch - CLUSTER - Clients - Dashboard - Octant": ".",
	"Arch - CLUSTER - Clients - Dashboard - Skooner": ".",
	"Arch - CLUSTER - Clients - Dashboard - Kubevious": "https://kubevious.io/.",
	"Arch - CLUSTER - Clients - Dashboard - K9s": "https://k9scli.io/.",
  "Arch - WORKERNODES": "The worker node(s) host the Pods that are the components of the application workload. Every cluster has at least one worker node.",
	"Arch - WORKERNODES - Node": "A node is a virtual or bare-metal machine in a Kubernetes cluster.",
  "Arch - WORKERNODES - Controllers - NodeController": "Responsible for managing Worker Nodes. It will monitor the new Nodes connecting to the cluster, validate the Node's health status based on metrics reported by the Node's Kubelet component, and update the Node's .status field. If a Kubelet stops posting health checks to the API Server, the Node Controller will be responsible for triggering Pod eviction from the missing Node before removing the Node from the cluster.",
  "Arch - WORKERNODES - Controllers - DaemonSetController": "A DaemonSet is an independent object that has its own controller.",
	"Arch - WORKERNODES - Components - kubelet": "The kubelet is the primary node agent that runs on each worker node.",
	"Arch - WORKERNODES - Components - kubelet - functions - register": "It can register the node with the apiserver using one of: the hostname; a flag to override the hostname; or specific logic for a cloud provider.",
	"Arch - WORKERNODES - Components - kubelet - functions - pods": "Runs the pods as defined in their specifications.",
	"Arch - WORKERNODES - Components - kubelet - functions - containers": "Manages containers.",
	"Arch - WORKERNODES - Components - kubelet - functions - containers - PosSpec": "The kubelet takes a set of PodSpecs that are provided through various mechanisms and ensures that the containers described in those PodSpecs are running and healthy.",
	"Arch - WORKERNODES - Components - kubelet - functions - containers - checks": "Runs health checks (liveness and readiness probes) to makes sure that containers are running in a pod.",
	"Arch - WORKERNODES - Components - kubelet - functions - containers - crash": "If a container crashes, the kubelet restarts it automatically.",
	"Arch - WORKERNODES - Components - CRI": "The Container Runtime Interface (CRI) is the main protocol for the communication between the kubelet and Container Runtime.",
  "Arch - WORKERNODES - Components - CRI - ContainerRuntime": "You need a working container runtime on each Node in your cluster, so that the kubelet can launch Pods and their containers.",
	"Arch - WORKERNODES - Components - kube-proxy": "Supports the service abstraction along with other networking operation.",
	"Arch - WORKERNODES - State": "",
	"Arch - WORKERNODES - State - Ready": "Node is operating normally.",
	"Arch - WORKERNODES - State - NotReady": "Node can't schedule pods.",
	"Arch - WORKERNODES - State - SchedulingDisabled": "The node is functioning normally but can't schedule pods because admins have used Kubernetes 'cordon' feature to disable scheduling on that node.",
	"Arch - WORKERNODES - State - Unknown": "The node is completely unreachable, typically due either to a failed network connection or because the node has permanently shut down.",
	"Arch - WORKERNODES - Lifecycle - Provisioning": "A machine (cloud or on-prem) is created. You, a cloud provider, or a cluster autoscaler. e.g. AWS EC2 instance spins up.",
	"Arch - WORKERNODES - Lifecycle - Registration": "The node registers itself with the Kubernetes control plane via the kubelet. The kubelet calls the API server and says “Hey, I’m here!”",
	"Arch - WORKERNODES - Lifecycle - Ready": "Node passes health checks and is ready to run pods.",
	"Arch - WORKERNODES - Lifecycle - NotReady": "Node fails health checks or kubelet stops reporting. Triggers: Network failure, resource exhaustion, kubelet crash. K8s behavior: Stops scheduling new pods and may evict existing ones depending on settings.",
	"Arch - WORKERNODES - Lifecycle - Running": "Node is actively running workloads (pods), reporting metrics, and responding to health checks.",
	"Arch - WORKERNODES - Lifecycle - Running - describe": "kubectl describe node < node_name >",
	"Arch - WORKERNODES - Lifecycle - Running - get": "kubectl get node < node_name >",
	"Arch - WORKERNODES - Lifecycle - Cordoned": "kubectl cordon < node > Node is manually marked unschedulable, so no new pods will land here.",
	"Arch - WORKERNODES - Lifecycle - Cordoned - uncordon": "kubectl uncordon < node >",
	"Arch - WORKERNODES - Lifecycle - Draining": "kubectl drain < node > Gracefully evicts pods to other nodes.",
	"Arch - WORKERNODES - Lifecycle - Deleted": "kubectl delete node < node > Node is removed from the cluster.",
	"Arch - WORKERNODES - Lifecycle - FailingNode": "Events when a node fails: NotReady + Pods Eviction + Autoscaler",
	"Arch - WORKERNODES - Lifecycle - FailingNode - kubelet": "kubelet marks the node as NotReady",
	"Arch - WORKERNODES - Lifecycle - FailingNode - Eviction": "Pods are evicted and rescheduled",
	"Arch - WORKERNODES - Lifecycle - FailingNode - Autoscaler": "Cluster AutoScaler may replace the failed node.",
	"Arch - WORKERNODES - Monitoring - kubectl": "kubectl top node < node_name >",
	"Arch - WORKERNODES - Monitoring - Status": "A node’s status contains the following information: Addresses, Condition, Capacity, Info",
  "Arch - WORKERNODES - Monitoring - Status - Addresses": "The usage of these fields varies depending on your cloud provider or bare metal configuration.",
  "Arch - WORKERNODES - Monitoring - Status - Condition": "The conditions field describes the status of all Running nodes.",
  "Arch - WORKERNODES - Monitoring - Status - Capacity": "Describes the resources available on the node: CPU, memory, and the maximum number of pods that can be scheduled onto the node.",
  "Arch - WORKERNODES - Monitoring - Status - Info": "Describes general information about the node, such as kernel version, Kubernetes version (kubelet and kube-proxy version), container runtime details, and which operating system the node uses. The kubelet gathers this information from the node and publishes it into the Kubernetes API.",
  "Arch - WORKERNODES - Monitoring - Status - Heartbeats": "Heartbeats, sent by Kubernetes nodes, help your cluster determine the availability of each node, and to take action when failures are detected.",
  "Arch - WORKERNODES - Errors - NodeMemoryPressure": "Node is running out of memory resource.",
	"Arch - POD": "Pods are the smallest scalable units. A pod is one or more containers deployed together on one host.",
	"Arch - POD - Configuration - Patterns": "",
	"Arch - POD - Configuration - Patterns - Container": "Typically, you only have one app container in a Pod.",
	"Arch - POD - Configuration - Patterns - Sidecar": "SidecarContainers are the secondary containers that run along with the main application container within the same Pod. These containers are used to enhance or to extend the functionality of the primary app container by providing additional services, or functionality such as logging, monitoring, security, or data synchronization, without directly altering the primary application code.",
	"Arch - POD - Configuration - Specification": "Defines how and where a Pod should run.",
	"Arch - POD - Configuration - SecurityContext": "A security context defines privilege and access control settings for a Pod",
	"Arch - POD - Configuration - SecurityContext - PSP": "PodSecurityPolicies (PSPs) were a Kubernetes feature used to control security settings for Pods before they were admitted into the cluster.",
	"Arch - POD - Configuration - SecurityContext - PSP - deprecated": "PodSecurityPolicies were deprecated in Kubernetes v1.21 and removed in v1.25.",
	"Arch - POD - Configuration - SecurityContext - PSA": "Pod Security Admission (PSA) (Built-in Replacement). Introduced in Kubernetes v1.23 as a lighter, simpler replacement for PSPs..",
	"Arch - POD - Configuration - SecurityContext - OPA": "Open Policy Agent (OPA) & Gatekeeper. A more flexible, policy-driven alternative to PSPs.",
	"Arch - POD - Configuration - SecurityContext - Kyverno": "Kyverno (Kubernetes-Native Policy Engine). Easier to use than OPA/Gatekeeper, with YAML-based policies.",
	"Arch - POD - Lifecyle": "",
  "Arch - POD - Lifecyle - Creation": "",
  "Arch - POD - Lifecyle - Creation - Creators - Manual - kubectl": "kubectl run <pod_name > Create pod",
  "Arch - POD - Lifecyle - Creation - Creators - Processes - kube-controller-manager": "",
  "Arch - POD - Lifecyle - Creation - Creators - Controllers - ReplicationController - deprecated": "A replication controller ensures a pod (or multiple copies) is always up and running. If the pod disappears for any reason (like in the event of a node disappearing from the cluster), the replication controller creates a new pod immediately",
  "Arch - POD - Lifecyle - Creation - Creators - Controllers - ReplicaSetController": " Improved version of ReplicationController. Responsible for creating/modifying Pods based on the ReplicaSet object configuration.",
  "Arch - POD - Lifecyle - Creation - Creators - Controllers - DeploymentController": "Manages ReplicaSets. Support features as rolling updates, declarative updates, rollbacks.",
  "Arch - POD - Lifecyle - Creation - Creators - Controllers - StatefulSetController": "Responsible for creating Pods in a guaranteed order with a sticky identity.",
  "Arch - POD - Lifecyle - Creation - Creators - Controllers - Job": "Job - A Job creates one or more short-lived Pods and expects them to successfully terminate.",
  "Arch - POD - Lifecyle - Creation - Creators - Controllers - CronJobController": "CronJob Controller: Responsible for creating Job objects based on the Cron schedule defined in CronJob objects.",
	"Arch - POD - Lifecyle - Creation - Process - 1.CRI": "The Container Runtime Interface (CRI) creates the containers for the Pod.",
  "Arch - POD - Lifecyle - Creation - Process - 2.CNI": "The Container Network Interface (CNI) connects the containers to the cluster network and assigns IP addresses.",
  "Arch - POD - Lifecyle - Creation - Process - 3.CSI": "The Container Storage Interface (CSI) mounts volumes in your containers.",
  "Arch - POD - Lifecyle - Schedule - Scheduler": "kube-scheduler. Watches for newly created Pods, finding the best Node for that Pod and assigns it.",
  "Arch - POD - Lifecyle - Schedule - NodeSelection": "Specifies which node the pod can be scheduled on.",
  "Arch - POD - Lifecyle - Schedule - NodeSelection - Affinity": "Schedule pods based on more advanced rules.",
  "Arch - POD - Lifecyle - Schedule - NodeSelection - Affinity - Node": "Schedule pods on specific nodes based on labels.",
  "Arch - POD - Lifecyle - Schedule - NodeSelection - Affinity - NodeAffinity": "Node affinity is conceptually similar to nodeSelector, allowing you to constrain which nodes your Pod can be scheduled on based on node labels.",
  "Arch - POD - Lifecyle - Schedule - NodeSelection - Affinity - NodeAffinity - requiredDuringSchedulingIgnoredDuringExecution": "The scheduler can't schedule the Pod unless the rule is met. This functions like nodeSelector, but with a more expressive syntax.",
  "Arch - POD - Lifecyle - Schedule - NodeSelection - Affinity - NodeAffinity - preferredDuringSchedulingIgnoredDuringExecution": "The scheduler tries to find a node that meets the rule. If a matching node is not available, the scheduler still schedules the Pod.",
  "Arch - POD - Lifecyle - Schedule - NodeSelection - Affinity - NodeAffinityWeight": "You can specify a weight between 1 and 100 for each instance of the preferredDuringSchedulingIgnoredDuringExecution affinity type. When the scheduler finds nodes that meet all the other scheduling requirements of the Pod, the scheduler iterates through every preferred rule that the node satisfies and adds the value of the weight for that expression to a sum. The final sum is added to the score of other priority functions for the node. Nodes with the highest total score are prioritized when the scheduler makes a scheduling decision for the Pod.",
  "Arch - POD - Lifecyle - Schedule - NodeSelection - Affinity - Pod": "Schedule pods close together.",
  "Arch - POD - Lifecyle - Schedule - NodeSelection - Affinity - PodAffinity": "Avoids placing pods in the same node.",
  "Arch - POD - Lifecyle - Schedule - NodeSelection - Affinity - PodAffinity - requiredDuringSchedulingIgnoredDuringExecution": "requiredDuringSchedulingIgnoredDuringExecution affinity to tell the scheduler to co-locate Pods of two services in the same cloud provider zone because they communicate with each other a lot..",
  "Arch - POD - Lifecyle - Schedule - NodeSelection - Affinity - PodAffinity - preferredDuringSchedulingIgnoredDuringExecution": "preferredDuringSchedulingIgnoredDuringExecution anti-affinity to spread Pods from a service across multiple cloud provider zones..",
  "Arch - POD - Lifecyle - Schedule - NodeSelection - Affinity - PodAntiAffinity": "Avoids placing pods in the same node.",
	"Arch - POD - Lifecyle - Schedule - NodeSelection - Taints": "Prevents pods to be scheduled on certain nodes unless the pod tolerates them. Used to dedicate nodes to specific workloads.",
	"Arch - POD - Lifecyle - Schedule - NodeSelection - Tolerations": "Allow pods to be scheduled on tainted nodes.",
  "Arch - POD - Lifecyle - Schedule - NodeName": "nodeName is a more direct form of node selection than affinity or nodeSelector. nodeName is a field in the Pod spec. If the nodeName field is not empty, the scheduler ignores the Pod and the kubelet on the named node tries to place the Pod on that node. Using nodeName overrules using nodeSelector or affinity and anti-affinity rules.",
  "Arch - POD - Lifecyle - Schedule - Errors - PendingPods": "Kubernetes unable to schedule the Pod onto a Node.",
  "Arch - POD - Lifecyle - Schedule - Errors - NodeNotReady": "The node is not ready for scheduling.",
	"Arch - POD - Lifecyle - Running - NoUpdate": "Since Pods are intended to be disposable and replaceable, you cannot add a container to a Pod once it has been created.",
	"Arch - POD - Lifecyle - Running - kubectl - get": "kubectl get pod",
	"Arch - POD - Lifecyle - Running - kubectl - edit": "kubectl edit pod < podName >",
	"Arch - POD - Lifecyle - Running - kubectl - describe": "kubectl describe pod < podName >",
	"Arch - POD - Lifecyle - Running - kubectl - logs": "kubectl logs pod < podName >",
	"Arch - POD - Lifecyle - Running - kubectl - execute": "kubectl exec < pod > -- < command >'",
	"Arch - POD - Lifecyle - Eviction": "The cluster is kicking the pod out for a reason (but might bring it back elsewhere).",
	"Arch - POD - Lifecyle - Eviction - Trigger": "Kubernetes itself — typically due to node pressure (CPU, memory, disk) or cluster autoscaling, or if the pod violates certain policies (like a PodDisruptionBudget).",
  "Arch - POD - Lifecyle - Eviction - Causes - Preemption": "Preemption is the process of terminating Pods with lower Priority so that Pods with higher Priority can schedule on Nodes.",
	"Arch - POD - Lifecyle - Eviction - Causes - Preemption - Scoring": "During the Scoring step, kube-scheduler will take the resulting list from Taints and Tolerations and assign a score to each of the nodes. This way, candidate nodes are ordered from most suitable to least. In case two nodes have the same score, kube-scheduler orders them randomly.",
  "Arch - POD - Lifecyle - Eviction - Causes - Preemption - PodPriorityClasses": "Each Pod Priority Class has a numerical priority value (higher values mean higher priority). When scheduling, Kubernetes considers this priority value to decide whether a Pod should preempt others.",
	"Arch - POD - Lifecyle - Eviction - Causes - Preemption - PodPriorityClasses - Higher": "Higher-priority Pods get scheduled first.",
	"Arch - POD - Lifecyle - Eviction - Causes - Preemption - PodPriorityClasses - lower": "Lower-priority Pods may get evicted by the scheduler",
  "Arch - POD - Lifecyle - Eviction - Causes - NodePressure": "In case a resource (like CPU or memory) consumption in the node reaches a certain threshold, kubelet will start evicting Pods in order to free up the resource.",
  "Arch - POD - Lifecyle - Eviction - Causes - NodePressure - QoS": "Quality of Service (QoS) will be taken into account to determine the eviction order.",
	"Arch - POD - Lifecyle - Eviction - Causes - NodePressure - QoS - Definition": "Kubernetes assigns a QoS class to each Pod as a consequence of the resource constraints that you specify for the containers in that Pod. Kubernetes relies on this classification to make decisions about which Pods to evict when there are not enough available resources on a Node.",
	"Arch - POD - Lifecyle - Eviction - Causes - NodePressure - QoS - Guaranteed": "Pods that are Guaranteed have the strictest resource limits and are least likely to face eviction. They are guaranteed not to be killed until they exceed their limits or there are no lower-priority Pods that can be preempted from the Node. They may not acquire resources beyond their specified limits. These Pods can also make use of exclusive CPUs using the static CPU management policy.",
	"Arch - POD - Lifecyle - Eviction - Causes - NodePressure - QoS - Burstable": "Pods that are Burstable have some lower-bound resource guarantees based on the request, but do not require a specific limit. If a limit is not specified, it defaults to a limit equivalent to the capacity of the Node, which allows the Pods to flexibly increase their resources if resources are available. In the event of Pod eviction due to Node resource pressure, these Pods are evicted only after all BestEffort Pods are evicted. Because a Burstable Pod can include a Container that has no resource limits or requests, a Pod that is Burstable can try to use any amount of node resources.",
	"Arch - POD - Lifecyle - Eviction - Causes - NodePressure - QoS - BestEffort": "Pods in the BestEffort QoS class can use node resources that aren't specifically assigned to Pods in other QoS classes. For example, if you have a node with 16 CPU cores available to the kubelet, and you assign 4 CPU cores to a Guaranteed Pod, then a Pod in the BestEffort QoS class can try to use any amount of the remaining 12 CPU cores. The kubelet prefers to evict BestEffort Pods if the node comes under resource pressure.",
	"Arch - POD - Lifecyle - Eviction - Causes - APIInitiatedEviction": "You can request an on-demand eviction of a Pod in one of your nodes by using Kubernetes Eviction API.",
	"Arch - POD - Lifecyle - Eviction - Causes - TaintBasedEviction": "With Kubernetes Taints and Tolerations you can guide how your Pods should be assigned to Nodes. But if you apply a NoExecute taint to an existing Node, all Pods which are not tolerating it will be immediately evicted.",
	"Arch - POD - Lifecyle - Eviction - Causes - NodeDrain": "There are times when Nodes become unusable or you don’t want to work on them anymore. The command kubectl cordon prevents new Pods to be scheduled on it, but there’s also the possibility to completely empty all current Pods at once. If you run kubectl drain nodename, all Pods in the node will be evicted, respecting its graceful termination period.",
	"Arch - POD - Lifecyle - Eviction - Process": "K8s starts the process of removing the pod from the node — either temporarily or permanently — and tries to reschedule it elsewhere.",
	"Arch - POD - Lifecyle - Eviction - Status": "Might show up as Evicted in pod events or status.",
  "Arch - POD - Lifecyle - Delete": "Kubernetes gracefully shuts down the pod, giving it time to clean up (respecting terminationGracePeriodSeconds).",
  "Arch - POD - Lifecyle - Delete - Trigger - User": "kubectl delete pod",
  "Arch - POD - Lifecyle - Delete - Trigger - Controller": ".",
  "Arch - POD - Lifecyle - Delete - Process": "When the Pod is deleted by using kubectl, you must follow the same steps but reversely with containers.",
  "Arch - POD - Lifecyle - Delete - Status": "Becomes Terminating during the process.",
	"Arch - POD - Lifecyle - Delete - RestartPolicy": "A Restart Policy is a property set for each Pod in Kubernetes that controls what happens when a container in the Pod terminates. The restart policy is applied at the Pod level but acts on individual containers within the Pod.",
	"Arch - POD - Lifecyle - Delete - RestartPolicy - Always": ".",
	"Arch - POD - Lifecyle - Delete - RestartPolicy - OnFailure": ".",
	"Arch - POD - Lifecyle - Delete - RestartPolicy - Never": ".",
	"Arch - POD - Lifecyle - Delete - RestartPolicy - default": ".",
	"Arch - POD - Lifecyle - Delete - RestartPolicy - default - Deployments": "The default restart policy for a Deployment is Always, as Deployments are used for running continuously available services. Even if a Pod crashes, Kubernetes will attempt to recreate the Pod to ensure that the service remains available.",
	"Arch - POD - Lifecyle - Delete - RestartPolicy - default - Jobs": "For Jobs, you would typically use OnFailure or Never, depending on whether you want the Job to retry on failure. Jobs are used for batch tasks that should complete once, like data processing jobs or migrations.",
	"Arch - POD - Lifecyle - Delete - RestartPolicy - default - DaemonSets": "Like Deployments, DaemonSets also use the default Always policy, as they are designed to run continuously on all nodes.",
	"Arch - POD - Lifecyle - Troubleshoot - FailingPod": "check status, describe info, check logs, shell",
	"Arch - POD - Lifecyle - Troubleshoot - FailingPod - status": "Check pod status: kubectl get pods",
	"Arch - POD - Lifecyle - Troubleshoot - FailingPod - describe": "Describe pod for detailed info: kubectl describe pod 'podname'.",
	"Arch - POD - Lifecyle - Troubleshoot - FailingPod - log": "Check logs: kubectl logs 'podname'.",
	"Arch - POD - Lifecyle - Troubleshoot - FailingPod - shell": "Access pod shell: kubectl exec -it 'podname' /bin/sh .",
	"Arch - POD - Lifecyle - Troubleshoot - FailingPod - PDB": "A Pod Disruption Budget (PDB) is a Kubernetes mechanism that helps protect applications from voluntary disruptions (like node upgrades, draining, or scaling operations). It defines how many Pods of a deployment, statefulset, or replicaset must always be available during such disruptions.",
	"Arch - POD - Lifecyle - Troubleshoot - FailingPod - PDB - HA": "PDB ensures high availability by limiting the number of pods that can be disrupted at the same time.",
	"Arch - POD - Lifecyle - PodStatus": "A Pod has a PodStatus, which has an array of PodConditions and a phase field.",
  "Arch - POD - Lifecyle - PodStatus - PodPhase": "The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle. The phase is not intended to be a comprehensive rollup of observations of Container or Pod state, nor is it intended to be a comprehensive state machine. The number and meanings of Pod phase values are tightly guarded. Other than what is documented here, nothing should be assumed about Pods that have a given phase value. Here are the possible values for phase:",
  "Arch - POD - Lifecyle - PodStatus - PodPhase - Pending": "The Pod has been accepted by the Kubernetes system, but one or more of the Container images has not been created. This includes time before being scheduled as well as time spent downloading images over the network, which could take a while..",
  "Arch - POD - Lifecyle - PodStatus - PodPhase - Running": "The Pod has been bound to a node, and all of the Containers have been created. At least one Container is still running, or is in the process of starting or restarting..",
  "Arch - POD - Lifecyle - PodStatus - PodPhase - Succeeded": "All Containers in the Pod have terminated in success, and will not be restarted.",
  "Arch - POD - Lifecyle - PodStatus - PodPhase - Failed": "All Containers in the Pod have terminated, and at least one Container has terminated in failure. That is, the Container either exited with non-zero status or was terminated by the system. Kubernetes uses the restart policy to determine what to do if a container reaches a failed state.",
  "Arch - POD - Lifecyle - PodStatus - PodPhase - Unknown": "For some reason the state of the Pod could not be obtained, typically due to an error in communicating with the host of the Pod.",
  "Arch - POD - Lifecyle - PodStatus - PodPhase - Errors - CrashLoopBackOff": "Pod keeps restarting due to errors. Container repeatedly crashing and restarting.",
  "Arch - POD - Lifecyle - PodStatus - PodConditions": "PodConditions through which the Pod has or has not passed. Kubelet manages the following PodConditions",
  "Arch - POD - Lifecyle - PodStatus - PodConditions - PodScheduled": "the Pod has been scheduled to a node.",
  "Arch - POD - Lifecyle - PodStatus - PodConditions - PodReadyToStartContainers": "PodReadyToStartContainers: (beta feature; enabled by default) the Pod sandbox has been successfully created and networking configured.",
  "Arch - POD - Lifecyle - PodStatus - PodConditions - ContainersReady": "all containers in the Pod are ready.",
  "Arch - POD - Lifecyle - PodStatus - PodConditions - Initialized": "Initialized: all init containers have completed successfully.",
  "Arch - POD - Lifecyle - PodStatus - PodConditions - Ready": "Ready: the Pod is able to serve requests and should be added to the load balancing pools of all matching Services.",
	"Arch - POD - Monitoring - kubectl": "kubectl top pod < pod_name >",
	"Arch - POD - Shared": "Containers in a pod share Namespaces, cgroups, Volumes, IP, HelperContainers.",
	"Arch - POD - Shared - HelperContainers": "Pods enable sidecar partterns where helper containers assit the main application.",
	"Arch - POD - Shared - NetworkNamespace": "Containers within the pod share the same network namespace",
	"Arch - POD - Shared - Localhost": "Containers within the pod can communicate with Localhost",
	"Arch - POD - Shared - Port": "Containers within the pod can cannot share the Port. Conflicts will occur.",
	"Arch - POD - Shared - IP": "All containers share the same IP and port space.",
	"Arch - POD - Shared - IP - NotUse - Unknown": "Isn’t easy to know what IP will be assigned to a pod ahead of time. This makes it nearly impossible to store IP information in a configuration where other applications can access it.",
	"Arch - POD - Shared - IP - NotUse - Multiple": "Many workloads create multiple pods — in some cases, dynamically. This means, at any point in time, we may not know how many pods are running for a given application.",
	"Arch - POD - Shared - IP - NotUse - Volatile": "Pods are nonpermanent resources. They are meant to start and stop over time, and each time this happens, it’s more than likely they will get a new IP address.",
	"Arch - POD - Shared - cgroups": "The same cgroups (resource limits)",
	"Arch - POD - Shared - volumes": "Volumes mounted in the pod are available to all containers.",
	"Arch - Container": "The word container is defined as a specific running or paused instance of a container image.",
	"Arch - Container - Configuration - Features - decoupled": "Containers decouple applications from the underlying host infrastructure. This makes deployment easier in different cloud or OS environments.",
  "Arch - Container - Configuration - Features - repeatable": "Each container that you run is repeatable; the standardization from having dependencies included means that you get the same behavior wherever you run it.",
  "Arch - Container - Configuration - Features - neighbours": "Containers in a Pod are co-located and co-scheduled to run on the same node.",
	"Arch - Container - Configuration - DownwardAPI": "The downward API allows containers to consume information about themselves or the cluster without using the Kubernetes client or API server.",
	"Arch - Container - Configuration - DownwardAPI - Mechanisms": "There are two ways to expose Pod and container fields to a running container: environment variables, and as files that are populated by a special volume type. Together, these two ways of exposing Pod and container fields are called the downward API.",
	"Arch - Container - Configuration - Environment": "The Kubernetes Container environment provides several important resources to Containers:.",
  "Arch - Container - Configuration - Environment - filesystem": "A filesystem, which is a combination of an image and one or more volumes.",
  "Arch - Container - Configuration - Environment - Container info": "The hostname of a Container is the name of the Pod in which the Container is running. It is available through the hostname command or the gethostname function call in libc. The Pod name and namespace are available as environment variables through the downward API. User defined environment variables from the Pod definition are also available to the Container, as are any environment variables specified statically in the container image.",
  "Arch - Container - Configuration - Environment - Cluster info": "A list of all services that were running when a Container was created is available to that Container as environment variables. This list is limited to services within the same namespace as the new Container's Pod and Kubernetes control plane services.",
	"Arch - Container - Configuration - Types": "",
  "Arch - Container - Configuration - Types - InitContainers": "They are run before the app containers are started.",
  "Arch - Container - Configuration - Types - InitContainers - goal": "Init containers support all the fields and features of app containers, including resource limits, volumes, and security settings.",
  "Arch - Container - Configuration - Types - InitContainers - multiple": "If you specify multiple init containers for a Pod, kubelet runs each init container sequentially. Each init container must succeed before the next can run. When all of the init containers have run to completion, kubelet initializes the application containers for the Pod and runs them as usual.",
  "Arch - Container - Configuration - Types - InitContainers - fail": "If a Pod's init container fails, the kubelet repeatedly restarts that init container until it succeeds. However, if the Pod has a restartPolicy of Never, and an init container fails during startup of that Pod, Kubernetes treats the overall Pod as failed.",
  "Arch - Container - Configuration - Types - AppContainers": "Run the application in the Pod.",
  "Arch - Container - Configuration - Types - AppContainers - unique": "Typically, you only have one app container in a Pod.",
  "Arch - Container - Configuration - Types - SidecarContainers": "Sidecar containers are the secondary containers that run along with the main application container within the same Pod. These containers are used to enhance or to extend the functionality of the primary app container by providing additional services, or functionality such as logging, monitoring, security, or data synchronization, without directly altering the primary application code. For example, if you have a web application that requires a local webserver, the local webserver is a sidecar and the web application itself is the app container.",
  "Arch - Container - Configuration - Types - SidecarContainers - goal": "These containers are used to enhance or to extend the functionality of the primary app container by providing additional services, or functionality such as logging, monitoring, security, or data synchronization, without directly altering the primary application code.",
  "Arch - Container - Configuration - Types - EphemeralContainers": "You use ephemeral containers to inspect services rather than to build applications. Ephemeral containers differ from other containers in that they lack guarantees for resources or execution, and they will never be automatically restarted, so they are not appropriate for building applications.",
	"Arch - Container - Configuration - SecurityContext": "A SecurityContext defines privilege and access control settings for a Container",
	"Arch - Container - Lifecycle - Creation - ContainerRuntime": "The container runtime in Kubernetes is the software responsible for running containers on a node.",
	"Arch - Container - Lifecycle - Creation - ContainerRuntime - docker": "Previously the most popular runtime, but Kubernetes stopped supporting Docker directly in version 1.20. However, Docker still works because it uses containerd under the hood",
	"Arch - Container - Lifecycle - Creation - ContainerRuntime - containerd": "default in most Kubernetes distributions. Lightweight and efficient, Originally part of Docker but now independent, Used by many Kubernetes providers like GKE, EKS, and AKS",
	"Arch - Container - Lifecycle - Creation - ContainerRuntime - CRI-O": "Designed specifically for Kubernetes, Lightweight and optimized for performance",
  "Arch - Container - Lifecycle - Creation - Process - 1.CRI": "Kubelet calls the container runtime via the Container Runtime Interface (CRI).",
  "Arch - Container - Lifecycle - Creation - Process - 2.image": "The container runtime pulls the image from a registry (e.g., Docker Hub, ECR, GCR). A container image is a ready-to-run software package containing everything needed to run an application: the code and any runtime it requires, application and system libraries, and default values for any essential settings.",
  "Arch - Container - Lifecycle - Creation - Process - 2.image - Image Registry": "An image registry is a content server that can store and serve container images.",
  "Arch - Container - Lifecycle - Creation - Process - 2.image - Image Registry - PublicRepositories": "Public image repositories, like Docker Hub, are accessible by anyone. They host container images made available to the public.",
  "Arch - Container - Lifecycle - Creation - Process - 2.image - Image Registry - PrivateRepositories": "Private repositories are restricted, requiring authentication for access. They host proprietary or sensitive images.",
  "Arch - Container - Lifecycle - Creation - Process - 2.image - ImagePull": ".",
  "Arch - Container - Lifecycle - Creation - Process - 2.image - ImagePull - Policy": "The choice of image pull policy Always, IfNotPresent, or Never is more than a configuration detail; it's a strategic decision that impacts applications' efficiency, reliability, and security.",
  "Arch - Container - Lifecycle - Creation - Process - 2.image - ImagePull - Policy - Always": "Always pull the image from the repository.",
  "Arch - Container - Lifecycle - Creation - Process - 2.image - ImagePull - Policy - IfNotPresent": "Pulls the image if not already present locally.",
  "Arch - Container - Lifecycle - Creation - Process - 2.image - ImagePull - Policy - Never": "Never pull the image; only use local images.",
  "Arch - Container - Lifecycle - Creation - Process - 2.image - ImagePull - Errors - ImagePullBackOff": "Issues pulling the container image which may be due to registry auth issue or wrong image configuration.",
  "Arch - Container - Lifecycle - Creation - Process - 2.image - ImagePull - Errors - ErrImagePull": "Issues pulling the container image which may be due to registry auth issue or wrong image configuration.",
	"Arch - Container - Lifecycle - Creation - Process - 3.CR": "The container runtime starts the container inside the Pod.",
	"Arch - Container - Lifecycle - Running - ": ".",
  "Arch - Container - Lifecycle - Running - Hooks": "The hooks enable Containers to be aware of events in their management lifecycle and run code implemented in a handler when the corresponding lifecycle hook is executed.",
  "Arch - Container - Lifecycle - Running - Hooks - Types - PostStart": "This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. No parameters are passed to the handler.",
  "Arch - Container - Lifecycle - Running - Hooks - Types - PreStop": "This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod's termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period. No parameters are passed to the handler.",
  "Arch - Container - Lifecycle - Running - Hooks - Handlers": "Containers can access a hook by implementing and registering a handler for that hook.",
  "Arch - Container - Lifecycle - Running - Hooks - Handlers - exec": "Executes a specific command, such as pre-stop.sh, inside the cgroups and namespaces of the Container. Resources consumed by the command are counted against the Container.",
  "Arch - Container - Lifecycle - Running - Hooks - Handlers - http": "Executes an HTTP request against a specific endpoint on the Container.",
  "Arch - Container - Lifecycle - Monitoring - States": "Kubernetes tracks the state of each container inside a Pod.",
  "Arch - Container - Lifecycle - Monitoring - States - Running": "The Running status indicates that a container is executing without issues. If there was a postStart hook configured, it has already executed and finished. When you use kubectl to query a Pod with a container that is Running, you also see information about when the container entered the Running state.",
  "Arch - Container - Lifecycle - Monitoring - States - Terminated": "A container in the Terminated state began execution and then either ran to completion or failed for some reason. When you use kubectl to query a Pod with a container that is Terminated, you see a reason, an exit code, and the start and finish time for that container's period of execution. If a container has a preStop hook configured, this hook runs before the container enters the Terminated state.",
  "Arch - Container - Lifecycle - Monitoring - States - Waiting": "If a container is not in either the Running or Terminated state, it is Waiting. A container in the Waiting state is still running the operations it requires in order to complete start up: for example, pulling the container image from a container image registry, or applying Secret data. When you use kubectl to query a Pod with a container that is Waiting, you also see a Reason field to summarize why the container is in that state.",
	"Arch - Container - Lifecycle - Monitoring - Probes": "A probe is a diagnostic performed periodically by the kubelet on a container. To perform a diagnostic, the kubelet either executes code within the container, or makes a network request.",
  "Arch - Container - Lifecycle - Monitoring - Probes - Types": "The kubelet can optionally perform and react to three kinds of probes on running containers:",
  "Arch - Container - Lifecycle - Monitoring - Probes - Types - Liveness": "Indicates whether the container is running. If the liveness probe fails, the kubelet kills the container, and the container is subjected to its restart policy. If a container does not provide a liveness probe, the default state is Success.",
  "Arch - Container - Lifecycle - Monitoring - Probes - Types - Leadiness": "Indicates whether the container is ready to respond to requests. If the readiness probe fails, the endpoints controller removes the Pod's IP address from the endpoints of all Services that match the Pod. The default state of readiness before the initial delay is Failure. If a container does not provide a readiness probe, the default state is Success.",
  "Arch - Container - Lifecycle - Monitoring - Probes - Types - Startup": "Indicates whether the application within the container is started. All other probes are disabled if a startup probe is provided, until it succeeds. If the startup probe fails, the kubelet kills the container, and the container is subjected to its restart policy. If a container does not provide a startup probe, the default state is Success.",
	"Arch - Container - Lifecycle - Monitoring - Probes - check": "There are four different ways to check a container using a probe.: exec, grpc, httpGet, tcpSocket",
  "Arch - Container - Lifecycle - Monitoring - Probes - check - exec": "Executes a specified command inside the container. The diagnostic is considered successful if the command exits with a status code of 0.",
  "Arch - Container - Lifecycle - Monitoring - Probes - check - grpc": "Performs a remote procedure call using gRPC. The target should implement gRPC health checks. The diagnostic is considered successful if the status of the response is SERVING.",
  "Arch - Container - Lifecycle - Monitoring - Probes - check - httpGet": "Performs an HTTP GET request against the Pod's IP address on a specified port and path. The diagnostic is considered successful if the response has a status code greater than or equal to 200 and less than 400.",
  "Arch - Container - Lifecycle - Monitoring - Probes - check - tcpSocket": "Performs a TCP check against the Pod's IP address on a specified port. The diagnostic is considered successful if the port is open. If the remote system (the container) closes the connection immediately after it opens, this counts as healthy.",
  "Arch - Container - Lifecycle - Monitoring - Probes - outcome": "Each probe has one of three results:",
  "Arch - Container - Lifecycle - Monitoring - Probes - outcome - Success": "The container passed the diagnostic:",
  "Arch - Container - Lifecycle - Monitoring - Probes - outcome - Failure": "The container failed the diagnostic.",
  "Arch - Container - Lifecycle - Monitoring - Probes - outcome - Unknown": "The diagnostic failed (no action should be taken, and the kubelet will make further checks).",
  "Arch - Container - Errors - OOMKilled": "Container terminated because it exceeded its memory limit.",
	"Arch - STORAGE - Volume": "Directory accessible to the containers in a pod.",
  "Arch - STORAGE - Volume - PV": "A PersistentVolume (PV) is a physical or virtual storage resource provisioned in a Kubernetes cluster. It represents an actual storage unit that an administrator or a storage class provides.",
  "Arch - STORAGE - Volume - VolumeSnapshot": "In Kubernetes, a VolumeSnapshot represents a snapshot of a volume on a storage system.",
  "Arch - STORAGE - Volume - Types - persistent": "",
  "Arch - STORAGE - Volume - Types - persistent - snapshots": "In Kubernetes, a VolumeSnapshot represents a snapshot of a volume on a storage system.",
  "Arch - STORAGE - Volume - Types - emptyDir": "Temporary directory that shares a pod lifetime.",
  "Arch - STORAGE - Volume - Types - hostPath": "Mounts a file/directory from host node.",
  "Arch - STORAGE - Volume - Types - PVC": "Use a PersistentVolume",
  "Arch - STORAGE - Volume - Types - configMap": "Special Volumes for configuration.",
  "Arch - STORAGE - Volume - Types - secret": "Special Volumes for configuration.",
  "Arch - STORAGE - Volume - Types - projected": "",
  "Arch - STORAGE - Volume - Types - ephemeral": "On-disk files in a Container are ephemeral, which presents some problems for non-trivial applications when running in Containers. First, when a Container crashes, kubelet will restart it, but the files will be lost - the Container starts with a clean state. Second, when running Containers together in a Pod it is often necessary to share files between those Containers. The Kubernetes Volume abstraction solves both of these problems.",
	"Arch - STORAGE - Volume - Usage - Configuration - ConfigMaps": ".",
	"Arch - STORAGE - Volume - Usage - Configuration - Secrets": "",
	"Arch - STORAGE - Volume - Lifecycle - Provision - Dynamic - StorageClass": "Instead of manually creating PVs, Kubernetes can dynamically provision them using a StorageClass.",
  "Arch - STORAGE - Volume - Lifecycle - Provision - Dynamic - PVC": "A PersistentVolumeClaim (PVC) is a request for storage by a Pod. It asks Kubernetes for a PV with specific characteristics.",
  "Arch - STORAGE - Volume - Communication - CSI": "Container Storage Interface was developed as a standard for exposing arbitrary block and file storage storage systems to Kubernetes. Container Storage Interface (CSI) is an initiative to unify the storage interface of Container Orchestrator Systems (COs) combined with storage vendors like Ceph, Portworx, NetApp etc.",
  "Arch - STORAGE - Volume - Communication - CSI - project": "On introduction of CSI, Kubernetes team released some external components which are not part of the core and that can interact with vendor implemented external components. They communicate to each other over gRPC on domain sockets.",
  "Arch - STORAGE - Volume - Communication - CSI - drivers": "Using CSI, third-party storage providers can write and deploy drivers exposing new storage systems in Kubernetes.",

  "Workloads": "SECTION",
  "Workloads - Apps": "A workload is an application running on Kubernetes composed by pods.",
  "Workloads - Apps - StatelessApps": "Use Ephemeral storage.",
  "Workloads - Apps - StatelessApps - Pods": "Pods are assigned random identifiers, derived from the Deployment’s name and a unique random string.",
  "Workloads - Apps - StatelessApps - Pods - interchangability": "Pods in a StatefulSet are not interchangeable. It’s expected that each Pod has a specific role, such as always running as a primary or read-only replica for a database application.",
  "Workloads - Apps - StatelessApps - Pods - ordering": "No ordering is supported. When you scale down the Deployment, Kubernetes will terminate a random Pod.",
  "Workloads - Apps - StatelessApps - Pods - Storage": "All Pods share the same PV and PVC.",
	"Workloads - Apps - StatelessApps - Workloads - Deployment": "A Deployment is a controller that manages a ReplicaSet, which in turn manages your Pods.",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Specification": ".",
  "Workloads - Apps - StatelessApps - Workloads - Deployment - Controller": "ReplicationController, ReplicaSetController, DeploymentController.",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Replication - Replication": ".",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Replication - Replication - Controller": "ReplicationController",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Replication - ReplicaSet": "A ReplicaSet's purpose is to maintain a stable set of replica Pods running at any given time.",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Replication - ReplicaSet - Controller": "ReplicaSetController",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Lifecycle - Creation": "Deployment + first ReplicaSet created",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Lifecycle - Creation - kubectl - create": "kubectl create deployment < deployment_name >",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Lifecycle - Creation - kubectl - get": "kubectl get deployment < deployment_name >",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Lifecycle - Creation - kubectl - edit": "kubectl edit deployment < deployment_name >",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Lifecycle - Creation - kubectl - describe": "kubectl describe deployment < deployment_name >",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Lifecycle - Creation - kubectl - delete": "kubectl delete deployment < deployment_name >",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Lifecycle - Creation - kubectl - scale": "kubectl scale deployment < deployment_name > --replicas = < replicas >",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Lifecycle - Creation - kubectl - rollback": "kubectl rollout deployment < deployment_name >",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Lifecycle - PodScheduling": "Pods assigned to nodes. Random, interchangeable, any order creation",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Lifecycle - PodRunning": "Pods pass readiness and start serving",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Lifecycle - Stable": "All replicas match desired state",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Lifecycle - Updating": "New ReplicaSet created, pods rolling out",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Lifecycle - Scaling": ".",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Lifecycle - Pausing": ".",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Lifecycle - Resuming": ".",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Lifecycle - Rollback": "Optional step if update goes wrong",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Status": ".",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Status - Progressing": ".",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Status - Complete": ".",
	"Workloads - Apps - StatelessApps - Workloads - Deployment - Status - Failed": ".",
  "Workloads - Apps - StatelessApps - Workloads - DaemonSet": "A DaemonSet ensures that all (or some) Nodes run a copy of a Pod.",
  "Workloads - Apps - StatelessApps - Workloads - DaemonSet - Pods": "DaemonSets automatically start pods and delete existing pods when nodes fail or are removed.",
  "Workloads - Apps - StatelessApps - Workloads - DaemonSet - Controller": "DaemonSet is an independent object that has its own controller.",
  "Workloads - Apps - StatelessApps - Workloads - DaemonSet - kubectl - get": "kubectl get daemonSet < daemonSet_name >.",
  "Workloads - Apps - StatelessApps - Workloads - DaemonSet - kubectl - edit": "kubectl edit daemonSet < daemonSet_name >.",
  "Workloads - Apps - StatelessApps - Workloads - DaemonSet - kubectl - describe": "kubectl describe daemonSet < daemonSet_name >.",
  "Workloads - Apps - StatelessApps - Workloads - DaemonSet - kubectl - delete": "kubectl delete daemonSet < daemonSet_name >.",
  "Workloads - Apps - StatelessApps - Workloads - DaemonSet - Lifecycle - Schedule": "The DaemonSet controller creates a DaemonPods for each eligible node and adds the spec.affinity.nodeAffinity field of the Pod to match the target host. After the Pod is created, the default scheduler typically takes over and then binds the Pod to the target host by setting the .spec.nodeName field. If the new Pod cannot fit on the node, the default scheduler may preempt (evict) some of the existing Pods based on the priority of the new Pod.",
  "Workloads - Apps - StatelessApps - Workloads - DaemonSet - Lifecycle - operation": "As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected.",
  "Workloads - Apps - StatelessApps - Workloads - DaemonSet - Lifecycle - operation - reconciliation": "The DamonSet controller uses a reconciliation loop to check the current state of nodes, and if they are not currently running the required pod, it will run them.",
  "Workloads - Apps - StatelessApps - Workloads - DaemonSet - Lifecycle - operation - scale": "When more eligible nodes are added to the cluster, the background service scales up. When nodes are removed, it will automatically scale down.",
  "Workloads - Apps - StatelessApps - Workloads - DaemonSet - UseCases": "This can be used to run administrative workloads such as logging and monitoring components.",
  "Workloads - Apps - StatelessApps - Workloads - DaemonSet - UseCases - NetworkingServices": "e.g. CNI plugins",
  "Workloads - Apps - StatelessApps - Workloads - DaemonSet - UseCases - MonitoringAgents": "e.g. Prometheus Node Exporter",
  "Workloads - Apps - StatelessApps - Workloads - DaemonSet - UseCases - LoggingAgents": "e.g. Fluentd, Filebeat",
  "Workloads - Apps - StatelessApps - Workloads - Job": "Jobs represent one-off tasks that run to completion and then stop.",
  "Workloads - Apps - StatelessApps - Workloads - Job - Specification": "",
  "Workloads - Apps - StatelessApps - Workloads - Job - Controller": "Job Controller → Creates Pods based on the Job template and tracks their completions.",
  "Workloads - Apps - StatelessApps - Workloads - Job - kubectl - get": "kubectl get job < job_name >.",
  "Workloads - Apps - StatelessApps - Workloads - Job - kubectl - edit": "kubectl edit job < job_name >.",
  "Workloads - Apps - StatelessApps - Workloads - Job - kubectl - describe": "kubectl describe job < job_name >.",
  "Workloads - Apps - StatelessApps - Workloads - Job - kubectl - delete": "kubectl delete job < job_name >.",
  "Workloads - Apps - StatelessApps - Workloads - Job - Lifecycle": "",
  "Workloads - Apps - StatelessApps - Workloads - Job - Lifecycle - Termination": "",
  "Workloads - Apps - StatelessApps - Workloads - Job - Lifecycle - CleanUp": "",
  "Workloads - Apps - StatelessApps - Workloads - CronJob": "A CronJob starts one-time Jobs on a repeating schedule.",
  "Workloads - Apps - StatelessApps - Workloads - CronJob - Specification": "",
  "Workloads - Apps - StatelessApps - Workloads - CronJob - Controller": "CronJobController. CronJob Controller → Reads the schedule and policies (e.g., concurrencyPolicy: Forbid). ",
  "Workloads - Apps - StatelessApps - Workloads - CronJob - Scheduler": "A CronJob is scheduled with a time pattern like '* * * * *'. When the schedule hits, the CronJob Controller spawns a Job resource.",
  "Workloads - Apps - StatelessApps - Workloads - CronJob - Types - Basic": "Simple cron-based scheduling of recurring tasks.",
  "Workloads - Apps - StatelessApps - Workloads - CronJob - Types - ConcurrentPolicy": "Specify how to handle concurrent executions of a CronJob, allowing for fine-grained control over task execution.",
  "Workloads - Apps - StatelessApps - Workloads - CronJob - Types - JobHistoryLimits": "Control the number of successful and failed Job completions retained by a CronJob, managing resource usage and storage requirements.",
  "Workloads - Apps - StatelessApps - Workloads - CronJob - Lifecycle": "",
  "Workloads - Apps - StatelessApps - Workloads - CronJob - UseCases - DataBackups": "Data Backups: Schedule regular backups of critical data to ensure data integrity and disaster recovery preparedness.",
  "Workloads - Apps - StatelessApps - Workloads - CronJob - UseCases - DataSyncing": "Data Syncing: Periodically synchronize data between different systems or databases to maintain consistency and up-to-date information.",
  "Workloads - Apps - StatelessApps - Workloads - CronJob - UseCases - PeriodicMaintenance": "Periodic Maintenance: Automate routine maintenance tasks such as log rotation, database cleanup, or temporary file deletion to optimize system performance and resource utilization.",
  "Workloads - Apps - StatelessApps - UseCases": "",
  "Workloads - Apps - StatelessApps - UseCases - WebServers": "NGINX, Apache",
  "Workloads - Apps - StatelessApps - UseCases - Microservices": "",
  "Workloads - Apps - StatelessApps - UseCases - StatelessApplications": "",
	"Workloads - Apps - StatefulApps": "Persistent Volume per Pod.",
  "Workloads - Apps - StatefulApps - Pods": "Unique, stable (ordinal index), sequential creation. Pods are assigned a persistent identifier, derived from the StatefulSet’s name and their ordinal creation index.",
  "Workloads - Apps - StatefulApps - Pods - interchangability": "All Pods are identical, so they’re interchangeable and can be replaced at any time.",
  "Workloads - Apps - StatefulApps - Pods - Order": "Pods are guaranteed to be created and removed in sequence. When you scale down the StatefulSet, Kubernetes will terminate the most recently created Pod.",
  "Workloads - Apps - StatefulApps - Pods - scaling": "Ordered",
  "Workloads - Apps - StatefulApps - Pods - updates": "Ordered and controlled",
  "Workloads - Apps - StatefulApps - Pods - Storage": "Each Pod in the StatefulSet is assigned its own Persistent Volume (PV) and Persistent Volume Claim (PVC).",
	"Workloads - Apps - StatefulApps - Workloads - StatefulSet": "A StatefulSet runs a group of Pods, and maintains a sticky identity for each of those Pods.",
	"Workloads - Apps - StatefulApps - Workloads - StatefulSet - Controllers": "StatefulSetController",
  "Workloads - Apps - StatefulApps - Workloads - StatefulSet - Examples": "Databases (MySQL, PostgreSQL, MongoDB), Distributed systems (Zookeeper, Kafka, Elasticsearch)",
	"Workloads - Autoscaling": "In Kubernetes, you can scale a workload depending on the current demand of resources. This allows your cluster to react to changes in resource demand more elastically and efficiently.",
	"Workloads - Autoscaling - HPA": "HorizontalPodAutoscaler (HPA) - Increase the number of pods.",
	"Workloads - Autoscaling - VPA": "VerticalPodAutoscaler (VPA) - Resizing CPU and memory resources assigned to containers",
	"Workloads - Autoscaling - VPA - InPlaceResourceResize - V1.33": "CPU and memory resources can now be adjusted for running Pods without requiring restarts, enabling true vertical scaling and better resource efficiency for long-running workloads.",
	"Workloads - Autoscaling - VPA - Modes": "At the moment, the VPA can operate in four different modes: Auto, Recreate, Initial, Off",
	"Workloads - Autoscaling - VPA - Modes - Auto": "Currently, Recreate might change to in-place updates in the future",
	"Workloads - Autoscaling - VPA - Modes - Recreate": "The VPA assigns resource requests on pod creation as well as updates them on existing pods by evicting them when the requested resources differ significantly from the new recommendation",
	"Workloads - Autoscaling - VPA - Modes - Initial": "The VPA only assigns resource requests on pod creation and never changes them later.",
	"Workloads - Autoscaling - VPA - Modes - Off": "The VPA does not automatically change the resource requirements of the pods. The recommendations are calculated and can be inspected in the VPA object.",
	"Workloads - Autoscaling - KEDA": "KEDA is a tool that helps Kubernetes scale applications based on real-world events. It was created by Microsoft and Red Hat. With KEDA, you can adjust the size of your containers automatically, depending on the workload—like the number of messages in a queue or incoming requests.",

  "Networking": "SECTION",
	"Networking - Service": "A Service exposes a workload (group of Pods) by providing Networking.",
	"Networking - Service - Motivation": " Solves the problem of ephemeral IP addresses of Pods providing an stable IP address to connect to Pods.",
	"Networking - Service - Addressability - Remote - DNSEntry": "A DNS entry is created like my-service.my-namespace.svc.cluster.local. Maps the Service to an external domain name (CNAME record) used by Ingress",
	"Networking - Service - Addressability - Local - ClusterIP": "ClusterIP is the default service type in Kubernetes. A virtual IP (ClusterIP) is assigned. Every service gets a unique URL that is accessible across the cluster.",
  "Networking - Service - ServiceDiscovery": "Services register their node information to Endpoints objects, so we can directly give deployment permissions to read the cluster's Endpoints object to get the node information.",
  "Networking - Service - ServiceDiscovery - EndpointAPI": "Originally, Kubernetes used the EndpointsAPI to store all backend Pod IPs for a Service in a single object (Endpoints).",
  "Networking - Service - ServiceDiscovery - EndpointAPI - Deprecated": "This caused scalability issues when handling thousands of Pods",
	"Networking - Service - ServiceDiscovery - EndpointAPI - EndPoint": "Endpoint is an object that maps the IP addresses and ports of the pods that are members of a Service.",
	"Networking - Service - ServiceDiscovery - EndpointAPI - Creation": "When you create a Service, Kubernetes automatically creates a corresponding Endpoints object with the same name.",
	"Networking - Service - ServiceDiscovery - EndpointAPI - Update": "The Endpoints object is continuously updated by the control plane as pods matching the Service's selector come and go.",
	"Networking - Service - ServiceDiscovery - EndpointAPI - kubectl - get": "kubectl get endpoints < service_name >",
	"Networking - Service - ServiceDiscovery - EndpointAPI - kubectl - describe": "kubectl describe endpoints < service_name >",
  "Networking - Service - ServiceDiscovery - EndpointSliceAPI - k8s-1.16": "Evolution of EndpointAPI which break large Endpoints into smaller, manageable pieces. contains references to a set of network endpoints.",
  "Networking - Service - ServiceDiscovery - EndpointSliceAPI - EndpointSlices": "The control plane automatically creates EndpointSlices for any Kubernetes Service that has a selector specified.",
  "Networking - Service - ServiceDiscovery - EndpointSliceAPI - EndpointSlices - Pods": "These EndpointSlices include references to all the Pods that match the Service selector.",
  "Networking - Service - ServiceDiscovery - EndpointSliceAPI - EndpointSlices - Grouped": "EndpointSlices group network endpoints together by unique combinations of protocol, port number, and Service name. The name of a EndpointSlice object must be a valid DNS subdomain name.",
	"Networking - Service - kubectl - create": "Kube create service < service_type > < service_name > --tcp- < port:target_port >.",
	"Networking - Service - kubectl - expose": "Kube expose - Expose a resource as a new Kubernetes service. Possible resources include (case insensitive): pod (po), service (svc), replicationcontroller (rc), deployment (deploy), replicaset (rs)",
	"Networking - Service - kubectl - get": "Kube get service < service >",
	"Networking - Service - kubectl - edit": "Kube edit service < service >",
	"Networking - Service - kubectl - update": "Kube update service < service > You can update the service (change ports, selectors, etc.), and K8s adjusts accordingly.",
	"Networking - Service - kubectl - describe": "Kube describe service < service >",
	"Networking - Service - kubectl - delete": "Kube delete service < service > When deleted: The Service object, its ClusterIP, and endpoints are removed. Any associated external resources (like LoadBalancers) are cleaned up.",
	"Networking - ServiceToService - ServiceMesh": ".",
	"Networking - Pods - IP": "Every pod gets its own IP address. We cannot rely on Pod's IP addresses as they always change.",
	"Networking - Pods - IP - EnvironmentVariables": "When a Pod is created, Kubernetes automatically injects environment variables for any Services in the same namespace. These environment variables include the Service name, cluster IP, and port number. However, this method is limited because it only works if the Pod is restarted after a new Service is created.",
	"Networking - ServiceToPods": "Requests sent to the Service are routed to one of the available endpoints (pods).",
	"Networking - ServiceToPods - kube-proxy": "Kube-proxy manages routing for Service-to-Pod traffic connect to ClusterIP of services.",
  "Networking - ServiceToPods - kube-proxy - Scope": "kube-proxy runs on each node in a cluster as a DaemonSet.",
	"Networking - ServiceToPods - kube-proxy - SessionAffinity ": "If SessionAffinity is enabled, it can stick users to the same pod.",
	"Networking - ServiceToPods - kube-proxy - Parts": "The Kube-proxy is an implementation of a network proxy and a load balancer.",
	"Networking - ServiceToPods - kube-proxy - Parts - NetworkProxy": ".",
	"Networking - ServiceToPods - kube-proxy - Parts - LoadBalancer": ".",
	"Networking - ServiceToPods - kube-proxy - Modes": "kube-proxy operates in different modes, depending on cluster configuration.",
	"Networking - ServiceToPods - kube-proxy - Modes - Userspace": "Traffic goes through a proxy in user space (slower due to context switching). Uses iptables to redirect traffic to a local proxy port. Rarely used in modern clusters.",
	"Networking - ServiceToPods - kube-proxy - Modes - iptables": "Relies on Linux iptables to forward traffic directly to Pods. No userspace overhead (faster than Userspace mode). No real load balancing—uses random selection. Can lead to connection drops if a Pod is unavailable (no retries).",
	"Networking - ServiceToPods - kube-proxy - Modes - IPVS": "Uses IP Virtual Server (IPVS) kernel feature for efficient load balancing. Supports multiple load-balancing algorithms: rr (Round Robin), lc (Least Connections), sh (Source Hashing), dh (Destination Hashing) Better scalability for large clusters.",
	"Networking - ServiceToPods - kube-proxy - NetworkPolicies.": "NetworkPolicies allow you to specify rules for traffic flow within your cluster, and also between Pods and the outside world.",
	"Networking - ExternaltoService": "By default, a service is private to the cluster. To reach externally we can use NodePort, LoadBalancer, Ingress",
	"Networking - ExternaltoService - NodePort": "Exposes the Service outside of the cluster on a static port on each Node’s IP.",
  "Networking - ExternaltoService - NodePort - IP - dynamic": "Pods in Kubernetes have dynamic IP addresses.",
	"Networking - ExternaltoService - LoadBalancer": "Exposes the Service externally by using a cloud provider’s load balancer.",
  "Networking - ExternaltoService - LoadBalancer - MonoService": "Because load balancers are defined per service, they can only route to a single service. This is different from an ingress, which has the ability to route to multiple services inside the cluster.",
  "Networking - ExternaltoService - LoadBalancer - LabelSelector": "The set of Pods targeted by a Service is (usually) determined by a Label Selector",
  "Networking - ExternaltoService - LoadBalancer - extension": "Rather than a standalone object like an ingress, a load balancer is just an extension of a service.",
  "Networking - ExternaltoService - LoadBalancer - Options": "All of the major cloud providers support external load balancers using their own resource types: AWS uses a Network Load Balancer, GKE also uses a Network Load Balancer, Azure uses a Public Load Balancer",
	"Networking - ExternaltoService - Ingress": "An API object that manages external access to the services in a cluster, acts as a reverse proxy and traffic router for HTTP/HTTPS requests.",
	"Networking - ExternaltoService - Ingress - Controller": "Not ingress controller by default. Therefore, it is up to the cluster administrator to ensure an appropriate controller is available..",
	"Networking - ExternaltoService - Ingress - Controller - Platforms": "Most cloud platforms provide their own ingress controllers.",
	"Networking - ExternaltoService - Ingress - Controller - OpenSource": "There are also plenty of open-source options to choose from.",
	"Networking - ExternaltoService - Ingress - Controller - OpenSource - nginx": "Perhaps the most popular is the nginx ingress controller, which is built on top of the popular web server of the same name.",
	"Networking - ExternaltoService - Ingress - Goal": "Forwards all of its traffic to an appropriate service (as a reverse proxy and traffic router).",
	"Networking - ExternaltoService - Ingress - Goal - efficient": "More efficient than creating multiple NodePort and LoadBalancer",
	"Networking - ExternaltoService - Ingress - Input - IP": "Provides a Public Static IP address.",
	"Networking - ExternaltoService - Ingress - Input - Protocols": "While it is possible to use an ingress with other types of protocols than HTTPS, it typically requires extra configuration.",
	"Networking - ExternaltoService - Ingress - Input - Protocols - HTTP": "Ingress exposes HTTP routes from outside the cluster to services within the cluster.",
	"Networking - ExternaltoService - Ingress - Input - Protocols - HTTPS": "SSL termination.",
  "Networking - ExternaltoService - Ingress - Input - DNS": "Service network identity provides both a static IP address and a DNS name. Services listen on a static address that doesn�t change and forwards the request to the unreliable container address. It internally keeps a map that always contains the latest IP address of the Pod. So, whenever a Pod restarts, it updates that map automatically so you get a seamless connection.",
  "Networking - ExternaltoService - Ingress - Input - DNS - KubeDNS": "Services are automatically registered in KubeDNS (or CoreDNS) so other Pods can find them using a hostname.",
	"Networking - ExternaltoService - Ingress - Input - DNS - CoreDNS": "Kubernetes includes a built-in DNS service (usually CoreDNS) that dynamically resolves Service names to their corresponding IP addresses. This is the standard way for applications to discover and communicate with Services.",
	"Networking - ExternaltoService - Ingress - Rules": "Using a set of rules: path or domain based.",
	"Networking - ExternaltoService - Ingress - Rules - LoadBalancing": "Ingress may provide load balancing",
  "Networking - ExternaltoService - Ingress - Rules - LoadBalancing - Routing": "Traffic routing is controlled by rules defined on the Ingress resource.",
	"Networking - ExternaltoService - Ingress - Rules - NameVirtuaHosting": "Ingress may provide name-based virtual hosting",
	"Networking - ExternaltoService - Ingress - Rules - NetworkPolicies": "Combine routing with NetworkPolicies",
	"Networking - ExternaltoService - Ingress - Output - Service": "Forwards all of its traffic to an appropriate service. That service will send the request to a pod that can actually handle the request.",
	"Networking - ExternaltoService - Ingress - Output - MultiService": "Ingresses are native objects inside the cluster that can route to multiple services.",
	"Networking - ExternaltoService - Ingress - kubectl - get": "kubectl get ingress",
	"Networking - ExternaltoService - Ingress - kubectl - edit": "kubectl edit ingress",
	"Networking - ExternaltoService - Ingress - kubectl - describe": "kubectl describe ingress",
	"Networking - ExternaltoService - Ingress - kubectl - delete": "kubectl delete ingress",
  "Networking - ExternaltoService - GatewayAPI": "Evolution of Ingress.",
  "Networking - ExternaltoService - GatewayAPI - Functions": "Make network services available by using an extensible, role-oriented, protocol-aware configuration mechanism.",
  "Networking - ExternaltoService - GatewayAPI - addon": "Gateway API is an add-on containing API kinds that provide dynamic infrastructure provisioning and advanced traffic routing.",
	"Networking - AgentToPod": "",
	"Networking - AgentToPod - kube-proxy": "Agents on a node (e.g. system daemons, kubelet) can communicate with all pods on that node using kube-proxy.",
	"Networking - PodToPod": "IntraCluster pod to pod",
	"Networking - PodToPod - Router": "Kube-proxy manages traffic routing between pods.",
	"Networking - PodToPod - IntraNode": "Each pod gets an unique IP address within the cluster. They communicate without NAT.",
	"Networking - PodToPod - ExtraNode": ".",
	"Networking - PodToPod - Issues": "Sometimes, pods might not be able to reach each other, which could happen due to various reasons. For instance, there might be network congestion, misconfigured networking policies, or even problems with the underlying infrastructure hosting your cluster.",
	"Networking - Containers": ".",
	"Networking - Containers - IP": "All containers in the pod share the same IP and port space.",
	"Networking - Containers - CNI": "A common interface between network plugins and container runtimes — a CNI acts like a bridge between them. ",
  "Networking - Containers - CNI - project": "CNI consists of a specification and libs for writing plugins to configure container network interfaces. The CNI focus is on network connectivity and removing resources allocated to containers when ther are deleted, so it has a wide range of support from applications and services. https://github.com/containernetworking/cni",
  "Networking - Containers - CNI - CNCF": "CNI is an initiative of the Cloud-Native Computing Foundation (CNCF), which specifies the configuration of Linux container network interfaces.",
  "Networking - Containers - CNI - mission": "The Container Network Interface (CNI) connects the containers to the cluster network and assigns IP addresses.",
  "Networking - Containers - CNI - CRI": "When the container runtime (like Kubernetes) expects to perform network operations on a container, it calls the CNI plugin with the desired command. The container runtime also provides related network configuration and container-specific data to the plugin, which performs the required operations and reports the result.",
  "Networking - Containers - CNI - Plugins": ".",
  "Networking - Containers - CNI - Plugins - Flannel": ".",
  "Networking - Containers - CNI - Plugins - Calico": ".",
  "Networking - Containers - CNI - Plugins - Cilium": ".",
  "Networking - Containers - CNI - Plugins - Weave": ".",
	"Networking - ContainertoContainer": "IntraPod Container to Container",
	"Networking - ContainertoContainer - Methods - SharedVolumes": "sufficient to use a directory on the host that is shared with all containers within a Pod.",
	"Networking - ContainertoContainer - Methods - IPC": "Containers in a Pod share the same IPC namespace, which means they can also communicate with each other using standard inter-process communications such as SystemV semaphores or POSIX shared memory.",
	"Networking - ContainertoContainer - Methods - IPC - Localhost": "Communication between containers is possible because they share the same network namespace, which means they can communicate over the localhost interface.",
	"Networking - ContainertoContainer - UseCase": "They could be part of the same application, with each container handling a different aspect, like a web server container talking to a database container to fetch data.",
	"Networking - ContainertoContainer - Issues": "But, just like with pod-to-pod communication, issues can arise here, too. One container may be unable to reach the other, or there are delays in communication. This could happen due to things like misconfigured network settings, firewall rules blocking communication, or even issues within the application itself.",
	"Networking - PodsToService": ".",
	"Networking - PodsToService - Router - kube-proxy": "Provides Network address translation (NAT) for Pod-to-Service communication",
	"Networking - PodsToService - Routing - DNS-IP": "When a pod needs to communicate with a service, it's like sending a message to a central hub, which then routes the message to the appropriate destination. This is possible because services have their unique IP address and a DNS name, which allows them to be easily discovered and communicated with.",
	"Networking - PodsToService - Issues": "Issues can still arise in pod-to-service communication. For example, misconfigured service definitions, network policies, or firewall rules could prevent pods from accessing the service.",
	"Networking - PodsToService - Issues - Troubleshooting": "Troubleshooting such issues might involve checking service configurations, inspecting network policies, or examining firewall rules to ensure smooth communication between pods and services.",
	"Networking - LayersAsDevops": "Kubernetes layers you need to know as a DevOps engineer: LoadBalancer > IngressController > KubeProxy > Service Mesh > Sidecars > Application",

  "K8s Market": "SECTION",
  "K8s Market - Extensions": "Extensions or plugins. Addons are pods and services that implement cluster features extending the functionality and capabilities of Kubernetes.",
  "K8s Market - Extensions - CRD": "Custom resources are extensions of the Kubernetes API that are not necessarily available in a default Kubernetes installation.",
  "K8s Market - Extensions - CRD - Operators": "Operators are software extensions to Kubernetes that make use of custom resources to manage applications and their components. Operators follow Kubernetes principles, notably the control loop.",
  "K8s Market - Extensions - CRD - Operators - Helm": "The Helm Operator is a Kubernetes operator, allowing one to declaratively manage Helm chart releases. Combined with Flux this can be utilized to automate releases in a GitOps manner, but the usage of Flux is not a strict requirement.",
  "K8s Market - Extensions - DNS": "While the other addons are not strictly required, all Kubernetes clusters should have cluster DNS, as many examples rely on it. Cluster DNS is a DNS server, in addition to the other DNS server(s) in your environment, which serves DNS records for Kubernetes services. Containers started by Kubernetes automatically include this DNS server in their DNS searches.",
  "K8s Market - Extensions - Web UI": "Dashboard is a general purpose, web-based UI for Kubernetes clusters. It allows users to manage and troubleshoot applications running in the cluster, as well as the cluster itself.",
  "K8s Market - Extensions - Container Resource Monitoring": "Container Resource Monitoring records generic time-series metrics about containers in a central database, and provides a UI for browsing that data..",
  "K8s Market - Extensions - Cluster-level Logging": "A Cluster-level logging mechanism is responsible for saving container logs to a central log store with search/browsing interface."

}