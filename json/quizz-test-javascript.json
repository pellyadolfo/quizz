{

	"Mocha": "SECTION",
	"Mocha - goal - backend": "For complex back-end applications, Mocha is a proper fit. Mocha is better suited for applications designed with Node.js",
	"Mocha ": "Mocha is a feature-rich JavaScript test framework running on Node.js and in the browser, making asynchronous testing simple and fun. Mocha tests run serially, allowing for flexible and accurate reporting, while mapping uncaught exceptions to the correct test cases.",

	"Jasmine": "SECTION",
	"Jasmine - goal - Angular": "Jasmine works better with Angular.js. Jasmine works better with light and simple projects.",
	"Jasmine - link": "https://jasmine.github.io/pages/docs_home.html",
	"Jasmine - describe": "The describe function is for grouping related specs, typically each test file has one at the top level. The string parameter is for naming the collection of specs, and will be concatenated with specs to make a spec's full name. This aids in finding specs in a large suite. If you name them well, your specs read as full sentences in traditional BDD style.",
	"Jasmine - describe - nesting": "Calls to describe can be nested, with specs defined at any level. This allows a suite to be composed as a tree of functions. Before a spec is executed, Jasmine walks down the tree executing each beforeEach function in order. After the spec is executed, Jasmine walks through the afterEach functions similarly.",
	"Jasmine - describe - xdescribe": "Suites can be disabled with the xdescribe function. These suites and any specs inside them are skipped when run and thus their results will show as pending.",
	"Jasmine - describe - fdescribe": "Suites can also be focused with the fdescribe function. That means only fdescribe suits will run.",
	"Jasmine - it": "Specs are defined by calling the global Jasmine function it, which, like describe takes a string and a function. The string is the title of the spec and the function is the spec, or test. A spec contains one or more expectations that test the state of the code. An expectation in Jasmine is an assertion that is either true or false. A spec with all true expectations is a passing spec. A spec with one or more false expectations is a failing spec.",
	"Jasmine - it - itx": "Pending specs do not run, but their names will show up in the results as pending. Any spec declared with xit is marked as pending.",
	"Jasmine - it - fit": "Tests can also be focused with the fit function. That means only fit tests will run.",
	"Jasmine - it - nofunction": "Any spec declared without a function body will also be marked pending in results.",
	"Jasmine - it - pending": "And if you call the function pending anywhere in the spec body, no matter the expectations, the spec will be marked pending. A string passed to pending will be treated as a reason and displayed when the suite finishes.",
	"Jasmine - Expectations": "Expectations are built with the function expect which takes a value, called the actual. It is chained with a Matcher function, which takes the expected value.",
	"Jasmine - Matchers": "Each matcher implements a boolean comparison between the actual value and the expected value. It is responsible for reporting to Jasmine if the expectation is true or false. Jasmine will then pass or fail the spec.",
	"Jasmine - Matchers - not": "Any matcher can evaluate to a negative assertion by chaining the call to expect with a not before calling the matcher.",
	"Jasmine - Matchers - Built-in": "Jasmine has a rich set of matchers included, you can find the full list in the API docs There is also the ability to write custom matchers for when a project's domain calls for specific assertions that are not included in Jasmine.",
	"Jasmine - Matchers - asymmetric": "Sometimes you don't want to match with exact equality. Jasmine provides a number of asymmetric equality testers.",
	"Jasmine - Matchers - asymmetric - any": "jasmine.any takes a constructor or 'class' name as an expected value. It returns true if the constructor matches the constructor of the actual value.",
	"Jasmine - Matchers - asymmetric - anything": "jasmine.anything returns true if the actual value is not null or undefined.",
	"Jasmine - Matchers - asymmetric - objectContaining": "jasmine.objectContaining is for those times when an expectation only cares about certain key/value pairs in the actual.",
	"Jasmine - Matchers - asymmetric - arrayContaining": "[jasmine.arrayContaining](/api/edge/global.html#.arrayContaining is for those times when an expectation only cares about some of the values in an array.",
	"Jasmine - Matchers - asymmetric - stringMatching": "jasmine.stringMatching is for when you don't want to match a string in a larger object exactly, or match a portion of a string in a spy expectation.",
	"Jasmine - Matchers - asymmetric - asymmetricMatch": "Custom asymmetric equality tester When you need to check that something meets a certain criteria, without being strictly equal, you can also specify a custom asymmetric equality tester simply by providing an object that has an asymmetricMatch function.",
	"Jasmine - Global": "To help a test suite DRY up any duplicated setup and teardown code, Jasmine provides the global beforeEach, afterEach, beforeAll, and afterAll functions.",
	"Jasmine - Global - Setup": ".",
	"Jasmine - Global - Setup - beforeAll": "The beforeAll function is called only once before all the specs in describe are run.",
	"Jasmine - Global - Setup - beforeEach": "As the name implies, the beforeEach function is called once before each spec in the describe in which it is called.",
	"Jasmine - Global - TearDown": ".",
	"Jasmine - Global - TearDown - afterEach": "afterEach function is called once after each spec..",
	"Jasmine - Global - TearDown - afterAll": "The afterAll function is called after all specs finish.",
	"Jasmine - Scope - this": "Another way to share variables between a beforeEach, it, and afterEach is through the this keyword. Each spec's beforeEach/it/afterEach has the this as the same empty object that is set back to empty for the next spec's beforeEach/it/afterEach. Note: If you want to use the this keyword to share variables, you must use the function keyword and not arrow functions.",
	"Jasmine - Async": "Jasmine also has support for running specs that require testing asynchronous operations. The functions that you pass to beforeAll, afterAll, beforeEach, afterEach, and it can be declared async. Jasmine also supports asynchronous functions that explicitly return promises or that take a callback. See the Asynchronous Work tutorial for more information.",
	"Jasmine - Async - done": "If the timeout expires before done is called, the current spec will be marked as failed and suite execution will continue as if done was called.",
	"Jasmine - Async - timeout": "If specific specs should fail faster or need more time this can be adjusted by passing a timeout value to it, etc.",
	"Jasmine - Async - timeout - 5": "By default jasmine will wait for 5 seconds for an asynchronous spec to finish before causing a timeout failure.",
	"Jasmine - Async - timeout - DEFAULT_TIMEOUT_INTERVAL": "If the entire suite should have a different timeout, jasmine.DEFAULT_TIMEOUT_INTERVAL can be set globally, outside of any given describe.",
	"Jasmine - Mocking": ".",
	"Jasmine - Mocking - date - Clock": "The Jasmine Clock can also be used to mock the current date.",
	"Jasmine - Mocking - date - mockDate": "If you do not provide a base time to mockDate it will use the current date.",
	"Jasmine - Spies": "Jasmine has test double functions called spies. A spy can stub any function and tracks calls to it and all arguments. A spy only exists in the describe or it block in which it is defined, and will be removed after each spec. There are special matchers for interacting with spies.",
	"Jasmine - Spies - Create - createSpy": "When there is not a function to spy on, jasmine.createSpy can create a 'bare' spy. This spy acts as any other spy - tracking calls, arguments, etc. But there is no implementation behind it.",
	"Jasmine - Spies - Create - createSpyObj": "In order to create a mock with multiple spies, use jasmine.createSpyObj and pass an array of strings. It returns an object that has a property for each string that is a spy.",
	"Jasmine - Spies - define": "You can define what the spy will do when invoked with and.",
	"Jasmine - Spies - toHaveBeenCalled": "The toHaveBeenCalled matcher will pass if the spy was called.",
	"Jasmine - Spies - toHaveBeenCalledTimes": "The toHaveBeenCalledTimes matcher will pass if the spy was called the specified number of times.",
	"Jasmine - Spies - toHaveBeenCalledWith": "The toHaveBeenCalledWith matcher will return true if the argument list matches any of the recorded calls to the spy.",
	"Jasmine - Spies - calls": "You get all of the data that a spy tracks about its calls with calls.",
	"Jasmine - Clock": "The Jasmine Clock is available for testing time-dependent code",
	"Jasmine - Clock - install": "It is installed with a call to jasmine.clock().install in a spec or suite that needs to manipulate time.",
	"Jasmine - Clock - uninstall": "Be sure to uninstall the clock after you are done to restore the original functions.",
	"Jasmine - Clock - Timeout - setTimeout": "You can make setTimeout or setInterval synchronous executing the registered functions only once the clock is ticked forward in time",
	"Jasmine - Clock - Timeout - setInterval": "You can make setTimeout or setInterval synchronous executing the registered functions only once the clock is ticked forward in time",
	"Jasmine - Clock - Timeout - tick": "To execute registered functions, move time forward via the jasmine.clock().tick function, which takes a number of milliseconds.",
	
	"TestBed": "SECTION",

	"JEST": "SECTION",
	"JEST ": "https://jestjs.io/docs/using-matchers",
	"JEST - goal - React": "Jest was primarily developed for React and worked well with Next.js too. For powerful UI-based applications, Jest is a good choice.",

	"Chai": "SECTION",

	"Karma": "SECTION",
	"karma - link": "https://karma-runner.github.io/6.4/intro/how-it-works.html",
	"karma - description": "Karma is essentially a tool which spawns a web server that executes source code against test code for each of the browsers connected.",
	"karma - browsers": "The results of each test against each browser are examined and displayed via the command line to the developer such that they can see which browsers and tests passed or failed.",
	"karma - browsers - captured - manually": "A browser can be captured manually, by visiting the URL where the Karma server is listening (typically http://localhost:9876/).",
	"karma - browsers - captured - automatically": "A browser can be captured or automatically by letting Karma know which browsers to start when Karma is run (see browsers).",
	"karma - test - trigger": "Karma also watches all the files, specified within the configuration file, and whenever any file changes, it triggers the test run by sending a signal to the testing server to inform all of the captured browsers to run the test code again. Each browser then loads the source files inside an IFrame, executes the tests and reports the results back to the server.",
	"karma - test - report": "The server collects the results from all of the captured browsers and presents them to the developer."


}