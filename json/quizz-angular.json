{
	"@NgModule": "SECTION",
	"NgModules - Definition": "basic building blocks of an Angular application",
	"NgModules - Multiplicity": "app always has at least a root module that enables bootstrapping, and typically has many more feature modules",
	"NgModules - More": "import additional modules",
	"NgModules - @NgModule decorator 'declarations' property": "Declares the components, directives, and pipes that belong to this NgModule.",
	"NgModules - @NgModule decorator 'exports' property": "The subset of declarations that should be visible and usable in the component templates of other NgModules.",
	"NgModules - @NgModule decorator 'imports' property": "Other modules whose exported classes are needed by component templates declared in this NgModule.",
	"NgModules - @NgModule decorator 'providers' property": "Creators of services that this NgModule contributes to the global collection of services, they become accessible in all parts of the app. (You can also specify providers at the component level, which is often preferred.).",
	"NgModules - @NgModule decorator 'bootstrap' property": "It is the main application view, also called the root component, which hosts all other app views. Only the root NgModule should set this bootstrap property. Angular creates and inserts into the index.html host web page",
	"NgModules - @NgModule decorator 'entryComponents' property": "components that are not found in html and created dynamically with ComponentFactoryResolver.",
	"NgModules - Built-in NgModules": "BrowserModule, CommonModule, FormsModule, ReactiveFormsModule, HttpClientModule, and RouterModule.",
	"NgModules - JavaScript Modules vs. NgModules": "In JavaScript, modules are individual files with JavaScript code in them. NgModules are classes decorated with @NgModule.",
	"NgModules - Types of Feature Modules": "Domain feature modules. Routed feature modules. Routing modules. Service feature modules. Widget feature modules.",
	"NgModules - AppModule": "Every Angular application has a bootstrapping module. It is also called as the AppModule. The bootstrapping module is mentioned in the AppModule class.",
	"NgModules - Router": "a service that lets you define a navigation path among the different application states and view hierarchies in your app. Presents a component for anu URL. It is not part of the Angular core. It is in its own library package, @angular/router",
	"NgModules - Router - links": "Lets you link to specific routes in your app.",
	"NgModules - Router - State": "You can access the current RouterState from anywhere in the application using the Router service and the routerState property.",
	"NgModules - Router - events": "During each navigation, the Router emits navigation events through the Router.events property. NavigationStart, RouteConfigLoadStart, RouteConfigLoadEnd, RoutesRecognized, GuardsCheckStart, ChildActivationStart, ActivationStart, GuardsCheckEnd, ResolveStart, ResolveEnd, ActivationEnd, ChildActivationEnd, NavigationEnd, NavigationCancel, NavigationError, Scroll",
	"NgModules - Router - Configuration": "configures the router as singleton via the RouterModule.forRoot method, and adds the result to the AppModule's imports array",
	"NgModules - Router - outlet": "the router matches that URL to the route path /heroes and displays the HeroListComponent after < router-outlet >< /router-outlet >",
	"NgModules - Router - Guards": "allow navigation to a requested route or not: CanActivate, CanActivateChild, CanDeactivate, CanLoad, Resolve",
	"NgModules - Router - Resolvers": "A Resolver is a class that implements the Resolve interface of Angular Router. In fact, Resolver is a service that has to be [provided] in the root module. Basically, a Resolver acts like middleware, which can be executed before a component is loaded. They allow applications to retrieve data first from an API response before the component gets loaded, allowing for route navigation.",
	"NgModules - Router - < base href >": "< base href='' >",

	"@Component": "SECTION",
	"Components - Angular view": "a component and template",
	"Components - @Component": "each app has at least a root component",
	"Components - @Component Multiplicity": "A component can only be declared in one module. if we want to use our component in multiple modules Just wrap your component into a module. Why not create a components module?",
	"Components - @Component metadata 'selector'": "A CSS selector that tells Angular to create and insert an instance of this component wherever it finds the corresponding tag in template HTML",
	"Components - @Component metadata 'templateUrl'": "The module-relative address of this component's HTML template. Alternatively, you can provide the HTML template inline, as the value of the template property. This template defines the component's host view.",
	"Components - @Component metadata 'providers':": "An array of dependency injection providers for services that the component requires",
	"Components - Component Lifecycle hooks List": "constructor -> ngOnChanges() -> ngOnInit() -> ngDoCheck() -> ngAfterContentInit() -> ngAfterContentChecked() -> ngAfterViewInit() -> ngAfterViewChecked() -> ngOnDestroy()",
	"Components - Component Interaction Types": "1. Pass data from parent to child with input binding, 2. Intercept input property changes with a setter, 3. Intercept input property changes with ngOnChanges(), 4. Parent listens for child event, 5. Parent interacts with child via local variable, 6. Parent calls an @ViewChild(), 7. Parent and children communicate via a service",
	"Components - Component Interaction. 1. Pass data from parent to child with input binding": "(1) Add @Input() title:string, to child, (2) Add childTitle:string = 'This text is passed to child', to parent, (3) do the binding in the template < child-selector [title]='childTitle' >< /child-selector >",
	"Components - Component Interaction. 2. Intercept input property changes with a setter": "(1) Add @Input() set name(name: string) { ... } to child, (2) Add name attribute to parent (3) do the binding in the template < app-name-child [name]='name' >< /app-name-child >",
	"Components - Component Interaction. 3. Intercept input property changes with ngOnChanges()": "(1) Add @Input() major: number, to child, (2) Add major: number = 1, to parent, (3) do the binding in ngOnChanges() in child",
	"Components - Component Interaction. 4. Parent listens for child event with EventEmitted as @Output()": "(1) Child exposed and EventEmitted as @Output() voted = new EventEmitter< boolean >(), (2) The parent binds an event handler called onVoted() that responds to the child event payload $event and updates a counter.",
	"Components - Component Interaction. 5. Parent interacts with child via local variable": "(1) Place a template reference variable in children tag in parents template < countdown-timer #timer >< /countdown-timer > (2) Use the reference in parent to acces children's variables, e.g. timer.start()",
	"Components - Component Interaction. 6. Parent calls an @ViewChild()": " (1) Inject child component into parent with @ViewChild(CountdownTimerComponent) private timerComponent: CountdownTimerComponent,",
	"Components - Component Interaction. 7. Parent and children communicate via a service": "(1) Declare service with Subject (2) Get Observable from Subject (3) Create method in Service writes to the Observable (4) Subscriber to Observable from Component1 (5) use the method to write in the Observable from Component 2",
	"Components - @angular/elements package": "exports a createCustomElement() API that provides a bridge from Angular's component interface and change detection functionality to the built-in DOM API",

	"Templates": "SECTION",
	"Templates - definition": "The template is simply an HTML view where binding controls can display data to the properties of the Angular component as side effects., < button (click)='deleteHero()' >Delete hero< /button >",
	"Templates - < ng-template >": "Angular element for rendering HTML. It is never displayed directly. Angular replaces the < ng-template > and its contents with a comment. Contains the template of the components. Also used when a template must be insrted in the DOM with Template Reference Variables",
	"Templates - Template Reference Variables": "< input #phone placeholder='phone number' > A template reference variable is often a reference to a DOM element within a template. It can also be a reference to an Angular component or directive or a web component.",
	"Templates - < ng-container >": "The Angular < ng-container > is a grouping element that doesn't interfere with styles or layout because Angular doesn't put it in the DOM. Host for structural directives.",
	"Templates - Binding - Angular supports 7 binding types between Component and DOM": "Event binding (click), Property binding [hero], Attribute Binding [attr.colspan], Class Binding [class.special], Style Binding [style.color], interpolations {{hero.name}} and 2 way [(ngModel)]",
	"Templates - Binding - 2 way binding": "ng-model-src (canonical form) instead [(src)]",
	"Templates - Binding - 2 Way Binding [(ngModel)]=": "< input [value]=\"currentHero.name\" input)=\"currentHero.name=$event.target.value\" >  === < input [ngModel]=\"currentHero.name\" (ngModelChange)=\"currentHero.name=$event\" >",
	"Templates - Binding - Event binding": "on-click (canonical form) vs (click)",
	"Templates - Binding - Event binding - Event handler": "$event",
	"Templates - Binding - Data binding": "ng-bind-src (canonical form) vs [src]",
	"Templates - Binding - Reference binding": "ref-text (canonical form) vs #text",
	"Templates - Binding - Attribute binding": "< tr >< td [attr.colspan]='1 + 1' >One-Two< /td >< /tr >",
	"Templates - Binding - Attribute Class binding": "< div [class.special]='isSpecial' >Special< /div >",
	"Templates - Binding - Attribute Style binding": "< button [style.color]=\"isSpecial ? 'red' : 'green'\" >",
	"Templates - Binding - String interpolation": "Interpolation refers to embedding expressions into marked up text. By default, interpolation uses the double curly braces {{ and }} as delimiters. <h3>Current customer: {{ currentCustomer }}</h3>",
	"Templates - Binding - String interpolation - safe navigation operator ( ?. )": "The current hero's name is {{currentHero?.name}}",
	"Templates - Binding - String interpolation - non-null assertion operator ( ! )": "The hero's name is {{hero!.name}}",
	"Templates - Binding - String interpolation - $any cast function": "you can use the $any cast function to cast the expression to the any type: {{$any(hero).marker}}",
	"Templates - Pipes": "Pipes are simple functions to use in template expressions to accept an input value and return a transformed value.",
	"Templates - Pipes - pure": "When writing a custom pipe in Angular you can specify whether you define a pure or an impure pipe: pure: false/true",
	"Templates - Pipes - pure - Pure pipes": "Pure function as a function that doesn’t have an internal state. A pure change is either a change to a primitive input value (String, Number, Boolean, Symbol) or a changed object reference (Date, Array, Function, Object).",
	"Templates - Pipes - pure - Impure pipes": "Impure function as a function that has an internal state. An impure pipe is called often, as often as every keystroke or mouse-move.",
	"Templates - Pipes - pure - Impure AsyncPipe": "The AsyncPipe accepts a Promise or Observable as input and subscribes to the input automatically, eventually returning the emitted values. The AsyncPipe is also stateful. The pipe maintains a subscription to the input Observable and keeps delivering values from that Observable as they arrive.",
	"Templates - Pipes - chain pipes": "<p>Average is {{ average | uppercase | number}}</p> ",
	"Templates - Pipes - Arguments": "<p>Price is {{ price | currency : “USD$” : 0.00 }}</p> ",
	"Templates - Pipes - Built-in pipes": "Angular comes with a stock of pipes such as DatePipe, UpperCasePipe, LowerCasePipe, CurrencyPipe, and PercentPipe. They are all available for use in any template.",
	"Templates - Pipes - custom": "create a class with @Pipe decorator and implement the method transform() of the PipeTransform class.",

	"@Directive": "SECTION",
	"Directives - @Directive decorator": "transfor the DOM: components, structural, attribute, predefined and custom directives",
	"Directives - Structural directives. How they work?": "alter the layout structure by adding, removing, and replacing elements in DOM. *ngFor=\"let hero of heroes\". *ngIf=\"selectedHero\"",
	"Directives - Structural directives Built-in.": "for example, *ngIf, *ngSwitch, *ngFor",
	"Directives - Structural directive *ngFor with index": "< div *ngFor='let hero of heroes, let i=index' >{{i + 1}} - {{hero.name}}< /div >",
	"Directives - Structural directive *ngFor with trackBy": "To customize the default tracking algorithm, NgForOf supports trackBy option. trackBy takes a function which has two arguments: index and item. If trackBy is given, Angular tracks changes by the return value of the function. < div *ngFor='let hero of heroes, trackBy: trackByHeroes' > <br/> trackByHeroes(index: number, heroes: any): string {   return heroes.name;  }  ",
	"Directives - Attribute directives. How they work?": "alter the appearance or behavior of an existing element, attributes, properties, and components [(ngModel)]=\"hero.name\"",
	"Directives - Attribute directives Built-in.": "for example NgClass, NgStyle, NgModel",
	"Directives - Custom Directives": "You can also write your own directives",
	"Directives - Directive with Custom events with EventEmitter": "Directives typically raise custom events with an Angular EventEmitter. The directive creates an EventEmitter and exposes it as a property. The directive calls EventEmitter.emit(payload) to fire an event, passing in a message payload, which can be anything. Parent directives listen for the event by binding to this property and accessing the payload through the $event object.",			
	"Directives - NgForms - NgForm": "Angular automatically creates and attaches an NgForm directive to the < form > tag. The NgForm directive supplements the form element with additional features.",
	"Directives - NgForms - ngSubmit": "< form (ngSubmit)='onSubmit()' #heroForm='ngForm' >",
	"Directives - NgForms - types": "Template-driven Forms (asynchronous), Reactive (model-driven) Forms (synchronous) and Reactive Forms with FormBuilder.",
	"Directives - NgForms - Template-driven Forms": "Writing templates in the Angular template syntax with the form-specific directives and techniques.",
	"Directives - NgForms - Template-driven Forms - Validation": "Add a directive to the template for validation then implements the Validator interface",
	"Directives - NgForms - Reactive Forms": "Each change to the form state returns a new state, which maintains the integrity of the model between changes. Reactive forms are built around observable streams",
	"Directives - NgForms - Reactive Forms. AbstractControl": "AbstractControl is the parent class of FormArray, FormGroup, and FormControl.",
	"Directives - NgForms - Reactive Forms. AbstractControl - markAsXXXXX": "MarkAllAsTouched (Angular 8), markAsDirty,  markAsTouched, and  markAsPending.",
	"Directives - NgForms - Reactive Forms. FormControl": "It communicates with an HTML Form element like input or select tag, this API handles the individual form value and validation state.",
	"Directives - NgForms - Reactive Forms. FormBuilder": "Creating multiple form control instances manually can become very repetitive when dealing with multiple forms. The FormBuilder service provides convenience methods to handle generating controls. Underneath, the FormBuilder is creating and returning the instances in the same manner, but with much less work",
	"Directives - NgForms - Reactive Forms. FormGroup": "FormGroup is a top-level API that maintains the values, properties and validation state of a group of AbstractControl instances in Angular.",
	"Directives - NgForms - Reactive Forms. FormArray": "A FormArray is an alternative to a FormGroup for managing any number of unnamed controls. As with FormGroup instances, you can dynamically insert and remove controls from a FormArray, and the FormArray instance's value and validation status is calculated from its child controls. However, you don't need to define a key for each control by name.",
	"Directives - NgForms - Reactive Forms - Validation": "Add validator functions directly to the form control model (FormControl) in the component class. Angular then calls these functions whenever the value of the control changes.",
	"Directives - NgForms - Form validation functions": ": functions that take a control instance and immediately return either a set of validation errors or null. Async validators: functions that take a control instance and return a Promise or Observable that later emits a set of validation errors or null",
	"Directives - NgForms - Form validation functions - types - Sync validators": "immediately return either a set of validation errors or null",
	"Directives - NgForms - Form validation functions - types - Async validators": "return a Promise or Observable that later emits a set of validation errors or null",
	"Directives - NgForms - Form validation functions - Built-in": "min, max, required, requiredTrue, email, minLegth, maxLength, pattern, nullVaidator, compose, composeAsync",
	"Directives - NgForms - Form validation functions - custom": "Create a function receiving AbstractControl as argument. Adding to template-driven forms or to Reactive Forms",

	"Services": "SECTION",
	"Services - Providers - Provider Registration": "A service provider provides the concrete, runtime version of a dependency value. The injector relies on providers to create instances of the services that the injector injects into components, directives, pipes, and other services. You must register a service provider with an injector, or it won't know how to create the service.",
	"Services - Providers - Provider Registration. Syntax": "Here's the class-provider syntax again. providers: [Logger] This is actually a shorthand expression for a provider registration using a provider object literal with two properties: [{ provide: Logger, useClass: Logger }]",
	"Services - Providers - Provider Registration. Syntax. provide property": "The provide property holds the token that serves as the key for both locating a dependency value and registering the provider.",
	"Services - Providers - Provider Registration. Syntax. second property": "The second property is always a provider definition object, which you can think of as a recipe for creating the dependency value. There are many ways to create dependency values just as there are many ways to write a recipe: useClass (create new instance), useValue (provide a ready made object), useFactory (he provider is a factory function), useExisting (use existing instance)",
	"Services - Providers - @Injectable decorator": "service class definition is immediately preceded by the @Injectable decorator",
	"Services - Providers - Dependency injection (or DI)": "inject services",
	"Services - Providers - Dependency injection - @Injectable()": "@Injectable() decorator for the service",
	"Services - Providers - Dependency Injectors Bootstrap": "Angular creates an application-wide injector for you during the bootstrap process.",
	"Services - Providers - Dependency Injectors Hierarchical": "Angular has a Hierarchical Dependency Injection system. An Angular application is a tree of components. Each component instance has its own injector. The tree of components parallels the tree of injectors.",
	"Services - Providers - Dependency Injectors Bubbling": "When a component requests a dependency, Angular tries to satisfy that dependency with a provider registered in that component's own injector. If the component's injector lacks the provider, it passes the request up to its parent component's injector. If that injector can't satisfy the request, it passes it along to its parent injector. The requests keep bubbling up until Angular finds an injector that can handle the request or runs out of ancestor injectors. If it runs out of ancestors, Angular throws an error.",
	"Services - Providers - Angular CLI command ng generate service": "registers a provider with the root injector for your service by including provider metadata in the @Injectable decorator",
	"Services - Providers - register a provider": "with a specific NgModule, the same instance of a service is available to all components in that NgModule.  at the component level, you get a new instance of the service with each new instance of that component",
	"Services - Providers - providedIn": "specify that a service should be provided in a particular @NgModule. if you use providedIn, the injectable is registered as a provider of the Module without adding it to the providers of the module.",
	"Services - Providers - Provider scope": "When you add a service provider to the root application injector, it’s available throughout the app. Another way to limit provider scope is by adding the service you want to limit to the component’s providers array. Providing a service in the component limits the service only to that component",
	"Services - Providers - ways to make a service a singleton in Angular": "Declare tha the service should be provided in the application root. Include the service in the AppModule or in a module that is only imported by the AppModule.",
	"Services - Providers - forRoot": "configure services and providers that are intended to be singletons and eager",
	"Services - Providers - forChild() ": "provider that is visible only to the children modules of our module, in case they are lazy loaded. As each lazy module is loaded on demand, it has its own injector..",
	"Services - Providers - Tree-shakable providers": "Tree shaking is the ability to remove code that is not referenced in an application from the final bundle. Tree-shakable providers give Angular the ability to remove services that are not used in your application from the final output. This significantly reduces the size of your bundles.",
	"Services - Providers - Tree-shakable providers. Default": "Ideally, if an application is not injecting a service, it should not be included in the final output. However, it turns out that the Angular compiler cannot identify at build time if the service will be required or not. Because it's always possible to inject a service directly using injector.get(Service), Angular cannot identify all of the places in your code where this injection could happen, so it has no choice but to include the service in the injector regardless. Thus, services provided in modules are not tree-shakable.",
	"Services - Providers - Tree-shakable providers. Configure": "To create providers that are tree-shakable, the information that used to be specified in the module should be specified in the @Injectable decorator on the service itself. @Injectable({ providedIn: 'root', useFactory: () => new Service('dependency'), })",
	"Services - HttpClient": "The HttpClientAPI rests on the XMLHttpRequest interface exposed by the browsers.",
	"Services - HttpClient - @angular/http": "@angular/http (deprecated Angular 8.0)",
	"Services - HttpClient - @angular/common/http": "offers a simplified client HTTP API (HttpClient) for Angular applications that rests on 2 options exposed by browsers: HttpXhrBackend that uses XmlHttpRequest API and JsonpClientBackend that uses JSONP technique.",
	"Services - HttpClient - Making a POST request": "return this.http.post< Hero >(this.heroesUrl, hero, httpOptions)",
	"Services - HttpClient - Headers": "httpOptions.headers = httpOptions.headers.set('Authorization', 'my-new-auth-token'),",
	"Services - HttpClient - URL Parameters": "const httpOptions = { params: new HttpParams().set('name', term) },",
	"Services - HttpClient - Interceptor": "With interception, you declare interceptors that inspect and transform HTTP requests from your application to the server.",
	"Services - HttpClient - Security: XSRF Protection": "By default, an interceptor sends this cookie on all mutating requests (POST, etc.) to relative URLs but not on GET/HEAD requests or on requests with an absolute URL.",
	"Services - Language": "The Angular Language Service is a way to get completions, errors, hints, and navigation inside your Angular templates whether they are external in an HTML file or embedded in annotations/decorators in a string. The Angular Language Service autodetects that you are opening an Angular file, reads your tsconfig.json file, finds all the templates you have in your application, and then provides language services for any templates that you open. npm install --save-dev @angular/language-service",

	"CICD": "SECTION",
	"CICD - debug - Angular Global (Angular9)": "The Angular team has exposed the global object ng, which is a lifesaver that makes the debugging process much easier.",
	"CICD - debug - Angular Global": "(1) ng serve --open (2) Open the browser developer console or press F12. (3) In the Console tab, type ng, and press Enter. All the default functions of the global ng object will be listed as shown in the following screenshot.",
	"CICD - testing - TestBed": "The TestBed is the most important of the Angular testing utilities. The TestBed creates a dynamically-constructed Angular test module that emulates an Angular @NgModule.",
	"CICD - testing - Protractor": "Protractor has recently announced the end of support 2022.",
	"CICD - testing - Cypress": "Cypress is built on Node.js, Cypress is an open-source Javascript/Typescript framework that enables unit testing, integration testing, and end-to-end testing. Unlike Protractor or WebdriverIO, Cypress runs on its own browser so we can expect fewer failures.",
	"CICD - build - compilation - JIT": "With JIT, the compilation happens during run-time in the browser. It is the default way used by Angular. The commands used for JIT compilation are – ng build ng serve ",
	"CICD - build - compilation - AOT": "The code is rendered faster because it gets converted from TypeScript (or HTML) to JavaScript during the build process itself. AOT is more suitable for the production environment whereas JIT is much suited for local development. ng build --aot ng server –aot",
	"CICD - build - compiler - webpack": "",
	"CICD - build - compiler - ng-packagr": "",
	"CICD - build - compiler - Bazel (Angular 8.0)": "CLI has integrated a new experimental build tool called Bazel.",
	"CICD - build - compiler - Ivy (Angular 8.0)": "Ivy is a new template compiler to build next-gen rendering pipelines in the current version.",
	"CICD - build - compiler - Ivy - advantages": "The advantages of Ivy are: Smaller Bundles. Reduced Payload Size. Faster Rebuild times. Enhance Backwards Compatibility . Pre-compiled Code shipment . Dismissal of metadata.json. Rise of meta programming. Improve template type checking. Broad Compatibility with existing Angular applications.",
	"CICD - build - compiler - Ivy - local": "Recompile only the changed components and allow quicker compiling.",
	"CICD - build - compiler - Ivy - treeshakable": "The unused code gets removed so that the application concentrates on the code used.",
	"CICD - Tools - Angular CLI": "Angular CLI automates the end-to-end development process. The app's initialization, configuration, and development process become straightforward and easy. With a CLI (Command Line Interface), we can create a new project, add new features, and run tests (unit tests and end-to-end tests) by just typing a few simple commands.",

	"Performance Optimization": "SECTION",
	"Performance Optimization - dev - Change Detection Strategy.OnPush": "Change detection is one of the most common features developers use for app development. It can mainly detect when the user's data got altered or changed with updates of the DOM to reflect the changes.  <br/>Here, framework components have the information they use to obtain data from their parent components. Angular parses the component tree and contains the data for any difference from its previous value when an async event occurs.<br/>Through the strict equality operator, checking for any differences is done for the app performance. This operator checks for connection changes in the branch's inputs or components. And, thereby, a new memory allotment is done for the input's current values.",
	"Performance Optimization - dev - Detaching the Change Detector": "When you plan to develop a website with Angular, it follows a tree section with a change detector. We can infiltrate this change detector (ChangeDetectorRef) to detach the CD tree's element or connect it to the CD tree Therefore, when Angular runs CD on the element tree, its element with its sub-tree will be skipped. Developers execute this by the use of the ChangeDetectorRef class.",
	"Performance Optimization - dev - Enabling Production Mode": "Angular app development is one of the most chosen services for web app development in today's time. And by default, Angular operates in debug mode that counts some affirmation checks and runs ChangeDetection twice. It will make sure that there are no unexpected changes to binding values.",
	"Performance Optimization - build - Ahead-of-Time Compilation (AOT)": "AOT compilation in AngularJS app development helps convert the TypeScript code into polished JavaScript code and optimizes and compresses the entire code before running it. This is one of the primary features of Angular, which are default features used to increase website speeds.",
	"Performance Optimization - download - Code Splitting": "Code splitting is another way of decreasing the load time, and it also helps in speeding up page navigation. Web applications become more complicated once they start structuring and developing. Thus, the JavaScript files shipped to users grew, which makes the task simpler. Due to its huge JavaScript files, it slows down the interaction time in the browser, especially for mobile users. For Angular app optimization, code splitting effectively reduces JavaScript loads in your app. Please note there is no loss of features doing the process. This technique helps developers divide the JavaScript code by breaking the code into multiple parts that can be progressively loaded as the user navigates to different routes",
	"Performance Optimization - download - Differential Loading (Angular 8.0)": "Differential loading lets you serve up different bundles to different browsers. This generally translates into two things: modern syntax and polyfills. On a newer browser that supports recent syntax changes in JavaScript (such as arrow functions in ES2015 or async functions in ES2017), it’d be great to ship to code as-is with as few polyfills as possible to keep download time low. On legacy browsers, we’ll need both transpiled code and more polyfills to make things work. This way, newer browsers aren’t punished for legacy browsers by having to load a massive bundle, but legacy browsers aren't left in the dust. Differential loading in Angular 8.0 forms a part of Manfred Steyer's project, ngx-build-modern. All bundling is done with the ng build command and the -prod extension, without requiring special actions.",
	"Performance Optimization - download - Lazy Loading": "{ path: '/student', loadChildren: './student/student.module#StudentModule' } <br/>Now, looks as: <br/>{ path: '/student', loadChildren: () => import('./student/student.module').then(s => s.StudentModule) } ",
	"Performance Optimization - download - server side rendering- Universal": "Angular Universal generates static application pages on the server through a process called server-side rendering (SSR).",
	"Performance Optimization - download - Minification": "For website optimization, several elements are used for better visual and readability such as JavaScript code, newline characters, comments, block delimiters, including white spaces. They aren't required for the code to run correctly, but it is suggested to use for minification. The minification process helps remove these characters and simplifies their names, ignoring unreachable code for further development. Minimizing your code increases website speed, and your web pages run faster.",
	"Performance Optimization - download - Serve Scaled Images": "Serve Scaled Images is used to improve the speed of your web application. It is a process to scale images that are used in your website, and it optimizes the site with scaled images. Although large images may be compressed into a fixed size, it will take up additional space to decrease the website's speed. To optimize angular performance and to avoid website down speed, developers must ensure that the uploaded images are the actual size of HTML images on the website.",
	"Performance Optimization - download - Optimize Images": "When developing and executing an Angular app, optimizing images is another essential way to enhance website speed. Along with the website, image optimization helps improve site performance. So, angular web development suggests keeping the file size in kilobytes and avoiding uploading images in megabytes. Developers keep these things in mind while image uploading, as it is important to convert large images into smaller files before uploading them.",
	"Performance Optimization - run - Web workers (deprecated)": "Web workers are the most general purpose type of worker. Unlike service workers and worklets they do not have a specific use case, other than the feature of being run separately to the main thread. As a result, web workers can be used to offload pretty much any heavy processing from the main thread. Web Workers are lightweight, in-browser threads that we can use to execute JavaScript code without blocking the main browser process.  Web workers are created using the Web Workers API. const worker = new Worker(`./my-worker.worker`, { type: `module` });",
	"Performance Optimization - run - Service workers (Angular 5.0)": "@angular/service-worker A service worker is a script that runs in the web browser and manages caching for an application. Service workers function as a network proxy. They intercept all outgoing HTTP requests made by the application and can choose how to respond to them. For example, they can query a local cache and deliver a cached response if one is available.",
	"Performance Optimization - run - Service workers - manifest": "To support these behaviors, the Angular service worker loads a manifest file from the server. The manifest describes the resources to cache and includes hashes of every file's contents. When an update to the application is deployed, the contents of the manifest change, informing the service worker that a new version of the application should be downloaded and cached. This manifest is generated from a CLI-generated configuration file called ngsw-config.json.",
	"Performance Optimization - run - Service workers - installation": "Importing ServiceWorkerModule into your AppModule doesn't just register the service worker, it also provides a few services you can use to interact with the service worker and control the caching of your app.",
	"Performance Optimization - run - Service workers - bypass": "bypassing the service worker with a specified request: this.http.get(‘api/users’, { headers: { ‘ngsw-bypass’: true } });",

	"locales": "SECTION",
	"locales - Internationalization": "For APP. Internationalization is the process of designing and preparing your APP to be usable in different languages.",
	"locales - Internationalization - Localization": "For TEXT. Localization is the process of translating the TEXT of your internationalized app into specific languages for particular locales.",
	"locales - Internationalization - Localization - translate": "(1) mark the text with a custom attribute, named i18n=\"<meaning>|<description>@@customId\" <br/><br/> (2) Add script to packages.json 'scripts': { 'i18n:extract': 'ng xi18n --output-path src/locales' } <br/><br/> (3) run npm run i18n:extract  <br/><br/> (4) open up scr/locales/messages.xlf. For each html element marked with the i18n directive, a trans-unit will be created.  <br/><br/> (5) create a new xlf file src/locales/messages.<locale>.xlf for each locale <br/><br/> (6) Add a script that builds the application for each locale we want to support on angular.json <br/><br/> (7) npm run start npm run start:fr -- --port 4201 <br/>  npm run start:gr -- --port 4202"
}