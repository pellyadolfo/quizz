{

	"Controllers": "SECTION",
	"Controllers ": "Spring Data modules that support the repository programming model ship with a variety of web support. The web related components require Spring MVC JARs to be on the classpath.",
	"Controllers - HATEOAS": "Some of them even provide integration with Spring HATEOAS.",
	"Controllers - @EnableSpringDataWebSupport": "The integration support is enabled by using the @EnableSpringDataWebSupport annotation in your JavaConfig configuration class,",
	"Controllers - @HateoasAwareSpringDataWebConfiguration":  "If you use Spring HATEOAS, register this one *instead* of @EnableSpringDataWebSupport",
	"Controllers - DomainClassConverter": "The DomainClassConverter lets you use domain types in your Spring MVC controller method signatures directly, so that you need not manually lookup the instances through the repository.",
	"Controllers - HandlerMethodArgumentResolvers": "HandlerMethodArgumentResolver implementations to let Spring MVC resolve Pageable and Sort instances from request parameters.",
	"Controllers - HandlerMethodArgumentResolvers - PageableHandlerMethodArgumentResolver": "enables Pageable as valid controller method arguments",
	"Controllers - HandlerMethodArgumentResolvers - PageableHandlerMethodArgumentResolver - PageableHandlerMethodArgumentResolverCustomizer": "To customize, register a bean implementing the PageableHandlerMethodArgumentResolverCustomizer interface, respectively. Its customize() method gets called, letting you change settings.",
	"Controllers - HandlerMethodArgumentResolvers - SortHandlerMethodArgumentResolver": "enables Sort as valid controller method arguments",
	"Controllers - HandlerMethodArgumentResolvers - SortHandlerMethodArgumentResolver - SortHandlerMethodArgumentResolverCustomizer": "To customize, register a bean implementing the SortHandlerMethodArgumentResolverCustomizer interface, respectively. Its customize() method gets called, letting you change settings.",

	"Repository": "SECTION",
	"Repository ": "It takes the domain class to manage as well as the ID type of the domain class as type arguments. This interface acts primarily as a marker interface to capture the types to work with and to help you to discover interfaces that extend this one.",
	"Repository - Config - Repository Instances": ".",
	"Repository - Config - Repository Instances - XML configuration": ".",
	"Repository - Config - Repository Instances - JavaConfig": ".",
	"Repository - Config - Repository Instances - Standalone usage": ".",
	"Repository - Config - Custom Repositories": ".",
	"Repository - Config - Custom Repositories - Individual": ".",
	"Repository - Config - Custom Repositories - Base": ".",
	"Repository - Config - Custom Repositories - Enable${store}Repositories": "epositories are not picked up by component scans since they are just interfaces whos concrete classes are created dynamically as beans by Spring Data provided you have included the @EnableJpaRepositories annotation in your configuration.",
	"Repository - Creation": "Typically, your repository interface extends Repository, CrudRepository, or PagingAndSortingRepository.",
	"Repository - Creation - Repository": "Has no methods. The central interface in the Spring Data repository abstraction is Repository.",
	"Repository - Creation - CrudRepository": "The CrudRepository provides sophisticated CRUD functionality for the entity class that is being managed.",
	"Repository - Creation - CrudRepository - methods - <S extends T> S save(S entity),": "Saves the given entity.",
	"Repository - Creation - CrudRepository - methods - Optional<T> findById(ID primaryKey),": "Returns the entity identified by the given ID.",
	"Repository - Creation - CrudRepository - methods - Iterable<T> findAll(),": "Returns all entities.",
	"Repository - Creation - CrudRepository - methods - long count(),": "Returns the number of entities.",
	"Repository - Creation - CrudRepository - methods - void delete(T entity),": "Deletes the given entity.",
	"Repository - Creation - CrudRepository - methods - boolean existsById(ID primaryKey),": "Indicates whether an entity with the given ID exists.",
	"Repository - Creation - PagingAndSortingRepository": "On top of the CrudRepository, there is a PagingAndSortingRepository abstraction that adds additional methods to ease paginated access to entities.",
	"Repository - Creation - PagingAndSortingRepository - methods - Iterable<T> findAll(Sort sort),": "",
	"Repository - Creation - PagingAndSortingRepository - methods - Page<T> findAll(Pageable pageable),": "",
	"Repository - Creation - @RepositoryDefinition": "Alternatively, if you do not want to extend Spring Data interfaces, you can also annotate your repository interface with @RepositoryDefinition.",
	"Repository - Creation - @NoRepositoryBean": "Extending CrudRepository exposes a complete set of methods to manipulate your entities. If you prefer to be selective about the methods being exposed, copy the methods you want to expose from CrudRepository into your domain repository.",
	"Repository - Creation - Nullable - Optional": "As of Spring Data 2.0, repository CRUD methods that return an individual aggregate instance use Java 8’s Optional to indicate the potential absence of a value. Besides that, Spring Data supports returning the following wrapper types on query methods: com.google.common.base.Optional, scala.Option, io.vavr.control.Option, javaslang.control.Option (deprecated as Javaslang is deprecated)",
	"Repository - Creation - Nullable - Nullable Annotations (Spring Core)": "",
	"Repository - Creation - Multiple": "Using a unique Spring Data module in your application makes things simple, because all repository interfaces in the defined scope are bound to the Spring Data module. Sometimes, applications require using more than one Spring Data module.",
	"Repository - Creation - Extensions": "We also provide persistence technology-specific abstractions, such as JpaRepository or MongoRepository. Those interfaces extend CrudRepository and expose the capabilities of the underlying persistence technology in addition to the rather generic persistence technology-agnostic interfaces such as CrudRepository.",
	"Repository - Creation - Extensions - JpaRepository": "",
	"Repository - Creation - Extensions - MongoRepository": "",
	"Repository - Creation - Reactive - ReactiveCrudRepository": "Interface for generic CRUD operations on a repository for a specific type. This repository follows reactive paradigms and uses Project Reactor types which are built on top of Reactive Streams.",
	"Repository - Creation - Reactive - ReactiveSortingRepository": "",
	"Repository - Creation - Reactive - RxJava2CrudRepository": "Interface for generic CRUD operations on a repository for a specific type. This repository follows reactive paradigms and uses RxJava 2 types.",
	"Repository - Creation - Reactive - RxJava2CrudRepository - RxJava2SortingRepository": "",
	"Repository - Querying - Custom methods": "The repository proxy has two ways to derive a store-specific query from the method name: (1) By deriving the query from the method name directly. (2) By using a manually defined query.",
	"Repository - Querying - Custom methods - Query Lookup Strategies": "The following strategies are available for the repository infrastructure to resolve the query. With XML configuration, you can configure the strategy at the namespace through the query-lookup-strategy attribute. For Java configuration, you can use the queryLookupStrategy attribute of the Enable${store}Repositories annotation. Some strategies may not be supported for particular datastores.",
	"Repository - Querying - Custom methods - Query Lookup Strategies - CREATE": "CREATE attempts to construct a store-specific query from the query method name. The general approach is to remove a given set of well known prefixes from the method name and parse the rest of the method.",
	"Repository - Querying - Custom methods - Query Lookup Strategies - USE_DECLARED_QUERY": "USE_DECLARED_QUERY tries to find a declared query and throws an exception if cannot find one. The query can be defined by an annotation somewhere or declared by other means. Consult the documentation of the specific store to find available options for that store. If the repository infrastructure does not find a declared query for the method at bootstrap time, it fails.",
	"Repository - Querying - Custom methods - Query Lookup Strategies - CREATE_IF_NOT_FOUND": "CREATE_IF_NOT_FOUND (default) combines CREATE and USE_DECLARED_QUERY. It looks up a declared query first, and, if no declared query is found, it creates a custom method name-based query. This is the default lookup strategy and, thus, is used if you do not configure anything explicitly. It allows quick query definition by method names but also custom-tuning of these queries by introducing declared queries as needed.",
	"Repository - Querying - Custom methods - Query Builder Mechanism": "The query builder mechanism built into Spring Data repository infrastructure is useful for building constraining queries over entities of the repository. The mechanism strips the prefixes find…By, read…By, query…By, count…By, and get…By from the method and starts parsing the rest of it. The introducing clause can contain further expressions, such as a Distinct to set a distinct flag on the query to be created. However, the first By acts as delimiter to indicate the start of the actual criteria. At a very basic level, you can define conditions on entity properties and concatenate them with And and Or.",
	"Repository - Querying - Custom methods - Query Builder Mechanism - dependency": "The actual result of parsing the method depends on the persistence store for which you create the query.",
	"Repository - Querying - Custom methods - Query Builder Mechanism - And (AND)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - Or (OR)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - After, IsAfter (AFTER)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - Before, IsBefore (BEFORE)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - Containing, IsContaining, Contains (CONTAINING)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - Between, IsBetween (BETWEEN)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - EndingWith, IsEndingWith, EndsWith (ENDING_WITH)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - Exists (EXISTS)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - False, IsFalse (FALSE)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - GreaterThan, IsGreaterThan (GREATER_THAN)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - GreaterThanEqual, IsGreaterThanEqual (GREATER_THAN_EQUALS)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - In, IsIn (IN)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - Is, Equals, (or no keyword) (OR)": "IS.",
	"Repository - Querying - Custom methods - Query Builder Mechanism - IsEmpty, Empty (IS_EMPTY)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - IsNotEmpty, NotEmpty (IS_NOT_EMPTY)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - NotNull, IsNotNull (IS_NOT_NULL)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - Null, IsNull (IS_NULL)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - LessThan, IsLessThan (LESS_THAN)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - LessThanEqual, IsLessThanEqual (LESS_THAN_EQUAL)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - Like, IsLike (LIKE)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - Near, IsNear (NEAR)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - Not, IsNot (NOT)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - NotIn, IsNotIn (NOT_IN)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - NotLike, IsNotLike (NOT_LIKE)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - Regex, MatchesRegex, Matches (REGEX)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - StartingWith, IsStartingWith, StartsWith (STARTING_WITH)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - True, IsTrue (TRUE)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - Within, IsWithin (WITHIN)": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - IgnoreCase": ".",
	"Repository - Querying - Custom methods - Query Builder Mechanism - OrderBy": ".",
	"Repository - Querying - Custom methods - Property Expressions": "Property expressions can refer only to a direct property of the managed entity.",
	"Repository - Querying - Custom methods - Property Expressions - Traversing": "you can also define constraints by traversing nested properties. Assume a Person has an Address with a ZipCode. In that case a method name of List<Person> findByAddressZipCode(ZipCode zipCode), creates the property traversal x.address.zipCode..",
	"Repository - Querying - Custom methods - Property Expressions - Traversing Manual": "Although this should work for most cases, it is possible for the algorithm to select the wrong property. Suppose the Person class has an addressZip property as well. The algorithm would match in the first split round already and essentially choose the wrong property and finally fail (as the type of addressZip probably has no code property). To resolve this ambiguity you can use _ inside your method name to manually define traversal points. So our method name would end up like so: List<Person> findByAddress_ZipCode(ZipCode zipCode),",
	"Repository - Querying - Custom methods - Collections - Pagination - Pageable": "Pass an org.springframework.data.domain.Pageable instance to the query method to dynamically add paging to your statically defined query.",
	"Repository - Querying - Custom methods - Collections - Pagination - Pageable - PageRequest": "Basic Java Bean implementation of Pageable.",
	"Repository - Querying - Custom methods - Collections - Pagination - Pageable - PageRequest - default": "The default Pageable passed into the method is equivalent to a new PageRequest(0, 20)",
	"Repository - Querying - Custom methods - Collections - Pagination - Pageable - PageRequest - @PageableDefault": "can be customized by using the @PageableDefault annotation on the Pageable parameter.",
	"Repository - Querying - Custom methods - Collections - Pagination - Pageable - parameters": "Request parameters evaluated for Pageable instances: page, size, sort",
	"Repository - Querying - Custom methods - Collections - Pagination - Pageable - parameters - page": "Page you want to retrieve. 0-indexed and defaults to 0.",
	"Repository - Querying - Custom methods - Collections - Pagination - Pageable - parameters - size": "Size of the page you want to retrieve. Defaults to 20.",
	"Repository - Querying - Custom methods - Collections - Pagination - Pageable - parameters - sort": "Properties that should be sorted by in the format property,property(,ASC|DESC). Default sort direction is ascending. Use multiple sort parameters if you want to switch directions — for example, ?sort=firstname&sort=lastname,asc.",
	"Repository - Querying - Custom methods - Collections - Pagination - Page": "A Page knows about the total number of elements and pages available. It does so by the infrastructure triggering a count query to calculate the overall number.",
	"Repository - Querying - Custom methods - Collections - Pagination - Page - PageImpl<T>": "Basic Page implementation.",
	"Repository - Querying - Custom methods - Collections - Pagination - Slide": "As this might be expensive depending on the store used, Slice can be used as return instead. A Slice only knows about whether there’s a next Slice available which might be just sufficient when walking through a larger result set.",
	"Repository - Querying - Custom methods - Collections - Pagination - Slide - SliceImpl<T>": "Default implementation of Slice.",
	"Repository - Querying - Custom methods - Collections - Sorting - Sort": "If you only need sorting, simply add an org.springframework.data.domain.Sort parameter to your method. As you also can see, simply returning a List is possible as well. In this case the additional metadata required to build the actual Page instance will not be created (which in turn means that the additional count query that would have been necessary not being issued) but rather simply restricts the query to look up only the given range of entities.",
	"Repository - Querying - Custom methods - Collections - Limiting": "The results of query methods can be limited by using the first or top keywords, which can be used interchangeably. An optional numeric value can be appended to top or first to specify the maximum result size to be returned. If the number is left out, a result size of 1 is assumed.",
	"Repository - Querying - Custom methods - Collections - Limiting - first": "Same as first1",
	"Repository - Querying - Custom methods - Collections - Limiting - first10": "Page<User> queryFirst10ByLastname(String lastname, Pageable pageable),",
	"Repository - Querying - Custom methods - Collections - Limiting - top": "Same as top1",
	"Repository - Querying - Custom methods - Collections - Limiting - top10": "List<User> findTop10ByLastname(String lastname, Pageable pageable),",
	"Repository - Querying - Custom methods - Collections - Streaming": "The results of query methods can be processed incrementally by using a Java 8 Stream<T> as return type. Instead of wrapping the query results in a Stream data store-specific methods are used to perform the streaming.",
	"Repository - Querying - Custom methods - Collections - Asyncing": "Repository queries can be run asynchronously by using Spring’s asynchronous method execution capability. This means the method returns immediately upon invocation while the actual query execution occurs in a task that has been submitted to a Spring TaskExecutor. Asynchronous query execution is different from reactive query execution and should not be mixed. Refer to store-specific documentation for more details on reactive support.",
	"Repository - Querying - Projections": "Spring Data query methods usually return one or multiple instances of the aggregate root managed by the repository. However, it might sometimes be desirable to create projections based on certain attributes of those types. Spring Data allows modeling dedicated return types, to more selectively retrieve partial views of the managed aggregates..",
	"Repository - Querying - Projections - Interface based": "The easiest way to limit the result of the queries to only the name attributes is by declaring an interface that exposes accessor methods for the properties to be read.",
	"Repository - Querying - Projections - Interface based - Closed Projections": "A projection interface whose accessor methods all match properties of the target aggregate is considered to be a closed projection.",
	"Repository - Querying - Projections - Interface based - Open Projections": "Accessor methods in projection interfaces can also be used to compute new values by using the @Value annotation.",
	"Repository - Querying - Projections - Class-based Projections (DTOs)": "Another way of defining projections is by using value type DTOs (Data Transfer Objects) that hold properties for the fields that are supposed to be retrieved. These DTO types can be used in exactly the same way projection interfaces are used, except that no proxying happens and no nested projections can be applied. If the store optimizes the query execution by limiting the fields to be loaded, the fields to be loaded are determined from the parameter names of the constructor that is exposed.",
	"Repository - Querying - Projections - Dynamic Projections": "So far, we have used the projection type as the return type or element type of a collection. However, you might want to select the type to be used at invocation time (which makes it dynamic).",
	"Repository - Querying - QBE": "Query by Example (QBE) is a user-friendly querying technique with a simple interface. It allows dynamic query creation and does not require you to write queries that contain field names. In fact, Query by Example does not require you to write queries by using store-specific query languages at all.",
	"Repository - Querying - QBE - cases": "Query by Example is well suited for several use cases: Querying your data store with a set of static or dynamic constraints. Frequent refactoring of the domain objects without worrying about breaking existing queries. Working independently from the underlying data store API",
	"Repository - Querying - QBE - limitations": "Query by Example also has several limitations: No support for nested or grouped property constraints, such as firstname = ?0 or (firstname = ?1 and lastname = ?2). Only supports starts/contains/ends/regex matching for strings and exact matching for other property types.",
	"Repository - Querying - QBE - parts": "The Query by Example API consists of three parts: Probe, ExampleMatcher, Example.",
	"Repository - Querying - QBE - parts - Probe": "The actual example of a domain object with populated fields.",
	"Repository - Querying - QBE - parts - ExampleMatcher": "The ExampleMatcher carries details on how to match particular fields. It can be reused across multiple Examples.",
	"Repository - Querying - QBE - parts - Example": "An Example consists of the probe and the ExampleMatcher. It is used to create the query. Example<Person> example = Example.of(person),",
	"Repository - Querying - QBE - repository - QueryByExampleExecutor": "let your repository interface extend QueryByExampleExecutor<T>.",
	"Repository - Querying - QBE - repository - QueryByExampleExecutor - count(Example<S> example)": "Returns the number of instances matching the given Example.",
	"Repository - Querying - QBE - repository - QueryByExampleExecutor - exists(Example<S> example)": "Checks whether the data store contains elements that match the given Example.",
	"Repository - Querying - QBE - repository - QueryByExampleExecutor - findAll(Example<S> example)": "Returns all entities matching the given Example.",
	"Repository - Querying - QBE - repository - QueryByExampleExecutor - findAll(Example<S> example, Pageable pageable)": "Returns a Page of entities matching the given Example.",
	"Repository - Querying - QBE - repository - QueryByExampleExecutor - findAll(Example<S> example, Sort sort)": "Returns all entities matching the given Example applying the given Sort.",
	"Repository - Querying - QBE - repository - QueryByExampleExecutor - findOne(Example<S> example)": "Returns a single entity matching the given Example or null if none was found.",
	"Repository - Querying - Querydsl": "Querydsl is a framework that enables the construction of statically typed SQL-like queries through its fluent API.",
	"Repository - Querying - Querydsl - QuerydslPredicateExecutor": "To make use of Querydsl support, extend QuerydslPredicateExecutor on your repository interface.",
	"Repository - Updating": "There are two main approaches to design of persistence APIs: (1) insert/update approach. (2) Unit of Work approach",
	"Repository - Updating - approach - insert/update": " When you need to modify the database you should call methods of persistence API explicitly: you call insert to insert an object, or update to save new state of the object to the database.",
	"Repository - Updating - approach - Unit of Work": " In this case you have a set of objects managed by persistence library. All changes you make to these objects will be flushed to the database automatically at the end of Unit of Work (i.e. at the end of the current transaction in typical case). When you need to insert new record to the database, you make the corresponding object managed. Managed objects are identified by their primary keys, so that if you make an object with predefined primary key managed, it will be associated with the database record of the same id, and state of this object will be propagated to that record automatically.",
	"Repository - Updating - current": "Spring Data follows the later approach. save() in Spring Data is backed by merge() in plain JPA, therefore it makes your entity managed as described above. It means that calling save() on an object with predefined id will update the corresponding database record rather than insert a new one, and also explains why save() is not called create().",
	"Repository - Events - @DomainEvents": "Entities managed by repositories are aggregate roots. In a Domain-Driven Design application, these aggregate roots usually publish domain events. Spring Data provides an annotation called @DomainEvents that you can use on a method of your aggregate root to make that publication as easy as possible,.",
	"Repository - Events - @AfterDomainEventPublication": "",
	"Auditing": ".",
		
	"DAO": "SECTION",
	"DAO ": "The Data Access Object (DAO) support in Spring is aimed at making it easy to work with data access technologies (such as JDBC, Hibernate, or JPA) in a consistent way. This lets you switch between persistence technologies fairly easily, and it also lets you code without worrying about catching exceptions that are specific to each technology..",
	"DAO - @Repository": "The best way to guarantee that your Data Access Objects (DAOs) or repositories provide exception translation is to use the @Repository annotation. This annotation also lets the component scanning support find and configure your DAOs and repositories without having to provide XML configuration entries for them.",
	"DAO - tasks": "The value provided by the Spring Framework JDBC abstraction is perhaps best shown by the sequence of actions outlined in the following table below. The table shows which actions Spring takes care of and which actions are your responsibility. The Spring Framework takes care of all the low-level details that can make JDBC such a tedious API.",
	"DAO - tasks - Define connection parameters.": "Developer",
	"DAO - tasks - Open the connection.": "Spring",
	"DAO - tasks - Specify the SQL statement.": "Developer",
	"DAO - tasks - Declare parameters and provide parameter values": "Developer",
	"DAO - tasks - Prepare and execute the statement.": "Spring",
	"DAO - tasks - Set up the loop to iterate through the results (if any).": "Spring",
	"DAO - tasks - Do the work for each iteration.": "Developer",
	"DAO - tasks - Process any exception.": "Spring",
	"DAO - tasks - Handle transactions.": "Spring",
	"DAO - tasks - Close the connection, the statement, and the resultset.": "Spring",
	"DAO - JdbcTemplate": "JdbcTemplate is the classic and most popular Spring JDBC approach. This “lowest-level” approach and all others use a JdbcTemplate under the covers. JdbcTemplate is the central class in the JDBC core package. It handles the creation and release of resources, which helps you avoid common errors, such as forgetting to close the connection. It performs the basic tasks of the core JDBC workflow (such as statement creation and execution), leaving application code to provide SQL and extract results.",
	"DAO - JdbcTemplate - tasks": "The JdbcTemplate class: Runs SQL queries, Updates statements and stored procedure calls, Performs iteration over ResultSet instances and extraction of returned parameter values, Catches JDBC exceptions and translates them to the generic, more informative, exception hierarchy defined in the org.springframework.dao package. When you use the JdbcTemplate for your code, you need only to implement callback interfaces, giving them a clearly defined contract. Given a Connection provided by the JdbcTemplate class, the PreparedStatementCreator callback interface creates a prepared statement, providing SQL and any necessary parameters. The same is true for the CallableStatementCreator interface, which creates callable statements. The RowCallbackHandler interface extracts values from each row of a ResultSet. You can use JdbcTemplate within a DAO implementation through direct instantiation with a DataSource reference, or you can configure it in a Spring IoC container and give it to DAOs as a bean reference.",
	"DAO - JdbcTemplate - features - threads": "Instances of the JdbcTemplate class are thread-safe, once configured. This is important because it means that you can configure a single instance of a JdbcTemplate and then safely inject this shared reference into multiple DAOs (or repositories).",
	"DAO - JdbcTemplate - features - stateful": "The JdbcTemplate is stateful, in that it maintains a reference to a DataSource, but this state is not conversational state.",
	"DAO - JdbcTemplate - features - datasource": "A common practice when using the JdbcTemplate class (and the associated NamedParameterJdbcTemplate class) is to configure a DataSource in your Spring configuration file and then dependency-inject that shared DataSource bean into your DAO classes. The JdbcTemplate is created in the setter for the DataSource. private JdbcTemplate jdbcTemplate,    public void setDataSource(DataSource dataSource) { this.jdbcTemplate = new JdbcTemplate(dataSource), } An alternative to explicit configuration is to use component-scanning and annotation support for dependency injection. In this case, you can annotate the class with @Repository (which makes it a candidate for component-scanning) and annotate the DataSource setter method with @Autowired.",
	"DAO - JdbcTemplate - methods - execute": "You can use the execute(..) method to run any arbitrary SQL. Consequently, the method is often used for DDL statements.",
	"DAO - JdbcTemplate - methods - query": ".",
	"DAO - JdbcTemplate - methods - queryForObject": ".",
	"DAO - JdbcTemplate - methods - queryForList": ".",
	"DAO - JdbcTemplate - methods - queryForMap": ".",
	"DAO - JdbcTemplate - methods - update": "You can use the update(..) method to perform insert, update, and delete operations. Parameter values are usually provided as variable argumets or, alternatively, as an object array.",
	"DAO - JdbcTemplate - methods - batchUpdate": ".",
	"DAO - JdbcTemplate - NamedParameterJdbcTemplate": "NamedParameterJdbcTemplate wraps a JdbcTemplate to provide named parameters instead of the traditional JDBC ? placeholders. This approach provides better documentation and ease of use when you have multiple parameters for an SQL statement.",
	"DAO - SimpleJdbcInsert": "SimpleJdbcInsert and SimpleJdbcCall optimize database metadata to limit the amount of necessary configuration. This approach simplifies coding so that you need to provide only the name of the table or procedure and provide a map of parameters matching the column names. This works only if the database provides adequate metadata. If the database does not provide this metadata, you have to provide explicit configuration of the parameters.",
	"DAO - SimpleJdbcCall": "SimpleJdbcInsert and SimpleJdbcCall optimize database metadata to limit the amount of necessary configuration. This approach simplifies coding so that you need to provide only the name of the table or procedure and provide a map of parameters matching the column names. This works only if the database provides adequate metadata. If the database does not provide this metadata, you have to provide explicit configuration of the parameters."
}