{

	"Reliability": "SECTION",
	"Reliability 0": "",
	"Reliability 1": "",
	"Reliability 2": "",
	"Reliability 3": "",
	"Reliability 4": "",
	"Reliability 5": "",
	"Reliability 6": "",

	"Patterns": "SECTION",
	"Patterns - Load - Idempotency": "Handle duplicate requests safely.",
	"Patterns - Load - Idempotency - How": "Design operations so repeating them has no side effects. Use idempotency keys (e.g., in payment processing).",
	"Patterns - Load - QueueBasedLoadLeveling": "Smooth out traffic spikes.",
	"Patterns - Load - QueueBasedLoadLeveling - How": "Buffer requests in a queue (e.g., Kafka, SQS). Workers process at a steady rate.",
	"Patterns - Load - QueueBasedLoadLeveling - Example - AmazonSQS": "Order processing via Amazon SQS.",
	"Patterns - Load - QueueBasedLoadLeveling - Example - EDA": "Event-driven architectures.",
	"Patterns - Load - LoadShedding": "Prioritize critical traffic during overload.",
	"Patterns - Load - LoadShedding - How": "Reject non-essential requests when nearing capacity. Use admission control (e.g., rate limiting).",
	"Patterns - Error - Timeout": "Prevent hung requests from consuming resources indefinitely.",
	"Patterns - Error - Deadlines": "Propagated Timeouts. Ensure long chains of services respect end-to-end latency limits.",
	"Patterns - Error - Deadlines - How": "Pass a deadline (e.g., 'this request must finish in 500ms'). Each service in the chain enforces the remaining time.",
	"Patterns - Error - Deadlines - Examples - gRPC": "gRPC uses deadlines natively.",
	"Patterns - Error - Deadlines - Examples - OpenTelemetry": "OpenTelemetry propagates context.",
	"Patterns - Error - Retries": "Auto-retry failed requests for resilience.",
	"Patterns - Error - Retries - How - Backoff": "Use exponential backoff (delay increases after each retry).",
	"Patterns - Error - Retries - How - Jitter": "Jitter (randomized delays) avoids thundering herds.",
	"Patterns - Error - Retries - Usage": "Handle transient failures (e.g., network glitches).",
	"Patterns - Error - Retries - Tools - SpringRetry": ".",
	"Patterns - Error - Retries - Tools - SpringRetry - @Retrayable": "Per @Retryable‘s default behavior, the retry may happen up to three times, with a delay of one second between retries.",
	"Patterns - Error - Retries - Tools - SpringRetry - @Recover": "The @Recover annotation defines a separate recovery method when a @Retryable method fails with a specified exception.",
	"Patterns - Error - Retries - Tools - SpringRetry - RetryOperations": "",
	"Patterns - Error - Retries - Tools - SpringRetry - RetryOperations - execute": "",
	"Patterns - Error - Retries - Tools - SpringRetry - RetryOperations - RetryTemplate": "The RetryTemplate is an implementation of the RetryOperations.",
	"Patterns - Error - Retries - Tools - SpringRetry - RetryCallback": "The RetryCallback, which is a parameter of the execute(), is an interface that allows the insertion of business logic that needs to be retried upon failure.",
	"Patterns - Error - Retries - Tools - SpringRetry - Listeners": "Listeners provide additional callbacks upon retries. And we can use these for various cross-cutting concerns across different retries.",
	"Patterns - Error - Failback": "Failback involves a full migration back to the production status quo—a recovery if you will—at the validated conclusion of a disaster. ",
	"Patterns - Error - Failover": "Failover refers to the process of automatically and seamlessly switching to a backup system or component when the primary system fails.",
	"Patterns - Propagation - CircuitBreaker": "Stop cascading failures.",
	"Patterns - Propagation - CircuitBreaker - Tools - Hystrix": "",
	"Patterns - Propagation - CircuitBreaker - Tools - Istio": "",
	"Patterns - Propagation - CircuitBreaker - Tools - Resilience4j": "Resilience4j is a lightweight, easy-to-use library, which offers a powerful circuit breaker implementation inspired by Netflix Hystrix but designed with functional programming approach.",
	"Patterns - Propagation - CircuitBreaker - Tools - Sentinel": "It is an open-source library that provides monitoring of services and controls the traffic. It can be used to implement circuit breaking, rate limiting. Sentinel can work in both Java and other languages.",
	"Patterns - Propagation - CircuitBreaker - Tools - AmazonAppMesh": "Amazon App Mesh is a managed service mesh that allows you to monitor and control services running on AWS.",
	"Patterns - Propagation - Bulkhead": "Compartmentalize your application's resources so that failure of any one of your dependencies is not propagated into the entire system",
	"Patterns - Propagation - Bulkhead - Partition": "Partition resources (thread pools, connections, instances).",
	"Patterns - Propagation - Bulkhead - Tools - Resilience4j": "",
	"Patterns - Propagation - Redundancy": "",
	"Patterns - SelfHealing - AutoRestart": "Auto-restart unhealthy containers (Kubernetes).",
	"Patterns - Test - HealthCheck": "Detect and recover from failures automatically.",
	"Patterns - Test - HealthCheck - LivenessProbes": "Liveness probes (is the service running?).",
	"Patterns - Test - HealthCheck - ReadinessProbes": "Readiness probes (can it accept traffic?).",
	"Patterns - Test - ChaosEngineering": "Proactively test resilience.",
	"Patterns - Test - ChaosEngineering - How": "Inject failures (e.g., kill pods, network partitions). Verify system recovery..",
	"Patterns - Test - ChaosEngineering - Example - ChaosMonkey": "Netflix Chaos Monkey (randomly terminates instances).",
	"Patterns - Test - ChaosEngineering - Example - Gremlin": "Gremlin (controlled chaos testing)."


}

